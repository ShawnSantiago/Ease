/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

;(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], function() {
      return (factory());
    });
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.whatInput = factory();
  }
} (this, function() {
  'use strict';


  /*
    ---------------
    variables
    ---------------
  */

  // array of actively pressed keys
  var activeKeys = [];

  // cache document.body
  var body = document.body;

  // boolean: true if touch buffer timer is running
  var buffer = false;

  // the last used input type
  var currentInput = null;

  // array of form elements that take keyboard input
  var formInputs = [
    'input',
    'select',
    'textarea'
  ];

  // user-set flag to allow typing in form fields to be recorded
  var formTyping = body.hasAttribute('data-whatinput-formtyping');

  // mapping of events to input types
  var inputMap = {
    'keydown': 'keyboard',
    'mousedown': 'mouse',
    'mouseenter': 'mouse',
    'touchstart': 'touch',
    'pointerdown': 'pointer',
    'MSPointerDown': 'pointer'
  };

  // array of all used input types
  var inputTypes = [];

  // mapping of key codes to common name
  var keyMap = {
    9: 'tab',
    13: 'enter',
    16: 'shift',
    27: 'esc',
    32: 'space',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down'
  };

  // map of IE 10 pointer events
  var pointerMap = {
    2: 'touch',
    3: 'touch', // treat pen like touch
    4: 'mouse'
  };

  // touch buffer timer
  var timer;


  /*
    ---------------
    functions
    ---------------
  */

  function bufferInput(event) {
    clearTimeout(timer);

    setInput(event);

    buffer = true;
    timer = setTimeout(function() {
      buffer = false;
    }, 1000);
  }

  function immediateInput(event) {
    if (!buffer) setInput(event);
  }

  function setInput(event) {
    var eventKey = key(event);
    var eventTarget = target(event);
    var value = inputMap[event.type];
    if (value === 'pointer') value = pointerType(event);

    if (currentInput !== value) {
      if (
        // only if the user flag isn't set
        !formTyping &&

        // only if currentInput has a value
        currentInput &&

        // only if the input is `keyboard`
        value === 'keyboard' &&

        // not if the key is `TAB`
        keyMap[eventKey] !== 'tab' &&

        // only if the target is one of the elements in `formInputs`
        formInputs.indexOf(eventTarget.nodeName.toLowerCase()) >= 0
      ) {
        // ignore keyboard typing on form elements
      } else {
        currentInput = value;
        body.setAttribute('data-whatinput', currentInput);

        if (inputTypes.indexOf(currentInput) === -1) inputTypes.push(currentInput);
      }
    }

    if (value === 'keyboard') logKeys(eventKey);
  }

  function key(event) {
    return (event.keyCode) ? event.keyCode : event.which;
  }

  function target(event) {
    return event.target || event.srcElement;
  }

  function pointerType(event) {
    return (typeof event.pointerType === 'number') ? pointerMap[event.pointerType] : event.pointerType;
  }

  // keyboard logging
  function logKeys(eventKey) {
    if (activeKeys.indexOf(keyMap[eventKey]) === -1 && keyMap[eventKey]) activeKeys.push(keyMap[eventKey]);
  }

  function unLogKeys(event) {
    var eventKey = key(event);
    var arrayPos = activeKeys.indexOf(keyMap[eventKey]);

    if (arrayPos !== -1) activeKeys.splice(arrayPos, 1);
  }


  /*
    ---------------
    init
    ---------------
  */

  (function bindEvents() {

    // pointer/mouse
    var mouseEvent = 'mousedown';

    if (window.PointerEvent) {
      mouseEvent = 'pointerdown';
    } else if (window.MSPointerEvent) {
      mouseEvent = 'MSPointerDown';
    }

    body.addEventListener(mouseEvent, immediateInput);
    body.addEventListener('mouseenter', immediateInput);

    // touch
    if ('ontouchstart' in document.documentElement) body.addEventListener('touchstart', bufferInput);

    // keyboard
    body.addEventListener('keydown', immediateInput);
    body.addEventListener('keyup', unLogKeys);

  })();


  /*
    ---------------
    api
    ---------------
  */

  return {

    // returns string: the current input type
    ask: function() { return currentInput; },

    // returns array: currently pressed keys
    keys: function() { return activeKeys; },

    // returns array: all the detected input types
    types: function() { return inputTypes; },

    // accepts string: manually set the input type
    set: setInput
  };

}));

!function($) {

"use strict";

var FOUNDATION_VERSION = '6.0.3';

// Global Foundation object
// This is attached to the window, or used as a module for AMD/Browserify
var Foundation = {
  version: FOUNDATION_VERSION,

  /**
   * Stores initialized plugins.
   */
  _plugins: {},

  /**
   * Stores generated unique ids for plugin instances
   */
  _uuids: [],
  /**
   * Stores currently active plugins.
   */
  _activePlugins: {},

  /**
   * Returns a boolean for RTL support
   */
  rtl: function(){
    return $('html').attr('dir') === 'rtl';
  },
  /**
   * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.
   * @param {Object} plugin - The constructor of the plugin.
   */
  plugin: function(plugin, name) {
    // Object key to use when adding to global Foundation object
    // Examples: Foundation.Reveal, Foundation.OffCanvas
    var className = (name || functionName(plugin));
    // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin
    // Examples: data-reveal, data-off-canvas
    var attrName  = hyphenate(className);

    // Add to the Foundation object and the plugins list (for reflowing)
    this._plugins[attrName] = this[className] = plugin;
  },
  /**
   * @function
   * Creates a pointer to an instance of a Plugin within the Foundation._activePlugins object.
   * Sets the `[data-pluginName="uniqueIdHere"]`, allowing easy access to any plugin's internal methods.
   * Also fires the initialization event for each plugin, consolidating repeditive code.
   * @param {Object} plugin - an instance of a plugin, usually `this` in context.
   * @fires Plugin#init
   */
  registerPlugin: function(plugin){
    var pluginName = functionName(plugin.constructor).toLowerCase();

    plugin.uuid = this.GetYoDigits(6, pluginName);
    plugin.$element.attr('data-' + pluginName, plugin.uuid)
          /**
           * Fires when the plugin has initialized.
           * @event Plugin#init
           */
          .trigger('init.zf.' + pluginName);

    this._activePlugins[plugin.uuid] = plugin;

    return;
  },
  /**
   * @function
   * Removes the pointer for an instance of a Plugin from the Foundation._activePlugins obj.
   * Also fires the destroyed event for the plugin, consolidating repeditive code.
   * @param {Object} plugin - an instance of a plugin, usually `this` in context.
   * @fires Plugin#destroyed
   */
  unregisterPlugin: function(plugin){
    var pluginName = functionName(plugin.constructor).toLowerCase();

    delete this._activePlugins[plugin.uuid];
    plugin.$element.removeAttr('data-' + pluginName)
          /**
           * Fires when the plugin has been destroyed.
           * @event Plugin#destroyed
           */
          .trigger('destroyed.zf.' + pluginName);

    return;
  },

  /**
   * @function
   * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.
   * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`
   * @default If no argument is passed, reflow all currently active plugins.
   */
  _reflow: function(plugins){
    var actvPlugins = Object.keys(this._activePlugins);
    var _this = this;

    if(!plugins){
      actvPlugins.forEach(function(p){
        _this._activePlugins[p]._init();
      });

    }else if(typeof plugins === 'string'){
      var namespace = plugins.split('-')[1];

      if(namespace){

        this._activePlugins[plugins]._init();

      }else{
        namespace = new RegExp(plugins, 'i');

        actvPlugins.filter(function(p){
          return namespace.test(p);
        }).forEach(function(p){
          _this._activePlugins[p]._init();
        });
      }
    }

  },

  /**
   * returns a random base-36 uid with namespacing
   * @function
   * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.
   * @param {String} namespace - name of plugin to be incorporated in uid, optional.
   * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.
   * @returns {String} - unique id
   */
  GetYoDigits: function(length, namespace){
    length = length || 6;
    return Math.round((Math.pow(36, length + 1) - Math.random() * Math.pow(36, length))).toString(36).slice(1) + (namespace ? '-' + namespace : '');
  },
  /**
   * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.
   * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.
   * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.
   */
  reflow: function(elem, plugins) {
    // If plugins is undefined, just grab everything
    if (typeof plugins === 'undefined') {
      plugins = Object.keys(this._plugins);
    }
    // If plugins is a string, convert it to an array with one item
    else if (typeof plugins === 'string') {
      plugins = [plugins];
    }

    var _this = this;

    // Iterate through each plugin
    $.each(plugins, function(i, name) {
      // Get the current plugin
      var plugin = _this._plugins[name];

      // Localize the search to all elements inside elem, as well as elem itself, unless elem === document
      var $elem = $(elem).find('[data-'+name+']').addBack('*');

      // For each plugin found, initialize it
      $elem.each(function() {
        // Don't double-dip on plugins
        if ($(this).attr('zf-plugin')) {
          console.warn("Tried to initialize "+name+" on an element that already has a Foundation plugin.");
          return;
        }
        $(this).data('zf-plugin', new plugin($(this)));
      });
    });
  },
  getFnName: functionName,
  transitionend: function($elem){
    var transitions = {
      'transition': 'transitionend',
      'WebkitTransition': 'webkitTransitionEnd',
      'MozTransition': 'transitionend',
      'OTransition': 'otransitionend'
    };
    var elem = document.createElement('div'),
        end;

    for (var t in transitions){
      if (typeof elem.style[t] !== 'undefined'){
        end = transitions[t];
      }
    }
    if(end){
      return end;
    }else{
      end = setTimeout(function(){
        $elem.triggerHandler('transitionend', [$elem]);
      }, 1);
      return 'transitionend';
    }
  }
};


Foundation.util = {
  /**
   * Function for applying a debounce effect to a function call.
   * @function
   * @param {Function} func - Function to be called at end of timeout.
   * @param {Number} delay - Time in ms to delay the call of `func`.
   * @returns function
   */
  throttle: function (func, delay) {
    var timer = null;

    return function () {
      var context = this, args = arguments;

      if (timer === null) {
        timer = setTimeout(function () {
          func.apply(context, args);
          timer = null;
        }, delay);
      }
    };
  }
};

// TODO: consider not making this a jQuery function
// TODO: need way to reflow vs. re-initialize
/**
 * The Foundation jQuery method.
 * @param {String|Array} method - An action to perform on the current jQuery object.
 */
var foundation = function(method) {
  var type = typeof method,
      $meta = $('meta.foundation-mq'),
      $noJS = $('.no-js');

  if(!$meta.length){
    $('<meta class="foundation-mq">').appendTo(document.head);
  }
  if($noJS.length){
    $noJS.removeClass('no-js');
  }

  if(type === 'undefined'){//needs to initialize the Foundation object, or an individual plugin.
    Foundation.MediaQuery._init();
    Foundation.reflow(this);
  }else if(type === 'string'){//an individual method to invoke on a plugin or group of plugins
    var args = Array.prototype.slice.call(arguments, 1);//collect all the arguments, if necessary
    var plugClass = this.data('zfPlugin');//determine the class of plugin

    if(plugClass !== undefined && plugClass[method] !== undefined){//make sure both the class and method exist
      if(this.length === 1){//if there's only one, call it directly.
          plugClass[method].apply(plugClass, args);
      }else{
        this.each(function(i, el){//otherwise loop through the jQuery collection and invoke the method on each
          plugClass[method].apply($(el).data('zfPlugin'), args);
        });
      }
    }else{//error for no class or no method
      throw new ReferenceError("We're sorry, '" + method + "' is not an available method for " + (plugClass ? functionName(plugClass) : 'this element') + '.');
    }
  }else{//error for invalid argument type
    throw new TypeError("We're sorry, '" + type + "' is not a valid parameter. You must use a string representing the method you wish to invoke.");
  }
  return this;
};

window.Foundation = Foundation;
$.fn.foundation = foundation;

// Polyfill for requestAnimationFrame
(function() {
  if (!Date.now || !window.Date.now)
    window.Date.now = Date.now = function() { return new Date().getTime(); };

  var vendors = ['webkit', 'moz'];
  for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
      var vp = vendors[i];
      window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];
      window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame']
                                 || window[vp+'CancelRequestAnimationFrame']);
  }
  if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent)
    || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
    var lastTime = 0;
    window.requestAnimationFrame = function(callback) {
        var now = Date.now();
        var nextTime = Math.max(lastTime + 16, now);
        return setTimeout(function() { callback(lastTime = nextTime); },
                          nextTime - now);
    };
    window.cancelAnimationFrame = clearTimeout;
  }
  /**
   * Polyfill for performance.now, required by rAF
   */
  if(!window.performance || !window.performance.now){
    window.performance = {
      start: Date.now(),
      now: function(){ return Date.now() - this.start; }
    };
  }
})();
if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs   = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP    = function() {},
        fBound  = function() {
          return fToBind.apply(this instanceof fNOP
                 ? this
                 : oThis,
                 aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    if (this.prototype) {
      // native functions don't have a prototype
      fNOP.prototype = this.prototype;
    }
    fBound.prototype = new fNOP();

    return fBound;
  };
}
// Polyfill to get the name of a function in IE9
function functionName(fn) {
  if (Function.prototype.name === undefined) {
    var funcNameRegex = /function\s([^(]{1,})\(/;
    var results = (funcNameRegex).exec((fn).toString());
    return (results && results.length > 1) ? results[1].trim() : "";
  }
  else if (fn.prototype === undefined) {
    return fn.constructor.name;
  }
  else {
    return fn.prototype.constructor.name;
  }
}

// Convert PascalCase to kebab-case
// Thank you: http://stackoverflow.com/a/8955580
function hyphenate(str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

}(jQuery);

!function(Foundation, window){
  /**
   * Compares the dimensions of an element to a container and determines collision events with container.
   * @function
   * @param {jQuery} element - jQuery object to test for collisions.
   * @param {jQuery} parent - jQuery object to use as bounding container.
   * @param {Boolean} lrOnly - set to true to check left and right values only.
   * @param {Boolean} tbOnly - set to true to check top and bottom values only.
   * @default if no parent object passed, detects collisions with `window`.
   * @returns {Boolean} - true if collision free, false if a collision in any direction.
   */
  var ImNotTouchingYou = function(element, parent, lrOnly, tbOnly){
    var eleDims = GetDimensions(element),
        top, bottom, left, right;

    if(parent){
      var parDims = GetDimensions(parent);

      bottom = (eleDims.offset.top + eleDims.height <= parDims.height + parDims.offset.top);
      top    = (eleDims.offset.top >= parDims.offset.top);
      left   = (eleDims.offset.left >= parDims.offset.left);
      right  = (eleDims.offset.left + eleDims.width <= parDims.width);
    }else{
      bottom = (eleDims.offset.top + eleDims.height <= eleDims.windowDims.height + eleDims.windowDims.offset.top);
      top    = (eleDims.offset.top >= eleDims.windowDims.offset.top);
      left   = (eleDims.offset.left >= eleDims.windowDims.offset.left);
      right  = (eleDims.offset.left + eleDims.width <= eleDims.windowDims.width);
    }
    var allDirs = [bottom, top, left, right];

    if(lrOnly){ return left === right === true; }
    if(tbOnly){ return top === bottom === true; }

    return allDirs.indexOf(false) === -1;
  };

  /**
   * Uses native methods to return an object of dimension values.
   * @function
   * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.
   * @returns {Object} - nested object of integer pixel values
   * TODO - if element is window, return only those values.
   */
  var GetDimensions = function(elem, test){
    elem = elem.length ? elem[0] : elem;

    if(elem === window || elem === document){ throw new Error("I'm sorry, Dave. I'm afraid I can't do that."); }

    var rect = elem.getBoundingClientRect(),
        parRect = elem.parentNode.getBoundingClientRect(),
        winRect = document.body.getBoundingClientRect(),
        winY = window.pageYOffset,
        winX = window.pageXOffset;

    return {
      width: rect.width,
      height: rect.height,
      offset: {
        top: rect.top + winY,
        left: rect.left + winX
      },
      parentDims: {
        width: parRect.width,
        height: parRect.height,
        offset: {
          top: parRect.top + winY,
          left: parRect.left + winX
        }
      },
      windowDims: {
        width: winRect.width,
        height: winRect.height,
        offset: {
          top: winY,
          left: winX
        }
      }
    };
  };
  /**
   * Returns an object of top and left integer pixel values for dynamically rendered elements,
   * such as: Tooltip, Reveal, and Dropdown
   * @function
   * @param {jQuery} element - jQuery object for the element being positioned.
   * @param {jQuery} anchor - jQuery object for the element's anchor point.
   * @param {String} position - a string relating to the desired position of the element, relative to it's anchor
   * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.
   * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.
   * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.
   * TODO alter/rewrite to work with `em` values as well/instead of pixels
   */
  var GetOffsets = function(element, anchor, position, vOffset, hOffset, isOverflow){
    var $eleDims = GetDimensions(element),
    // var $eleDims = GetDimensions(element),
        $anchorDims = anchor ? GetDimensions(anchor) : null;
        // $anchorDims = anchor ? GetDimensions(anchor) : null;
    switch(position){
      case 'top':
        return {
          left: $anchorDims.offset.left,
          top: $anchorDims.offset.top - ($eleDims.height + vOffset)
        };
        break;
      case 'left':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top
        };
        break;
      case 'right':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset,
          top: $anchorDims.offset.top
        };
        break;
      case 'center top':
        return {
          left: ($anchorDims.offset.left + ($anchorDims.width / 2)) - ($eleDims.width / 2),
          top: $anchorDims.offset.top - ($eleDims.height + vOffset)
        };
        break;
      case 'center bottom':
        return {
          left: isOverflow ? hOffset : (($anchorDims.offset.left + ($anchorDims.width / 2)) - ($eleDims.width / 2)),
          top: $anchorDims.offset.top + $anchorDims.height + vOffset
        };
        break;
      case 'center left':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: ($anchorDims.offset.top + ($anchorDims.height / 2)) - ($eleDims.height / 2)
        };
        break;
      case 'center right':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset + 1,
          top: ($anchorDims.offset.top + ($anchorDims.height / 2)) - ($eleDims.height / 2)
        };
        break;
      case 'center':
        return {
          left: ($eleDims.windowDims.offset.left + ($eleDims.windowDims.width / 2)) - ($eleDims.width / 2),
          top: ($eleDims.windowDims.offset.top + ($eleDims.windowDims.height / 2)) - ($eleDims.height / 2)
        };
        break;
      case 'reveal':
        return {
          left: ($eleDims.windowDims.width - $eleDims.width) / 2,
          top: $eleDims.windowDims.offset.top + vOffset
        };
      case 'reveal full':
        return {
          left: $eleDims.windowDims.offset.left,
          top: $eleDims.windowDims.offset.top,
        };
        break;
      default:
        return {
          left: $anchorDims.offset.left,
          top: $anchorDims.offset.top + $anchorDims.height + vOffset
        };
    }
  };
  Foundation.Box = {
    ImNotTouchingYou: ImNotTouchingYou,
    GetDimensions: GetDimensions,
    GetOffsets: GetOffsets
  };
}(window.Foundation, window);

/*******************************************
 *                                         *
 * This util was created by Marius Olbertz *
 * Please thank Marius on GitHub /owlbertz *
 * or the web http://www.mariusolbertz.de/ *
 *                                         *
 ******************************************/
!function($, Foundation){
  'use strict';
  Foundation.Keyboard = {};

  var keyCodes = {
    9: 'TAB',
    13: 'ENTER',
    27: 'ESCAPE',
    32: 'SPACE',
    37: 'ARROW_LEFT',
    38: 'ARROW_UP',
    39: 'ARROW_RIGHT',
    40: 'ARROW_DOWN'
  };

  // constants for easier comparing Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
  var keys = (function(kcs) {
    var k = {};
    for (var kc in kcs) k[kcs[kc]] = kcs[kc];
    return k;
  })(keyCodes);

  Foundation.Keyboard.keys = keys;

  /**
   * Parses the (keyboard) event and returns a String that represents its key
   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
   * @param {Event} event - the event generated by the event handler
   * @return String key - String that represents the key pressed
   */
  var parseKey = function(event) {
    var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase();
    if (event.shiftKey) key = 'SHIFT_' + key;
    if (event.ctrlKey) key = 'CTRL_' + key;
    if (event.altKey) key = 'ALT_' + key;
    return key;
  };
  Foundation.Keyboard.parseKey = parseKey;


  // plain commands per component go here, ltr and rtl are merged based on orientation
  var commands = {};

  /**
   * Handles the given (keyboard) event
   * @param {Event} event - the event generated by the event handler
   * @param {Object} component - Foundation component, e.g. Slider or Reveal
   * @param {Objects} functions - collection of functions that are to be executed
   */
  var handleKey = function(event, component, functions) {
    var commandList = commands[Foundation.getFnName(component)],
      keyCode = parseKey(event),
      cmds,
      command,
      fn;
    if (!commandList) return console.warn('Component not defined!');

    if (typeof commandList.ltr === 'undefined') { // this component does not differentiate between ltr and rtl
        cmds = commandList; // use plain list
    } else { // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa
        if (Foundation.rtl()) cmds = $.extend({}, commandList.ltr, commandList.rtl);

        else cmds = $.extend({}, commandList.rtl, commandList.ltr);
    }
    command = cmds[keyCode];


    fn = functions[command];
    if (fn && typeof fn === 'function') { // execute function with context of the component if exists
        fn.apply(component);
        if (functions.handled || typeof functions.handled === 'function') { // execute function when event was handled
            functions.handled.apply(component);
        }
    } else {
        if (functions.unhandled || typeof functions.unhandled === 'function') { // execute function when event was not handled
            functions.unhandled.apply(component);
        }
    }
  };
  Foundation.Keyboard.handleKey = handleKey;

  /**
   * Finds all focusable elements within the given `$element`
   * @param {jQuery} $element - jQuery object to search within
   * @return {jQuery} $focusable - all focusable elements within `$element`
   */
  var findFocusable = function($element) {
    return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function() {
      if (!$(this).is(':visible') || $(this).attr('tabindex') < 0) { return false; } //only have visible elements and those that have a tabindex greater or equal 0
      return true;
    });
  };
  Foundation.Keyboard.findFocusable = findFocusable;

  /**
   * Returns the component name name
   * @param {Object} component - Foundation component, e.g. Slider or Reveal
   * @return String componentName
   */

  var register = function(componentName, cmds) {
    commands[componentName] = cmds;
  };
  Foundation.Keyboard.register = register;
}(jQuery, window.Foundation);

!function($, Foundation) {

// Default set of media queries
var defaultQueries = {
  'default' : 'only screen',
  landscape : 'only screen and (orientation: landscape)',
  portrait : 'only screen and (orientation: portrait)',
  retina : 'only screen and (-webkit-min-device-pixel-ratio: 2),' +
    'only screen and (min--moz-device-pixel-ratio: 2),' +
    'only screen and (-o-min-device-pixel-ratio: 2/1),' +
    'only screen and (min-device-pixel-ratio: 2),' +
    'only screen and (min-resolution: 192dpi),' +
    'only screen and (min-resolution: 2dppx)'
};

var MediaQuery = {
  queries: [],
  current: '',

  /**
   * Checks if the screen is at least as wide as a breakpoint.
   * @function
   * @param {String} size - Name of the breakpoint to check.
   * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.
   */
  atLeast: function(size) {
    var query = this.get(size);

    if (query) {
      return window.matchMedia(query).matches;
    }

    return false;
  },

  /**
   * Gets the media query of a breakpoint.
   * @function
   * @param {String} size - Name of the breakpoint to get.
   * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.
   */
  get: function(size) {
    for (var i in this.queries) {
      var query = this.queries[i];
      if (size === query.name) return query.value;
    }

    return null;
  },

  /**
   * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.
   * @function
   * @private
   */
  _init: function() {
    var self = this;
    var extractedStyles = $('.foundation-mq').css('font-family');
    var namedQueries;

    namedQueries = parseStyleToObject(extractedStyles);

    for (var key in namedQueries) {
      self.queries.push({
        name: key,
        value: 'only screen and (min-width: ' + namedQueries[key] + ')'
      });
    }

    this.current = this._getCurrentSize();

    this._watcher();

    // Extend default queries
    // namedQueries = $.extend(defaultQueries, namedQueries);
  },

  /**
   * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).
   * @function
   * @private
   * @returns {String} Name of the current breakpoint.
   */
  _getCurrentSize: function() {
    var matched;

    for (var i in this.queries) {
      var query = this.queries[i];

      if (window.matchMedia(query.value).matches) {
        matched = query;
      }
    }

    if(typeof matched === 'object') {
      return matched.name;
    } else {
      return matched;
    }
  },

  /**
   * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.
   * @function
   * @private
   */
  _watcher: function() {
    var _this = this;

    $(window).on('resize.zf.mediaquery', function() {
      var newSize = _this._getCurrentSize();

      if (newSize !== _this.current) {
        // Broadcast the media query change on the window
        $(window).trigger('changed.zf.mediaquery', [newSize, _this.current]);

        // Change the current media query
        _this.current = newSize;
      }
    });
  }
};

Foundation.MediaQuery = MediaQuery;

// matchMedia() polyfill - Test a CSS media type/query in JS.
// Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license
window.matchMedia || (window.matchMedia = function() {
  'use strict';

  // For browsers that support matchMedium api such as IE 9 and webkit
  var styleMedia = (window.styleMedia || window.media);

  // For those that don't support matchMedium
  if (!styleMedia) {
    var style   = document.createElement('style'),
    script      = document.getElementsByTagName('script')[0],
    info        = null;

    style.type  = 'text/css';
    style.id    = 'matchmediajs-test';

    script.parentNode.insertBefore(style, script);

    // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
    info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

    styleMedia = {
      matchMedium: function(media) {
        var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

        // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
        if (style.styleSheet) {
          style.styleSheet.cssText = text;
        } else {
          style.textContent = text;
        }

        // Test if media query is true or false
        return info.width === '1px';
      }
    };
  }

  return function(media) {
    return {
      matches: styleMedia.matchMedium(media || 'all'),
      media: media || 'all'
    };
  };
}());

// Thank you: https://github.com/sindresorhus/query-string
function parseStyleToObject(str) {
  var styleObject = {};

  if (typeof str !== 'string') {
    return styleObject;
  }

  str = str.trim().slice(1, -1); // browsers re-quote string style values

  if (!str) {
    return styleObject;
  }

  styleObject = str.split('&').reduce(function(ret, param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = parts[0];
    var val = parts[1];
    key = decodeURIComponent(key);

    // missing `=` should be `null`:
    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
    val = val === undefined ? null : decodeURIComponent(val);

    if (!ret.hasOwnProperty(key)) {
      ret[key] = val;
    } else if (Array.isArray(ret[key])) {
      ret[key].push(val);
    } else {
      ret[key] = [ret[key], val];
    }
    return ret;
  }, {});

  return styleObject;
}

}(jQuery, Foundation)

/**
 * Motion module.
 * @module foundation.motion
 */
!function($, Foundation) {

var initClasses   = ['mui-enter', 'mui-leave'];
var activeClasses = ['mui-enter-active', 'mui-leave-active'];

function animate(isIn, element, animation, cb) {
  element = $(element).eq(0);

  if (!element.length) return;

  var initClass = isIn ? initClasses[0] : initClasses[1];
  var activeClass = isIn ? activeClasses[0] : activeClasses[1];

  // Set up the animation
  reset();
  element.addClass(animation)
         .css('transition', 'none');
        //  .addClass(initClass);
  // if(isIn) element.show();
  requestAnimationFrame(function() {
    element.addClass(initClass);
    if (isIn) element.show();
  });
  // Start the animation
  requestAnimationFrame(function() {
    element[0].offsetWidth;
    element.css('transition', '');
    element.addClass(activeClass);
  });
  // Move(500, element, function(){
  //   // element[0].offsetWidth;
  //   element.css('transition', '');
  //   element.addClass(activeClass);
  // });

  // Clean up the animation when it finishes
  element.one(Foundation.transitionend(element), finish);//.one('finished.zf.animate', finish);

  // Hides the element (for out animations), resets the element, and runs a callback
  function finish() {
    if (!isIn) element.hide();
    reset();
    if (cb) cb.apply(element);
  }

  // Resets transitions and removes motion-specific classes
  function reset() {
    element[0].style.transitionDuration = 0;
    element.removeClass(initClass + ' ' + activeClass + ' ' + animation);
  }
}

var Motion = {
  animateIn: function(element, animation, /*duration,*/ cb) {
    animate(true, element, animation, cb);
  },

  animateOut: function(element, animation, /*duration,*/ cb) {
    animate(false, element, animation, cb);
  }
};

var Move = function(duration, elem, fn){
  var anim, prog, start = null;
  // console.log('called');

  function move(ts){
    if(!start) start = window.performance.now();
    // console.log(start, ts);
    prog = ts - start;
    fn.apply(elem);

    if(prog < duration){ anim = window.requestAnimationFrame(move, elem); }
    else{
      window.cancelAnimationFrame(anim);
      elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
    }
  }
  anim = window.requestAnimationFrame(move);
};

Foundation.Move = Move;
Foundation.Motion = Motion;

}(jQuery, Foundation);

!function($, Foundation){
  'use strict';
  Foundation.Nest = {
    Feather: function(menu, type){
      menu.attr('role', 'menubar');
      type = type || 'zf';
      var items = menu.find('li').attr({'role': 'menuitem'}),
          subMenuClass = 'is-' + type + '-submenu',
          subItemClass = subMenuClass + '-item',
          hasSubClass = 'is-' + type + '-submenu-parent';

      items.each(function(){
        var $item = $(this),
            $sub = $item.children('ul');
        if($sub.length){
          $item.addClass('has-submenu ' + hasSubClass);
          $sub.addClass('submenu ' + subMenuClass).attr('data-submenu', '');
        }
        if($item.parent('[data-submenu]').length){
          $item.addClass('is-submenu-item ' + subItemClass);
        }
      });
      return;
    },
    Burn: function(menu, type){
      var items = menu.find('li').removeAttr('tabindex'),
          subMenuClass = 'is-' + type + '-submenu',
          subItemClass = subMenuClass + '-item',
          hasSubClass = 'is-' + type + '-submenu-parent';

      // menu.find('.is-active').removeClass('is-active');
      menu.find('*')
      // menu.find('.' + subMenuClass + ', .' + subItemClass + ', .is-active, .has-submenu, .is-submenu-item, .submenu, [data-submenu]')
          .removeClass(subMenuClass + ' ' + subItemClass + ' ' + hasSubClass + ' has-submenu is-submenu-item submenu is-active')
          .removeAttr('data-submenu').css('display', '');

      // console.log(      menu.find('.' + subMenuClass + ', .' + subItemClass + ', .has-submenu, .is-submenu-item, .submenu, [data-submenu]')
      //           .removeClass(subMenuClass + ' ' + subItemClass + ' has-submenu is-submenu-item submenu')
      //           .removeAttr('data-submenu'));
      // items.each(function(){
      //   var $item = $(this),
      //       $sub = $item.children('ul');
      //   if($item.parent('[data-submenu]').length){
      //     $item.removeClass('is-submenu-item ' + subItemClass);
      //   }
      //   if($sub.length){
      //     $item.removeClass('has-submenu');
      //     $sub.removeClass('submenu ' + subMenuClass).removeAttr('data-submenu');
      //   }
      // });
    }
  };
}(jQuery, window.Foundation);

!function($, Foundation){
  'use strict';
  var Timer = function(elem, options, cb){
    var _this = this,
        duration = options.duration,//options is an object for easily adding features later.
        nameSpace = Object.keys(elem.data())[0] || 'timer',
        remain = -1,
        start,
        timer;

    this.restart = function(){
      remain = -1;
      clearTimeout(timer);
      this.start();
    };

    this.start = function(){
      // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
      clearTimeout(timer);
      remain = remain <= 0 ? duration : remain;
      elem.data('paused', false);
      start = Date.now();
      timer = setTimeout(function(){
        if(options.infinite){
          _this.restart();//rerun the timer.
        }
        cb();
      }, remain);
      elem.trigger('timerstart.zf.' + nameSpace);
    };

    this.pause = function(){
      //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
      clearTimeout(timer);
      elem.data('paused', true);
      var end = Date.now();
      remain = remain - (end - start);
      elem.trigger('timerpaused.zf.' + nameSpace);
    };
  };
  /**
   * Runs a callback function when images are fully loaded.
   * @param {Object} images - Image(s) to check if loaded.
   * @param {Func} callback - Function to execute when image is fully loaded.
   */
  var onImagesLoaded = function(images, callback){
    var self = this,
        unloaded = images.length;

    if (unloaded === 0) {
      callback();
    }

    var singleImageLoaded = function() {
      unloaded--;
      if (unloaded === 0) {
        callback();
      }
    };

    images.each(function() {
      if (this.complete) {
        singleImageLoaded();
      }
      else if (typeof this.naturalWidth !== 'undefined' && this.naturalWidth > 0) {
        singleImageLoaded();
      }
      else {
        $(this).one('load', function() {
          singleImageLoaded();
        });
      }
    });
  };

  Foundation.Timer = Timer;
  Foundation.onImagesLoaded = onImagesLoaded;
}(jQuery, window.Foundation);

//**************************************************
//**Work inspired by multiple jquery swipe plugins**
//**Done by Yohai Ararat ***************************
//**************************************************
(function($) {

  $.spotSwipe = {
    version: '1.0.0',
    enabled: 'ontouchstart' in document.documentElement,
    preventDefault: true,
    moveThreshold: 75,
    timeThreshold: 200
  };

  var   startPosX,
        startPosY,
        startTime,
        elapsedTime,
        isMoving = false;

  function onTouchEnd() {
    //  alert(this);
    this.removeEventListener('touchmove', onTouchMove);
    this.removeEventListener('touchend', onTouchEnd);
    isMoving = false;
  }

  function onTouchMove(e) {
    if ($.spotSwipe.preventDefault) { e.preventDefault(); }
    if(isMoving) {
      var x = e.touches[0].pageX;
      var y = e.touches[0].pageY;
      var dx = startPosX - x;
      var dy = startPosY - y;
      var dir;
      elapsedTime = new Date().getTime() - startTime;
      if(Math.abs(dx) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
        dir = dx > 0 ? 'left' : 'right';
      }
      else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
        dir = dy > 0 ? 'down' : 'up';
      }
      if(dir) {
        onTouchEnd.call(this);
        $(this).trigger('swipe', dir).trigger('swipe' + dir);
      }
    }
  }

  function onTouchStart(e) {
    if (e.touches.length == 1) {
      startPosX = e.touches[0].pageX;
      startPosY = e.touches[0].pageY;
      isMoving = true;
      startTime = new Date().getTime();
      this.addEventListener('touchmove', onTouchMove, false);
      this.addEventListener('touchend', onTouchEnd, false);
    }
  }

  function init() {
    this.addEventListener && this.addEventListener('touchstart', onTouchStart, false);
  }

  function teardown() {
    this.removeEventListener('touchstart', onTouchStart);
  }

  $.event.special.swipe = { setup: init };

  $.each(['left', 'up', 'down', 'right'], function () {
    $.event.special['swipe' + this] = { setup: function(){
      $(this).on('swipe', $.noop);
    } };
  });
})(jQuery);
/****************************************************
 * Method for adding psuedo drag events to elements *
 ***************************************************/
!function($){
  $.fn.addTouch = function(){
    this.each(function(i,el){
      $(el).bind('touchstart touchmove touchend touchcancel',function(){
        //we pass the original event object because the jQuery event
        //object is normalized to w3c specs and does not provide the TouchList
        handleTouch(event);
      });
    });

    var handleTouch = function(event){
      var touches = event.changedTouches,
          first = touches[0],
          eventTypes = {
            touchstart: 'mousedown',
            touchmove: 'mousemove',
            touchend: 'mouseup'
          },
          type = eventTypes[event.type];

      var simulatedEvent = document.createEvent('MouseEvent');
      simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0/*left*/, null);
      first.target.dispatchEvent(simulatedEvent);
    };
  };
}(jQuery);


//**********************************
//**From the jQuery Mobile Library**
//**need to recreate functionality**
//**and try to improve if possible**
//**********************************

/* Removing the jQuery function ****
************************************

(function( $, window, undefined ) {

	var $document = $( document ),
		// supportTouch = $.mobile.support.touch,
		touchStartEvent = 'touchstart'//supportTouch ? "touchstart" : "mousedown",
		touchStopEvent = 'touchend'//supportTouch ? "touchend" : "mouseup",
		touchMoveEvent = 'touchmove'//supportTouch ? "touchmove" : "mousemove";

	// setup new event shortcuts
	$.each( ( "touchstart touchmove touchend " +
		"swipe swipeleft swiperight" ).split( " " ), function( i, name ) {

		$.fn[ name ] = function( fn ) {
			return fn ? this.bind( name, fn ) : this.trigger( name );
		};

		// jQuery < 1.8
		if ( $.attrFn ) {
			$.attrFn[ name ] = true;
		}
	});

	function triggerCustomEvent( obj, eventType, event, bubble ) {
		var originalType = event.type;
		event.type = eventType;
		if ( bubble ) {
			$.event.trigger( event, undefined, obj );
		} else {
			$.event.dispatch.call( obj, event );
		}
		event.type = originalType;
	}

	// also handles taphold

	// Also handles swipeleft, swiperight
	$.event.special.swipe = {

		// More than this horizontal displacement, and we will suppress scrolling.
		scrollSupressionThreshold: 30,

		// More time than this, and it isn't a swipe.
		durationThreshold: 1000,

		// Swipe horizontal displacement must be more than this.
		horizontalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

		// Swipe vertical displacement must be less than this.
		verticalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

		getLocation: function ( event ) {
			var winPageX = window.pageXOffset,
				winPageY = window.pageYOffset,
				x = event.clientX,
				y = event.clientY;

			if ( event.pageY === 0 && Math.floor( y ) > Math.floor( event.pageY ) ||
				event.pageX === 0 && Math.floor( x ) > Math.floor( event.pageX ) ) {

				// iOS4 clientX/clientY have the value that should have been
				// in pageX/pageY. While pageX/page/ have the value 0
				x = x - winPageX;
				y = y - winPageY;
			} else if ( y < ( event.pageY - winPageY) || x < ( event.pageX - winPageX ) ) {

				// Some Android browsers have totally bogus values for clientX/Y
				// when scrolling/zooming a page. Detectable since clientX/clientY
				// should never be smaller than pageX/pageY minus page scroll
				x = event.pageX - winPageX;
				y = event.pageY - winPageY;
			}

			return {
				x: x,
				y: y
			};
		},

		start: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ],
						origin: $( event.target )
					};
		},

		stop: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ]
					};
		},

		handleSwipe: function( start, stop, thisObject, origTarget ) {
			if ( stop.time - start.time < $.event.special.swipe.durationThreshold &&
				Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&
				Math.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {
				var direction = start.coords[0] > stop.coords[ 0 ] ? "swipeleft" : "swiperight";

				triggerCustomEvent( thisObject, "swipe", $.Event( "swipe", { target: origTarget, swipestart: start, swipestop: stop }), true );
				triggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );
				return true;
			}
			return false;

		},

		// This serves as a flag to ensure that at most one swipe event event is
		// in work at any given time
		eventInProgress: false,

		setup: function() {
			var events,
				thisObject = this,
				$this = $( thisObject ),
				context = {};

			// Retrieve the events data for this element and add the swipe context
			events = $.data( this, "mobile-events" );
			if ( !events ) {
				events = { length: 0 };
				$.data( this, "mobile-events", events );
			}
			events.length++;
			events.swipe = context;

			context.start = function( event ) {

				// Bail if we're already working on a swipe event
				if ( $.event.special.swipe.eventInProgress ) {
					return;
				}
				$.event.special.swipe.eventInProgress = true;

				var stop,
					start = $.event.special.swipe.start( event ),
					origTarget = event.target,
					emitted = false;

				context.move = function( event ) {
					if ( !start || event.isDefaultPrevented() ) {
						return;
					}

					stop = $.event.special.swipe.stop( event );
					if ( !emitted ) {
						emitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );
						if ( emitted ) {

							// Reset the context to make way for the next swipe event
							$.event.special.swipe.eventInProgress = false;
						}
					}
					// prevent scrolling
					if ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {
						event.preventDefault();
					}
				};

				context.stop = function() {
						emitted = true;

						// Reset the context to make way for the next swipe event
						$.event.special.swipe.eventInProgress = false;
						$document.off( touchMoveEvent, context.move );
						context.move = null;
				};

				$document.on( touchMoveEvent, context.move )
					.one( touchStopEvent, context.stop );
			};
			$this.on( touchStartEvent, context.start );
		},

		teardown: function() {
			var events, context;

			events = $.data( this, "mobile-events" );
			if ( events ) {
				context = events.swipe;
				delete events.swipe;
				events.length--;
				if ( events.length === 0 ) {
					$.removeData( this, "mobile-events" );
				}
			}

			if ( context ) {
				if ( context.start ) {
					$( this ).off( touchStartEvent, context.start );
				}
				if ( context.move ) {
					$document.off( touchMoveEvent, context.move );
				}
				if ( context.stop ) {
					$document.off( touchStopEvent, context.stop );
				}
			}
		}
	};
	$.each({
		swipeleft: "swipe.left",
		swiperight: "swipe.right"
	}, function( event, sourceEvent ) {

		$.event.special[ event ] = {
			setup: function() {
				$( this ).bind( sourceEvent, $.noop );
			},
			teardown: function() {
				$( this ).unbind( sourceEvent );
			}
		};
	});
})( jQuery, this );
*/

!function(Foundation, $) {
  'use strict';
  // Elements with [data-open] will reveal a plugin that supports it when clicked.
  $(document).on('click.zf.trigger', '[data-open]', function() {
    var id = $(this).data('open');
    $('#' + id).triggerHandler('open.zf.trigger', [$(this)]);
  });

  // Elements with [data-close] will close a plugin that supports it when clicked.
  // If used without a value on [data-close], the event will bubble, allowing it to close a parent component.
  $(document).on('click.zf.trigger', '[data-close]', function() {
    var id = $(this).data('close');
    if (id) {
      $('#' + id).triggerHandler('close.zf.trigger', [$(this)]);
    }
    else {
      $(this).trigger('close.zf.trigger');
    }
  });

  // Elements with [data-toggle] will toggle a plugin that supports it when clicked.
  $(document).on('click.zf.trigger', '[data-toggle]', function() {
    var id = $(this).data('toggle');
    $('#' + id).triggerHandler('toggle.zf.trigger', [$(this)]);
  });

  // Elements with [data-closable] will respond to close.zf.trigger events.
  $(document).on('close.zf.trigger', '[data-closable]', function() {
    var animation = $(this).data('closable') || 'fade-out';
    if(Foundation.Motion){
      Foundation.Motion.animateOut($(this), animation, function() {
        $(this).trigger('closed.zf');
      });
    }else{
      $(this).fadeOut().trigger('closed.zf');
    }
  });

  var MutationObserver = (function () {
    var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
    for (var i=0; i < prefixes.length; i++) {
      if (prefixes[i] + 'MutationObserver' in window) {
        return window[prefixes[i] + 'MutationObserver'];
      }
    }
    return false;
  }());


  var checkListeners = function(){
    eventsListener();
    resizeListener();
    scrollListener();
    closemeListener();
  };
  /**
  * Fires once after all other scripts have loaded
  * @function
  * @private
  */
  $(window).load(function(){
    checkListeners();
  });

  //******** only fires this function once on load, if there's something to watch ********
  var closemeListener = function(pluginName){
    var yetiBoxes = $('[data-yeti-box]'),
        plugNames = ['dropdown', 'tooltip', 'reveal'];

    if(pluginName){
      if(typeof pluginName === 'string'){
        plugNames.push(pluginName);
      }else if(typeof pluginName === 'object' && typeof pluginName[0] === 'string'){
        plugNames.concat(pluginName);
      }else{
        console.error('Plugin names must be strings');
      }
    }
    if(yetiBoxes.length){
      var listeners = plugNames.map(function(name){
        return 'closeme.zf.' + name;
      }).join(' ');

      $(window).off(listeners).on(listeners, function(e, pluginId){
        var plugin = e.namespace.split('.')[0];
        var plugins = $('[data-' + plugin + ']').not('[data-yeti-box="' + pluginId + '"]');

        plugins.each(function(){
          var _this = $(this);

          _this.triggerHandler('close.zf.trigger', [_this]);
        });
      });
    }
  };
  var resizeListener = function(debounce){
    var timer,
        $nodes = $('[data-resize]');
    if($nodes.length){
      $(window).off('resize.zf.trigger')
      .on('resize.zf.trigger', function(e) {
        if (timer) { clearTimeout(timer); }

        timer = setTimeout(function(){

          if(!MutationObserver){//fallback for IE 9
            $nodes.each(function(){
              $(this).triggerHandler('resizeme.zf.trigger');
            });
          }
          //trigger all listening elements and signal a resize event
          $nodes.attr('data-events', "resize");
        }, debounce || 10);//default time to emit resize event
      });
    }
  };
  var scrollListener = function(debounce){
    var timer,
        $nodes = $('[data-scroll]');
    if($nodes.length){
      $(window).off('scroll.zf.trigger')
      .on('scroll.zf.trigger', function(e){
        if(timer){ clearTimeout(timer); }

        timer = setTimeout(function(){

          if(!MutationObserver){//fallback for IE 9
            $nodes.each(function(){
              $(this).triggerHandler('scrollme.zf.trigger');
            });
          }
          //trigger all listening elements and signal a scroll event
          $nodes.attr('data-events', "scroll");
        }, debounce || 10);//default time to emit scroll event
      });
    }
  };
  // function domMutationObserver(debounce) {
  //   // !!! This is coming soon and needs more work; not active  !!! //
  //   var timer,
  //   nodes = document.querySelectorAll('[data-mutate]');
  //   //
  //   if (nodes.length) {
  //     // var MutationObserver = (function () {
  //     //   var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
  //     //   for (var i=0; i < prefixes.length; i++) {
  //     //     if (prefixes[i] + 'MutationObserver' in window) {
  //     //       return window[prefixes[i] + 'MutationObserver'];
  //     //     }
  //     //   }
  //     //   return false;
  //     // }());
  //
  //
  //     //for the body, we need to listen for all changes effecting the style and class attributes
  //     var bodyObserver = new MutationObserver(bodyMutation);
  //     bodyObserver.observe(document.body, { attributes: true, childList: true, characterData: false, subtree:true, attributeFilter:["style", "class"]});
  //
  //
  //     //body callback
  //     function bodyMutation(mutate) {
  //       //trigger all listening elements and signal a mutation event
  //       if (timer) { clearTimeout(timer); }
  //
  //       timer = setTimeout(function() {
  //         bodyObserver.disconnect();
  //         $('[data-mutate]').attr('data-events',"mutate");
  //       }, debounce || 150);
  //     }
  //   }
  // }
  var eventsListener = function() {
    if(!MutationObserver){ return false; }
    var nodes = document.querySelectorAll('[data-resize], [data-scroll], [data-mutate]');

    //element callback
    var listeningElementsMutation = function(mutationRecordsList) {
      var $target = $(mutationRecordsList[0].target);
      //trigger the event handler for the element depending on type
      switch ($target.attr("data-events")) {

        case "resize" :
        $target.triggerHandler('resizeme.zf.trigger', [$target]);
        break;

        case "scroll" :
        $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);
        break;

        // case "mutate" :
        // console.log('mutate', $target);
        // $target.triggerHandler('mutate.zf.trigger');
        //
        // //make sure we don't get stuck in an infinite loop from sloppy codeing
        // if ($target.index('[data-mutate]') == $("[data-mutate]").length-1) {
        //   domMutationObserver();
        // }
        // break;

        default :
        return false;
        //nothing
      }
    }

    if(nodes.length){
      //for each element that needs to listen for resizing, scrolling, (or coming soon mutation) add a single observer
      for (var i = 0; i <= nodes.length-1; i++) {
        var elementObserver = new MutationObserver(listeningElementsMutation);
        elementObserver.observe(nodes[i], { attributes: true, childList: false, characterData: false, subtree:false, attributeFilter:["data-events"]});
      }
    }
  };
  // ------------------------------------

  // [PH]
  // Foundation.CheckWatchers = checkWatchers;
  Foundation.IHearYou = checkListeners;
  // Foundation.ISeeYou = scrollListener;
  // Foundation.IFeelYou = closemeListener;

}(window.Foundation, window.jQuery);

!function(Foundation, $) {
  'use strict';

  /**
   * Creates a new instance of Abide.
   * @class
   * @fires Abide#init
   * @param {Object} element - jQuery object to add the trigger to.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function Abide(element, options) {
    this.$element = element;
    this.options  = $.extend({}, Abide.defaults, this.$element.data(), options);
    this.$window  = $(window);
    this.name     = 'Abide';
    this.attr     = 'data-abide';

    this._init();
    this._events();

    Foundation.registerPlugin(this);
  }

  /**
   * Default settings for plugin
   */
  Abide.defaults = {
    validateOn: 'fieldChange', // options: fieldChange, manual, submit
    labelErrorClass: 'is-invalid-label',
    inputErrorClass: 'is-invalid-input',
    formErrorSelector: '.form-error',
    formErrorClass: 'is-visible',
    patterns: {
      alpha : /^[a-zA-Z]+$/,
      alpha_numeric : /^[a-zA-Z0-9]+$/,
      integer : /^[-+]?\d+$/,
      number : /^[-+]?\d*(?:[\.\,]\d+)?$/,

      // amex, visa, diners
      card : /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,
      cvv : /^([0-9]){3,4}$/,

      // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address
      email : /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,

      url : /^(https?|ftp|file|ssh):\/\/(((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/,
      // abc.de
      domain : /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,8}$/,

      datetime : /^([0-2][0-9]{3})\-([0-1][0-9])\-([0-3][0-9])T([0-5][0-9])\:([0-5][0-9])\:([0-5][0-9])(Z|([\-\+]([0-1][0-9])\:00))$/,
      // YYYY-MM-DD
      date : /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,
      // HH:MM:SS
      time : /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,
      dateISO : /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,
      // MM/DD/YYYY
      month_day_year : /^(0[1-9]|1[012])[- \/.](0[1-9]|[12][0-9]|3[01])[- \/.]\d{4}$/,
      // DD/MM/YYYY
      day_month_year : /^(0[1-9]|[12][0-9]|3[01])[- \/.](0[1-9]|1[012])[- \/.]\d{4}$/,

      // #FFF or #FFFFFF
      color : /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/
    },
    validators: {
      equalTo: function (el, required, parent) {
        var from  = document.getElementById(el.getAttribute(this.add_namespace('data-equalto'))).value,
            to    = el.value,
            valid = (from === to);

        return valid;
      }
    }
  };


  /**
   * Initializes the Abide plugin and calls functions to get Abide functioning on load.
   * @private
   */
  Abide.prototype._init = function() {
  };

  /**
   * Initializes events for Abide.
   * @private
   */
  Abide.prototype._events = function() {
    var self = this;
    this.$element
      .off('.abide')
      .on('reset.fndtn.abide', function(e) {
        self.resetForm($(this));
      })
      .on('submit.fndtn.abide', function(e) {
        e.preventDefault();
        self.validateForm(self.$element);
      })
      .find('input, textarea, select')
        .off('.abide')
        .on('blur.fndtn.abide change.fndtn.abide', function (e) {
          if (self.options.validateOn === 'fieldChange') {
            self.validateInput($(e.target), self.$element);
          }
          // self.validateForm(self.$element);
        })
        .on('keydown.fndtn.abide', function (e) {
          // if (settings.live_validate === true && e.which != 9) {
          //   clearTimeout(self.timer);
          //   self.timer = setTimeout(function () {
          //     self.validate([this], e);
          //   }.bind(this), settings.timeout);
          // }
          // self.validateForm(self.$element);
        });

  },
  /**
   * Calls necessary functions to update Abide upon DOM change
   * @private
   */
  Abide.prototype._reflow = function() {
    var self = this;
  };
  /**
   * Checks whether or not a form element has the required attribute and if it's checked or not
   * @param {Object} element - jQuery object to check for required attribute
   * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
   */
  Abide.prototype.requiredCheck = function($el) {
    switch ($el[0].type) {
      case 'text':
        if ($el.attr('required') && !$el.val()) {
          // requirement check does not pass
          return false;
        } else {
          return true;
        }
        break;
      case 'checkbox':
        if ($el.attr('required') && !$el.is(':checked')) {
          return false;
        } else {
          return true;
        }
        break;
      case 'radio':
        if ($el.attr('required') && !$el.is(':checked')) {
          return false;
        } else {
          return true;
        }
        break;
      default:
        if ($el.attr('required') && (!$el.val() || !$el.val().length || $el.is(':empty'))) {
          return false;
        } else {
          return true;
        }
    }
  };
  /**
   * Checks whether or not a form element has the required attribute and if it's checked or not
   * @param {Object} element - jQuery object to check for required attribute
   * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
   */
  Abide.prototype.findLabel = function($el) {
    if ($el.next('label').length) {
      return $el.next('label');
    }
    else {
      return $el.closest('label');
    }
  };
  /**
   * Adds the CSS error class as specified by the Abide settings to the label, input, and the form
   * @param {Object} element - jQuery object to add the class to
   */
  Abide.prototype.addErrorClasses = function($el) {
    var self = this,
        $label = self.findLabel($el),
        $formError = $el.next(self.options.formErrorSelector) || $el.find(self.options.formErrorSelector);

    // label
    if ($label) {
      $label.addClass(self.options.labelErrorClass);
    }
    // form error
    if ($formError) {
      $formError.addClass(self.options.formErrorClass);
    }
    // input
    $el.addClass(self.options.inputErrorClass);
  };
  /**
   * Removes CSS error class as specified by the Abide settings from the label, input, and the form
   * @param {Object} element - jQuery object to remove the class from
   */
  Abide.prototype.removeErrorClasses = function($el) {
    var self = this,
        $label = self.findLabel($el),
        $formError = $el.next(self.options.formErrorSelector) || $el.find(self.options.formErrorSelector);
    // label
    if ($label && $label.hasClass(self.options.labelErrorClass)) {
      $label.removeClass(self.options.labelErrorClass);
    }
    // form error
    if ($formError && $formError.hasClass(self.options.formErrorClass)) {
      $formError.removeClass(self.options.formErrorClass);
    }
    // input
    if ($el.hasClass(self.options.inputErrorClass)) {
      $el.removeClass(self.options.inputErrorClass);
    }
  };
  /**
   * Goes through a form to find inputs and proceeds to validate them in ways specific to their type
   * @fires Abide#invalid
   * @fires Abide#valid
   * @param {Object} element - jQuery object to validate, should be an HTML input
   * @param {Object} form - jQuery object of the entire form to find the various input elements
   */
  Abide.prototype.validateInput = function($el, $form) {
    var self = this,
        textInput = $form.find('input[type="text"]'),
        checkInput = $form.find('input[type="checkbox"]'),
        label,
        radioGroupName;

    if ($el[0].type === 'text') {
      if (!self.requiredCheck($el) || !self.validateText($el)) {
        self.addErrorClasses($el);
        $el.trigger('invalid.fndtn.abide', $el[0]);
      }
      else {
        self.removeErrorClasses($el);
        $el.trigger('valid.fndtn.abide', $el[0]);
      }
    }
    else if ($el[0].type === 'radio') {
      radioGroupName = $el.attr('name');
      label = $el.siblings('label');

      if (self.validateRadio(radioGroupName)) {
        $(label).each(function() {
          if ($(this).hasClass(self.options.labelErrorClass)) {
            $(this).removeClass(self.options.labelErrorClass);
          }
        });
        $el.trigger('valid.fndtn.abide', $el[0]);
      }
      else {
        $(label).each(function() {
          $(this).addClass(self.options.labelErrorClass);
        });
        $el.trigger('invalid.fndtn.abide', $el[0]);
      };
    }
    else if ($el[0].type === 'checkbox') {
      if (!self.requiredCheck($el)) {
        self.addErrorClasses($el);
        $el.trigger('invalid.fndtn.abide', $el[0]);
      }
      else {
        self.removeErrorClasses($el);
        $el.trigger('valid.fndtn.abide', $el[0]);
      }
    }
    else {
      if (!self.requiredCheck($el) || !self.validateText($el)) {
        self.addErrorClasses($el);
        $el.trigger('invalid.fndtn.abide', $el[0]);
      }
      else {
        self.removeErrorClasses($el);
        $el.trigger('valid.fndtn.abide', $el[0]);
      }
    }
  };
  /**
   * Goes through a form and if there are any invalid inputs, it will display the form error element
   * @param {Object} element - jQuery object to validate, should be a form HTML element
   */
  Abide.prototype.validateForm = function($form) {
    var self = this,
        inputs = $form.find('input'),
        inputCount = $form.find('input').length,
        counter = 0;

    while (counter < inputCount) {
      self.validateInput($(inputs[counter]), $form);
      counter++;
    }

    // what are all the things that can go wrong with a form?
    if ($form.find('.form-error.is-visible').length || $form.find('.is-invalid-label').length) {
      $form.find('[data-abide-error]').css('display', 'block');
    }
    else {
      $form.find('[data-abide-error]').css('display', 'none');
    }
  };
  /**
   * Determines whether or a not a text input is valid based on the patterns specified in the attribute
   * @param {Object} element - jQuery object to validate, should be a text input HTML element
   * @returns {Boolean} Boolean value depends on whether or not the input value matches the pattern specified
   */
  Abide.prototype.validateText = function($el) {
    var self = this,
        valid = false,
        patternLib = this.options.patterns,
        inputText = $($el).val(),
        // maybe have a different way of parsing this bc people might use type
        pattern = $($el).attr('pattern');

    // if there's no value, then return true
    // since required check has already been done
    if (inputText.length === 0) {
      return true;
    }
    else {
      if (inputText.match(patternLib[pattern])) {
        return true;
      }
      else {
        return false;
      }
    }
  };
  /**
   * Determines whether or a not a radio input is valid based on whether or not it is required and selected
   * @param {String} group - A string that specifies the name of a radio button group
   * @returns {Boolean} Boolean value depends on whether or not at least one radio input has been selected (if it's required)
   */
  Abide.prototype.validateRadio = function(group) {
    var self = this,
        labels = $(':radio[name="' + group + '"]').siblings('label'),
        counter = 0;
    // go through each radio button
    $(':radio[name="' + group + '"]').each(function() {
      // put them through the required checkpoint
      if (!self.requiredCheck($(this))) {
        // if at least one doesn't pass, add a tally to the counter
        counter++;
      }
      // if at least one is checked
      // reset the counter
      if ($(this).is(':checked')) {
        counter = 0;
      }
    });

    if (counter > 0) {
      return false;
    }
    else {
      return true;
    }
  };
  Abide.prototype.matchValidation = function(val, validation) {

  };
  /**
   * Resets form inputs and styles
   * @param {Object} $form - A jQuery object that should be an HTML form element
   */
  Abide.prototype.resetForm = function($form) {
    var self = this;
    var invalidAttr = 'data-invalid';
    // remove data attributes
    $('[' + self.invalidAttr + ']', $form).removeAttr(invalidAttr);
    // remove styles
    $('.' + self.options.labelErrorClass, $form).not('small').removeClass(self.options.labelErrorClass);
    $('.' + self.options.inputErrorClass, $form).not('small').removeClass(self.options.inputErrorClass);
    $('.form-error.is-visible').removeClass('is-visible');
    $form.find('[data-abide-error]').css('display', 'none');
    $(':input', $form).not(':button, :submit, :reset, :hidden, [data-abide-ignore]').val('').removeAttr(invalidAttr);
  };
  Abide.prototype.destroy = function(){
    //TODO this...
  };

  Foundation.plugin(Abide, 'Abide');

  // Exports for AMD/Browserify
  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined')
    module.exports = Abide;
  if (typeof define === 'function')
    define(['foundation'], function() {
      return Abide;
    });

}(Foundation, jQuery);

/**
 * Accordion module.
 * @module foundation.accordion
 * @requires foundation.util.keyboard
 * @requires foundation.util.motion
 */
!function($, Foundation) {
  'use strict';

  /**
   * Creates a new instance of an accordion.
   * @class
   * @fires Accordion#init
   * @param {jQuery} element - jQuery object to make into an accordion.
   */
  function Accordion(element, options){
    this.$element = element;
    this.options = $.extend({}, Accordion.defaults, this.$element.data(), options);

    this._init();

    Foundation.registerPlugin(this);
    Foundation.Keyboard.register('Accordion', {
      'ENTER': 'toggle',
      'SPACE': 'toggle',
      'ARROW_DOWN': 'next',
      'ARROW_UP': 'previous'
    });
  }

  Accordion.defaults = {
    /**
     * Amount of time to animate the opening of an accordion pane.
     * @option
     * @example 250
     */
    slideSpeed: 250,
    /**
     * Allow the accordion to have multiple open panes.
     * @option
     * @example false
     */
    multiExpand: false,
    /**
     * Allow the accordion to close all panes.
     * @option
     * @example false
     */
    allowAllClosed: false
  };

  /**
   * Initializes the accordion by animating the preset active pane(s).
   * @private
   */
  Accordion.prototype._init = function() {
    this.$element.attr('role', 'tablist');
    this.$tabs = this.$element.children('li');
    this.$tabs.each(function(idx, el){

      var $el = $(el),
          $content = $el.find('[data-tab-content]'),
          id = $content[0].id || Foundation.GetYoDigits(6, 'accordion'),
          linkId = el.id || id + '-label';

      $el.find('a:first').attr({
        'aria-controls': id,
        'role': 'tab',
        'id': linkId,
        'aria-expanded': false,
        'aria-selected': false
      });
      $content.attr({'role': 'tabpanel', 'aria-labelledby': linkId, 'aria-hidden': true, 'id': id});
    });
    var $initActive = this.$element.find('.is-active').children('[data-tab-content]');
    if($initActive.length){
      this.down($initActive, true);
    }
    this._events();
  };

  /**
   * Adds event handlers for items within the accordion.
   * @private
   */
  Accordion.prototype._events = function() {
    var _this = this;

    this.$tabs.each(function(){
      var $elem = $(this);
      var $tabContent = $elem.children('[data-tab-content]');
      if ($tabContent.length) {
        $elem.children('a').off('click.zf.accordion keydown.zf.accordion')
               .on('click.zf.accordion', function(e){
        // $(this).children('a').on('click.zf.accordion', function(e) {
          e.preventDefault();
          if ($elem.hasClass('is-active')) {
            if(_this.options.allowAllClosed || $elem.siblings().hasClass('is-active')){
              _this.up($tabContent);
            }
          }
          else {
            _this.down($tabContent);
          }
        }).on('keydown.zf.accordion', function(e){
          Foundation.Keyboard.handleKey(e, _this, {
            toggle: function() {
              _this.toggle($tabContent);
            },
            next: function() {
              $elem.next().find('a').focus().trigger('click.zf.accordion');
            },
            previous: function() {
              $elem.prev().find('a').focus().trigger('click.zf.accordion');
            },
            handled: function() {
              e.preventDefault();
              e.stopPropagation();
            }
          });
        });
      }
    });
  };
  /**
   * Toggles the selected content pane's open/close state.
   * @param {jQuery} $target - jQuery object of the pane to toggle.
   * @function
   */
  Accordion.prototype.toggle = function($target){
    if($target.parent().hasClass('is-active')){
      if(this.options.allowAllClosed || $target.parent().siblings().hasClass('is-active')){
        this.up($target);
      }else{ return; }
    }else{
      this.down($target);
    }
  };
  /**
   * Opens the accordion tab defined by `$target`.
   * @param {jQuery} $target - Accordion pane to open.
   * @param {Boolean} firstTime - flag to determine if reflow should happen.
   * @fires Accordion#down
   * @function
   */
  Accordion.prototype.down = function($target, firstTime) {
    var _this = this;
    if(!this.options.multiExpand && !firstTime){
      var $currentActive = this.$element.find('.is-active').children('[data-tab-content]');
      if($currentActive.length){
        this.up($currentActive);
      }
    }

    $target
      .attr('aria-hidden', false)
      .parent('[data-tab-content]')
      .addBack()
      .parent().addClass('is-active');

    Foundation.Move(_this.options.slideSpeed, $target, function(){
      $target.slideDown(_this.options.slideSpeed);
    });

    if(!firstTime){
      Foundation._reflow(this.$element.attr('data-accordion'));
    }
    $('#' + $target.attr('aria-labelledby')).attr({
      'aria-expanded': true,
      'aria-selected': true
    });
    /**
     * Fires when the tab is done opening.
     * @event Accordion#down
     */
    this.$element.trigger('down.zf.accordion', [$target]);
  };

  /**
   * Closes the tab defined by `$target`.
   * @param {jQuery} $target - Accordion tab to close.
   * @fires Accordion#up
   * @function
   */
  Accordion.prototype.up = function($target) {
    var $aunts = $target.parent().siblings(),
        _this = this;
    var canClose = this.options.multiExpand ? $aunts.hasClass('is-active') : $target.parent().hasClass('is-active');

    if(!this.options.allowAllClosed && !canClose){
      return;
    }

    Foundation.Move(this.options.slideSpeed, $target, function(){
      $target.slideUp(_this.options.slideSpeed);
    });

    $target.attr('aria-hidden', true)
           .parent().removeClass('is-active');

    $('#' + $target.attr('aria-labelledby')).attr({
     'aria-expanded': false,
     'aria-selected': false
   });

    /**
     * Fires when the tab is done collapsing up.
     * @event Accordion#up
     */
    this.$element.trigger('up.zf.accordion', [$target]);
  };

  /**
   * Destroys an instance of an accordion.
   * @fires Accordion#destroyed
   * @function
   */
  Accordion.prototype.destroy = function() {
    this.$element.find('[data-tab-content]').slideUp(0).css('display', '');
    this.$element.find('a').off('.zf.accordion');

    Foundation.unregisterPlugin(this);
  };

  Foundation.plugin(Accordion, 'Accordion');
}(jQuery, window.Foundation);

/**
 * AccordionMenu module.
 * @module foundation.accordionMenu
 * @requires foundation.util.keyboard
 * @requires foundation.util.motion
 * @requires foundation.util.nest
 */
!function($) {
  'use strict';

  /**
   * Creates a new instance of an accordion menu.
   * @class
   * @fires AccordionMenu#init
   * @param {jQuery} element - jQuery object to make into an accordion menu.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function AccordionMenu(element, options) {
    this.$element = element;
    this.options = $.extend({}, AccordionMenu.defaults, this.$element.data(), options);

    Foundation.Nest.Feather(this.$element, 'accordion');

    this._init();

    Foundation.registerPlugin(this);
    Foundation.Keyboard.register('AccordionMenu', {
      'ENTER': 'toggle',
      'SPACE': 'toggle',
      'ARROW_RIGHT': 'open',
      'ARROW_UP': 'up',
      'ARROW_DOWN': 'down',
      'ARROW_LEFT': 'close',
      'ESCAPE': 'closeAll',
      'TAB': 'down',
      'SHIFT_TAB': 'up'
    });
  }

  AccordionMenu.defaults = {
    /**
     * Amount of time to animate the opening of a submenu in ms.
     * @option
     * @example 250
     */
    slideSpeed: 250,
    /**
     * Allow the menu to have multiple open panes.
     * @option
     * @example true
     */
    multiOpen: true
  };

  /**
   * Initializes the accordion menu by hiding all nested menus.
   * @private
   */
  AccordionMenu.prototype._init = function() {
    this.$element.find('[data-submenu]').not('.is-active').slideUp(0);//.find('a').css('padding-left', '1rem');
    this.$element.attr({
      'role': 'tablist',
      'aria-multiselectable': this.options.multiOpen
    });

    this.$menuLinks = this.$element.find('.has-submenu');
    this.$menuLinks.each(function(){
      var linkId = this.id || Foundation.GetYoDigits(6, 'acc-menu-link'),
          $elem = $(this),
          $sub = $elem.children('[data-submenu]'),
          subId = $sub[0].id || Foundation.GetYoDigits(6, 'acc-menu'),
          isActive = $sub.hasClass('is-active');
      $elem.attr({
        'aria-controls': subId,
        'aria-expanded': isActive,
        'aria-selected': false,
        'role': 'tab',
        'id': linkId
      });
      $sub.attr({
        'aria-labelledby': linkId,
        'aria-hidden': !isActive,
        'role': 'tabpanel',
        'id': subId
      });
    });
    var initPanes = this.$element.find('.is-active');
    if(initPanes.length){
      var _this = this;
      initPanes.each(function(){
        _this.down($(this));
      });
    }
    this._events();
  };

  /**
   * Adds event handlers for items within the menu.
   * @private
   */
  AccordionMenu.prototype._events = function() {
    var _this = this;

    this.$element.find('li').each(function() {
      var $submenu = $(this).children('[data-submenu]');

      if ($submenu.length) {
        $(this).children('a').off('click.zf.accordionmenu').on('click.zf.accordionmenu', function(e) {
          e.preventDefault();

          _this.toggle($submenu);
        });
      }
    }).on('keydown.zf.accordionmenu', function(e){
      var $element = $(this),
          $elements = $element.parent('ul').children('li'),
          $prevElement,
          $nextElement,
          $target = $element.children('[data-submenu]');

      $elements.each(function(i) {
        if ($(this).is($element)) {
          $prevElement = $elements.eq(Math.max(0, i-1));
          $nextElement = $elements.eq(Math.min(i+1, $elements.length-1));

          if ($(this).children('[data-submenu]:visible').length) { // has open sub menu
            $nextElement = $element.find('li:first-child');
          }
          if ($(this).is(':first-child')) { // is first element of sub menu
            $prevElement = $element.parents('li').first();
          } else if ($prevElement.children('[data-submenu]:visible').length) { // if previous element has open sub menu
            $prevElement = $prevElement.find('li:last-child');
          }
          if ($(this).is(':last-child')) { // is last element of sub menu
            $nextElement = $element.parents('li').first().next('li');
          }

          return;
        }
      });
      Foundation.Keyboard.handleKey(e, _this, {
        open: function() {
          if ($target.is(':hidden')) {
            _this.down($target);
            $target.find('li').first().focus();
          }
        },
        close: function() {
          if ($target.length && !$target.is(':hidden')) { // close active sub of this item
            _this.up($target);
          } else if ($element.parent('[data-submenu]').length) { // close currently open sub
            _this.up($element.parent('[data-submenu]'));
            $element.parents('li').first().focus();
          }
        },
        up: function() {
          $prevElement.focus();
        },
        down: function() {
          $nextElement.focus();
        },
        toggle: function() {
          if ($element.children('[data-submenu]').length) {
            _this.toggle($element.children('[data-submenu]'));
          }
        },
        closeAll: function() {
          _this.hideAll();
        },
        handled: function() {
          e.preventDefault();
          e.stopImmediatePropagation();
        }
      });
    });//.attr('tabindex', 0);
  };
  /**
   * Closes all panes of the menu.
   * @function
   */
  AccordionMenu.prototype.hideAll = function(){
    this.$element.find('[data-submenu]').slideUp(this.options.slideSpeed);
  };
  /**
   * Toggles the open/close state of a submenu.
   * @function
   * @param {jQuery} $target - the submenu to toggle
   */
  AccordionMenu.prototype.toggle = function($target){
    if (!$target.is(':hidden')) {
      this.up($target);
    }
    else {
      this.down($target);
    }
  };
  /**
   * Opens the sub-menu defined by `$target`.
   * @param {jQuery} $target - Sub-menu to open.
   * @fires AccordionMenu#down
   */
  AccordionMenu.prototype.down = function($target) {
    var _this = this;
    console.log($target);
    if(!this.options.multiOpen){
      this.up(this.$element.find('.is-active').not($target.parentsUntil(this.$element)));
    }

    $target.addClass('is-active').attr({'aria-hidden': false})
      .parent('.has-submenu').attr({'aria-expanded': true, 'aria-selected': true});

      Foundation.Move(this.options.slideSpeed, $target, function(){
        $target.slideDown(_this.options.slideSpeed);
      });
    /**
     * Fires when the menu is done collapsing up.
     * @event AccordionMenu#down
     */
    this.$element.trigger('down.zf.accordionMenu', [$target]);
  };

  /**
   * Closes the sub-menu defined by `$target`. All sub-menus inside the target will be closed as well.
   * @param {jQuery} $target - Sub-menu to close.
   * @fires AccordionMenu#up
   */
  AccordionMenu.prototype.up = function($target) {
    var _this = this;
    Foundation.Move(this.options.slideSpeed, $target, function(){
      $target.slideUp(_this.options.slideSpeed);
    });
    $target.attr('aria-hidden', true)
           .find('[data-submenu]').slideUp(0).attr('aria-hidden', true).end()
           .parent('.has-submenu')
           .attr({'aria-expanded': false, 'aria-selected': false});
    // $target.slideUp(this.options.slideSpeed, function() {
    //   $target.find('[data-submenu]').slideUp(0).attr('aria-hidden', true);
    // }).attr('aria-hidden', true).parent('.has-submenu').attr({'aria-expanded': false, 'aria-selected': false});

    /**
     * Fires when the menu is done collapsing up.
     * @event AccordionMenu#up
     */
    this.$element.trigger('up.zf.accordionMenu', [$target]);
  };

  /**
   * Destroys an instance of accordion menu.
   * @fires AccordionMenu#destroyed
   */
  AccordionMenu.prototype.destroy = function(){
    this.$element.find('[data-submenu]').slideDown(0).css('display', '');
    this.$element.find('a').off('click.zf.accordionMenu');

    Foundation.Nest.Burn(this.$element, 'accordion');
    Foundation.unregisterPlugin(this);
  };

  Foundation.plugin(AccordionMenu, 'AccordionMenu');
}(jQuery, window.Foundation);

/**
 * Drilldown module.
 * @module foundation.drilldown
 * @requires foundation.util.keyboard
 * @requires foundation.util.motion
 * @requires foundation.util.nest
 */
!function($, Foundation){
  'use strict';

  /**
   * Creates a new instance of a drilldown menu.
   * @class
   * @param {jQuery} element - jQuery object to make into an accordion menu.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function Drilldown(element, options){
    this.$element = element;
    this.options = $.extend({}, Drilldown.defaults, this.$element.data(), options);

    Foundation.Nest.Feather(this.$element, 'drilldown');

    this._init();

    Foundation.registerPlugin(this);
    Foundation.Keyboard.register('Drilldown', {
      'ENTER': 'open',
      'SPACE': 'open',
      'ARROW_RIGHT': 'next',
      'ARROW_UP': 'up',
      'ARROW_DOWN': 'down',
      'ARROW_LEFT': 'previous',
      'ESCAPE': 'close',
      'TAB': 'down',
      'SHIFT_TAB': 'up'
    });
  }
  Drilldown.defaults = {
    /**
     * Markup used for JS generated back button. Prepended to submenu lists and deleted on `destroy` method.
     * @option
     * @example '<li><a>Back</a></li>'
     */
    backButton: '<li class="js-drilldown-back" tabindex="0"><a>Back</a></li>',
    /**
     * Markup used to wrap drilldown menu. Use a class name for independent styling, or the JS applied class: `is-drilldown`.
     * @option
     * @example '<div></div>'
     */
    wrapper: '<div></div>',
    /**
     * Allow the menu to return to root list on body click.
     * @option
     * @example false
     */
    closeOnClick: false,
    // holdOpen: false
  };
  /**
   * Initializes the drilldown by creating jQuery collections of elements
   * @private
   */
  Drilldown.prototype._init = function(){
    this.$submenuAnchors = this.$element.find('li.has-submenu');
    this.$submenus = this.$submenuAnchors.children('[data-submenu]').addClass('is-drilldown-sub')/*.wrap($(this.options.wrapper).addClass('is-drilldown-sub'))*/;
    // this.$rootElems = this.$element.children('[data-submenu]')/*.addClass('first-sub')*/;
    this.$menuItems = this.$element.find('li').not('.js-drilldown-back').attr('role', 'menuitem');
    // this.$submenus;


    this._prepareMenu();
    // this._getMaxDims();
    this._keyboardEvents();
  };
  /**
   * prepares drilldown menu by setting attributes to links and elements
   * sets a min height to prevent content jumping
   * wraps the element if not already wrapped
   * @private
   * @function
   */
  Drilldown.prototype._prepareMenu = function(){
    var _this = this;
    // if(!this.options.holdOpen){
    //   this._menuLinkEvents();
    // }
    this.$submenuAnchors.each(function(){
      var $sub = $(this);
      $sub.find('a')[0].removeAttribute('href');
      $sub.children('[data-submenu]')
          .attr({
            'aria-hidden': true,
            'tabindex': 0,
            'role': 'menu'
          });
      _this._events($sub);
    });
    this.$submenus.each(function(){
      var $menu = $(this),
          $back = $menu.find('.js-drilldown-back');
      if(!$back.length){
        $menu.prepend(_this.options.backButton);
        _this._back($menu);
      }
    });
    if(!this.$element.parent().hasClass('is-drilldown')){
      this.$wrapper = $(this.options.wrapper).addClass('is-drilldown').css(this._getMaxDims());
      this.$element.wrap(this.$wrapper);
    }

  };
  /**
   * Adds event handlers to elements in the menu.
   * @function
   * @private
   * @param {jQuery} $elem - the current menu item to add handlers to.
   */
  Drilldown.prototype._events = function($elem){
    var _this = this;

    $elem.off('click.zf.drilldown')
    .on('click.zf.drilldown', function(e){
      e.stopImmediatePropagation();
      e.preventDefault();

      if(e.target !== e.currentTarget.firstElementChild){
        return false;
      }
      _this._show($elem);

      if(_this.options.closeOnClick){
        var $body = $('body').not(_this.$wrapper);
        $body.off('.zf.drilldown').on('click.zf.drilldown', function(e){
          e.preventDefault();
          _this._hideAll();
          $body.off('.zf.drilldown');
        });
      }
    });
  };
  /**
   * Adds keydown event listener to `li`'s in the menu.
   * @private
   */
  Drilldown.prototype._keyboardEvents = function() {
    var _this = this;
    this.$menuItems.add(this.$element.find('.js-drilldown-back')).on('keydown.zf.drilldown', function(e){
      var $element = $(this),
          $elements = $element.parent('ul').children('li'),
          $prevElement,
          $nextElement;

      $elements.each(function(i) {
        if ($(this).is($element)) {
          $prevElement = $elements.eq(Math.max(0, i-1));
          $nextElement = $elements.eq(Math.min(i+1, $elements.length-1));
          return;
        }
      });
      Foundation.Keyboard.handleKey(e, _this, {
        next: function() {
          if ($element.is(_this.$submenuAnchors)) {
            _this._show($element);
            $element.on(Foundation.transitionend($element), function(){
              $element.find('ul li').filter(_this.$menuItems).first().focus();
            });
          }
        },
        previous: function() {
          _this._hide($element.parent('ul'));
          $element.parent('ul').on(Foundation.transitionend($element), function(){
            setTimeout(function() {
              $element.parent('ul').parent('li').focus();
            }, 1);
          });
        },
        up: function() {
          $prevElement.focus();
        },
        down: function() {
          $nextElement.focus();
        },
        close: function() {
          _this._back();
          //_this.$menuItems.first().focus(); // focus to first element
        },
        open: function() {
          if (!$element.is(_this.$menuItems)) { // not menu item means back button
            _this._hide($element.parent('ul'));
            setTimeout(function(){$element.parent('ul').parent('li').focus();}, 1);
          } else if ($element.is(_this.$submenuAnchors)) {
            _this._show($element);
            setTimeout(function(){$element.find('ul li').filter(_this.$menuItems).first().focus();}, 1);
          }
        },
        handled: function() {
          e.preventDefault();
          e.stopImmediatePropagation();
        }
      });
    }); // end keyboardAccess
  };

  /**
   * Closes all open elements, and returns to root menu.
   * @function
   * @fires Drilldown#closed
   */
  Drilldown.prototype._hideAll = function(){
    var $elem = this.$element.find('.is-drilldown-sub.is-active').addClass('is-closing');
    $elem.one(Foundation.transitionend($elem), function(e){
      $elem.removeClass('is-active is-closing');
    });
        /**
         * Fires when the menu is fully closed.
         * @event Drilldown#closed
         */
    this.$element.trigger('closed.zf.drilldown');
  };
  /**
   * Adds event listener for each `back` button, and closes open menus.
   * @function
   * @fires Drilldown#back
   * @param {jQuery} $elem - the current sub-menu to add `back` event.
   */
  Drilldown.prototype._back = function($elem){
    var _this = this;
    $elem.off('click.zf.drilldown');
    $elem.children('.js-drilldown-back')
      .on('click.zf.drilldown', function(e){
        e.stopImmediatePropagation();
        // console.log('mouseup on back');
        _this._hide($elem);
      });
  };
  /**
   * Adds event listener to menu items w/o submenus to close open menus on click.
   * @function
   * @private
   */
  Drilldown.prototype._menuLinkEvents = function(){
    var _this = this;
    this.$menuItems.not('.has-submenu')
        .off('click.zf.drilldown')
        .on('click.zf.drilldown', function(e){
          // e.stopImmediatePropagation();
          setTimeout(function(){
            _this._hideAll();
          }, 0);
      });
  };
  /**
   * Opens a submenu.
   * @function
   * @fires Drilldown#open
   * @param {jQuery} $elem - the current element with a submenu to open.
   */
  Drilldown.prototype._show = function($elem){
    $elem.children('[data-submenu]').addClass('is-active');

    this.$element.trigger('open.zf.drilldown', [$elem]);
  };
  /**
   * Hides a submenu
   * @function
   * @fires Drilldown#hide
   * @param {jQuery} $elem - the current sub-menu to hide.
   */
  Drilldown.prototype._hide = function($elem){
    var _this = this;
    $elem.addClass('is-closing')
         .one(Foundation.transitionend($elem), function(){
           $elem.removeClass('is-active is-closing');
         });
    /**
     * Fires when the submenu is has closed.
     * @event Drilldown#hide
     */
    $elem.trigger('hide.zf.drilldown', [$elem]);

  };
  /**
   * Iterates through the nested menus to calculate the min-height, and max-width for the menu.
   * Prevents content jumping.
   * @function
   * @private
   */
  Drilldown.prototype._getMaxDims = function(){
    var max = 0, result = {};
    this.$submenus.add(this.$element).each(function(){
      var numOfElems = $(this).children('li').length;
      max = numOfElems > max ? numOfElems : max;
    });

    result.height = max * this.$menuItems[0].getBoundingClientRect().height + 'px';
    result.width = this.$element[0].getBoundingClientRect().width + 'px';

    return result;
  };
  /**
   * Destroys the Drilldown Menu
   * @function
   */
  Drilldown.prototype.destroy = function(){
    this._hideAll();
    Foundation.Nest.Burn(this.$element, 'drilldown');
    this.$element.unwrap()
                 .find('.js-drilldown-back').remove()
                 .end().find('.is-active, .is-closing, .is-drilldown-sub').removeClass('is-active is-closing is-drilldown-sub')
                 .end().find('[data-submenu]').removeAttr('aria-hidden tabindex role')
                 .off('.zf.drilldown').end().off('zf.drilldown');

    Foundation.unregisterPlugin(this);
  };
  Foundation.plugin(Drilldown, 'Drilldown');
}(jQuery, window.Foundation);

/**
 * Dropdown module.
 * @module foundation.dropdown
 * @requires foundation.util.keyboard
 * @requires foundation.util.box
 */
!function($, Foundation){
  'use strict';
  /**
   * Creates a new instance of a dropdown.
   * @class
   * @param {jQuery} element - jQuery object to make into an accordion menu.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function Dropdown(element, options){
    this.$element = element;
    this.options = $.extend({}, Dropdown.defaults, this.$element.data(), options);
    this._init();

    Foundation.registerPlugin(this);
    Foundation.Keyboard.register('Dropdown', {
      'ENTER': 'open',
      'SPACE': 'open',
      'ESCAPE': 'close',
      'TAB': 'tab_forward',
      'SHIFT_TAB': 'tab_backward'
    });
  }

  Dropdown.defaults = {
    /**
     * Amount of time to delay opening a submenu on hover event.
     * @option
     * @example 250
     */
    hoverDelay: 250,
    /**
     * Allow submenus to open on hover events
     * @option
     * @example false
     */
    hover: false,
    /**
     * Number of pixels between the dropdown pane and the triggering element on open.
     * @option
     * @example 1
     */
    vOffset: 1,
    /**
     * Number of pixels between the dropdown pane and the triggering element on open.
     * @option
     * @example 1
     */
    hOffset: 1,
    /**
     * Class applied to adjust open position. JS will test and fill this in.
     * @option
     * @example 'top'
     */
    positionClass: '',
    /**
     * Allow the plugin to trap focus to the dropdown pane on open.
     * @option
     * @example false
     */
    trapFocus: false
  };
  /**
   * Initializes the plugin by setting/checking options and attributes, adding helper variables, and saving the anchor.
   * @function
   * @private
   */
  Dropdown.prototype._init = function(){
    var $id = this.$element.attr('id');

    this.$anchor = $('[data-toggle="' + $id + '"]') || $('[data-open="' + $id + '"]');
    this.$anchor.attr({
      'aria-controls': $id,
      'data-is-focus': false,
      'data-yeti-box': $id,
      'aria-haspopup': true,
      'aria-expanded': false
      // 'data-resize': $id
    });

    this.options.positionClass = this.getPositionClass();
    this.counter = 4;
    this.usedPositions = [];
    this.$element.attr({
      'aria-hidden': 'true',
      'data-yeti-box': $id,
      'data-resize': $id,
      'aria-labelledby': this.$anchor[0].id || Foundation.GetYoDigits(6, 'dd-anchor')
    });
    this._events();
  };
  /**
   * Helper function to determine current orientation of dropdown pane.
   * @function
   * @returns {String} position - string value of a position class.
   */
  Dropdown.prototype.getPositionClass = function(){
    var position = this.$element[0].className.match(/(top|left|right)/g);
        position = position ? position[0] : '';
    return position;
  };
  /**
   * Adjusts the dropdown panes orientation by adding/removing positioning classes.
   * @function
   * @private
   * @param {String} position - position class to remove.
   */
  Dropdown.prototype._reposition = function(position){
    this.usedPositions.push(position ? position : 'bottom');
    //default, try switching to opposite side
    if(!position && (this.usedPositions.indexOf('top') < 0)){
      this.$element.addClass('top');
    }else if(position === 'top' && (this.usedPositions.indexOf('bottom') < 0)){
      this.$element.removeClass(position);
    }else if(position === 'left' && (this.usedPositions.indexOf('right') < 0)){
      this.$element.removeClass(position)
          .addClass('right');
    }else if(position === 'right' && (this.usedPositions.indexOf('left') < 0)){
      this.$element.removeClass(position)
          .addClass('left');
    }

    //if default change didn't work, try bottom or left first
    else if(!position && (this.usedPositions.indexOf('top') > -1) && (this.usedPositions.indexOf('left') < 0)){
      this.$element.addClass('left');
    }else if(position === 'top' && (this.usedPositions.indexOf('bottom') > -1) && (this.usedPositions.indexOf('left') < 0)){
      this.$element.removeClass(position)
          .addClass('left');
    }else if(position === 'left' && (this.usedPositions.indexOf('right') > -1) && (this.usedPositions.indexOf('bottom') < 0)){
      this.$element.removeClass(position);
    }else if(position === 'right' && (this.usedPositions.indexOf('left') > -1) && (this.usedPositions.indexOf('bottom') < 0)){
      this.$element.removeClass(position);
    }
    //if nothing cleared, set to bottom
    else{
      this.$element.removeClass(position);
    }
    this.classChanged = true;
    this.counter--;
  };
  /**
   * Sets the position and orientation of the dropdown pane, checks for collisions.
   * Recursively calls itself if a collision is detected, with a new position class.
   * @function
   * @private
   */
  Dropdown.prototype._setPosition = function(){
    if(this.$anchor.attr('aria-expanded') === 'false'){ return false; }
    var position = this.getPositionClass(),
        $eleDims = Foundation.Box.GetDimensions(this.$element),
        $anchorDims = Foundation.Box.GetDimensions(this.$anchor),
        _this = this,
        direction = (position === 'left' ? 'left' : ((position === 'right') ? 'left' : 'top')),
        param = (direction === 'top') ? 'height' : 'width',
        offset = (param === 'height') ? this.options.vOffset : this.options.hOffset;

    if(($eleDims.width >= $eleDims.windowDims.width) || (!this.counter && !Foundation.Box.ImNotTouchingYou(this.$element))){
      this.$element.offset(Foundation.Box.GetOffsets(this.$element, this.$anchor, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({
        'width': $eleDims.windowDims.width - (this.options.hOffset * 2),
        'height': 'auto',
      });
      this.classChanged = true;
      return false;
    }

    this.$element.offset(Foundation.Box.GetOffsets(this.$element, this.$anchor, position, this.options.vOffset, this.options.hOffset));

    while(!Foundation.Box.ImNotTouchingYou(this.$element) && this.counter){
      this._reposition(position);
      this._setPosition();
    }
  };
  /**
   * Adds event listeners to the element utilizing the triggers utility library.
   * @function
   * @private
   */
  Dropdown.prototype._events = function(){
    var _this = this;
    this.$element.on({
      'open.zf.trigger': this.open.bind(this),
      'close.zf.trigger': this.close.bind(this),
      'toggle.zf.trigger': this.toggle.bind(this),
      'resizeme.zf.trigger': this._setPosition.bind(this)
    });

    if(this.options.hover){
      this.$anchor.off('mouseenter.zf.dropdown mouseleave.zf.dropdown')
          .on('mouseenter.zf.dropdown', function(){
            console.log('hover');
            clearTimeout(_this.timeout);
            _this.timeOut = setTimeout(function(){
              _this.open();
              _this.$anchor.data('hover', true);
            }, _this.options.hoverDelay);
          }).on('mouseleave.zf.dropdown', function(){
            clearTimeout(_this.timeout);
            _this.timeOut = setTimeout(function(){
              _this.close();
              _this.$anchor.data('hover', false);
            }, _this.options.hoverDelay);
          });
    }
    this.$anchor.add(this.$element).on('keydown.zf.dropdown', function(e) {

      var visibleFocusableElements = Foundation.Keyboard.findFocusable(_this.$element);

      Foundation.Keyboard.handleKey(e, _this, {
        tab_forward: function() {
          if (this.$element.find(':focus').is(visibleFocusableElements.eq(-1))) { // left modal downwards, setting focus to first element
            if (this.options.trapFocus) { // if focus shall be trapped
              visibleFocusableElements.eq(0).focus();
              e.preventDefault();
            } else { // if focus is not trapped, close dropdown on focus out
              this.close();
            }
          }
        },
        tab_backward: function() {
          if (this.$element.find(':focus').is(visibleFocusableElements.eq(0)) || this.$element.is(':focus')) { // left modal upwards, setting focus to last element
            if (this.options.trapFocus) { // if focus shall be trapped
              visibleFocusableElements.eq(-1).focus();
              e.preventDefault();
            } else { // if focus is not trapped, close dropdown on focus out
              this.close();
            }
          }
        },
        open: function() {
          _this.open();
          _this.$element.attr('tabindex', -1).focus();
        },
        close: function() {
          _this.close();
          _this.$anchor.focus();
        }
      });
    });
  };
  /**
   * Opens the dropdown pane, and fires a bubbling event to close other dropdowns.
   * @function
   * @fires Dropdown#closeme
   * @fires Dropdown#show
   */
  Dropdown.prototype.open = function(){
    // var _this = this;
    /**
     * Fires to close other open dropdowns
     * @event Dropdown#closeme
     */
    this.$element.trigger('closeme.zf.dropdown', this.$element.attr('id'));
    this.$anchor.addClass('hover')
        .attr({'aria-expanded': true});
    // this.$element/*.show()*/;
    this._setPosition();
    this.$element.addClass('is-open')
        .attr({'aria-hidden': false});



    /**
     * Fires once the dropdown is visible.
     * @event Dropdown#show
     */
     this.$element.trigger('show.zf.dropdown', [this.$element]);
    //why does this not work correctly for this plugin?
    // Foundation.reflow(this.$element, 'dropdown');
    // Foundation._reflow(this.$element.attr('data-dropdown'));
  };

  /**
   * Closes the open dropdown pane.
   * @function
   * @fires Dropdown#hide
   */
  Dropdown.prototype.close = function(){
    if(!this.$element.hasClass('is-open')){
      return false;
    }
    this.$element.removeClass('is-open')
        .attr({'aria-hidden': true});

    this.$anchor.removeClass('hover')
        .attr('aria-expanded', false);

    if(this.classChanged){
      var curPositionClass = this.getPositionClass();
      if(curPositionClass){
        this.$element.removeClass(curPositionClass);
      }
      this.$element.addClass(this.options.positionClass)
          /*.hide()*/.css({height: '', width: ''});
      this.classChanged = false;
      this.counter = 4;
      this.usedPositions.length = 0;
    }
    this.$element.trigger('hide.zf.dropdown', [this.$element]);
    // Foundation.reflow(this.$element, 'dropdown');
  };
  /**
   * Toggles the dropdown pane's visibility.
   * @function
   */
  Dropdown.prototype.toggle = function(){
    if(this.$element.hasClass('is-open')){
      if(this.$anchor.data('hover')) return;
      this.close();
    }else{
      this.open();
    }
  };
  /**
   * Destroys the dropdown.
   * @function
   */
  Dropdown.prototype.destroy = function(){
    this.$element.off('.zf.trigger').hide();
    this.$anchor.off('.zf.dropdown');

    Foundation.unregisterPlugin(this);
  };

  Foundation.plugin(Dropdown, 'Dropdown');
}(jQuery, window.Foundation);

/**
 * DropdownMenu module.
 * @module foundation.dropdown-menu
 * @requires foundation.util.keyboard
 * @requires foundation.util.box
 * @requires foundation.util.nest
 */
!function(Foundation, $) {
  'use strict';

  /**
   * Creates a new instance of DropdownMenu.
   * @class
   * @fires DropdownMenu#init
   * @param {jQuery} element - jQuery object to make into a dropdown menu.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function DropdownMenu(element, options) {
    this.$element = element;
    this.options = $.extend({}, DropdownMenu.defaults, this.$element.data(), options);

    Foundation.Nest.Feather(this.$element, 'dropdown');

    this._init();

    Foundation.registerPlugin(this);
    Foundation.Keyboard.register('DropdownMenu', {
      'ENTER': 'open',
      'SPACE': 'open',
      'ARROW_RIGHT': 'next',
      'ARROW_UP': 'up',
      'ARROW_DOWN': 'down',
      'ARROW_LEFT': 'previous',
      'ESCAPE': 'close'
    });

    // /**
    //  * Fires when the plugin has been successfuly initialized.
    //  * @event DropdownMenu#init
    //  */
    // this.$element.trigger('init.zf.dropdown');
  }

  /**
   * Default settings for plugin
   */
  DropdownMenu.defaults = {
    // toggleOn: 'both',
    /**
     * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.
     * @option
     * @example true
     */
    clickOpen: true,
    /**
     * Allow clicks on the body to close any open submenus.
     * @option
     * @example false
     */
    closeOnClick: false,
    /**
     * Disallows hover events from opening submenus
     * @option
     * @example false
     */
    disableHover: false,
    /**
     * Allow a submenu to automatically close on a mouseleave event.
     * @option
     * @example true
     */
    autoclose: true,
    /**
     * Amount of time to delay opening a submenu on hover event.
     * @option
     * @example 150
     */
    hoverDelay: 150,
    /**
     * Amount of time to delay closing a submenu on a mouseleave event.
     * @option
     * @example 500
     */
    closingTime: 500,
    // wrapOnKeys: true,
    /**
     * Position of the menu relative to what direction the submenus should open. Handled by JS.
     * @option
     * @example 'left'
     */
    alignment: 'left',
    /**
     * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.
     * @option
     * @example 'vertical'
     */
    verticalClass: 'vertical',
    /**
     * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.
     * @option
     * @example 'align-right'
     */
    rightClass: 'align-right'
  };
  /**
   * Initializes the plugin, and calls _prepareMenu
   * @private
   * @function
   */
  DropdownMenu.prototype._init = function(){
    if(this.$element.hasClass(this.options.verticalClass)){
      this.vertical = true;
    }
    // this.vertical = this.$element.hasClass(this.options.verticalClass);
    this._prepareMenu();
    // this._addTopLevelKeyHandler();
  };
  /**
   * Prepares the menu by checking alignment and orientation, setting attributes for elements, and creating jQuery collections of elements.
   * @private
   * @function
   */
  DropdownMenu.prototype._prepareMenu = function(){
    var _this = this;
    this.$tabs = this.$element.children('li.has-submenu');
    this.$tabs.children('[data-submenu]').addClass('first-sub');
    this.$submenus = this.$element.find('li.has-submenu');
    this.$menuItems = this.$element.find('li').attr({'role': 'menuitem', 'tabindex': 0});
    this.$menuItems.children('a').attr('tabindex', -1);
    if(this.$element.hasClass(this.options.rightClass)){
      this.options.alignment = 'right';
      this.$submenus.addClass('is-left-arrow opens-left');
    }else{
      this.$submenus.addClass('is-right-arrow opens-right');
    }
    if(!this.vertical){
      this.$tabs.removeClass('is-right-arrow is-left-arrow opens-left opens-right').addClass('is-down-arrow');
    }

    this.$tabs.each(function(){
      var $tab = $(this);
      $tab.attr({
        'role': 'menuitem',
        'tabindex': 0,
        'aria-label': $tab.children('a:first-child').text()/*.match(/\w/ig).join('')*/
      }).children('a').attr('tabindex', -1);//maybe add a more specific regex to match alphanumeric characters and join them appropriately
      if($tab.children('[data-submenu]')){
        $tab.attr('aria-haspopup', true);
      }
    });


    this.$submenus.each(function(){
      var $sub = $(this);

      // if(_this.options.alignment === 'right'){
      //   $sub.children('[data-submenu]').addClass('is-right-arrow');
      // }

      $sub.children('[data-submenu]')
          .attr({
            'aria-hidden': true,
            'tabindex': -1,
            'role': 'menu'
          }).addClass('vertical');
      _this._events($sub);
    });
  };

  /**
   * Adds event listeners to elements within the menu
   * @param {jQuery} $elem - the element to attach listeners too.
   * @private
   * @function
   */
  DropdownMenu.prototype._events = function($elem){
    var _this = this,
        isTouch = window.ontouchstart !== undefined;

    if(this.options.clickOpen || isTouch){
      $elem.off('click.zf.dropdownmenu')
          .on('click.zf.dropdownmenu', function(e){
            if(!$(this).hasClass('is-dropdown-submenu-parent')){ return; }
            var hasClicked = $elem.data('isClick');
            if(isTouch && hasClicked) return;
            e.preventDefault();
            e.stopPropagation();

            if(hasClicked){
              _this._hide($elem);
            }else{
              _this._hideOthers($elem);
              _this._show($elem);
              $elem.data('isClick', true)
                  .parentsUntil('[data-dropdown-menu]', '.is-dropdown-submenu-parent')
                  .data('isClick', true);
              if(_this.options.closeOnClick){
                _this._addBodyHandler();
              }
            }
          });
    }

    if(!this.options.disableHover){
      //add ability for all menu items to close an open menu on the same level//
      this.$menuItems.on('mouseenter.zf.dropdownmenu', function(e){
        var $el = $(this);
        if(!$el.hasClass('is-active')){
          _this._hideOthers($el);
        }
      });
      //elements with submenus
      $elem.off('mouseenter.zf.dropdownmenu')
        .on('mouseenter.zf.dropdownmenu', function(e){
          clearTimeout($elem.closeTimer);
          if(!$elem.hasClass('is-active')){
            $elem.openTimer = setTimeout(function(){
                // _this._hideOthers($elem);
                _this._show($elem);
            }, _this.options.hoverDelay);
          }
      }).on('mouseleave.zf.dropdownmenu', function(e){
        if(!$elem.data('isClick') && _this.options.autoclose){
        clearTimeout($elem.openTimer);
          $elem.closeTimer = setTimeout(function(){
            _this._hide($elem);
          }, _this.options.closingTime);
        }
      });
    }

    this.$menuItems.on('keydown.zf.dropdownmenu', function(e){
      var $element = $(this),
          $tabs = _this.$element.children('li'),
          isTab = $element.is($tabs),
          $elements = isTab ? $tabs : $element.parents('li').first().add($element.parent('ul').children('li')),
          $prevElement,
          $nextElement;

      $elements.each(function(i) {
        if ($(this).is($element)) {
          $prevElement = $elements.eq(i-1);
          $nextElement = $elements.eq(i+1);
          return;
        }
      });
      var nextSibling = function() {
        if (!$element.is(':last-child')) $nextElement.focus();
      }, prevSibling = function() {
        $prevElement.focus();
      }, openSub = function() {
        if ($element.has('ul').length) {
          _this._show($element);
          $element.find('li').first().focus();
        }
      }, closeSub = function() {
        //if ($element.is(':first-child')) {
          $element.parents('li').first().focus();
          _this._hide($element.parents('li').first());
        //}
      };
      var functions = {
        open: openSub,
        close: function() {
          _this._hideAll();
          _this.$menuItems.first().focus(); // focus to first element
        },
        handled: function() {
          e.preventDefault();
          e.stopImmediatePropagation();
        }
      };

      if (isTab) {
        if (_this.vertical) { // vertical menu
          if (_this.options.alignment === 'left') { // left aligned
            $.extend(functions, {
              down: nextSibling,
              up: prevSibling,
              next: openSub,
              previous: closeSub,
            });
          } else { // right aligned
            $.extend(functions, {
              down: nextSibling,
              up: prevSibling,
              next: closeSub,
              previous: openSub,
            });
          }
        } else { // horizontal menu
          $.extend(functions, {
            next: nextSibling,
            previous: prevSibling,
            down: openSub,
            up: closeSub,
          });
        }
      } else { // not tabs -> one sub
        if (_this.options.alignment === 'left') { // left aligned
          $.extend(functions, {
            next: openSub,
            previous: closeSub,
            down: nextSibling,
            up: prevSibling
          });
        } else { // right aligned
          $.extend(functions, {
            next: closeSub,
            previous: openSub,
            down: nextSibling,
            up: prevSibling
          });
        }
      }
      Foundation.Keyboard.handleKey(e, _this, functions);
    });
     // end keyboardAccess
  };
  /**
   * Toggles the current dropdown pane.
   * @param {jQuery} $elem - the current element with a submenu to toggle.
   * @function
   * @private
   */
  DropdownMenu.prototype._toggle = function($elem){
    if($elem.hasClass('is-active')){
      this._hide($elem);
    }else{
      this._show($elem);
    }
  };
  /**
   * Adds an event handler to the body to close any dropdowns on a click.
   * @function
   * @private
   */
  DropdownMenu.prototype._addBodyHandler = function(){
    var $body = $('body'),
        _this = this;
    $body.not(_this.$element).on('click.zf.dropdownmenu tap.zf.dropdownmenu touchend.zf.dropdownmenu', function(e){
      _this._hideAll();
      $body.off('click.zf.dropdownmenu tap.zf.dropdownmenu touchend.zf.dropdownmenu');
    });
  };
//show & hide stuff @private
  /**
   * Opens a dropdown pane, and checks for collisions first.
   * @param {jQuery} $elem - current element with a submenu to show
   * @function
   * @private
   * @fires DropdownMenu#show
   */
  DropdownMenu.prototype._show = function($elem){
    this._hideOthers($elem);
    $elem.focus();
    // console.log('showing some stuff', $elem.find('li:first-child'));
    var $sub = $elem.children('[data-submenu]:first-of-type');
    $elem.addClass('is-active');
    $sub.css('visibility', 'hidden').addClass('js-dropdown-active')
        .attr('aria-hidden', false);


    //break this into own function
    var clear = Foundation.Box.ImNotTouchingYou($sub, null, true);
    if(!clear){
      if(this.options.alignment === 'left'){
        $elem.removeClass('opens-left').addClass('opens-right');
      }else{
        $elem.removeClass('opens-right').addClass('opens-left');
      }
      this.changed = true;

      // still not clear, small screen, add inner class
      clear = Foundation.Box.ImNotTouchingYou($sub, null, true);
      if (!clear) {
        $elem.removeClass('opens-left opens-right').addClass('opens-inner');
        this.changed = true;
      }
    }
    $sub.css('visibility', '');
    /**
     * Fires when the new dropdown pane is visible.
     * @event DropdownMenu#show
     */
    this.$element.trigger('show.zf.dropdownmenu', [$elem]);
  };
  /**
   * Hides a single, currently open dropdown pane.
   * @function
   * @param {jQuery} $elem - element with a submenu to hide
   * @private
   */
  DropdownMenu.prototype._hide = function($elem){
    this._hideSome($elem);
  };
  /**
   * Hides currently open dropdown panes from a jQuery collection passed by other functions.
   * Resets the position classes if the element was mutated due to a collision.
   * @function
   * @param {jQuery} $elems - element(s) with a submenu to hide
   * @private
   * @fires DropdownMenu#hide
   */
  DropdownMenu.prototype._hideSome = function($elems){
    if($elems.length){
      // if($elems.hasClass('first-sub')){
      //   console.log('true');
      //   $elems.blur();
      // }
      $elems.removeClass('is-active opens-inner').data('isClick', false)

            .find('.is-active').removeClass('is-active').data('isClick', false).end()

            .find('.js-dropdown-active').removeClass('js-dropdown-active')
                                        .attr('aria-hidden', true);
      $elems.parent('.has-submenu').removeClass('is-active');
      if(this.changed){
        //remove position class
        if(this.options.alignment === 'left'){
          $elems.find('.opens-left').removeClass('opens-left').addClass('opens-right');
        }else{
          $elems.find('.opens-right').removeClass('opens-right').addClass('opens-left');
        }
      }
      /**
       * Fires when the open menus are closed.
       * @event DropdownMenu#hide
       */
      this.$element.trigger('hide.zf.dropdownmenu');
    }
  };
  /**
   * Hides a submenu's siblings.
   * @param {jQuery} $elem - the element that should remain open.
   * @function
   * @private
   */
  DropdownMenu.prototype._hideOthers = function($elem){
    this._hideSome($elem.siblings('.has-submenu.is-active'));
  };
  /**
   * Hides everything.
   * @function
   */
  DropdownMenu.prototype._hideAll = function(){
    this._hideSome(this.$element);
  };
  /**
   * Destroys the plugin.
   * @function
   */
  DropdownMenu.prototype.destroy = function() {
    this._hideAll();
    this.$element
        .removeData('zf-plugin')
        .find('li')
        .removeClass('js-dropdown-nohover is-right-arrow is-left-arrow opens-left opens-inner opens-right')
        .add('a').off('.zf.dropdownmenu')
        .end().find('ul').removeClass('first-sub');
    Foundation.Nest.Burn(this.$element, 'dropdown');
    Foundation.unregisterPlugin(this);
  };

  Foundation.plugin(DropdownMenu, 'DropdownMenu');

  var checkClass = function($elem){
    return $elem.hasClass('is-active');
  };

}(Foundation, jQuery);

!function(Foundation, $) {
  'use strict';

  /**
   * Creates a new instance of Equalizer.
   * @class
   * @fires Equalizer#init
   * @param {Object} element - jQuery object to add the trigger to.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function Equalizer(element, options) {
    this.$element = element;
    this.options  = $.extend({}, Equalizer.defaults, this.$element.data(), options);
    this.$window  = $(window);
    this.name     = 'equalizer';
    this.attr     = 'data-equalizer';

    this._init();
    this._events();

    Foundation.registerPlugin(this);
  }

  /**
   * Default settings for plugin
   */
  Equalizer.defaults = {
    /**
     * Enable height equalization when stacked on smaller screens.
     * @option
     * @example true
     */
    equalizeOnStack: true,
    /**
     * Amount of time, in ms, to debounce the size checking/equalization. Lower times mean smoother transitions/less performance on mobile.
     * @option
     * @example 50
     */
    throttleInterval: 50
  };

  /**
   * Initializes the Equalizer plugin and calls functions to get equalizer functioning on load.
   * @private
   */
  Equalizer.prototype._init = function() {
    this._reflow();
  };

  /**
   * Initializes events for Equalizer.
   * @private
   */
  Equalizer.prototype._events = function() {
    var self = this;

    this.$window
      .off('.equalizer')
      .on('resize.fndtn.equalizer', Foundation.util.throttle(function () {
        self._reflow();
      }, self.options.throttleInterval));
  };

  /**
   * A noop version for the plugin
   * @private
   */
  Equalizer.prototype._killswitch = function() {
    return;
  };
  /**
   * Calls necessary functions to update Equalizer upon DOM change
   * @private
   */
  Equalizer.prototype._reflow = function() {
    var self = this;

    $('[' + this.attr + ']').each(function() {
      var $eqParent       = $(this),
          adjustedHeights = [],
          $images = $eqParent.find('img');

      if ($images.length) {
        Foundation.onImagesLoaded($images, function() {
          adjustedHeights = self.getHeights($eqParent);
          self.applyHeight($eqParent, adjustedHeights);
        });
      }
      else {
        adjustedHeights = self.getHeights($eqParent);
        self.applyHeight($eqParent, adjustedHeights);
      }
    });
  };
  /**
   * Finds the outer heights of children contained within an Equalizer parent and returns them in an array
   * @param {Object} $eqParent A jQuery instance of an Equalizer container
   * @returns {Array} heights An array of heights of children within Equalizer container
   */
  Equalizer.prototype.getHeights = function($eqParent) {
    var eqGroupName = $eqParent.data('equalizer'),
        eqGroup     = eqGroupName ? $eqParent.find('[' + this.attr + '-watch="' + eqGroupName + '"]:visible') : $eqParent.find('[' + this.attr + '-watch]:visible'),
        heights;

    eqGroup.height('inherit');
    heights = eqGroup.map(function () { return $(this).outerHeight(false);}).get();
    console.log(heights);
    return heights;
  };
  /**
   * Changes the CSS height property of each child in an Equalizer parent to match the tallest
   * @param {Object} $eqParent - A jQuery instance of an Equalizer container
   * @param {array} heights - An array of heights of children within Equalizer container
   * @fires Equalizer#preEqualized
   * @fires Equalizer#postEqualized
   */
  Equalizer.prototype.applyHeight = function($eqParent, heights) {
    var eqGroupName = $eqParent.data('equalizer'),
        eqGroup     = eqGroupName ? $eqParent.find('['+this.attr+'-watch="'+eqGroupName+'"]:visible') : $eqParent.find('['+this.attr+'-watch]:visible'),
        max         = Math.max.apply(null, heights);

    /**
     * Fires before the heights are applied
     * @event Equalizer#preEqualized
     */
    $eqParent.trigger('preEqualized.zf.Equalizer');

    // for now, apply the max height found in the array
    for (var i = 0; i < eqGroup.length; i++) {
      $(eqGroup[i]).css('height', max);
    }
    // console.log(max);
    /**
     * Fires when the heights have been applied
     * @event Equalizer#postEqualized
     */
    $eqParent.trigger('postEqualized.zf.Equalizer');
  };
  /**
   * Destroys an instance of Equalizer.
   * @function
   */
  Equalizer.prototype.destroy = function(){
    //TODO this.
  };

  Foundation.plugin(Equalizer, 'Equalizer');

  // Exports for AMD/Browserify
  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined')
    module.exports = Equalizer;
  if (typeof define === 'function')
    define(['foundation'], function() {
      return Equalizer;
    });

}(Foundation, jQuery);

/**
 * Interchange module.
 * @module foundation.interchange
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.timerAndImageLoader
 */
!function(Foundation, $) {
  'use strict';

  /**
   * Creates a new instance of Interchange.
   * @class
   * @fires Interchange#init
   * @param {Object} element - jQuery object to add the trigger to.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function Interchange(element, options) {
    this.$element = element;
    this.options = $.extend({}, Interchange.defaults, options);
    this.rules = [];
    this.currentPath = '';

    this._init();
    this._events();

    Foundation.registerPlugin(this);
  }

  /**
   * Default settings for plugin
   */
  Interchange.defaults = {
    /**
     * Rules to be applied to Interchange elements. Set with the `data-interchange` array notation.
     * @option
     */
    rules: null
  };

  Interchange.SPECIAL_QUERIES = {
    'landscape': 'screen and (orientation: landscape)',
    'portrait': 'screen and (orientation: portrait)',
    'retina': 'only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)'
  };

  /**
   * Initializes the Interchange plugin and calls functions to get interchange functioning on load.
   * @function
   * @private
   */
  Interchange.prototype._init = function() {
    this._addBreakpoints();
    this._generateRules();
    this._reflow();
  };

  /**
   * Initializes events for Interchange.
   * @function
   * @private
   */
  Interchange.prototype._events = function() {
    $(window).on('resize.fndtn.interchange', Foundation.util.throttle(this._reflow.bind(this), 50));
  };

  /**
   * Calls necessary functions to update Interchange upon DOM change
   * @function
   * @private
   */
  Interchange.prototype._reflow = function() {
    var match;

    // Iterate through each rule, but only save the last match
    for (var i in this.rules) {
      var rule = this.rules[i];

      if (window.matchMedia(rule.query).matches) {
        match = rule;
      }
    }

    if (match) {
      this.replace(match.path);
    }
  };

  /**
   * Gets the Foundation breakpoints and adds them to the Interchange.SPECIAL_QUERIES object.
   * @function
   * @private
   */
  Interchange.prototype._addBreakpoints = function() {
    for (var i in Foundation.MediaQuery.queries) {
      var query = Foundation.MediaQuery.queries[i];
      Interchange.SPECIAL_QUERIES[query.name] = query.value;
    }
  };

  /**
   * Checks the Interchange element for the provided media query + content pairings
   * @function
   * @private
   * @param {Object} element - jQuery object that is an Interchange instance
   * @returns {Array} scenarios - Array of objects that have 'mq' and 'path' keys with corresponding keys
   */
  Interchange.prototype._generateRules = function() {
    var rulesList = [];
    var rules;

    if (this.options.rules) {
      rules = this.options.rules;
    }
    else {
      rules = this.$element.data('interchange').match(/\[.*?\]/g);
    }

    for (var i in rules) {
      var rule = rules[i].slice(1, -1).split(', ');
      var path = rule.slice(0, -1).join('');
      var query = rule[rule.length - 1];

      if (Interchange.SPECIAL_QUERIES[query]) {
        query = Interchange.SPECIAL_QUERIES[query];
      }

      rulesList.push({
        path: path,
        query: query
      });
    }

    this.rules = rulesList;
  };

  /**
   * Update the `src` property of an image, or change the HTML of a container, to the specified path.
   * @function
   * @param {String} path - Path to the image or HTML partial.
   * @fires Interchange#replaced
   */
  Interchange.prototype.replace = function(path) {
    if (this.currentPath === path) return;

    var _this = this;

    // Replacing images
    if (this.$element[0].nodeName === 'IMG') {
      this.$element.attr('src', path).load(function() {
        _this.$element.trigger('replaced.zf.interchange');
        _this.currentPath = path;
      });
    }
    // Replacing background images
    else if (path.match(/\.(gif|jpg|jpeg|tiff|png)([?#].*)?/i)) {
      this.$element.css({ 'background-image': 'url('+path+')' });
    }
    // Replacing HTML
    else {
      $.get(path, function(response) {
        _this.$element.html(response);
        _this.$element.trigger('replaced.zf.interchange');
        _this.currentPath = path;
      });
    }
  };
  /**
   * Destroys an instance of interchange.
   * @function
   */
  Interchange.prototype.destroy = function(){
    //TODO this.
  };
  Foundation.plugin(Interchange, 'Interchange');

  // Exports for AMD/Browserify
  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined')
    module.exports = Interchange;
  if (typeof define === 'function')
    define(['foundation'], function() {
      return Interchange;
    });

}(Foundation, jQuery);

/**
 * Magellan module.
 * @module foundation.magellan
 */
!function(Foundation, $) {
  'use strict';

  /**
   * Creates a new instance of Magellan.
   * @class
   * @fires Magellan#init
   * @param {Object} element - jQuery object to add the trigger to.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function Magellan(element, options) {
    this.$element = element;
    this.options  = $.extend({}, Magellan.defaults, options);

    this._init();

    Foundation.registerPlugin(this);
  }

  /**
   * Default settings for plugin
   */
  Magellan.defaults = {
    /**
     * Amount of time, in ms, the animated scrolling should take between locations.
     * @option
     * @example 500
     */
    animationDuration: 500,
    /**
     * Animation style to use when scrolling between locations.
     * @option
     * @example 'ease-in-out'
     */
    animationEasing: 'linear',
    /**
     * Number of pixels to use as a marker for location changes.
     * @option
     * @example 50
     */
    threshold: 50,
    /**
     * Class applied to the active locations link on the magellan container.
     * @option
     * @example 'active'
     */
    activeClass: 'active',
    /**
     * Allows the script to manipulate the url of the current page, and if supported, alter the history.
     * @option
     * @example true
     */
    deepLinking: false
  };

  /**
   * Initializes the Magellan plugin and calls functions to get equalizer functioning on load.
   * @private
   */
  Magellan.prototype._init = function() {
    var id = this.$element[0].id || Foundation.GetYoDigits(6, 'magellan'),
        _this = this;
    this.$targets = $('[data-magellan-target]');
    this.$links = this.$element.find('a');
    this.$element.attr({
      'data-resize': id,
      'data-scroll': id,
      'id': id
    });
    this.$active = $();
    this.scrollPos = parseInt(window.pageYOffset, 10);

    this._events();
  };
  /**
   * Calculates an array of pixel values that are the demarcation lines between locations on the page.
   * Can be invoked if new elements are added or the size of a location changes.
   * @function
   */
  Magellan.prototype.calcPoints = function(){
    var _this = this,
        body = document.body,
        html = document.documentElement;

    this.points = [];
    this.winHeight = Math.round(Math.max(window.innerHeight, document.body.clientHeight));
    this.docHeight = Math.round(Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight));

    this.$targets.each(function(){
      var $tar = $(this),
          pt = Math.round($tar.offset().top - _this.options.threshold);
      $tar.targetPoint = pt;
      _this.points.push(pt);
    });
  };
  /**
   * Initializes events for Magellan.
   * @private
   */
  Magellan.prototype._events = function() {
    var _this = this,
        $body = $('html, body'),
        opts = {
          duration: _this.options.animationDuration,
          easing:   _this.options.animationEasing
        };

    $(window).one('load', function(){
      _this.calcPoints();
      _this._updateActive();
    });

    this.$element.on({
      'resizeme.zf.trigger': this.reflow.bind(this),
      'scrollme.zf.trigger': this._updateActive.bind(this)
    }).on('click.zf.magellan', 'a[href^="#"]', function(e) {
        e.preventDefault();
        var arrival   = this.getAttribute('href'),
            scrollPos = $(arrival).offset().top - _this.options.threshold / 2;

        // requestAnimationFrame is disabled for this plugin currently
        // Foundation.Move(_this.options.animationDuration, $body, function(){
          $body.stop(true).animate({
            scrollTop: scrollPos
          }, opts);
        });
      // });
  };
  /**
   * Calls necessary functions to update Magellan upon DOM change
   * @function
   */
  Magellan.prototype.reflow = function(){
    this.calcPoints();
    this._updateActive();
  };
  /**
   * Updates the visibility of an active location link, and updates the url hash for the page, if deepLinking enabled.
   * @private
   * @function
   * @fires Magellan#update
   */
  Magellan.prototype._updateActive = function(/*evt, elem, scrollPos*/){
    var winPos = /*scrollPos ||*/ parseInt(window.pageYOffset, 10),
        curIdx;

    if(winPos + this.winHeight === this.docHeight){ curIdx = this.points.length - 1; }
    else if(winPos < this.points[0]){ curIdx = 0; }
    else{
      var isDown = this.scrollPos < winPos,
          _this = this,
          curVisible = this.points.filter(function(p, i){
            return isDown ? p <= winPos : p - _this.options.threshold <= winPos;//&& winPos >= _this.points[i -1] - _this.options.threshold;
          });
      curIdx = curVisible.length ? curVisible.length - 1 : 0;
    }

    this.$active.removeClass(this.options.activeClass);
    this.$active = this.$links.eq(curIdx).addClass(this.options.activeClass);

    if(this.options.deepLinking){
      var hash = this.$active[0].getAttribute('href');
      if(window.history.pushState){
        window.history.pushState(null, null, hash);
      }else{
        window.location.hash = hash;
      }
    }

    this.scrollPos = winPos;
    /**
     * Fires when magellan is finished updating to the new active element.
     * @event Magellan#update
     */
    this.$element.trigger('update.zf.magellan', [this.$active]);
  };
  /**
   * Destroys an instance of Magellan and resets the url of the window.
   * @function
   */
  Magellan.prototype.destroy = function(){
    this.$element.off('.zf.trigger .zf.magellan')
        .find('.' + this.options.activeClass).removeClass(this.options.activeClass);

    var hash = this.$active[0].getAttribute('href');

    window.location.hash.replace(hash, '');

    Foundation.unregisterPlugin(this);
  };
  Foundation.plugin(Magellan, 'Magellan');

  // Exports for AMD/Browserify
  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined')
    module.exports = Magellan;
  if (typeof define === 'function')
    define(['foundation'], function() {
      return Magellan;
    });

}(Foundation, jQuery);

/**
 * OffCanvas module.
 * @module foundation.offcanvas
 * @requires foundation.util.triggers
 * @requires foundation.util.motion
 */
!function($, Foundation) {

'use strict';

/**
 * Creates a new instance of an off-canvas wrapper.
 * @class
 * @fires OffCanvas#init
 * @param {Object} element - jQuery object to initialize.
 * @param {Object} options - Overrides to the default plugin settings.
 */
function OffCanvas(element, options) {
  this.$element = element;
  this.options = $.extend({}, OffCanvas.defaults, this.$element.data(), options);
  this.$lastTrigger = $();

  this._init();
  this._events();

  Foundation.registerPlugin(this);
}

OffCanvas.defaults = {
  /**
   * Allow the user to click outside of the menu to close it.
   * @option
   * @example true
   */
  closeOnClick: true,
  /**
   * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.
   * @option
   * @example 500
   */
  transitionTime: 0,
  /**
   * Direction the offcanvas opens from. Determines class applied to body.
   * @option
   * @example left
   */
  position: 'left',
  /**
   * Force the page to scroll to top on open.
   */
  forceTop: true,
  /**
   * Allow the offcanvas to be sticky while open. Does nothing if Sass option `$maincontent-prevent-scroll === true`.
   * Performance in Safari OSX/iOS is not great.
   */
  // isSticky: false,
  /**
   * Allow the offcanvas to remain open for certain breakpoints. Can be used with `isSticky`.
   * @option
   * @example false
   */
  isRevealed: false,
  /**
   * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class @`revealClass`.
   * @option
   * @example reveal-for-large
   */
  revealOn: null,
  /**
   * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.
   * @option
   * @example true
   */
  autoFocus: true,
  /**
   * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.
   * @option
   * TODO improve the regex testing for this.
   * @example reveal-for-large
   */
  revealClass: 'reveal-for-'
};

/**
 * Initializes the off-canvas wrapper by adding the exit overlay (if needed).
 * @function
 * @private
 */
OffCanvas.prototype._init = function() {
  var id = this.$element.attr('id');

  this.$element.attr('aria-hidden', 'true');

  // Find triggers that affect this element and add aria-expanded to them
  $(document)
    .find('[data-open="'+id+'"], [data-close="'+id+'"], [data-toggle="'+id+'"]')
    .attr('aria-expanded', 'false')
    .attr('aria-controls', id);

  // Add a close trigger over the body if necessary
  if (this.options.closeOnClick){
    if($('.js-off-canvas-exit').length){
      this.$exiter = $('.js-off-canvas-exit');
    }else{
      var exiter = document.createElement('div');
      exiter.setAttribute('class', 'js-off-canvas-exit');
      $('[data-off-canvas-content]').append(exiter);

      this.$exiter = $(exiter);
    }
  }

  this.options.isRevealed = this.options.isRevealed || new RegExp(this.options.revealClass, 'g').test(this.$element[0].className);

  if(this.options.isRevealed){
    this.options.revealOn = this.options.revealOn || this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split('-')[2];
    this._setMQChecker();
  }
  if(!this.options.transitionTime){
    this.options.transitionTime = parseFloat(window.getComputedStyle($('[data-off-canvas-wrapper]')[0]).transitionDuration) * 1000;
  }
};

/**
 * Adds event handlers to the off-canvas wrapper and the exit overlay.
 * @function
 * @private
 */
OffCanvas.prototype._events = function() {
  this.$element.on({
    'open.zf.trigger': this.open.bind(this),
    'close.zf.trigger': this.close.bind(this),
    'toggle.zf.trigger': this.toggle.bind(this),
    'keydown.zf.offcanvas': this._handleKeyboard.bind(this)
  });

  if (this.$exiter.length) {
    var _this = this;
    this.$exiter.on({'click.zf.offcanvas': this.close.bind(this)});
  }
};
/**
 * Applies event listener for elements that will reveal at certain breakpoints.
 * @private
 */
OffCanvas.prototype._setMQChecker = function(){
  var _this = this;

  $(window).on('changed.zf.mediaquery', function(){
    if(Foundation.MediaQuery.atLeast(_this.options.revealOn)){
      _this.reveal(true);
    }else{
      _this.reveal(false);
    }
  }).one('load.zf.offcanvas', function(){
    if(Foundation.MediaQuery.atLeast(_this.options.revealOn)){
      _this.reveal(true);
    }
  });
};
/**
 * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.
 * @param {Boolean} isRevealed - true if element should be revealed.
 * @function
 */
OffCanvas.prototype.reveal = function(isRevealed){
  var $closer = this.$element.find('[data-close]');
  if(isRevealed){
    // if(!this.options.forceTop){
    //   var scrollPos = parseInt(window.pageYOffset);
    //   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';
    // }
    // if(this.options.isSticky){ this._stick(); }
    if($closer.length){ $closer.hide(); }
  }else{
    // if(this.options.isSticky || !this.options.forceTop){
    //   this.$element[0].style.transform = '';
    //   $(window).off('scroll.zf.offcanvas');
    // }
    if($closer.length){
      $closer.show();
    }
  }
};

/**
 * Opens the off-canvas menu.
 * @function
 * @param {Object} event - Event object passed from listener.
 * @param {jQuery} trigger - element that triggered the off-canvas to open.
 * @fires OffCanvas#opened
 */
OffCanvas.prototype.open = function(event, trigger) {
  if (this.$element.hasClass('is-open')){ return; }
  var _this = this,
      $body = $(document.body);
  $('body').scrollTop(0);
  // window.pageYOffset = 0;

  // if(!this.options.forceTop){
  //   var scrollPos = parseInt(window.pageYOffset);
  //   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';
  //   if(this.$exiter.length){
  //     this.$exiter[0].style.transform = 'translate(0,' + scrollPos + 'px)';
  //   }
  // }
  /**
   * Fires when the off-canvas menu opens.
   * @event OffCanvas#opened
   */
  Foundation.Move(this.options.transitionTime, this.$element, function(){
    $('[data-off-canvas-wrapper]').addClass('is-off-canvas-open is-open-'+ _this.options.position);

    _this.$element
      .addClass('is-open')
      .attr('aria-hidden', 'false')
      .trigger('opened.zf.offcanvas');

    // if(_this.options.isSticky){
    //   _this._stick();
    // }
  });
  if(trigger){
    this.$lastTrigger = trigger.attr('aria-expanded', 'true');
  }
  if(this.options.autoFocus){
    this.$element.one('finished.zf.animate', function(){
      _this.$element.find('a, button').eq(0).focus();
    });
  }
};
/**
 * Allows the offcanvas to appear sticky utilizing translate properties.
 * @private
 */
// OffCanvas.prototype._stick = function(){
//   var elStyle = this.$element[0].style;
//
//   if(this.options.closeOnClick){
//     var exitStyle = this.$exiter[0].style;
//   }
//
//   $(window).on('scroll.zf.offcanvas', function(e){
//     console.log(e);
//     var pageY = window.pageYOffset;
//     elStyle.transform = 'translate(0,' + pageY + 'px)';
//     if(exitStyle !== undefined){ exitStyle.transform = 'translate(0,' + pageY + 'px)'; }
//   });
//   // this.$element.trigger('stuck.zf.offcanvas');
// };
/**
 * Closes the off-canvas menu.
 * @function
 * @fires OffCanvas#closed
 */
OffCanvas.prototype.close = function() {
  if(!this.$element.hasClass('is-open')){ return; }

  var _this = this;

   Foundation.Move(this.options.transitionTime, this.$element, function(){
    $('[data-off-canvas-wrapper]').removeClass('is-off-canvas-open is-open-'+_this.options.position);

    _this.$element.removeClass('is-open');
    // Foundation._reflow();
  });
  this.$element.attr('aria-hidden', 'true')
    /**
     * Fires when the off-canvas menu opens.
     * @event OffCanvas#closed
     */
      .trigger('closed.zf.offcanvas');
  // if(_this.options.isSticky || !_this.options.forceTop){
  //   setTimeout(function(){
  //     _this.$element[0].style.transform = '';
  //     $(window).off('scroll.zf.offcanvas');
  //   }, this.options.transitionTime);
  // }

  this.$lastTrigger.attr('aria-expanded', 'false');
};

/**
 * Toggles the off-canvas menu open or closed.
 * @function
 * @param {Object} event - Event object passed from listener.
 * @param {jQuery} trigger - element that triggered the off-canvas to open.
 */
OffCanvas.prototype.toggle = function(event, trigger) {
  if (this.$element.hasClass('is-open')) {
    this.close(event, trigger);
  }
  else {
    this.open(event, trigger);
  }
};

/**
 * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.
 * @function
 * @private
 */
OffCanvas.prototype._handleKeyboard = function(event) {
  if (event.which !== 27) return;

  event.stopPropagation();
  event.preventDefault();
  this.close();
  this.$lastTrigger.focus();
};
/**
 * Destroys the offcanvas plugin.
 * @function
 */
OffCanvas.prototype.destroy = function(){
  //TODO make this...
};

Foundation.plugin(OffCanvas, 'OffCanvas');

}(jQuery, Foundation);

/**
 * Orbit module.
 * @module foundation.orbit
 * @requires foundation.util.keyboard
 * @requires foundation.util.motion
 * @requires foundation.util.timerAndImageLoader
 * @requires foundation.util.touch
 */
!function($, Foundation){
  'use strict';
  /**
   * Creates a new instance of an orbit carousel.
   * @class
   * @param {jQuery} element - jQuery object to make into an accordion menu.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function Orbit(element, options){
    this.$element = element;
    this.options = $.extend({}, Orbit.defaults, this.$element.data(), options);

    this._init();

    Foundation.registerPlugin(this);
    Foundation.Keyboard.register('Orbit', {
        'ltr': {
          'ARROW_RIGHT': 'next',
          'ARROW_LEFT': 'previous'
        },
        'rtl': {
          'ARROW_LEFT': 'next',
          'ARROW_RIGHT': 'previous'
        }
    });
  }
  Orbit.defaults = {
    /**
     * Tells the JS to loadBullets.
     * @option
     * @example true
     */
    bullets: true,
    /**
     * Tells the JS to apply event listeners to nav buttons
     * @option
     * @example true
     */
    navButtons: true,
    /**
     * motion-ui animation class to apply
     * @option
     * @example 'slide-in-right'
     */
    animInFromRight: 'slide-in-right',
    /**
     * motion-ui animation class to apply
     * @option
     * @example 'slide-out-right'
     */
    animOutToRight: 'slide-out-right',
    /**
     * motion-ui animation class to apply
     * @option
     * @example 'slide-in-left'
     *
     */
    animInFromLeft: 'slide-in-left',
    /**
     * motion-ui animation class to apply
     * @option
     * @example 'slide-out-left'
     */
    animOutToLeft: 'slide-out-left',
    /**
     * Allows Orbit to automatically animate on page load.
     * @option
     * @example true
     */
    autoPlay: true,
    /**
     * Amount of time, in ms, between slide transitions
     * @option
     * @example 5000
     */
    timerDelay: 5000,
    /**
     * Allows Orbit to infinitely loop through the slides
     * @option
     * @example true
     */
    infiniteWrap: true,
    /**
     * Allows the Orbit slides to bind to swipe events for mobile, requires an additional util library
     * @option
     * @example true
     */
    swipe: true,
    /**
     * Allows the timing function to pause animation on hover.
     * @option
     * @example true
     */
    pauseOnHover: true,
    /**
     * Allows Orbit to bind keyboard events to the slider, to animate frames with arrow keys
     * @option
     * @example true
     */
    accessible: true,
    /**
     * Class applied to the container of Orbit
     * @option
     * @example 'orbit-container'
     */
    containerClass: 'orbit-container',
    /**
     * Class applied to individual slides.
     * @option
     * @example 'orbit-slide'
     */
    slideClass: 'orbit-slide',
    /**
     * Class applied to the bullet container. You're welcome.
     * @option
     * @example 'orbit-bullets'
     */
    boxOfBullets: 'orbit-bullets',
    /**
     * Class applied to the `next` navigation button.
     * @option
     * @example 'orbit-next'
     */
    nextClass: 'orbit-next',
    /**
     * Class applied to the `previous` navigation button.
     * @option
     * @example 'orbit-previous'
     */
    prevClass: 'orbit-previous'
  };
  /**
   * Initializes the plugin by creating jQuery collections, setting attributes, and starting the animation.
   * @function
   * @private
   */
  Orbit.prototype._init = function(){
    this.$wrapper = this.$element.find('.' + this.options.containerClass);
    this.$slides = this.$element.find('.' + this.options.slideClass);
    var $images = this.$element.find('img'),
        initActive = this.$slides.filter('.is-active');

    if(!initActive.length){
      this.$slides.eq(0).addClass('is-active');
    }

    if($images.length){
      Foundation.onImagesLoaded($images, this._prepareForOrbit.bind(this));
    }else{
      this._prepareForOrbit();//hehe
    }

    if(this.options.bullets){
      this._loadBullets();
    }

    this._events();

    if(this.options.autoPlay){
      this.geoSync();
    }
    if(this.options.accessible){ // allow wrapper to be focusable to enable arrow navigation
      this.$wrapper.attr('tabindex', 0);
    }
  };
  /**
   * Creates a jQuery collection of bullets, if they are being used.
   * @function
   * @private
   */
  Orbit.prototype._loadBullets = function(){
    this.$bullets = this.$element.find('.' + this.options.boxOfBullets).find('button');
  };
  /**
   * Sets a `timer` object on the orbit, and starts the counter for the next slide.
   * @function
   */
  Orbit.prototype.geoSync = function(){
    var _this = this;
    this.timer = new Foundation.Timer(
                      this.$element,
                      {duration: this.options.timerDelay,
                       infinite: false},
                      function(){
                        _this.changeSlide(true);
                      });
    this.timer.start();
  };
  /**
   * Sets wrapper and slide heights for the orbit.
   * @function
   * @private
   */
  Orbit.prototype._prepareForOrbit = function(){
    var _this = this;
    this._setWrapperHeight(function(max){
      _this._setSlideHeight(max);
    });
  };
  /**
   * Calulates the height of each slide in the collection, and uses the tallest one for the wrapper height.
   * @function
   * @private
   * @param {Function} cb - a callback function to fire when complete.
   */
  Orbit.prototype._setWrapperHeight = function(cb){//rewrite this to `for` loop
    var max = 0, temp, counter = 0;

    this.$slides.each(function(){
      temp = this.getBoundingClientRect().height;
      $(this).attr('data-slide', counter);

      if(counter){//if not the first slide, set css position and display property
        $(this).css({'position': 'relative', 'display': 'none'});
      }
      max = temp > max ? temp : max;
      counter++;
    });

    if(counter === this.$slides.length){
      this.$wrapper.css({'height': max});//only change the wrapper height property once.
      cb(max);//fire callback with max height dimension.
    }
  };
  /**
   * Sets the max-height of each slide.
   * @function
   * @private
   */
  Orbit.prototype._setSlideHeight = function(height){
    this.$slides.each(function(){
      $(this).css('max-height', height);
    });
  };
  /**
   * Adds event listeners to basically everything within the element.
   * @function
   * @private
   */
  Orbit.prototype._events = function(){
    var _this = this;

    //***************************************
    //**Now using custom event - thanks to:**
    //**      Yohai Ararat of Toronto      **
    //***************************************
    if(this.options.swipe){
      this.$slides.off('swipeleft.zf.orbit swiperight.zf.orbit')
      .on('swipeleft.zf.orbit', function(e){
        e.preventDefault();
        _this.changeSlide(true);
      }).on('swiperight.zf.orbit', function(e){
        e.preventDefault();
        _this.changeSlide(false);
      });
    }
    //***************************************

    if(this.options.autoPlay){
      this.$slides.on('click.zf.orbit', function(){
        _this.$element.data('clickedOn', _this.$element.data('clickedOn') ? false : true);
        _this.timer[_this.$element.data('clickedOn') ? 'pause' : 'start']();
      });
      if(this.options.pauseOnHover){
        this.$element.on('mouseenter.zf.orbit', function(){
          _this.timer.pause();
        }).on('mouseleave.zf.orbit', function(){
          if(!_this.$element.data('clickedOn')){
            _this.timer.start();
          }
        });
      }
    }

    if(this.options.navButtons){
      var $controls = this.$element.find('.' + this.options.nextClass + ', .' + this.options.prevClass);
      $controls.attr('tabindex', 0)
        //also need to handle enter/return and spacebar key presses
               .on('click.zf.orbit touchend.zf.orbit', function(){
                 _this.changeSlide($(this).hasClass(_this.options.nextClass));
               });
    }

    if(this.options.bullets){
      this.$bullets.on('click.zf.orbit touchend.zf.orbit', function(){
        if(/is-active/g.test(this.className)){ return false; }//if this is active, kick out of function.
        var idx = $(this).data('slide'),
            ltr = idx > _this.$slides.filter('.is-active').data('slide'),
            $slide = _this.$slides.eq(idx);

        _this.changeSlide(ltr, $slide, idx);
      });
    }

    this.$wrapper.add(this.$bullets).on('keydown.zf.orbit', function(e){
      // handle keyboard event with keyboard util
      Foundation.Keyboard.handleKey(e, _this, {
        next: function() {
          _this.changeSlide(true);
        },
        previous: function() {
          _this.changeSlide(false);
        },
        handled: function() { // if bullet is focused, make sure focus moves
          if ($(e.target).is(_this.$bullets)) {
            _this.$bullets.filter('.is-active').focus();
          }
        }
      });
    });
  };
  /**
   * Changes the current slide to a new one.
   * @function
   * @param {Boolean} isLTR - flag if the slide should move left to right.
   * @param {jQuery} chosenSlide - the jQuery element of the slide to show next, if one is selected.
   * @param {Number} idx - the index of the new slide in its collection, if one chosen.
   * @fires Orbit#slidechange
   */
  Orbit.prototype.changeSlide = function(isLTR, chosenSlide, idx){
    var $curSlide = this.$slides.filter('.is-active').eq(0);


    if(/mui/g.test($curSlide[0].className)){ return false; }//if the slide is currently animating, kick out of the function

    var $firstSlide = this.$slides.first(),
        $lastSlide = this.$slides.last(),
        dirIn = isLTR ? 'Right' : 'Left',
        dirOut = isLTR ? 'Left' : 'Right',
        _this = this,
        $newSlide;

    if(!chosenSlide){//most of the time, this will be auto played or clicked from the navButtons.
      $newSlide = isLTR ? //if wrapping enabled, check to see if there is a `next` or `prev` sibling, if not, select the first or last slide to fill in. if wrapping not enabled, attempt to select `next` or `prev`, if there's nothing there, the function will kick out on next step. CRAZY NESTED TERNARIES!!!!!
                    (this.options.infiniteWrap ? $curSlide.next('.' + this.options.slideClass).length ? $curSlide.next('.' + this.options.slideClass) : $firstSlide : $curSlide.next('.' + this.options.slideClass))//pick next slide if moving left to right
                    :
                    (this.options.infiniteWrap ? $curSlide.prev('.' + this.options.slideClass).length ? $curSlide.prev('.' + this.options.slideClass) : $lastSlide : $curSlide.prev('.' + this.options.slideClass));//pick prev slide if moving right to left
    }else{
      $newSlide = chosenSlide;
    }
    if($newSlide.length){
      if(this.options.bullets){
        idx = idx || this.$slides.index($newSlide);//grab index to update bullets
        this._updateBullets(idx);
      }
      Foundation.Motion.animateIn(
        $newSlide.addClass('is-active').css({'position': 'absolute', 'top': 0}),
        this.options['animInFrom' + dirIn],
        function(){
          $newSlide.css({'position': 'relative', 'display': 'block'})
                   .attr('aria-live', 'polite');
        });

      Foundation.Motion.animateOut(
        $curSlide.removeClass('is-active'),
        this.options['animOutTo' + dirOut],
        function(){
          $curSlide.removeAttr('aria-live');
          if(_this.options.autoPlay){
            _this.timer.restart();
          }
          //do stuff?
          /**
           * Triggers when the slide has finished animating in.
           * @event Orbit#slidechange
           */
          _this.$element.trigger('slidechange.zf.orbit', [$newSlide]);
        });
    }
  };
  /**
   * Updates the active state of the bullets, if displayed.
   * @function
   * @private
   * @param {Number} idx - the index of the current slide.
   */
  Orbit.prototype._updateBullets = function(idx){
    var $oldBullet = this.$element.find('.' + this.options.boxOfBullets)
                                  .find('.is-active').removeClass('is-active').blur(),
        span = $oldBullet.find('span:last').detach(),
        $newBullet = this.$bullets.eq(idx).addClass('is-active').append(span);
  };
  /**
   * Destroys the carousel and hides the element.
   * @function
   */
  Orbit.prototype.destroy = function(){
    delete this.timer;
    this.$element.off('.zf.orbit').find('*').off('.zf.orbit').end().hide();
    Foundation.unregisterPlugin(this);
  };

  Foundation.plugin(Orbit, 'Orbit');

}(jQuery, window.Foundation);

/**
 * ResponsiveMenu module.
 * @module foundation.responsiveMenu
 * @requires foundation.util.triggers
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.accordionMenu
 * @requires foundation.util.drilldown
 * @requires foundation.util.dropdown-menu
 */
!function(Foundation, $) {
  'use strict';

  // The plugin matches the plugin classes with these plugin instances.
  var MenuPlugins = {
    dropdown: {
      cssClass: 'dropdown',
      plugin: Foundation._plugins['dropdown-menu'] || null
    },
    drilldown: {
      cssClass: 'drilldown',
      plugin: Foundation._plugins['drilldown'] || null
    },
    accordion: {
      cssClass: 'accordion-menu',
      plugin: Foundation._plugins['accordion-menu'] || null
    }
  };

  // [PH] Media queries
  var phMedia = {
    small: '(min-width: 0px)',
    medium: '(min-width: 640px)'
  };

  /**
   * Creates a new instance of a responsive menu.
   * @class
   * @fires ResponsiveMenu#init
   * @param {jQuery} element - jQuery object to make into a dropdown menu.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function ResponsiveMenu(element) {
    this.$element = $(element);
    this.rules = this.$element.data('responsive-menu');
    this.currentMq = null;
    this.currentPlugin = null;

    this._init();
    this._events();

    Foundation.registerPlugin(this);
  }

  ResponsiveMenu.defaults = {};

  /**
   * Initializes the Menu by parsing the classes from the 'data-ResponsiveMenu' attribute on the element.
   * @function
   * @private
   */
  ResponsiveMenu.prototype._init = function() {
    var rulesTree = {};

    // Parse rules from "classes" in data attribute
    var rules = this.rules.split(' ');

    // Iterate through every rule found
    for (var i = 0; i < rules.length; i++) {
      var rule = rules[i].split('-');
      var ruleSize = rule.length > 1 ? rule[0] : 'small';
      var rulePlugin = rule.length > 1 ? rule[1] : rule[0];

      if (MenuPlugins[rulePlugin] !== null) {
        rulesTree[ruleSize] = MenuPlugins[rulePlugin];
      }
    }

    this.rules = rulesTree;

    if (!$.isEmptyObject(rulesTree)) {
      this._checkMediaQueries();
    }
  };

  /**
   * Initializes events for the Menu.
   * @function
   * @private
   */
  ResponsiveMenu.prototype._events = function() {
    var _this = this;

    $(window).on('changed.zf.mediaquery', function() {
      _this._checkMediaQueries();
    });
    // $(window).on('resize.zf.ResponsiveMenu', function() {
    //   _this._checkMediaQueries();
    // });
  };

  /**
   * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.
   * @function
   * @private
   */
  ResponsiveMenu.prototype._checkMediaQueries = function() {
    var matchedMq, _this = this;
    // Iterate through each rule and find the last matching rule
    $.each(this.rules, function(key) {
      if (Foundation.MediaQuery.atLeast(key)) {
        matchedMq = key;
      }
    });

    // No match? No dice
    if (!matchedMq) return;

    // Plugin already initialized? We good
    if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return;

    // Remove existing plugin-specific CSS classes
    $.each(MenuPlugins, function(key, value) {
      _this.$element.removeClass(value.cssClass);
    });

    // Add the CSS class for the new plugin
    this.$element.addClass(this.rules[matchedMq].cssClass);

    // Create an instance of the new plugin
    if (this.currentPlugin) this.currentPlugin.destroy();
    this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});
  };

  /**
   * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.
   * @function
   */
  ResponsiveMenu.prototype.destroy = function() {
    this.currentPlugin.destroy();
    $(window).off('.zf.ResponsiveMenu');
    Foundation.unregisterPlugin(this);
  };
  Foundation.plugin(ResponsiveMenu, 'ResponsiveMenu');

}(Foundation, jQuery);

/**
 * ResponsiveToggle module.
 * @module foundation.responsiveToggle
 * @requires foundation.util.mediaQuery
 */
!function($, Foundation) {

'use strict';

/**
 * Creates a new instance of Tab Bar.
 * @class
 * @fires ResponsiveToggle#init
 * @param {jQuery} element - jQuery object to attach tab bar functionality to.
 * @param {Object} options - Overrides to the default plugin settings.
 */
function ResponsiveToggle(element, options) {
  this.$element = $(element);
  this.options = $.extend({}, ResponsiveToggle.defaults, this.$element.data(), options);

  this._init();
  this._events();

  Foundation.registerPlugin(this);
}

ResponsiveToggle.defaults = {
  /**
   * The breakpoint after which the menu is always shown, and the tab bar is hidden.
   * @option
   * @example 'medium'
   */
  hideFor: 'medium'
};

/**
 * Initializes the tab bar by finding the target element, toggling element, and running update().
 * @function
 * @private
 */
ResponsiveToggle.prototype._init = function() {
  var targetID = this.$element.data('responsive-toggle');
  if (!targetID) {
    console.error('Your tab bar needs an ID of a Menu as the value of data-tab-bar.');
  }

  this.$targetMenu = $('#'+targetID);
  this.$toggler = this.$element.find('[data-toggle]');

  this._update();
};

/**
 * Adds necessary event handlers for the tab bar to work.
 * @function
 * @private
 */
ResponsiveToggle.prototype._events = function() {
  var _this = this;

  $(window).on('changed.zf.mediaquery', this._update.bind(this));

  this.$toggler.on('click.zf.responsiveToggle', this.toggleMenu.bind(this));
};

/**
 * Checks the current media query to determine if the tab bar should be visible or hidden.
 * @function
 * @private
 */
ResponsiveToggle.prototype._update = function() {
  // Mobile
  if (!Foundation.MediaQuery.atLeast(this.options.hideFor)) {
    this.$element.show();
    this.$targetMenu.hide();
  }

  // Desktop
  else {
    this.$element.hide();
    this.$targetMenu.show();
  }
};

/**
 * Toggles the element attached to the tab bar. The toggle only happens if the screen is small enough to allow it.
 * @function
 * @fires ResponsiveToggle#toggled
 */
ResponsiveToggle.prototype.toggleMenu = function() {
  if (!Foundation.MediaQuery.atLeast(this.options.hideFor)) {
    this.$targetMenu.toggle(0);

    /**
     * Fires when the element attached to the tab bar toggles.
     * @event ResponsiveToggle#toggled
     */
    this.$element.trigger('toggled.zf.responsiveToggle');
  }
};
ResponsiveToggle.prototype.destroy = function(){
  //TODO this...
};
Foundation.plugin(ResponsiveToggle, 'ResponsiveToggle');

}(jQuery, Foundation);

/**
 * Reveal module.
 * @module foundation.reveal
 * @requires foundation.util.keyboard
 * @requires foundation.util.box
 * @requires foundation.util.triggers
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.motion if using animations
 */
!function(Foundation, $) {
  'use strict';

  /**
   * Creates a new instance of Reveal.
   * @class
   * @param {jQuery} element - jQuery object to use for the modal.
   * @param {Object} options - optional parameters.
   */

  function Reveal(element, options) {
    this.$element = element;
    this.options = $.extend({}, Reveal.defaults, this.$element.data(), options);
    this._init();

    Foundation.registerPlugin(this);
    Foundation.Keyboard.register('Reveal', {
      'ENTER': 'open',
      'SPACE': 'open',
      'ESCAPE': 'close',
      'TAB': 'tab_forward',
      'SHIFT_TAB': 'tab_backward'
    });
  }

  Reveal.defaults = {
    /**
     * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
     * @option
     * @example 'slide-in-left'
     */
    animationIn: '',
    /**
     * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
     * @option
     * @example 'slide-out-right'
     */
    animationOut: '',
    /**
     * Time, in ms, to delay the opening of a modal after a click if no animation used.
     * @option
     * @example 10
     */
    showDelay: 0,
    /**
     * Time, in ms, to delay the closing of a modal after a click if no animation used.
     * @option
     * @example 10
     */
    hideDelay: 0,
    /**
     * Allows a click on the body/overlay to close the modal.
     * @option
     * @example true
     */
    closeOnClick: true,
    /**
     * Allows the modal to close if the user presses the `ESCAPE` key.
     * @option
     * @example true
     */
    closeOnEsc: true,
    /**
     * If true, allows multiple modals to be displayed at once.
     * @option
     * @example false
     */
    multipleOpened: false,
    /**
     * Distance, in pixels, the modal should push down from the top of the screen.
     * @option
     * @example 100
     */
    vOffset: 100,
    /**
     * Distance, in pixels, the modal should push in from the side of the screen.
     * @option
     * @example 0
     */
    hOffset: 0,
    /**
     * Allows the modal to be fullscreen, completely blocking out the rest of the view. JS checks for this as well.
     * @option
     * @example false
     */
    fullScreen: false,
    /**
     * Percentage of screen height the modal should push up from the bottom of the view.
     * @option
     * @example 10
     */
    btmOffsetPct: 10,
    /**
     * Allows the modal to generate an overlay div, which will cover the view when modal opens.
     * @option
     * @example true
     */
    overlay: true,
    /**
     * Allows the modal to remove and reinject markup on close. Should be true if using video elements w/o using provider's api.
     * @option
     * @example false
     */
    resetOnClose: false
  };

  /**
   * Initializes the modal by adding the overlay and close buttons, (if selected).
   * @private
   */
  Reveal.prototype._init = function(){
    this.id = this.$element.attr('id');
    this.isActive = false;

    this.$anchor = $('[data-open="' + this.id + '"]').length ? $('[data-open="' + this.id + '"]') : $('[data-toggle="' + this.id + '"]');

    if(this.$anchor.length){
      var anchorId = this.$anchor[0].id || Foundation.GetYoDigits(6, 'reveal');

      this.$anchor.attr({
        'aria-controls': this.id,
        'id': anchorId,
        'aria-haspopup': true,
        'tabindex': 0
      });
      this.$element.attr({'aria-labelledby': anchorId});
    }

    // this.options.fullScreen = this.$element.hasClass('full');
    if(this.options.fullScreen || this.$element.hasClass('full')){
      this.options.fullScreen = true;
      this.options.overlay = false;
    }
    if(this.options.overlay){
      this.$overlay = this._makeOverlay(this.id);
    }

    this.$element.attr({
        'role': 'dialog',
        'aria-hidden': true,
        'data-yeti-box': this.id,
        'data-resize': this.id
    });

    this._events();
  };

  /**
   * Creates an overlay div to display behind the modal.
   * @private
   */
  Reveal.prototype._makeOverlay = function(id){
    var $overlay = $('<div></div>')
                    .addClass('reveal-overlay')
                    .attr({'tabindex': -1, 'aria-hidden': true})
                    .appendTo('body');
    if(this.options.closeOnClick){
      $overlay.attr({
        'data-close': id
      });
    }
    return $overlay;
  };

  /**
   * Adds event handlers for the modal.
   * @private
   */
  Reveal.prototype._events = function(){
    var _this = this;

    this.$element.on({
      'open.zf.trigger': this.open.bind(this),
      'close.zf.trigger': this.close.bind(this),
      'toggle.zf.trigger': this.toggle.bind(this),
      'resizeme.zf.trigger': function(){
        if(_this.$element.is(':visible')){
          _this._setPosition(function(){});
        }
      }
    });

    if(this.$anchor.length){
      this.$anchor.on('keydown.zf.reveal', function(e){
        if(e.which === 13 || e.which === 32){
          e.stopPropagation();
          e.preventDefault();
          _this.open();
        }
      });
    }


    if(this.options.closeOnClick && this.options.overlay){
      this.$overlay.off('.zf.reveal').on('click.zf.reveal', this.close.bind(this));
    }
  };
  /**
   * Sets the position of the modal before opening
   * @param {Function} cb - a callback function to execute when positioning is complete.
   * @private
   */
  Reveal.prototype._setPosition = function(cb){
    var eleDims = Foundation.Box.GetDimensions(this.$element);
    var elePos = this.options.fullScreen ? 'reveal full' : (eleDims.height >= (0.5 * eleDims.windowDims.height)) ? 'reveal' : 'center';

    if(elePos === 'reveal full'){
      console.log('full');
      //set to full height/width
      this.$element
          .offset(Foundation.Box.GetOffsets(this.$element, null, elePos, this.options.vOffset))
          .css({
            'height': eleDims.windowDims.height,
            'width': eleDims.windowDims.width
          });
    }else if(!Foundation.MediaQuery.atLeast('medium') || !Foundation.Box.ImNotTouchingYou(this.$element, null, true, false)){
      //if smaller than medium, resize to 100% width minus any custom L/R margin
      this.$element
          .css({
            'width': eleDims.windowDims.width - (this.options.hOffset * 2)
          })
          .offset(Foundation.Box.GetOffsets(this.$element, null, 'center', this.options.vOffset, this.options.hOffset));
      //flag a boolean so we can reset the size after the element is closed.
      this.changedSize = true;
    }else{
      this.$element
          .css({
            'max-height': eleDims.windowDims.height - (this.options.vOffset * (this.options.btmOffsetPct / 100 + 1)),
            'width': ''
          })
          .offset(Foundation.Box.GetOffsets(this.$element, null, elePos, this.options.vOffset));
          //the max height based on a percentage of vertical offset plus vertical offset
    }

    cb();
  };

  /**
   * Opens the modal controlled by `this.$anchor`, and closes all others by default.
   * @function
   * @fires Reveal#closeAll
   * @fires Reveal#open
   */
  Reveal.prototype.open = function(){
    var _this = this;
    this.isActive = true;
    //make element invisible, but remove display: none so we can get size and positioning
    this.$element
        .css({'visibility': 'hidden'})
        .show()
        .scrollTop(0);

    this._setPosition(function(){
      _this.$element.hide()
                   .css({'visibility': ''});
      if(!_this.options.multipleOpened){
        /**
         * Fires immediately before the modal opens.
         * Closes any other modals that are currently open
         * @event Reveal#closeAll
         */
        _this.$element.trigger('closeme.zf.reveal', _this.id);
      }
      if(_this.options.animationIn){
        if(_this.options.overlay){
          Foundation.Motion.animateIn(_this.$overlay, 'fade-in', function(){
            Foundation.Motion.animateIn(_this.$element, _this.options.animationIn, function(){
            });
          });
        }else{
          Foundation.Motion.animateIn(_this.$element, _this.options.animationIn, function(){
          });
        }
      }else{
        if(_this.options.overlay){
          _this.$overlay.show(0, function(){
            _this.$element.show(_this.options.showDelay, function(){
            });
          });
        }else{
          _this.$element.show(_this.options.showDelay, function(){
          });
        }
      }
    });


    // handle accessibility
    this.$element.attr({'aria-hidden': false}).attr('tabindex', -1).focus()
    /**
     * Fires when the modal has successfully opened.
     * @event Reveal#open
     */
                 .trigger('open.zf.reveal');

    $('body').addClass('is-reveal-open')
             .attr({'aria-hidden': (this.options.overlay || this.options.fullScreen) ? true : false});
    setTimeout(function(){
      _this._extraHandlers();
      // Foundation.reflow();
    }, 0);
  };

  /**
   * Adds extra event handlers for the body and window if necessary.
   * @private
   */
  Reveal.prototype._extraHandlers = function(){
    var _this = this;
    var visibleFocusableElements = this.$element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function() {
      if (!$(this).is(':visible') || $(this).attr('tabindex') < 0){ return false; }//only have visible elements and those that have a tabindex greater or equal 0
      return true;
    });

    if(!this.options.overlay && this.options.closeOnClick && !this.options.fullScreen){
      $('body').on('click.zf.reveal', function(e){
        // if()
          _this.close();
      });
    }
    if(this.options.closeOnEsc){
      $(window).on('keydown.zf.reveal', function(e){
        if (visibleFocusableElements.length === 0) { // no focusable elements inside the modal at all, prevent tabbing in general
          e.preventDefault();
        }
        Foundation.Keyboard.handleKey(e, _this, {
          close: function() {
            if (this.options.closeOnEsc) {
              this.close();
            }
          }
        });
      });
    }

    // lock focus within modal while tabbing
    this.$element.on('keydown.zf.reveal', function(e) {
      var $target = $(this);
      // handle keyboard event with keyboard util
      Foundation.Keyboard.handleKey(e, _this, {
        tab_forward: function() {
          if (this.$element.find(':focus').is(visibleFocusableElements.eq(-1))) { // left modal downwards, setting focus to first element
            visibleFocusableElements.eq(0).focus();
            e.preventDefault();
          }
        },
        tab_backward: function() {
          if (this.$element.find(':focus').is(visibleFocusableElements.eq(0)) || this.$element.is(':focus')) { // left modal upwards, setting focus to last element
            visibleFocusableElements.eq(-1).focus();
            e.preventDefault();
          }
        },
        open: function() {
          if ($target.is(visibleFocusableElements)) { // dont't trigger if acual element has focus (i.e. inputs, links, ...)
            this.open();
          }
        },
        close: function() {
          if (this.options.closeOnEsc) {
            this.close();
          }
        }
      });
      if (visibleFocusableElements.length === 0) { // no focusable elements inside the modal at all, prevent tabbing in general
        e.preventDefault();
      }
    });

  };

  /**
   * Closes the modal.
   * @function
   * @fires Reveal#closed
   */
  Reveal.prototype.close = function(){
    if(!this.isActive || !this.$element.is(':visible')){
      return false;
    }
    var _this = this;

    if(this.options.animationOut){
      Foundation.Motion.animateOut(this.$element, this.options.animationOut, function(){
        if(_this.options.overlay){
          Foundation.Motion.animateOut(_this.$overlay, 'fade-out', function(){
          });
        }
      });
    }else{
      this.$element.hide(_this.options.hideDelay, function(){
        if(_this.options.overlay){
          _this.$overlay.hide(0, function(){
          });
        }
      });
    }
    //conditionals to remove extra event listeners added on open
    if(this.options.closeOnEsc){
      $(window).off('keydown.zf.reveal');
    }
    if(!this.options.overlay && this.options.closeOnClick){
      $('body').off('click.zf.reveal');
    }
    this.$element.off('keydown.zf.reveal');

    //if the modal changed size, reset it
    if(this.changedSize){
      this.$element.css({
        'height': '',
        'width': ''
      });
    }

    $('body').removeClass('is-reveal-open').attr({'aria-hidden': false, 'tabindex': ''});

    /**
    * Resets the modal content
    * This prevents a running video to keep going in the background
    */
    if(this.options.resetOnClose) {
      this.$element.html(this.$element.html());
    }

    this.isActive = false;
    this.$element.attr({'aria-hidden': true})
    /**
     * Fires when the modal is done closing.
     * @event Reveal#closed
     */
                 .trigger('closed.zf.reveal');
  };
  /**
   * Toggles the open/closed state of a modal.
   * @function
   */
  Reveal.prototype.toggle = function(){
    if(this.isActive){
      this.close();
    }else{
      this.open();
    }
  };

  /**
   * Destroys an instance of a modal.
   * @function
   */
  Reveal.prototype.destroy = function() {
    if(this.options.overlay){
      this.$overlay.hide().off().remove();
    }
    this.$element.hide();
    this.$anchor.off();

    Foundation.unregisterPlugin(this);
  };

  Foundation.plugin(Reveal, 'Reveal');

  // Exports for AMD/Browserify
  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined')
    module.exports = Reveal;
  if (typeof define === 'function')
    define(['foundation'], function() {
      return Reveal;
    });

}(Foundation, jQuery);

/**
 * Slider module.
 * @module foundation.slider
 * @requires foundation.util.motion
 * @requires foundation.util.triggers
 * @requires foundation.util.keyboard
 * @requires foundation.util.touch
 */
!function($, Foundation){
  'use strict';

  /**
   * Creates a new instance of a drilldown menu.
   * @class
   * @param {jQuery} element - jQuery object to make into an accordion menu.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function Slider(element, options){
    this.$element = element;
    this.options = $.extend({}, Slider.defaults, this.$element.data(), options);

    this._init();

    Foundation.registerPlugin(this);
    Foundation.Keyboard.register('Slider', {
      'ltr': {
        'ARROW_RIGHT': 'increase',
        'ARROW_UP': 'increase',
        'ARROW_DOWN': 'decrease',
        'ARROW_LEFT': 'decrease',
        'SHIFT_ARROW_RIGHT': 'increase_fast',
        'SHIFT_ARROW_UP': 'increase_fast',
        'SHIFT_ARROW_DOWN': 'decrease_fast',
        'SHIFT_ARROW_LEFT': 'decrease_fast'
      },
      'rtl': {
        'ARROW_LEFT': 'increase',
        'ARROW_RIGHT': 'decrease',
        'SHIFT_ARROW_LEFT': 'increase_fast',
        'SHIFT_ARROW_RIGHT': 'decrease_fast'
      }
    });
  }

  Slider.defaults = {
    /**
     * Minimum value for the slider scale.
     * @option
     * @example 0
     */
    start: 0,
    /**
     * Maximum value for the slider scale.
     * @option
     * @example 100
     */
    end: 100,
    /**
     * Minimum value change per change event. Not Currently Implemented!

     */
    step: 1,
    /**
     * Value at which the handle/input *(left handle/first input)* should be set to on initialization.
     * @option
     * @example 0
     */
    initialStart: 0,
    /**
     * Value at which the right handle/second input should be set to on initialization.
     * @option
     * @example 100
     */
    initialEnd: 100,
    /**
     * Allows the input to be located outside the container and visible. Set to by the JS
     * @option
     * @example false
     */
    binding: false,
    /**
     * Allows the user to click/tap on the slider bar to select a value.
     * @option
     * @example true
     */
    clickSelect: true,
    /**
     * Set to true and use the `vertical` class to change alignment to vertical.
     * @option
     * @example false
     */
    vertical: false,
    /**
     * Allows the user to drag the slider handle(s) to select a value.
     * @option
     * @example true
     */
    draggable: true,
    /**
     * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.
     * @option
     * @example false
     */
    disabled: false,
    /**
     * Allows the use of two handles. Double checked by the JS. Changes some logic handling.
     * @option
     * @example false
     */
    doubleSided: false,
    /**
     * Potential future feature.
     */
    // steps: 100,
    /**
     * Number of decimal places the plugin should go to for floating point precision.
     * @option
     * @example 2
     */
    decimal: 2,
    /**
     * Time delay for dragged elements.
     */
    // dragDelay: 0,
    /**
     * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.
     * @option
     * @example 200
     */
    moveTime: 200,//update this if changing the transition time in the sass
    /**
     * Class applied to disabled sliders.
     * @option
     * @example 'disabled'
     */
    disabledClass: 'disabled'
  };
  /**
   * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).
   * @function
   * @private
   */
  Slider.prototype._init = function(){
    this.inputs = this.$element.find('input');
    this.handles = this.$element.find('[data-slider-handle]');

    this.$handle = this.handles.eq(0);
    this.$input = this.inputs.length ? this.inputs.eq(0) : $('#' + this.$handle.attr('aria-controls'));
    this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);

    var isDbl = false,
        _this = this;
    if(this.options.disabled || this.$element.hasClass(this.options.disabledClass)){
      this.options.disabled = true;
      this.$element.addClass(this.options.disabledClass);
    }
    if(!this.inputs.length){
      this.inputs = $().add(this.$input);
      this.options.binding = true;
    }
    this._setInitAttr(0);
    this._events(this.$handle);

    if(this.handles[1]){
      this.options.doubleSided = true;
      this.$handle2 = this.handles.eq(1);
      this.$input2 = this.inputs.length ? this.inputs.eq(1) : $('#' + this.$handle2.attr('aria-controls'));

      if(!this.inputs[1]){
        this.inputs = this.inputs.add(this.$input2);
      }
      isDbl = true;

      this._setHandlePos(this.$handle, this.options.initialStart, true, function(){

        _this._setHandlePos(_this.$handle2, _this.options.initialEnd);
      });
      // this.$handle.triggerHandler('click.zf.slider');
      this._setInitAttr(1);
      this._events(this.$handle2);
    }

    if(!isDbl){
      this._setHandlePos(this.$handle, this.options.initialStart, true);
    }
  };
  /**
   * Sets the position of the selected handle and fill bar.
   * @function
   * @private
   * @param {jQuery} $hndl - the selected handle to move.
   * @param {Number} location - floating point between the start and end values of the slider bar.
   * @param {Function} cb - callback function to fire on completion.
   * @fires Slider#moved
   */
  Slider.prototype._setHandlePos = function($hndl, location, noInvert, cb){
  //might need to alter that slightly for bars that will have odd number selections.
    location = parseFloat(location);//on input change events, convert string to number...grumble.
    // prevent slider from running out of bounds
    if(location < this.options.start){ location = this.options.start; }
    else if(location > this.options.end){ location = this.options.end; }

    var isDbl = this.options.doubleSided,
        callback = cb || null;

    if(isDbl){
      if(this.handles.index($hndl) === 0){
        var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));
        location = location >= h2Val ? h2Val - this.options.step : location;
      }else{
        var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));
        location = location <= h1Val ? h1Val + this.options.step : location;
      }
    }

    if(this.options.vertical && !noInvert){
      location = this.options.end - location;
    }
    var _this = this,
        vert = this.options.vertical,
        hOrW = vert ? 'height' : 'width',
        lOrT = vert ? 'top' : 'left',
        halfOfHandle = $hndl[0].getBoundingClientRect()[hOrW] / 2,
        elemDim = this.$element[0].getBoundingClientRect()[hOrW],
        pctOfBar = percent(location, this.options.end).toFixed(this.options.decimal),
        pxToMove = (elemDim - halfOfHandle) * pctOfBar,
        movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal),
        location = location > 0 ? parseFloat(location.toFixed(this.options.decimal)) : 0,
        anim, prog, start = null, css = {};

    this._setValues($hndl, location);

    if(this.options.doubleSided){//update to calculate based on values set to respective inputs??
      var isLeftHndl = this.handles.index($hndl) === 0,
          dim,
          idx = this.handles.index($hndl);

      if(isLeftHndl){
        css[lOrT] = (pctOfBar > 0 ? pctOfBar * 100 : 0) + '%';//
        dim = /*Math.abs*/((percent(this.$handle2.position()[lOrT] + halfOfHandle, elemDim) - parseFloat(pctOfBar)) * 100).toFixed(this.options.decimal) + '%';
        css['min-' + hOrW] = dim;
        if(cb && typeof cb === 'function'){ cb(); }
      }else{
        location = (location < 100 ? location : 100) - (parseFloat(this.$handle[0].style.left) || this.options.end - location);
        css['min-' + hOrW] = location + '%';
      }
    }

    this.$element.one('finished.zf.animate', function(){
                    _this.animComplete = true;
                    /**
                     * Fires when the handle is done moving.
                     * @event Slider#moved
                     */
                    _this.$element.trigger('moved.zf.slider', [$hndl]);
                });
    var moveTime = _this.$element.data('dragging') ? 1000/60 : _this.options.moveTime;
    /*var move = new */Foundation.Move(moveTime, $hndl, function(){
      $hndl.css(lOrT, movement + '%');
      if(!_this.options.doubleSided){
        _this.$fill.css(hOrW, pctOfBar * 100 + '%');
      }else{
        _this.$fill.css(css);
      }
    });
    // move.do();
  };
  /**
   * Sets the initial attribute for the slider element.
   * @function
   * @private
   * @param {Number} idx - index of the current handle/input to use.
   */
  Slider.prototype._setInitAttr = function(idx){
    var id = this.inputs.eq(idx).attr('id') || Foundation.GetYoDigits(6, 'slider');
    this.inputs.eq(idx).attr({
      'id': id,
      'max': this.options.end,
      'min': this.options.start

    });
    this.handles.eq(idx).attr({
      'role': 'slider',
      'aria-controls': id,
      'aria-valuemax': this.options.end,
      'aria-valuemin': this.options.start,
      'aria-valuenow': idx === 0 ? this.options.initialStart : this.options.initialEnd,
      'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',
      'tabindex': 0
    });
  };
  /**
   * Sets the input and `aria-valuenow` values for the slider element.
   * @function
   * @private
   * @param {jQuery} $handle - the currently selected handle.
   * @param {Number} val - floating point of the new value.
   */
  Slider.prototype._setValues = function($handle, val){
    var idx = this.options.doubleSided ? this.handles.index($handle) : 0;
    this.inputs.eq(idx).val(val);
    $handle.attr('aria-valuenow', val);
  };
  /**
   * Handles events on the slider element.
   * Calculates the new location of the current handle.
   * If there are two handles and the bar was clicked, it determines which handle to move.
   * @function
   * @private
   * @param {Object} e - the `event` object passed from the listener.
   * @param {jQuery} $handle - the current handle to calculate for, if selected.
   * @param {Number} val - floating point number for the new value of the slider.
   */
  Slider.prototype._handleEvent = function(e, $handle, val){
    var value, hasVal;
    if(!val){//click or drag events
      e.preventDefault();
      var _this = this,
          vertical = this.options.vertical,
          param = vertical ? 'height' : 'width',
          direction = vertical ? 'top' : 'left',
          pageXY = vertical ? e.pageY : e.pageX,
          halfOfHandle = this.$handle[0].getBoundingClientRect()[param] / 2,
          barDim = this.$element[0].getBoundingClientRect()[param],
          barOffset = (this.$element.offset()[direction] -  pageXY),
          barXY = barOffset > 0 ? -halfOfHandle : (barOffset - halfOfHandle) < -barDim ? barDim : Math.abs(barOffset),//if the cursor position is less than or greater than the elements bounding coordinates, set coordinates within those bounds
          // eleDim = this.$element[0].getBoundingClientRect()[param],
          offsetPct = percent(barXY, barDim);
      value = (this.options.end - this.options.start) * offsetPct;
      hasVal = false;

      if(!$handle){//figure out which handle it is, pass it to the next function.
        var firstHndlPos = absPosition(this.$handle, direction, barXY, param),
            secndHndlPos = absPosition(this.$handle2, direction, barXY, param);
            $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;
      }

    }else{//change event on input
      value = val;
      hasVal = true;
    }

    this._setHandlePos($handle, value, hasVal);
  };
  /**
   * Adds event listeners to the slider elements.
   * @function
   * @private
   * @param {jQuery} $handle - the current handle to apply listeners to.
   */
  Slider.prototype._events = function($handle){
    if(this.options.disabled){ return false; }

    var _this = this,
        curHandle,
        timer;

      this.inputs.off('change.zf.slider').on('change.zf.slider', function(e){
        var idx = _this.inputs.index($(this));
        _this._handleEvent(e, _this.handles.eq(idx), $(this).val());
      });

    if(this.options.clickSelect){
      this.$element.off('click.zf.slider').on('click.zf.slider', function(e){
        if(_this.$element.data('dragging')){ return false; }
        _this.animComplete = false;
        if(_this.options.doubleSided){
          _this._handleEvent(e);
        }else{
          _this._handleEvent(e, _this.$handle);
        }
      });
    }

    if(this.options.draggable){
      this.handles.addTouch();
      // var curHandle,
      //     timer,
      var $body = $('body');
      $handle
        .off('mousedown.zf.slider')
        .on('mousedown.zf.slider', function(e){
          $handle.addClass('is-dragging');
          _this.$fill.addClass('is-dragging');//
          _this.$element.data('dragging', true);
          _this.animComplete = false;
          curHandle = $(e.currentTarget);

          $body.on('mousemove.zf.slider', function(e){
            e.preventDefault();

            // timer = setTimeout(function(){
            _this._handleEvent(e, curHandle);
            // }, _this.options.dragDelay);
          }).on('mouseup.zf.slider', function(e){
            // clearTimeout(timer);
            _this.animComplete = true;
            _this._handleEvent(e, curHandle);
            $handle.removeClass('is-dragging');
            _this.$fill.removeClass('is-dragging');
            _this.$element.data('dragging', false);
            // Foundation.reflow(_this.$element, 'slider');
            $body.off('mousemove.zf.slider mouseup.zf.slider');
          });
      });
    }
    $handle.off('keydown.zf.slider').on('keydown.zf.slider', function(e){
      var idx = _this.options.doubleSided ? _this.handles.index($(this)) : 0,
        oldValue = parseFloat(_this.inputs.eq(idx).val()),
        newValue;

      var _$handle = $(this);

      // handle keyboard event with keyboard util
      Foundation.Keyboard.handleKey(e, _this, {
        decrease: function() {
          newValue = oldValue - _this.options.step;
        },
        increase: function() {
          newValue = oldValue + _this.options.step;
        },
        decrease_fast: function() {
          newValue = oldValue - _this.options.step * 10;
        },
        increase_fast: function() {
          newValue = oldValue + _this.options.step * 10;
        },
        handled: function() { // only set handle pos when event was handled specially
          e.preventDefault();
          _this._setHandlePos(_$handle, newValue, true);
        }
      });
      /*if (newValue) { // if pressed key has special function, update value
        e.preventDefault();
        _this._setHandlePos(_$handle, newValue);
      }*/
    });
  };
  /**
   * Destroys the slider plugin.
   */
   Slider.prototype.destroy = function(){
     this.handles.off('.zf.slider');
     this.inputs.off('.zf.slider');
     this.$element.off('.zf.slider');

     Foundation.unregisterPlugin(this);
   };

  Foundation.plugin(Slider, 'Slider');

  function percent(frac, num){
    return (frac / num);
  }
  function absPosition($handle, dir, clickPos, param){
    return Math.abs(($handle.position()[dir] + ($handle[param]() / 2)) - clickPos);
  }
}(jQuery, window.Foundation);

//*********this is in case we go to static, absolute positions instead of dynamic positioning********
// this.setSteps(function(){
//   _this._events();
//   var initStart = _this.options.positions[_this.options.initialStart - 1] || null;
//   var initEnd = _this.options.initialEnd ? _this.options.position[_this.options.initialEnd - 1] : null;
//   if(initStart || initEnd){
//     _this._handleEvent(initStart, initEnd);
//   }
// });

//***********the other part of absolute positions*************
// Slider.prototype.setSteps = function(cb){
//   var posChange = this.$element.outerWidth() / this.options.steps;
//   var counter = 0
//   while(counter < this.options.steps){
//     if(counter){
//       this.options.positions.push(this.options.positions[counter - 1] + posChange);
//     }else{
//       this.options.positions.push(posChange);
//     }
//     counter++;
//   }
//   cb();
// };

/**
 * Sticky module.
 * @module foundation.sticky
 * @requires foundation.util.triggers
 * @requires foundation.util.mediaQuery
 */
!function($, Foundation){
  'use strict';

  /**
   * Creates a new instance of a sticky thing.
   * @class
   * @param {jQuery} element - jQuery object to make sticky.
   * @param {Object} options - options object passed when creating the element programmatically.
   */
  function Sticky(element, options){
    this.$element = element;
    this.options = $.extend({}, Sticky.defaults, this.$element.data(), options);

    this._init();

    Foundation.registerPlugin(this);
  }
  Sticky.defaults = {
    /**
     * Customizable container template. Add your own classes for styling and sizing.
     * @option
     * @example '<div data-sticky-container class="small-6 columns"></div>'
     */
    container: '<div data-sticky-container></div>',
    /**
     * Location in the view the element sticks to.
     * @option
     * @example 'top'
     */
    stickTo: 'top',
    /**
     * If anchored to a single element, the id of that element.
     * @option
     * @example 'exampleId'
     */
    anchor: '',
    /**
     * If using more than one element as anchor points, the id of the top anchor.
     * @option
     * @example 'exampleId:top'
     */
    topAnchor: '',
    /**
     * If using more than one element as anchor points, the id of the bottom anchor.
     * @option
     * @example 'exampleId:bottom'
     */
    btmAnchor: '',
    /**
     * Margin, in `em`'s to apply to the top of the element when it becomes sticky.
     * @option
     * @example 1
     */
    marginTop: 1,
    /**
     * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.
     * @option
     * @example 1
     */
    marginBottom: 1,
    /**
     * Breakpoint string that is the minimum screen size an element should become sticky.
     * @option
     * @example 'medium'
     */
    stickyOn: 'medium',
    /**
     * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.
     * @option
     * @example 'sticky'
     */
    stickyClass: 'sticky',
    /**
     * Class applied to sticky container. Foundation defaults to `sticky-container`.
     * @option
     * @example 'sticky-container'
     */
    containerClass: 'sticky-container',
    /**
     * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.
     * @option
     * @example 50
     */
    checkEvery: -1
  };

  /**
   * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes
   * Also triggered by Foundation._reflow
   * @function
   * @private
   */
  Sticky.prototype._init = function(){
    var $parent = this.$element.parent('[data-sticky-container]'),
        id = this.$element[0].id || Foundation.GetYoDigits(6, 'sticky'),
        _this = this;

    if(!$parent.length){
      this.wasWrapped = true;
    }
    this.$container = $parent.length ? $parent : $(this.options.container).wrapInner(this.$element);
    this.$container.addClass(this.options.containerClass);


    this.$element.addClass(this.options.stickyClass)
                 .attr({'data-resize': id});

    this.scrollCount = this.options.checkEvery;
    this.isStuck = false;
    // console.log(this.options.anchor, this.options.topAnchor);
    if(this.options.topAnchor !== ''){
      this._parsePoints();
      // console.log(this.points[0]);
    }else{
      this.$anchor = this.options.anchor ? $('#' + this.options.anchor) : $(document.body);
    }


    this._setSizes(function(){
      _this._calc(false);
    });
    this._events(id.split('-').reverse().join('-'));
  };
  /**
   * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.
   * @function
   * @private
   */
  Sticky.prototype._parsePoints = function(){
    var top = this.options.topAnchor,
        btm = this.options.btmAnchor,
        pts = [top, btm],
        breaks = {};
    for(var i = 0, len = pts.length; i < len && pts[i]; i++){
      var pt;
      if(typeof pts[i] === 'number'){
        pt = pts[i];
      }else{
        var place = pts[i].split(':'),
            anchor = $('#' + place[0]);

        pt = anchor.offset().top;
        if(place[1] && place[1].toLowerCase() === 'bottom'){
          pt += anchor[0].getBoundingClientRect().height;
        }
      }
      breaks[i] = pt;
    }
      // console.log(breaks);
    this.points = breaks;
    // console.log(this.points);
    return;
  };

  /**
   * Adds event handlers for the scrolling element.
   * @private
   * @param {String} id - psuedo-random id for unique scroll event listener.
   */
  Sticky.prototype._events = function(id){
    // console.log('called');
    var _this = this,
        scrollListener = 'scroll.zf.' + id;
    if(this.isOn){ return; }
    if(this.canStick){
      this.isOn = true;
      // this.$anchor.off('change.zf.sticky')
      //             .on('change.zf.sticky', function(){
      //               _this._setSizes(function(){
      //                 _this._calc(false);
      //               });
      //             });

      $(window).off(scrollListener)
               .on(scrollListener, function(e){
                 if(_this.scrollCount === 0){
                   _this.scrollCount = _this.options.checkEvery;
                   _this._setSizes(function(){
                     _this._calc(false, window.pageYOffset);
                   });
                 }else{
                   _this.scrollCount--;
                   _this._calc(false, window.pageYOffset);
                 }
              });
    }

    this.$element.off('resizeme.zf.trigger')
                 .on('resizeme.zf.trigger', function(e, el){
                     _this._setSizes(function(){
                       _this._calc(false);
                       if(_this.canStick){
                         if(!_this.isOn){
                           _this._events(id);
                         }
                       }else if(_this.isOn){
                         _this._pauseListeners(scrollListener);
                       }
                     });
    });
  };

  /**
   * Removes event handlers for scroll and change events on anchor.
   * @fires Sticky#pause
   * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`
   */
  Sticky.prototype._pauseListeners = function(scrollListener){
    this.isOn = false;
    // this.$anchor.off('change.zf.sticky');
    $(window).off(scrollListener);

    /**
     * Fires when the plugin is paused due to resize event shrinking the view.
     * @event Sticky#pause
     * @private
     */
     this.$element.trigger('pause.zf.sticky');
  };

  /**
   * Called on every `scroll` event and on `_init`
   * fires functions based on booleans and cached values
   * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.
   * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.
   */
  Sticky.prototype._calc = function(checkSizes, scroll){
    if(checkSizes){ this._setSizes(); }

    if(!this.canStick){
      if(this.isStuck){
        this._removeSticky(true);
      }
      return false;
    }

    if(!scroll){ scroll = window.pageYOffset; }

    if(scroll >= this.topPoint){
      if(scroll <= this.bottomPoint){
        if(!this.isStuck){
          this._setSticky();
        }
      }else{
        if(this.isStuck){
          this._removeSticky(false);
        }
      }
    }else{
      if(this.isStuck){
        this._removeSticky(true);
      }
    }
  };
  /**
   * Causes the $element to become stuck.
   * Adds `position: fixed;`, and helper classes.
   * @fires Sticky#stuckto
   * @function
   * @private
   */
  Sticky.prototype._setSticky = function(){
    var stickTo = this.options.stickTo,
        mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',
        notStuckTo = stickTo === 'top' ? 'bottom' : 'top',
        css = {};

    css[mrgn] = this.options[mrgn] + 'em';
    css[stickTo] = 0;
    css[notStuckTo] = 'auto';
    css['left'] = this.$container.offset().left + parseInt(window.getComputedStyle(this.$container[0])["padding-left"], 10);
    this.isStuck = true;
    this.$element.removeClass('is-anchored is-at-' + notStuckTo)
                 .addClass('is-stuck is-at-' + stickTo)
                 .css(css)
                 /**
                  * Fires when the $element has become `position: fixed;`
                  * Namespaced to `top` or `bottom`.
                  * @event Sticky#stuckto
                  */
                 .trigger('sticky.zf.stuckto:' + stickTo);
  };

  /**
   * Causes the $element to become unstuck.
   * Removes `position: fixed;`, and helper classes.
   * Adds other helper classes.
   * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.
   * @fires Sticky#unstuckfrom
   * @private
   */
  Sticky.prototype._removeSticky = function(isTop){
    var stickTo = this.options.stickTo,
        stickToTop = stickTo === 'top',
        css = {}, mrgn, notStuckTo,
        anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight;
        mrgn = stickToTop ? 'marginTop' : 'marginBottom';
        notStuckTo = stickToTop ? 'bottom' : 'top';
      css[mrgn] = 0;
    if((isTop && !stickToTop) || (stickToTop && !isTop)){
      css[stickTo] = anchorPt;
      css[notStuckTo] = 0;
    }else{
      css[stickTo] = 0;
      css[notStuckTo] = anchorPt;
    }
    css['left'] = '';
    this.isStuck = false;
    this.$element.removeClass('is-stuck is-at-' + stickTo)
                 .addClass('is-anchored is-at-' + (isTop ? 'top' : 'bottom'))
                 .css(css)
                 /**
                  * Fires when the $element has become anchored.
                  * Namespaced to `top` or `bottom`.
                  * @event Sticky#unstuckfrom
                  */
                 .trigger('sticky.zf.unstuckfrom:' + isTop ? 'top' : 'bottom');
  };

  /**
   * Sets the $element and $container sizes for plugin.
   * Calls `_setBreakPoints`.
   * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.
   * @private
   */
  Sticky.prototype._setSizes = function(cb){
    this.canStick = Foundation.MediaQuery.atLeast(this.options.stickyOn);
    if(!this.canStick){ cb(); }
    var _this = this,
        newElemWidth = this.$container[0].getBoundingClientRect().width,
        comp = window.getComputedStyle(this.$container[0]),
        pdng = parseInt(comp['padding-right'], 10);

    // console.log(this.$anchor);
    if(this.$anchor && this.$anchor.length){
      this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;
    }else{
      this._parsePoints();
    }

    this.$element.css({
      'max-width': newElemWidth - pdng + 'px'
    });

    var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;
    this.containerHeight = newContainerHeight;
    this.$container.css({
      height: newContainerHeight
    });
    this.elemHeight = newContainerHeight;

  	if (this.isStuck) {
  		this.$element.css({"left":this.$container.offset().left + parseInt(comp['padding-left'], 10)});
  	}

    this._setBreakPoints(newContainerHeight, function(){
      if(cb){ cb(); }
    });

  };
  /**
   * Sets the upper and lower breakpoints for the element to become sticky/unsticky.
   * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.
   * @param {Function} cb - optional callback function to be called on completion.
   * @private
   */
  Sticky.prototype._setBreakPoints = function(elemHeight, cb){
    if(!this.canStick){
      if(cb){ cb(); }
      else{ return false; }
    }
    var mTop = emCalc(this.options.marginTop),
        mBtm = emCalc(this.options.marginBottom),
        topPoint = this.points ? this.points[0] : this.$anchor.offset().top,
        bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,
        // topPoint = this.$anchor.offset().top || this.points[0],
        // bottomPoint = topPoint + this.anchorHeight || this.points[1],
        winHeight = window.innerHeight;

    if(this.options.stickTo === 'top'){
      topPoint -= mTop;
      bottomPoint -= (elemHeight + mTop);
    }else if(this.options.stickTo === 'bottom'){
      topPoint -= (winHeight - (elemHeight + mBtm));
      bottomPoint -= (winHeight - mBtm);
    }else{
      //this would be the stickTo: both option... tricky
    }

    this.topPoint = topPoint;
    this.bottomPoint = bottomPoint;

    if(cb){ cb(); }
  };

  /**
   * Destroys the current sticky element.
   * Resets the element to the top position first.
   * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.
   * @function
   */
  Sticky.prototype.destroy = function(){
    this._removeSticky(true);

    this.$element.removeClass(this.options.stickyClass + ' is-anchored is-at-top')
                 .css({
                   height: '',
                   top: '',
                   bottom: '',
                   'max-width': ''
                 })
                 .off('resizeme.zf.trigger');

    this.$anchor.off('change.zf.sticky');
    $(window).off('scroll.zf.sticky');

    if(this.wasWrapped){
      this.$element.unwrap();
    }else{
      this.$container.removeClass(this.options.containerClass)
                     .css({
                       height: ''
                     });
    }
    Foundation.unregisterPlugin(this);
  };
  /**
   * Helper function to calculate em values
   * @param Number {em} - number of em's to calculate into pixels
   */
  function emCalc(em){
    return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;
  }
  Foundation.plugin(Sticky, 'Sticky');
}(jQuery, window.Foundation);

/**
 * Tabs module.
 * @module foundation.tabs
 * @requires foundation.util.keyboard
 * @requires foundation.util.timerAndImageLoader if tabs contain images
 */
!function($, Foundation) {
  'use strict';

  /**
   * Creates a new instance of tabs.
   * @class
   * @fires Tabs#init
   * @param {jQuery} element - jQuery object to make into tabs.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function Tabs(element, options){
    this.$element = element;
    this.options = $.extend({}, Tabs.defaults, this.$element.data(), options);

    this._init();
    Foundation.registerPlugin(this);
    Foundation.Keyboard.register('Tabs', {
      'ENTER': 'open',
      'SPACE': 'open',
      'ARROW_RIGHT': 'next',
      'ARROW_UP': 'previous',
      'ARROW_DOWN': 'next',
      'ARROW_LEFT': 'previous',
      // 'TAB': 'next',
      // 'SHIFT_TAB': 'previous'
    });
  }

  Tabs.defaults = {
    // /**
    //  * Allows the JS to alter the url of the window. Not yet implemented.
    //  */
    // deepLinking: false,
    // /**
    //  * If deepLinking is enabled, allows the window to scroll to content if window is loaded with a hash including a tab-pane id
    //  */
    // scrollToContent: false,
    /**
     * Allows the window to scroll to content of active pane on load if set to true.
     * @option
     * @example false
     */
    autoFocus: false,
    /**
     * Allows keyboard input to 'wrap' around the tab links.
     * @option
     * @example true
     */
    wrapOnKeys: true,
    /**
     * Allows the tab content panes to match heights if set to true.
     * @option
     * @example false
     */
    matchHeight: false,
    /**
     * Class applied to `li`'s in tab link list.
     * @option
     * @example 'tabs-title'
     */
    linkClass: 'tabs-title',
    // contentClass: 'tabs-content',
    /**
     * Class applied to the content containers.
     * @option
     * @example 'tabs-panel'
     */
    panelClass: 'tabs-panel'
  };

  /**
   * Initializes the tabs by showing and focusing (if autoFocus=true) the preset active tab.
   * @private
   */
  Tabs.prototype._init = function(){
    var _this = this;

    this.$tabTitles = this.$element.find('.' + this.options.linkClass);
    this.$tabContent = $('[data-tabs-content="' + this.$element[0].id + '"]');

    this.$tabTitles.each(function(){
      var $elem = $(this),
          $link = $elem.find('a'),
          isActive = $elem.hasClass('is-active'),
          hash = $link.attr('href').slice(1),
          linkId = hash + '-label',
          $tabContent = $(hash);

      $elem.attr({'role': 'presentation'});

      $link.attr({
        'role': 'tab',
        'aria-controls': hash,
        'aria-selected': isActive,
        'id': linkId
      });

      $tabContent.attr({
        'role': 'tabpanel',
        'aria-hidden': !isActive,
        'aria-labelledby': linkId
      });

      if(isActive && _this.options.autoFocus){
        $link.focus();
      }
    });
    if(this.options.matchHeight){
      var $images = this.$tabContent.find('img');
      if($images.length){
        Foundation.onImagesLoaded($images, this._setHeight.bind(this));
      }else{
        this._setHeight();
      }
    }
    this._events();
  };
  /**
   * Adds event handlers for items within the tabs.
   * @private
   */
   Tabs.prototype._events = function(){
    this._addKeyHandler();
    this._addClickHandler();
    if(this.options.matchHeight){
      $(window).on('changed.zf.mediaquery', this._setHeight.bind(this));
    }
  };

  /**
   * Adds click handlers for items within the tabs.
   * @private
   */
  Tabs.prototype._addClickHandler = function(){
    var _this = this;
    this.$tabTitles.off('click.zf.tabs')
                   .on('click.zf.tabs', function(e){
                     e.preventDefault();
                     e.stopPropagation();
                     if($(this).hasClass('is-active')){
                       return;
                     }
                     _this._handleTabChange($(this));
                   });
  };

  /**
   * Adds keyboard event handlers for items within the tabs.
   * @private
   */
  Tabs.prototype._addKeyHandler = function(){
    var _this = this;
    var $firstTab = _this.$element.find('li:first-of-type');
    var $lastTab = _this.$element.find('li:last-of-type');

    this.$tabTitles.off('keydown.zf.tabs').on('keydown.zf.tabs', function(e){
      e.stopPropagation();
      e.preventDefault();

      var $element = $(this),
        $elements = $element.parent('ul').children('li'),
        $prevElement,
        $nextElement;

      $elements.each(function(i) {
        if ($(this).is($element)) {
          if (_this.options.wrapOnKeys) {
            $prevElement = i === 0 ? $elements.last() : $elements.eq(i-1);
            $nextElement = i === $elements.length -1 ? $elements.first() : $elements.eq(i+1);
          } else {
            $prevElement = $elements.eq(Math.max(0, i-1));
            $nextElement = $elements.eq(Math.min(i+1, $elements.length-1));
          }
          return;
        }
      });

      // handle keyboard event with keyboard util
      Foundation.Keyboard.handleKey(e, _this, {
        open: function() {
          $element.find('[role="tab"]').focus();
          _this._handleTabChange($element);
        },
        previous: function() {
          $prevElement.find('[role="tab"]').focus();
          _this._handleTabChange($prevElement);
        },
        next: function() {
          $nextElement.find('[role="tab"]').focus();
          _this._handleTabChange($nextElement);
        }
      });
    });
  };


  /**
   * Opens the tab `$targetContent` defined by `$target`.
   * @param {jQuery} $target - Tab to open.
   * @fires Tabs#change
   * @function
   */
  Tabs.prototype._handleTabChange = function($target){
    var $tabLink = $target.find('[role="tab"]'),
        hash = $tabLink.attr('href'),
        $targetContent = $(hash),

        $oldTab = this.$element.find('.' + this.options.linkClass + '.is-active')
                  .removeClass('is-active').find('[role="tab"]')
                  .attr({'aria-selected': 'false'}).attr('href');

    $($oldTab).removeClass('is-active').attr({'aria-hidden': 'true'});

    $target.addClass('is-active');

    $tabLink.attr({'aria-selected': 'true'});

    $targetContent
      .addClass('is-active')
      .attr({'aria-hidden': 'false'});

    /**
     * Fires when the plugin has successfully changed tabs.
     * @event Tabs#change
     */
    this.$element.trigger('change.zf.tabs', [$target]);
    // Foundation.reflow(this.$element, 'tabs');
  };

  /**
   * Public method for selecting a content pane to display.
   * @param {jQuery | String} elem - jQuery object or string of the id of the pane to display.
   * @function
   */
  Tabs.prototype.selectTab = function(elem){
    var idStr;
    if(typeof elem === 'object'){
      idStr = elem[0].id;
    }else{
      idStr = elem;
    }

    if(idStr.indexOf('#') < 0){
      idStr = '#' + idStr;
    }
    var $target = this.$tabTitles.find('[href="' + idStr + '"]').parent('.' + this.options.linkClass);

    this._handleTabChange($target);
  };
  /**
   * Sets the height of each panel to the height of the tallest panel.
   * If enabled in options, gets called on media query change.
   * If loading content via external source, can be called directly or with _reflow.
   * @function
   * @private
   */
  Tabs.prototype._setHeight = function(){
    var max = 0;
    this.$tabContent.find('.' + this.options.panelClass)
                    .css('height', '')
                    .each(function(){
                      var panel = $(this),
                          isActive = panel.hasClass('is-active');

                      if(!isActive){
                        panel.css({'visibility': 'hidden', 'display': 'block'});
                      }
                      var temp = this.getBoundingClientRect().height;

                      if(!isActive){
                        panel.css({'visibility': '', 'display': ''});
                      }

                      max = temp > max ? temp : max;
                    })
                    .css('height', max + 'px');
  };

  /**
   * Destroys an instance of an tabs.
   * @fires Tabs#destroyed
   */
  Tabs.prototype.destroy = function() {
    this.$element.find('.' + this.options.linkClass)
                 .off('.zf.tabs').hide().end()
                 .find('.' + this.options.panelClass)
                 .hide();
    if(this.options.matchHeight){
      $(window).off('changed.zf.mediaquery');
    }
    Foundation.unregisterPlugin(this);
  };

  Foundation.plugin(Tabs, 'Tabs');

  function checkClass($elem){
    return $elem.hasClass('is-active');
  }
}(jQuery, window.Foundation);

/**
 * Toggler module.
 * @module foundation.toggler
 * @requires foundation.util.motion
 */

!function(Foundation, $) {
  'use strict';

  /**
   * Creates a new instance of Toggler.
   * @class
   * @fires Toggler#init
   * @param {Object} element - jQuery object to add the trigger to.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  function Toggler(element, options) {
    this.$element = element;
    this.options = $.extend({}, Toggler.defaults, element.data(), options);
    this.className = '';

    this._init();
    this._events();

    Foundation.registerPlugin(this);
  }

  Toggler.defaults = {
    /**
     * Tells the plugin if the element should animated when toggled.
     * @option
     * @example false
     */
    animate: false
  };

  /**
   * Initializes the Toggler plugin by parsing the toggle class from data-toggler, or animation classes from data-animate.
   * @function
   * @private
   */
  Toggler.prototype._init = function() {
    var input;
    // Parse animation classes if they were set
    if (this.options.animate) {
      input = this.options.animate.split(' ');

      this.animationIn = input[0];
      this.animationOut = input[1] || null;
    }
    // Otherwise, parse toggle class
    else {
      input = this.$element.data('toggler');

      // Allow for a . at the beginning of the string
      if (input[0] === '.') {
        this.className = input.slice(1);
      }
      else {
        this.className = input;
      }
    }

    // Add ARIA attributes to triggers
    var id = this.$element[0].id;
    $('[data-open="'+id+'"], [data-close="'+id+'"], [data-toggle="'+id+'"]')
      .attr('aria-controls', id);

    // If the target is hidden, add aria-hidden
    if (this.$element.is(':hidden')) {
      this.$element.attr('aria-expanded', 'false');
    }
  };

  /**
   * Initializes events for the toggle trigger.
   * @function
   * @private
   */
  Toggler.prototype._events = function() {
    var _this = this;

    this.$element.on('toggle.zf.trigger', function() {
      _this.toggle();
      return false;
    });
  };

  /**
   * Toggles the target class on the target element. An event is fired from the original trigger depending on if the resultant state was "on" or "off".
   * @function
   * @fires Toggler#on
   * @fires Toggler#off
   */
  Toggler.prototype.toggle = function() {
    if (!this.options.animate) {
      this._toggleClass();
    }
    else {
      this._toggleAnimate();
    }
  };

  Toggler.prototype._toggleClass = function() {
    var _this = this;
    this.$element.toggleClass(this.className);

    if (this.$element.hasClass(this.className)) {
      /**
       * Fires if the target element has the class after a toggle.
       * @event Toggler#on
       */
      this.$element.trigger('on.zf.toggler');
    }
    else {
      /**
       * Fires if the target element does not have the class after a toggle.
       * @event Toggler#off
       */
      this.$element.trigger('off.zf.toggler');
    }

    _this._updateARIA();
  };

  Toggler.prototype._toggleAnimate = function() {
    var _this = this;

    if (this.$element.is(':hidden')) {
      Foundation.Motion.animateIn(this.$element, this.animationIn, function() {
        this.trigger('on.zf.toggler');
        _this._updateARIA();
      });
    }
    else {
      Foundation.Motion.animateOut(this.$element, this.animationOut, function() {
        this.trigger('off.zf.toggler');
        _this._updateARIA();
      });
    }
  };

  Toggler.prototype._updateARIA = function() {
    if (this.$element.is(':hidden')) {
      this.$element.attr('aria-expanded', 'false');
    }
    else {
      this.$element.attr('aria-expanded', 'true');
    }
  };

  /**
   * Destroys the instance of Toggler on the element.
   * @function
   */
  Toggler.prototype.destroy= function() {
    this.$element.off('.zf.toggler');
    Foundation.unregisterPlugin(this);
  };

  Foundation.plugin(Toggler, 'Toggler');

  // Exports for AMD/Browserify
  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined')
    module.exports = Toggler;
  if (typeof define === 'function')
    define(['foundation'], function() {
      return Toggler;
    });

}(Foundation, jQuery);

/**
 * Tooltip module.
 * @module foundation.tooltip
 * @requires foundation.util.box
 * @requires foundation.util.triggers
 */
!function($, document, Foundation){
  'use strict';

  /**
   * Creates a new instance of a Tooltip.
   * @class
   * @fires Tooltip#init
   * @param {jQuery} element - jQuery object to attach a tooltip to.
   * @param {Object} options - object to extend the default configuration.
   */
  function Tooltip(element, options){
    this.$element = element;
    this.options = $.extend({}, Tooltip.defaults, this.$element.data(), options);

    this.isActive = false;
    this.isClick = false;
    this._init();

    Foundation.registerPlugin(this);
  }

  Tooltip.defaults = {
    disableForTouch: false,
    /**
     * Time, in ms, before a tooltip should open on hover.
     * @option
     * @example 200
     */
    hoverDelay: 200,
    /**
     * Time, in ms, a tooltip should take to fade into view.
     * @option
     * @example 150
     */
    fadeInDuration: 150,
    /**
     * Time, in ms, a tooltip should take to fade out of view.
     * @option
     * @example 150
     */
    fadeOutDuration: 150,
    /**
     * Disables hover events from opening the tooltip if set to true
     * @option
     * @example false
     */
    disableHover: false,
    /**
     * Optional addtional classes to apply to the tooltip template on init.
     * @option
     * @example 'my-cool-tip-class'
     */
    templateClasses: '',
    /**
     * Non-optional class added to tooltip templates. Foundation default is 'tooltip'.
     * @option
     * @example 'tooltip'
     */
    tooltipClass: 'tooltip',
    /**
     * Class applied to the tooltip anchor element.
     * @option
     * @example 'has-tip'
     */
    triggerClass: 'has-tip',
    /**
     * Minimum breakpoint size at which to open the tooltip.
     * @option
     * @example 'small'
     */
    showOn: 'small',
    /**
     * Custom template to be used to generate markup for tooltip.
     * @option
     * @example '<div class="tooltip"></div>'
     */
    template: '',
    /**
     * Text displayed in the tooltip template on open.
     * @option
     * @example 'Some cool space fact here.'
     */
    tipText: '',
    touchCloseText: 'Tap to close.',
    /**
     * Allows the tooltip to remain open if triggered with a click or touch event.
     * @option
     * @example true
     */
    clickOpen: true,
    /**
     * Additional positioning classes, set by the JS
     * @option
     * @example 'top'
     */
    positionClass: '',
    /**
     * Distance, in pixels, the template should push away from the anchor on the Y axis.
     * @option
     * @example 10
     */
    vOffset: 10,
    /**
     * Distance, in pixels, the template should push away from the anchor on the X axis, if aligned to a side.
     * @option
     * @example 12
     */
    hOffset: 12
  };

  /**
   * Initializes the tooltip by setting the creating the tip element, adding it's text, setting private variables and setting attributes on the anchor.
   * @private
   */
  Tooltip.prototype._init = function(){
    var elemId = this.$element.attr('aria-describedby') || Foundation.GetYoDigits(6, 'tooltip');

    this.options.positionClass = this._getPositionClass(this.$element);
    this.options.tipText = this.options.tipText || this.$element.attr('title');
    this.template = this.options.template ? $(this.options.template) : this._buildTemplate(elemId);

    this.template.appendTo(document.body)
        .text(this.options.tipText)
        .hide();

    this.$element.attr({
      'title': '',
      'aria-describedby': elemId,
      'data-yeti-box': elemId,
      'data-toggle': elemId,
      'data-resize': elemId
    }).addClass(this.triggerClass);

    //helper variables to track movement on collisions
    this.usedPositions = [];
    this.counter = 4;
    this.classChanged = false;

    this._events();
  };

  /**
   * Grabs the current positioning class, if present, and returns the value or an empty string.
   * @private
   */
  Tooltip.prototype._getPositionClass = function(element){
    if(!element){ return ''; }
    // var position = element.attr('class').match(/top|left|right/g);
    var position = element[0].className.match(/(top|left|right)/g);
        position = position ? position[0] : '';
    return position;
  };
  /**
   * builds the tooltip element, adds attributes, and returns the template.
   * @private
   */
  Tooltip.prototype._buildTemplate = function(id){
    var templateClasses = (this.options.tooltipClass + ' ' + this.options.positionClass).trim();
    var $template =  $('<div></div>').addClass(templateClasses).attr({
      'role': 'tooltip',
      'aria-hidden': true,
      'data-is-active': false,
      'data-is-focus': false,
      'id': id
    });
    return $template;
  };

  /**
   * Function that gets called if a collision event is detected.
   * @param {String} position - positioning class to try
   * @private
   */
  Tooltip.prototype._reposition = function(position){
    this.usedPositions.push(position ? position : 'bottom');

    //default, try switching to opposite side
    if(!position && (this.usedPositions.indexOf('top') < 0)){
      this.template.addClass('top');
    }else if(position === 'top' && (this.usedPositions.indexOf('bottom') < 0)){
      this.template.removeClass(position);
    }else if(position === 'left' && (this.usedPositions.indexOf('right') < 0)){
      this.template.removeClass(position)
          .addClass('right');
    }else if(position === 'right' && (this.usedPositions.indexOf('left') < 0)){
      this.template.removeClass(position)
          .addClass('left');
    }

    //if default change didn't work, try bottom or left first
    else if(!position && (this.usedPositions.indexOf('top') > -1) && (this.usedPositions.indexOf('left') < 0)){
      this.template.addClass('left');
    }else if(position === 'top' && (this.usedPositions.indexOf('bottom') > -1) && (this.usedPositions.indexOf('left') < 0)){
      this.template.removeClass(position)
          .addClass('left');
    }else if(position === 'left' && (this.usedPositions.indexOf('right') > -1) && (this.usedPositions.indexOf('bottom') < 0)){
      this.template.removeClass(position);
    }else if(position === 'right' && (this.usedPositions.indexOf('left') > -1) && (this.usedPositions.indexOf('bottom') < 0)){
      this.template.removeClass(position);
    }
    //if nothing cleared, set to bottom
    else{
      this.template.removeClass(position);
    }
    this.classChanged = true;
    this.counter--;

  };

  /**
   * sets the position class of an element and recursively calls itself until there are no more possible positions to attempt, or the tooltip element is no longer colliding.
   * if the tooltip is larger than the screen width, default to full width - any user selected margin
   * @private
   */
  Tooltip.prototype._setPosition = function(){
    var position = this._getPositionClass(this.template),
        $tipDims = Foundation.Box.GetDimensions(this.template),
        $anchorDims = Foundation.Box.GetDimensions(this.$element),
        direction = (position === 'left' ? 'left' : ((position === 'right') ? 'left' : 'top')),
        param = (direction === 'top') ? 'height' : 'width',
        offset = (param === 'height') ? this.options.vOffset : this.options.hOffset,
        _this = this;

    if(($tipDims.width >= $tipDims.windowDims.width) || (!this.counter && !Foundation.Box.ImNotTouchingYou(this.template))){
      this.template.offset(Foundation.Box.GetOffsets(this.template, this.$element, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({
      // this.$element.offset(Foundation.GetOffsets(this.template, this.$element, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({
        'width': $anchorDims.windowDims.width - (this.options.hOffset * 2),
        'height': 'auto'
      });
      return false;
    }

    this.template.offset(Foundation.Box.GetOffsets(this.template, this.$element,'center ' + (position || 'bottom'), this.options.vOffset, this.options.hOffset));

    while(!Foundation.Box.ImNotTouchingYou(this.template) && this.counter){
      this._reposition(position);
      this._setPosition();
    }
  };

  /**
   * reveals the tooltip, and fires an event to close any other open tooltips on the page
   * @fires Closeme#tooltip
   * @fires Tooltip#show
   * @function
   */
  Tooltip.prototype.show = function(){
    if(this.options.showOn !== 'all' && !Foundation.MediaQuery.atLeast(this.options.showOn)){
      // console.error('The screen is too small to display this tooltip');
      return false;
    }

    var _this = this;
    this.template.css('visibility', 'hidden').show();
    this._setPosition();

    /**
     * Fires to close all other open tooltips on the page
     * @event Closeme#tooltip
     */
    this.$element.trigger('closeme.zf.tooltip', this.template.attr('id'));


    this.template.attr({
      'data-is-active': true,
      'aria-hidden': false
    });
    _this.isActive = true;
    // console.log(this.template);
    this.template.stop().hide().css('visibility', '').fadeIn(this.options.fadeInDuration, function(){
      //maybe do stuff?
    });
    /**
     * Fires when the tooltip is shown
     * @event Tooltip#show
     */
    this.$element.trigger('show.zf.tooltip');
  };

  /**
   * Hides the current tooltip, and resets the positioning class if it was changed due to collision
   * @fires Tooltip#hide
   * @function
   */
  Tooltip.prototype.hide = function(){
    // console.log('hiding', this.$element.data('yeti-box'));
    var _this = this;
    this.template.stop().attr({
      'aria-hidden': true,
      'data-is-active': false
    }).fadeOut(this.options.fadeOutDuration, function(){
      _this.isActive = false;
      _this.isClick = false;
      if(_this.classChanged){
        _this.template
             .removeClass(_this._getPositionClass(_this.template))
             .addClass(_this.options.positionClass);

       _this.usedPositions = [];
       _this.counter = 4;
       _this.classChanged = false;
      }
    });
    /**
     * fires when the tooltip is hidden
     * @event Tooltip#hide
     */
    this.$element.trigger('hide.zf.tooltip');
  };

  /**
   * adds event listeners for the tooltip and its anchor
   * TODO combine some of the listeners like focus and mouseenter, etc.
   * @private
   */
  Tooltip.prototype._events = function(){
    var _this = this;
    var $template = this.template;
    var isFocus = false;

    if(!this.options.disableHover){

      this.$element
      .on('mouseenter.zf.tooltip', function(e){
        if(!_this.isActive){
          _this.timeout = setTimeout(function(){
            _this.show();
          }, _this.options.hoverDelay);
        }
      })
      .on('mouseleave.zf.tooltip', function(e){
        clearTimeout(_this.timeout);
        if(!isFocus || (!_this.isClick && _this.options.clickOpen)){
          _this.hide();
        }
      });
    }
    if(this.options.clickOpen){
      this.$element.on('mousedown.zf.tooltip', function(e){
        e.stopImmediatePropagation();
        if(_this.isClick){
          _this.hide();
          // _this.isClick = false;
        }else{
          _this.isClick = true;
          if((_this.options.disableHover || !_this.$element.attr('tabindex')) && !_this.isActive){
            _this.show();
          }
        }
      });
    }

    if(!this.options.disableForTouch){
      this.$element
      .on('tap.zf.tooltip touchend.zf.tooltip', function(e){
        _this.isActive ? _this.hide() : _this.show();
      });
    }

    this.$element.on({
      // 'toggle.zf.trigger': this.toggle.bind(this),
      // 'close.zf.trigger': this.hide.bind(this)
      'close.zf.trigger': this.hide.bind(this)
    });

    this.$element
      .on('focus.zf.tooltip', function(e){
        isFocus = true;
        console.log(_this.isClick);
        if(_this.isClick){
          return false;
        }else{
          // $(window)
          _this.show();
        }
      })

      .on('focusout.zf.tooltip', function(e){
        isFocus = false;
        _this.isClick = false;
        _this.hide();
      })

      .on('resizeme.zf.trigger', function(){
        if(_this.isActive){
          _this._setPosition();
        }
      });
  };
  /**
   * adds a toggle method, in addition to the static show() & hide() functions
   * @function
   */
  Tooltip.prototype.toggle = function(){
    if(this.isActive){
      this.hide();
    }else{
      this.show();
    }
  };
  /**
   * Destroys an instance of tooltip, removes template element from the view.
   * @function
   */
  Tooltip.prototype.destroy = function(){
    this.$element.attr('title', this.template.text())
                 .off('.zf.trigger .zf.tootip')
                //  .removeClass('has-tip')
                 .removeAttr('aria-describedby')
                 .removeAttr('data-yeti-box')
                 .removeAttr('data-toggle')
                 .removeAttr('data-resize');

    this.template.remove();

    Foundation.unregisterPlugin(this);
  };
  /**
   * TODO utilize resize event trigger
   */

  Foundation.plugin(Tooltip, 'Tooltip');
}(jQuery, window.document, window.Foundation);

/*              
 * ChartNew.js  
 *                                                                                   
 * Vancoppenolle Francois - January 2014                                                                               
 * francois.vancoppenolle@favomo.be                                     
 *
 * GitHub community : https://github.com/FVANCOP/ChartNew.js
 *
 * This file is originally an adaptation of the chart.js source developped by Nick Downie (2013)
 * https://github.com/nnnick/Chart.js. But since june 2014, Nick puts a new version with a
 * refunded code. Current code of ChartNew.js is no more comparable to the code of Chart.js 
 *
 * new charts compared to Chart.js
 *
 *     horizontalBar
 *     horizontalStackedBar
 *
 * Added items compared to Chart.js:
 *
 *     Title, Subtitle, footnotes, axis labels, unit label
 *     Y Axis on the right and/or the left
 *     canvas Border
 *     Legend
 *     crossText, crossImage
 *     graphMin, graphMax
 *     logarithmic y-axis (for line and bar)
 *     rotateLabels
 *     and lot of others...
 *
 */

// ctx.firstPass=0 or "undefined" : Chart has never been drawn (because dynamicDisplay = true and ctx has never been displayed in current screen)
// ctx.firstPass=1 : Chart has to be drawn with animation (if config.animation = true);
// ctx.firstPass=2 : chart has to be drawn without animation;
// ctx.firstPass=9 : chart is completely drawn;
// If chartJsResize called : increment the value of ctx.firstPass with a value of 10.


// non standard functions;

var chartJSLineStyle=[];
chartJSLineStyle["solid"]=[];
chartJSLineStyle["dotted"]=[1,4];
chartJSLineStyle["shortDash"]=[2,1];
chartJSLineStyle["dashed"]=[4,2];
chartJSLineStyle["dashSpace"]=[4,6];
chartJSLineStyle["longDashDot"]=[7,2,1,2];
chartJSLineStyle["longDashShortDash"]=[10,4,4,4];
chartJSLineStyle["gradient"]=[1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,9,9,8,8,7,7,6,6,5,5,4,4,3,3,2,2,1];

function lineStyleFn(data)
{
if ((typeof chartJSLineStyle[data]) === "object")return chartJSLineStyle[data];
else return chartJSLineStyle["solid"];
};

if (typeof String.prototype.trim !== 'function') {
	String.prototype.trim = function() {
		return this.replace(/^\s+|\s+$/g, '');
	}
};
if (!Array.prototype.indexOf) {
	Array.prototype.indexOf = function(searchElement /*, fromIndex */ ) {
		"use strict";
		if (this == null) {
			throw new TypeError();
		}
		var t = Object(this);
		var len = t.length >>> 0;
		if (len === 0) {
			return -1;
		}
		var n = 0;
		if (arguments.length > 0) {
			n = Number(arguments[1]);
			if (n != n) { // shortcut for verifying if it's NaN
				n = 0;
			} else if (n != 0 && n != Infinity && n != -Infinity) {
				n = (n > 0 || -1) * Math.floor(Math.abs(n));
			}
		}
		if (n >= len) {
			return -1;
		}
		var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
		for (; k < len; k++) {
			if (k in t && t[k] === searchElement) {
				return k;
			}
		}
		return -1;
	}
};
var charJSPersonalDefaultOptions = {};
var charJSPersonalDefaultOptionsLine = {} ;
var charJSPersonalDefaultOptionsRadar = {} ;
var charJSPersonalDefaultOptionsPolarArea = {} ;
var charJSPersonalDefaultOptionsPie = {};
var charJSPersonalDefaultOptionsDoughnut = {};
var charJSPersonalDefaultOptionsBar = {};
var charJSPersonalDefaultOptionsStackedBar = {};
var charJSPersonalDefaultOptionsHorizontalBar = {};
var charJSPersonalDefaultOptionsHorizontalStackedBar = {};
	///////// FUNCTIONS THAN CAN BE USED IN THE TEMPLATES ///////////////////////////////////////////

function roundToWithThousands(config, num, place) {
	var newval = 1 * unFormat(config, num);
	if (typeof(newval) == "number" && place != "none") {
		var roundVal;
		if (place <= 0) {
			roundVal = -place;
			newval = +(Math.round(newval + "e+" + roundVal) + "e-" + roundVal);
		} else {
			roundVal = place;
			var divval = "1e+" + roundVal;
			newval = +(Math.round(newval / divval)) * divval;
		}
	}
	newval = fmtChartJS(config, newval, "none");
	return (newval);
};

function unFormat(config, num) {
	if ((config.decimalSeparator != "." || config.thousandSeparator != "") && typeof(num) == "string") {
		var v1 = "" + num;
		if (config.thousandSeparator != "") {
			while (v1.indexOf(config.thousandSeparator) >= 0) v1 = "" + v1.replace(config.thousandSeparator, "");
		}
		if (config.decimalSeparator != ".") v1 = "" + v1.replace(config.decimalSeparator, ".")
		return 1 * v1;
	} else {
		return num;
	}
};
///////// ANNOTATE PART OF THE SCRIPT ///////////////////////////////////////////
/********************************************************************************
Copyright (C) 1999 Thomas Brattli
This script is made by and copyrighted to Thomas Brattli
Visit for more great scripts. This may be used freely as long as this msg is intact!
I will also appriciate any links you could give me.
Distributed by Hypergurl
********************************************************************************/
var cachebis = {};

function fmtChartJSPerso(config, value, fmt) {
	switch (fmt) {
		case "SampleJS_Format":
			if (typeof(value) == "number") return_value = "My Format : " + value.toString() + " $";
			else return_value = value + "XX";
			break;
		case "Change_Month":
			if (typeof(value) == "string") return_value = value.toString() + " 2014";
			else return_value = value.toString() + "YY";
			break;
		default:
			return_value = value;
			break;
	}
	return (return_value);
};

function fmtChartJS(config, value, fmt) {
	var return_value;
	if (fmt == "notformatted") {
		return_value = value;
	} else if ((fmt == "none" || fmt=="money") && typeof(value) == "number") {
		if (config.roundNumber != "none") {
			var roundVal;
			if (config.roundNumber <= 0) {
				roundVal = -config.roundNumber;
				value = +(Math.round(value + "e+" + roundVal) + "e-" + roundVal);
			} else {
				roundVal = config.roundNumber;
				var divval = "1e+" + roundVal;
				value = +(Math.round(value / divval)) * divval;
			}
		}
		if (config.decimalSeparator != "." || config.thousandSeparator != "") {
			return_value = value.toString().replace(/\./g, config.decimalSeparator);
			if (config.thousandSeparator != "") {
				var part1 = return_value;
				var part2 = "";
				var posdec = part1.indexOf(config.decimalSeparator);
				if (posdec >= 0) {
					part2 = part1.substring(posdec + 1, part1.length);
					part2 = part2.split('').reverse().join(''); // reverse string
					part1 = part1.substring(0, posdec);
				}
				part1 = part1.toString().replace(/\B(?=(\d{3})+(?!\d))/g, config.thousandSeparator);
				part2 = part2.split('').reverse().join(''); // reverse string
				return_value = part1
				if (part2 != "") return_value = return_value + config.decimalSeparator + part2;
			}
		} else return_value = value;
		if(fmt=="money") {
			if(config.currencyPosition=="before")return_value=config.currency+return_value;
			else return_value=return_value+config.currency;
		}
	} else if (fmt != "none" && fmt != "notformatted") {
		return_value = fmtChartJSPerso(config, value, fmt);
	} else {
		return_value = value;
	}
	return (return_value);
};

function addParameters2Function(data, fctName, fctList) {
	var mathFunctions = {
		mean: {
			data: data.data,
			datasetNr: data.v11
		},
		varianz: {
			data: data.data,
			datasetNr: data.v11
		},
		stddev: {
			data: data.data,
			datasetNr: data.v11
		},
		cv: {
			data: data.data,
			datasetNr: data.v11
		},
		median: {
			data: data.data,
			datasetNr: data.v11
		}
	};
	// difference to current value (v3)
	dif = false;
	if (fctName.substr(-3) == "Dif") {
		fctName = fctName.substr(0, fctName.length - 3);
		dif = true;
	}
	if (typeof eval(fctName) == "function") {
		var parameter = eval(fctList + "." + fctName);
		if (dif) {
			// difference between v3 (current value) and math function
			return data.v3 - window[fctName](parameter);
		}
		return window[fctName](parameter);
	}
	return null;
};

function isNumber(n) {
	return !isNaN(parseFloat(n)) && isFinite(n);
};

function tmplbis(str, data,config) {
	newstr=str;
	if(newstr.substr(0,config.templatesOpenTag.length)==config.templatesOpenTag)newstr="<%="+newstr.substr(config.templatesOpenTag.length,newstr.length-config.templatesOpenTag.length);
	if(newstr.substr(newstr.length-config.templatesCloseTag.length,config.templatesCloseTag.length)==config.templatesCloseTag)newstr=newstr.substr(0,newstr.length-config.templatesCloseTag.length)+"%>";
	return tmplter(newstr,data);
}

function tmplter(str, data) {
	var mathFunctionList = ["mean", "varianz", "stddev", "cv", "median"];
	var regexMath = new RegExp('<%=((?:(?:.*?)\\W)??)((?:' + mathFunctionList.join('|') + ')(?:Dif)?)\\(([0-9]*?)\\)(.*?)%>', 'g');
	while (regexMath.test(str)) {
		str = str.replace(regexMath, function($0, $1, $2, $3, $4) {
			var rndFac;
			if ($3) rndFac = $3;
			else rndFac = 2;
			var value = addParameters2Function(data, $2, "mathFunctions");
			if (isNumber(value)) 
				return '<%=' + $1 + '' + Math.round(Math.pow(10, rndFac) * value) / Math.pow(10, rndFac) + '' + $4 + '%>';
			return '<%= %>';
		});
	}
	// Figure out if we're getting a template, or if we need to
	// load the template - and be sure to cache the result.
	// first check if it's can be an id
	var fn = /^[A-Za-z][-A-Za-z0-9_:.]*$/.test(str) ? cachebis[str] = cachebis[str] ||
		tmplter(document.getElementById(str).innerHTML) :
		// Generate a reusable function that will serve as a template
		// generator (and which will be cached).
		new Function("obj",
			"var p=[],print=function(){p.push.apply(p,arguments);};" +
			// Introduce the data as local variables using with(){}
			"with(obj){p.push('" +
			// Convert the template into pure JavaScript
			str
			.replace(/[\r\n]/g, "\\n")
			.replace(/[\t]/g, " ")
			.split("<%").join("\t")
			.replace(/((^|%>)[^\t]*)'/g, "$1\r")
			.replace(/\t=(.*?)%>/g, "',$1,'")
			.split("\t").join("');")
			.split("%>").join("p.push('")
			.split("\r").join("\\'") + "');}return p.join('');");
	// Provide some basic currying to the user
	return data ? fn(data) : fn;
};
if (typeof CanvasRenderingContext2D !== 'undefined') {
	/**
	 * ctx.prototype
	 * fillText option for canvas Multiline Support
	 * @param text string \n for newline
	 * @param x x position
	 * @param y y position
	 * @param yLevel = "bottom" => last line has this y-Pos [default], = "middle" => the middle line has this y-Pos)
	 * @param lineHeight lineHeight
	 * @param horizontal horizontal
	 */
	CanvasRenderingContext2D.prototype.fillTextMultiLine = function(text, x, y, yLevel, lineHeight,horizontal,detectMouseOnText,ctx,idText,rotate,x_decal,y_decal,posi,posj) {
		var lines = ("" + text).split("\n");
		// if its one line => in the middle 
		// two lines one above the mid one below etc.	
		if (yLevel == "middle") {
			if(horizontal)y -= ((lines.length - 1) / 2) * lineHeight;
		} else if (yLevel == "bottom") { // default
			if(horizontal)y -= (lines.length - 1) * lineHeight;
		}

		var y_pos=y-lineHeight;

		for (var i = 0; i < lines.length; i++) {
			this.fillText(lines[i], x, y);
			y += lineHeight;
		}
		if(detectMouseOnText) {
			var txtSize=ctx.measureTextMultiLine(text,lineHeight);
			var x_pos=[];
			var y_pos=[];
			x_pos.p1=x_decal+x;
			y_pos.p1=y_decal+y-lineHeight;
			var rotateRV=(Math.PI/2)+rotate;
			       if(ctx.textAlign=="left" && yLevel=="top"){
				x_pos.p1+=lineHeight*Math.cos(rotateRV);
				y_pos.p1+=lineHeight*Math.sin(rotateRV);
			} else if(ctx.textAlign=="left" && yLevel=="middle"){
				x_pos.p1+=(lineHeight/2)*Math.cos(rotateRV);
				y_pos.p1+=(lineHeight/2)*Math.sin(rotateRV);
			} else if(ctx.textAlign=="left" && yLevel=="bottom"){
			       // nothing to adapt;
			} else if(ctx.textAlign=="center" && yLevel=="top"){
				x_pos.p1+=lineHeight*Math.cos(rotateRV)-(txtSize.textWidth/2)*Math.cos(rotate);
				y_pos.p1+=lineHeight*Math.sin(rotateRV)-(txtSize.textWidth/2)*Math.sin(rotate);
			} else if(ctx.textAlign=="center" && yLevel=="middle"){
				x_pos.p1+=(lineHeight/2)*Math.cos(rotateRV)-(txtSize.textWidth/2)*Math.cos(rotate);
				y_pos.p1+=(lineHeight/2)*Math.sin(rotateRV)-(txtSize.textWidth/2)*Math.sin(rotate);
			} else if(ctx.textAlign=="center" && yLevel=="bottom"){
				x_pos.p1-=(txtSize.textWidth/2)*Math.cos(rotate);
				y_pos.p1-=(txtSize.textWidth/2)*Math.sin(rotate);
			} else if(ctx.textAlign=="right" && yLevel=="top"){
				x_pos.p1+=(lineHeight*Math.cos(rotateRV)-txtSize.textWidth*Math.cos(rotate));
				y_pos.p1+=(lineHeight*Math.sin(rotateRV)-txtSize.textWidth*Math.sin(rotate));
			} else if(ctx.textAlign=="right" && yLevel=="middle"){
				x_pos.p1+=(lineHeight/2)*Math.cos(rotateRV)-txtSize.textWidth*Math.cos(rotate);
				y_pos.p1+=(lineHeight/2)*Math.sin(rotateRV)-txtSize.textWidth*Math.sin(rotate);
			} else if(ctx.textAlign=="right" && yLevel=="bottom"){
				x_pos.p1-=txtSize.textWidth*Math.cos(rotate);
				y_pos.p1-=txtSize.textWidth*Math.sin(rotate);
			} 

			// Other corners of the rectangle;
			
			x_pos.p2=x_pos.p1+txtSize.textWidth*Math.cos(rotate);
			y_pos.p2=y_pos.p1+txtSize.textWidth*Math.sin(rotate);
			
			x_pos.p3=x_pos.p1-lineHeight*Math.cos(rotateRV);
			y_pos.p3=y_pos.p1-lineHeight*Math.sin(rotateRV);
			
			x_pos.p4=x_pos.p3+txtSize.textWidth*Math.cos(rotate);
			y_pos.p4=y_pos.p3+txtSize.textWidth*Math.sin(rotate);

			jsTextMousePos[ctx.ChartNewId][jsTextMousePos[ctx.ChartNewId].length] = [idText,text,x_pos,y_pos,rotate,txtSize.textWidth,txtSize.textHeight,posi,posj];
						
		}	
	};
	CanvasRenderingContext2D.prototype.measureTextMultiLine = function(text, lineHeight) {
		var textWidth = 0;
		var lg;
		var lines = ("" + text).replace(/<BR>/ig, "\n").split("\n");
		var textHeight = lines.length * lineHeight;
		// if its one line => in the middle 
		// two lines one above the mid one below etc.	
		for (var i = 0; i < lines.length; i++) {
			lg = this.measureText(lines[i]).width;
			if (lg > textWidth) textWidth = lg;
		}
		return {
			textWidth: textWidth,
			textHeight: 1.5*textHeight
		};
	};
	if (typeof CanvasRenderingContext2D.prototype.setLineDash !== 'function') {
		CanvasRenderingContext2D.prototype.setLineDash = function( listdash) {
			return 0;
		};
	};
	
	CanvasRenderingContext2D.prototype.drawRectangle = function(TheRectangle){
		//this.shadowColor = '#999';
     		// this.shadowBlur = 5;
	    	// this.shadowOffsetX = 15;
     		//this.shadowOffsetY = 15;
		originalfillStyle =this.fillStyle;
    		if(typeof TheRectangle.x=='undefined'){TheRectangle.x=0}
      		if(TheRectangle.width<0){TheRectangle.x+=TheRectangle.width;TheRectangle.width*=-1}
        	if(TheRectangle.height<0){TheRectangle.y+=TheRectangle.height;TheRectangle.height*=-1}
    		if(typeof TheRectangle.y=='undefined'){TheRectangle.y=0}
  		if(typeof TheRectangle.y=='undefined'){TheRectangle.y=0}
  		if(typeof TheRectangle.backgroundColor!='undefined'){this.fillStyle=TheRectangle.backgroundColor}
  		if(typeof TheRectangle.borderRadius=='undefined'){TheRectangle.borderRadius=0}
  
  		if(TheRectangle.borderRadius==0 && TheRectangle.fill==true){this.fillRect(TheRectangle.x,TheRectangle.y,TheRectangle.width,TheRectangle.height);}
    		if(TheRectangle.borderRadius==0 && TheRectangle.stroke==true){this.strokeRect(TheRectangle.x,TheRectangle.y,TheRectangle.width,TheRectangle.height);}
    		if(TheRectangle.borderRadius!=0){
      			rectangleRadius=parseInt(TheRectangle.borderRadius);
      			if(rectangleRadius>TheRectangle.width/2 ){rectangleRadius=TheRectangle.width/2}
      			if(TheRectangle.height<TheRectangle.width &&rectangleRadius>TheRectangle.height/2 ){rectangleRadius=TheRectangle.height/2}
      			this.beginPath();
      			this.moveTo(TheRectangle.x+rectangleRadius,TheRectangle.y);
      			this.lineTo(TheRectangle.x+TheRectangle.width-rectangleRadius,TheRectangle.y);
     			this.arc(TheRectangle.x+TheRectangle.width-rectangleRadius,TheRectangle.y+rectangleRadius,rectangleRadius,1.5*Math.PI,0); 
      			this.lineTo(TheRectangle.x+TheRectangle.width,TheRectangle.y+TheRectangle.height-rectangleRadius);
    			this.arc(TheRectangle.x+TheRectangle.width-rectangleRadius,TheRectangle.y+TheRectangle.height-rectangleRadius,rectangleRadius,0,0.5*Math.PI); 
     			this.lineTo(TheRectangle.x+rectangleRadius,TheRectangle.y+TheRectangle.height);
       			this.arc(TheRectangle.x+rectangleRadius,TheRectangle.y+TheRectangle.height-rectangleRadius,rectangleRadius,0.5*Math.PI,1*Math.PI); 
       			this.lineTo(TheRectangle.x,TheRectangle.y+rectangleRadius);
       			this.arc(TheRectangle.x+rectangleRadius,TheRectangle.y+rectangleRadius,rectangleRadius,1*Math.PI,1.5*Math.PI); 
	   		this.closePath();
    			if(TheRectangle.fill==true) {this.fill()};
      			if(TheRectangle.stroke==true) {this.stroke()};
	    	} 
 		this.fillStyle= originalfillStyle;
		return this;
	};
};

cursorDivCreated = false;

function createCursorDiv() {
	if (cursorDivCreated == false) {
		var div = document.createElement('divCursor');
		div.id = 'divCursor';
		div.style.position = 'absolute';
		document.body.appendChild(div);
		cursorDivCreated = true;
	}
};

initChartJsResize = false;
var jsGraphResize = new Array();

function addResponsiveChart(id,ctx,data,config) {
	if(initChartJsResize==false) {
		if (window.addEventListener) {
			window.addEventListener("resize", chartJsResize);
		} else {
			window.attachEvent("resize", chartJsResize);
		}
	}
	jsGraphResize[jsGraphResize.length]= [id,ctx.tpchart,ctx,data,config];
};


var container;
function getMaximumWidth(domNode){
    if(domNode.parentNode!=null)
        if(domNode.parentNode!=undefined)
            container = domNode.parentNode;
    return container.clientWidth;
};

function getMaximumHeight(domNode){
	if(domNode.parentNode!=null)
            if(domNode.parentNode!=undefined)
                container = domNode.parentNode;
	return container.clientHeight;
};

function resizeCtx(ctx,config)
{
	if (isIE() < 9 && isIE() != false) return(true);

	if(config.responsive) {	
		if(typeof config.maintainAspectRatio == "undefined")config.maintainAspectRatio=true;
		if(typeof config.responsiveMinWidth == "undefined")config.responsiveMinWidth=0;
		if(typeof config.responsiveMinHeight  == "undefined")config.responsiveMinHeight=0;
		if(typeof config.responsiveMaxWidth  == "undefined")config.responsiveMaxWidth=9999999;
		if(typeof config.responsiveMaxHeight  == "undefined")config.responsiveMaxHeight=9999999;
		var canvas = ctx.canvas;
		if(typeof ctx.aspectRatio == "undefined") {
			ctx.aspectRatio = canvas.width / canvas.height;
		}
  		var newWidth = getMaximumWidth(canvas);
		var newHeight = config.maintainAspectRatio ? newWidth / ctx.aspectRatio : getMaximumHeight(canvas);
		newWidth=Math.min(config.responsiveMaxWidth,Math.max(config.responsiveMinWidth,newWidth));
		newHeight=Math.min(config.responsiveMaxHeight,Math.max(config.responsiveMinHeight,newHeight));

		if(typeof ctx.DefaultchartTextScale=="undefined")ctx.DefaultchartTextScale=config.chartTextScale;
		if(typeof ctx.DefaultchartLineScale=="undefined")ctx.DefaultchartLineScale=config.chartLineScale;
		if(typeof ctx.DefaultchartSpaceScale=="undefined")ctx.DefaultchartSpaceScale=config.chartSpaceScale;
		/* new ratio */
		if(typeof ctx.chartTextScale != "undefined" && config.responsiveScaleContent) {
			ctx.chartTextScale=ctx.DefaultchartTextScale*(newWidth/ctx.initialWidth);
			ctx.chartLineScale=ctx.DefaultchartLineScale*(newWidth/ctx.initialWidth);
			ctx.chartSpaceScale=ctx.DefaultchartSpaceScale*(newWidth/ctx.initialWidth);
		}
		
		if (window.devicePixelRatio>1) {
			ctx.canvas.style.width = newWidth + "px";
			ctx.canvas.style.height = newHeight + "px";
		}
		ctx.canvas.height = newHeight * Math.max(1,window.devicePixelRatio);
		ctx.canvas.width = newWidth * Math.max(1,window.devicePixelRatio);
		ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
	} else if (window.devicePixelRatio>1) {
		if(typeof ctx.original_width=="undefined") {
			ctx.original_width=ctx.canvas.width;
			ctx.original_height=ctx.canvas.height;
		}
		ctx.canvas.style.width = ctx.original_width + "px";
		ctx.canvas.style.height = ctx.original_height + "px";
		ctx.canvas.height = ctx.original_height * window.devicePixelRatio;
		ctx.canvas.width = ctx.original_width * window.devicePixelRatio;
		ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
	}
};




function chartJsResize() {
	for (var i=0;i<jsGraphResize.length;i++)  {
		if(jsGraphResize[i][2].firstPass ==0)  {
		} else if(jsGraphResize[i][2].firstPass ==9) {
			jsGraphResize[i][2].firstPass=2;
			redrawGraph(jsGraphResize[i][2],jsGraphResize[i][3],jsGraphResize[i][4]);
		} else if(jsGraphResize[i][2].firstPass < 10 ) {
			jsGraphResize[i][2].firstPass+=10;
		} 
	}
};

function testRedraw(ctx,data,config) {
	if (ctx.firstPass>10) {
		ctx.firstPass=2;
		redrawGraph(ctx,data,config) ;
		return true;
	} else {
		return false;
	}		
};

function updateChart(ctx,data,config,animation,runanimationcompletefunction) {

	if (ctx.firstPass==9)
	{
		
		ctx.runanimationcompletefunction=runanimationcompletefunction;

		if(animation)ctx.firstPass=1;
		else         ctx.firstPass=2;

		if(config.responsive) {
			// update jsGraphResize;
			for (var i=0;i<jsGraphResize.length;i++)  {
				if(jsGraphResize[i][2].ChartNewId== ctx.ChartNewId) {
					jsGraphResize[i][3]=data;
					jsGraphResize[i][4]=config;
				}
			}
		}
		redrawGraph(ctx,data,config);
	}
};


function redrawGraph(ctx,data,config) {
	var myGraph = new Chart(ctx);	
        eval("myGraph."+ctx.tpchart+"(data,config);");
};


//Default browsercheck, added to all scripts!                                   
function checkBrowser() {
	this.ver = navigator.appVersion
	this.dom = document.getElementById ? 1 : 0
	this.ie5 = (this.ver.indexOf("MSIE 5") > -1 && this.dom) ? 1 : 0;
	this.ie4 = (document.all && !this.dom) ? 1 : 0;
	this.ns5 = (this.dom && parseInt(this.ver) >= 5) ? 1 : 0;
	this.ns4 = (document.layers && !this.dom) ? 1 : 0;
	this.bw = (this.ie5 || this.ie4 || this.ns4 || this.ns5)
	return this
};
bw = new checkBrowser();
//Set these variables:
fromLeft = 10; // How much from the left of the cursor should the div be?
fromTop = 10; // How much from the top of the cursor should the div be?
/********************************************************************
Initilizes the objects
*********************************************************************/
function cursorInit() {
	scrolled = bw.ns4 || bw.ns5 ? "window.pageYOffset" : "document.body.scrollTop"
	if (bw.ns4) document.captureEvents(Event.MOUSEMOVE)
};
/********************************************************************
Contructs the cursorobjects
*********************************************************************/
function makeCursorObj(obj, nest) {
	createCursorDiv();
	nest = (!nest) ? '' : 'document.' + nest + '.'
	this.css = bw.dom ? document.getElementById(obj).style : bw.ie4 ? document.all[obj].style : bw.ns4 ? eval(nest + "document.layers." + obj) : 0;
	this.moveIt = b_moveIt;
	cursorInit();
	return this
};

function b_moveIt(x, y) {
	this.x = x;
	this.y = y;
	this.css.left = this.x + "px";
	this.css.top = this.y + "px";
};

function isIE() {
	var myNav = navigator.userAgent.toLowerCase();
	return (myNav.indexOf('msie') != -1) ? parseInt(myNav.split('msie')[1]) : false;
};

function mergeChartConfig(defaults, userDefined) {
	var returnObj = {};
	for (var attrname in defaults) {
		returnObj[attrname] = defaults[attrname];
	}
	for (var attrnameBis in userDefined) {
		returnObj[attrnameBis] = userDefined[attrnameBis];
	}
	return returnObj;
};

function sleep(ms) {
	var dt = new Date();
	dt.setTime(dt.getTime() + ms);
	while (new Date().getTime() < dt.getTime()) {};
};

function saveCanvas(ctx, data, config) {
	cvSave = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
	var saveCanvasConfig = {
		savePng: false,
		annotateDisplay: false,
		animation: false,
		dynamicDisplay: false
	};
	var savePngConfig = mergeChartConfig(config, saveCanvasConfig);
	savePngConfig.clearRect = false;
	/* And ink them */

	redrawGraph(ctx,data,savePngConfig);
	var image;
	if (config.savePngOutput == "NewWindow") {
		image = ctx.canvas.toDataURL();
		ctx.putImageData(cvSave, 0, 0);
		window.open(image, '_blank');
	}
	if (config.savePngOutput == "CurrentWindow") {
		image = ctx.canvas.toDataURL();
		ctx.putImageData(cvSave, 0, 0);
		window.location.href = image;
	}
	if (config.savePngOutput == "Save") {
		image = ctx.canvas.toDataURL();
		var downloadLink = document.createElement("a");
		downloadLink.href = image;
		downloadLink.download = config.savePngName + ".png";
		document.body.appendChild(downloadLink);
		downloadLink.click();
		document.body.removeChild(downloadLink);
	}
};
if (typeof String.prototype.trim !== 'function') {
	String.prototype.trim = function() {
		return this.replace(/^\s+|\s+$/g, '');
	}
};
var dynamicDisplay = new Array();
var dynamicDisplayList = new Array();

function dynamicFunction(data, config, ctx) {
	if (isIE() < 9 && isIE() != false) return(true);

	if (config.dynamicDisplay && ctx.firstPass==0) {
		if (ctx.canvas.id == "") {
			var cvdate = new Date();
			var cvmillsec = cvdate.getTime();
			ctx.canvas.id = "Canvas_" + cvmillsec;
		}
		if (typeof(dynamicDisplay[ctx.canvas.id]) == "undefined") {
			dynamicDisplayList[dynamicDisplayList["length"]] = ctx.canvas.id;
			dynamicDisplay[ctx.canvas.id] = [ctx, data, config];
			window.onscroll = scrollFunction;
		} 
		if (!isScrolledIntoView(ctx.canvas,config)) return false;
	}
	return true;
};

function isScrolledIntoView(element,config) {
	var xPosition = 0;
	var yPosition = 0;
	var eltWidth, eltHeight;
	if(typeof element.recomputedHeight=="undefined") {
		if (window.devicePixelRatio) {
			// 31/12/2015 - On retina display, the size of the canvas changes after the canvas is displayed.
			//              before it is displayd, the size on the screen is the size on non retina display;
                        //              If we do not divide the height & width by the devicePixelRatio, and if the
                        //              value of config.dynamicDisplayYPartOfChart and if there is a chart on to bottom of the
                        //              web page, this chart will never be displayed....
                        //              If the Size of the canvas was directly the real size displayed on the web page, we should not
                        //              divide the height/width by the devicePixelRatio.... (Bug in Brosers ?)
			element.recomputedHeight=element.height/window.devicePixelRatio;
			element.recomputedWidth=element.width/window.devicePixelRatio;
		} else {
			element.recomputedHeight=element.height;
			element.recomputedWidth=element.width;
		}
	}
	eltWidth=element.recomputedWidth;
	eltHeight=element.recomputedHeight;
	elem = element;
	while (elem) {
		xPosition += (elem.offsetLeft + elem.clientLeft);
		yPosition += (elem.offsetTop + elem.clientTop);
		elem = elem.offsetParent;
	}

	if (xPosition + (eltWidth * config.dynamicDisplayXPartOfChart) >= window.pageXOffset &&
		xPosition + (eltWidth * config.dynamicDisplayXPartOfChart) <= window.pageXOffset + window.innerWidth &&
		yPosition + (eltHeight * config.dynamicDisplayYPartOfChart) >= window.pageYOffset &&
		yPosition + (eltHeight * config.dynamicDisplayYPartOfChart) <= window.pageYOffset + window.innerHeight
	) {
		return (true);
	}
	else {
		return false;
	}
};

function scrollFunction() {
	for (var i = 0; i < dynamicDisplayList["length"]; i++) {
		if ((dynamicDisplay[dynamicDisplayList[i]][0]).firstPass==0) {
			redrawGraph(dynamicDisplay[dynamicDisplayList[i]][0],dynamicDisplay[dynamicDisplayList[i]][1], dynamicDisplay[dynamicDisplayList[i]][2]);
		}
	}
};

var jsGraphAnnotate = new Array();
var jsTextMousePos = new Array();
var mouseActionData=new Array();

function clearAnnotate(ctxid) {
	jsGraphAnnotate[ctxid] = [];
	jsTextMousePos[ctxid] = [];
};

function getMousePos(canvas, evt) {
	var rect = canvas.getBoundingClientRect();
	return {
		x: evt.clientX - rect.left,
		y: evt.clientY - rect.top
	};
};

function isHighLighted(reference,ctx,data,statData,posi,posj,othervars){
	var i;
	if(ctx.tpdata==0) {
		if(typeof data.special=="object") {
			for(i=data.special.length-1;i>=0;i--){
				if(data.special[i].typespecial=="highLight" && data.special[i].posi==posi && data.special[i].posj==posj) return true;
			}
		}
	} else {
		if(typeof data[0].special=="object") {
			for(i=data[0].special.length-1;i>=0;i--){
				if(data[0].special[i].typespecial=="highLight" && data[0].special[i].posi==posi) return true;
			}
		}
	}
	return false;
};

function isNotHighLighted(reference,ctx,data,statData,posi,posj,othervars) {
	return(!isHighLighted(reference,ctx,data,statData,posi,posj,othervars));
}
function deleteHighLight(ctx,data) {
	var i;
	if(ctx.tpdata==0) {
		if(typeof data.special=="object") {
			for(i=data.special.length-1;i>=0;i--){
				if(data.special[i].typespecial=="highLight") data.special.splice(i,1);
			}
		}
	} else {
		if(typeof data[0].special=="object") {
			for(i=data[0].special.length-1;i>=0;i--){
				if(data[0].special[i].typespecial=="highLight") data[0].special.splice(i,1);
			}
		}
	}

};

function highLightAction(action,ctx,data,config,v1,v2) {
	if (ctx.firstPass!=9)return;

	var currentlyDisplayed=[-1,-1];
	var redisplay=false;
	var i,j;


	if(ctx.tpdata==0) {
		if(typeof data.special=="object") {
			for(i=0;i<data.special.length && currentlyDisplayed[0]==-1;i++){
				if(data.special[i].typespecial=="highLight") currentlyDisplayed=[data.special[i].posi,data.special[i].posj];
			}
		}
	} else {
		if(typeof data[0].special=="object") {
			for(i=0;i<data[0].special.length && currentlyDisplayed[0]==-1;i++){
				if(data[0].special[i].typespecial=="highLight") currentlyDisplayed=[data[0].special[i].posi,-1];
			}
		}
	}
	var deleteOld=false;
	var addNew=false;
	var property;
	var output;

	if(action=="HIDE" && currentlyDisplayed[0]!=-1)deleteOld=true;
	else if(ctx.tpdata==0 && action!="HIDE" && config.highLightFullLine== "group" && (currentlyDisplayed[1]!=v2 )) { if(currentlyDisplayed[0]!=-1)deleteOld=true; addNew=true;}
	else if(ctx.tpdata==0 && action!="HIDE" && config.highLightFullLine== false && (currentlyDisplayed[0]!=v1 || currentlyDisplayed[1]!=v2)) { if(currentlyDisplayed[0]!=-1)deleteOld=true; addNew=true;}
	else if(ctx.tpdata==0 && action!="HIDE" && config.highLightFullLine== true && (currentlyDisplayed[0]!=v1 )) { if(currentlyDisplayed[0]!=-1)deleteOld=true; addNew=true;}
	else if(ctx.tpdata==1 && action!="HIDE" && currentlyDisplayed[0]!=v1) { if(currentlyDisplayed[0]!=-1)deleteOld=true; addNew=true;}
	
	if(deleteOld) {
		redisplay=true;
		if(ctx.tpdata==0) {
			for(i=data.special.length-1;i>=0;i--){
				if(data.special[i].typespecial=="highLight") data.special.splice(i,1);
			}
		} else {
			for(i=data[0].special.length-1;i>=0;i--){
				if(data[0].special[i].typespecial=="highLight") data[0].special.splice(i,1);
			}
		}
	}
	if(addNew) {
		redisplay=true;
		if(ctx.tpdata==0) {
			if(typeof data.special == "undefined") data.special=[];
			if(config.highLightFullLine == "group") {
				for(j=0;j<data.datasets.length;j++) {
					if(!(data.datasets[j].mouseDetection==false)) {
						output="";
						for (property in config.highLightSet) {
  							if (output !="") output=output+",";  
  							if(typeof config.highLightSet[property]=="string")output += property + ': "' + config.highLightSet[property]+'"';
  							else output += property + ': ' + config.highLightSet[property];
						}
        					eval("data.special[data.special.length]={"+output+"};");
						data.special[data.special.length-1].posi=j;
						data.special[data.special.length-1].posj=v2;
						data.special[data.special.length-1].typespecial="highLight";
					}
				}
			
			} else if(config.highLightFullLine == true) {
				if(!(data.datasets[v1].mouseDetection==false)) {
					for(j=0;j<data.datasets[v1].data.length;j++) {
						output="";
						for (property in config.highLightSet) {
  							if (output !="") output=output+",";  
  							if(typeof config.highLightSet[property]=="string")output += property + ': "' + config.highLightSet[property]+'"';
  							else output += property + ': ' + config.highLightSet[property];
						}
        					eval("data.special[data.special.length]={"+output+"};");
						data.special[data.special.length-1].posi=v1;
						data.special[data.special.length-1].posj=j;
						data.special[data.special.length-1].typespecial="highLight";
					}
				}
			} else if(!(data.datasets[v1].mouseDetection==false)) {
				output="";
				for (property in config.highLightSet) {
  					if (output !="") output=output+",";  
  					if(typeof config.highLightSet[property]=="string")output += property + ': "' + config.highLightSet[property]+'"';
  					else output += property + ': ' + config.highLightSet[property];
				}
        			eval("data.special[data.special.length]={"+output+"};");
				data.special[data.special.length-1].posi=v1;
				data.special[data.special.length-1].posj=v2;
				data.special[data.special.length-1].typespecial="highLight";
			}
		} else {
			if(typeof data[0].special == "undefined") data[0].special=[];
			output="";
			for (property in config.highLightSet) {
				if (output !="") output=output+",";  
				if(typeof config.highLightSet[property]=="string")output += property + ': "' + config.highLightSet[property]+'"';
				else output += property + ': ' + config.highLightSet[property];
			}
			eval("data[0].special[data[0].special.length]={"+output+"};");
			data[0].special[data[0].special.length-1].posi=v1;
			data[0].special[data[0].special.length-1].posj=v2;
			data[0].special[data[0].special.length-1].typespecial="highLight";
		}
	}
	if(redisplay==true) {
		updateChart(ctx,data,config,false,config.highLightRerunEndFunction);
	}
};

var inMouseAction=new Array();

function doMouseAction(event, ctx, action) {
	if (ctx.firstPass != 9)return;
	if(action=="mousedown") action=action+" "+event.which;
	if(ctx.mouseAction.indexOf(action)<0){return;}
	var config=mouseActionData[ctx.ChartNewId].config;
	var data=mouseActionData[ctx.ChartNewId].data;
	var i,prevShown,prevShowSaved;
	var inRect,P12,D12,D34,P13,D13,D24, y1,y2,y3,y4;
	var pieceOfChartFound=[];
	var textOnChartFound=[];
	var distance, angle,topY, bottomY,leftX, rightX;
	var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel" 
	var canvas_pos = getMousePos(ctx.canvas, event);
	var realAction;
	var annotateDIV,showDiv;

	     if(action=="mousedown 1")realAction="mousedown left";
	else if(action=="mousedown 2")realAction="mousedown middle";
	else if(action=="mousedown 3")realAction="mousedown right";
	else if(action==mousewheelevt)realAction="mousewheel";
	else realAction=action;

	// search if mouse over one or more pieces of chart;

	for (i = 0; i < jsGraphAnnotate[ctx.ChartNewId]["length"]; i++) {
		if (jsGraphAnnotate[ctx.ChartNewId][i][0] == "ARC") {
			myStatData=jsGraphAnnotate[ctx.ChartNewId][i][3][jsGraphAnnotate[ctx.ChartNewId][i][1]];
			distance = Math.sqrt((canvas_pos.x - myStatData.midPosX) * (canvas_pos.x - myStatData.midPosX) + (canvas_pos.y - myStatData.midPosY) * (canvas_pos.y - myStatData.midPosY));
			if (distance > myStatData.int_radius && distance < myStatData.radiusOffset) {
				angle = (Math.acos((canvas_pos.x - myStatData.midPosX) / distance) % (2* Math.PI) + 2*Math.PI) % (2*Math.PI);
				if (canvas_pos.y < myStatData.midPosY) angle = -angle;
				angle = (((angle  + 2 * Math.PI) % (2 * Math.PI)) + 2* Math.PI) % (2* Math.PI) ; 
				myStatData.startAngle=(((myStatData.startAngle  + 2 * Math.PI) % (2 * Math.PI)) + 2* Math.PI) % (2* Math.PI);
				myStatData.endAngle=(((myStatData.endAngle  + 2 * Math.PI) % (2 * Math.PI)) + 2* Math.PI) % (2* Math.PI);
				if(myStatData.endAngle<myStatData.startAngle)myStatData.endAngle+=2 * Math.PI;
				if ((angle > myStatData.startAngle && angle < myStatData.endAngle) || (angle > myStatData.startAngle - 2 * Math.PI && angle < myStatData.endAngle - 2 * Math.PI) || (angle > myStatData.startAngle + 2 * Math.PI && angle < myStatData.endAngle + 2 * Math.PI)) {
					myStatData.graphPosX = canvas_pos.x;
					myStatData.graphPosY = canvas_pos.y;
					pieceOfChartFound[pieceOfChartFound.length]={
						piece : i,
						myStatData: myStatData
					};
				}
			}
		} else if (jsGraphAnnotate[ctx.ChartNewId][i][0] == "RECT") {
			myStatData=jsGraphAnnotate[ctx.ChartNewId][i][3][jsGraphAnnotate[ctx.ChartNewId][i][1]][jsGraphAnnotate[ctx.ChartNewId][i][2]];
			topY=Math.max(myStatData.yPosBottom,myStatData.yPosTop);
			bottomY=Math.min(myStatData.yPosBottom,myStatData.yPosTop);
			if (topY-bottomY <config.annotateBarMinimumDetectionHeight) {
				topY=(topY+bottomY+config.annotateBarMinimumDetectionHeight)/2;
			        bottomY=topY-config.annotateBarMinimumDetectionHeight;
			}
			leftX=Math.min(myStatData.xPosLeft,myStatData.xPosRight);
			rightX=Math.max(myStatData.xPosLeft,myStatData.xPosRight);
			if (rightX-leftX <config.annotateBarMinimumDetectionHeight) {
				rightX=(rightX+leftX+config.annotateBarMinimumDetectionHeight)/2;
			        leftX=rightX-config.annotateBarMinimumDetectionHeight;
			}
			if (canvas_pos.x > leftX && canvas_pos.x < rightX && canvas_pos.y < topY && canvas_pos.y > bottomY) {
				myStatData.graphPosX = canvas_pos.x;
				myStatData.graphPosY = canvas_pos.y;
				pieceOfChartFound[pieceOfChartFound.length]={
					piece : i,
					myStatData: myStatData
				};
			}
		} else if (jsGraphAnnotate[ctx.ChartNewId][i][0] == "POINT") {
			myStatData=jsGraphAnnotate[ctx.ChartNewId][i][3][jsGraphAnnotate[ctx.ChartNewId][i][1]][jsGraphAnnotate[ctx.ChartNewId][i][2]];
			if(config.detectAnnotateOnFullLine) {
				if(canvas_pos.x < Math.min(myStatData.annotateStartPosX,myStatData.annotateEndPosX)-Math.ceil(ctx.chartSpaceScale*config.pointHitDetectionRadius) || canvas_pos.x > Math.max(myStatData.annotateStartPosX,myStatData.annotateEndPosX)+Math.ceil(ctx.chartSpaceScale*config.pointHitDetectionRadius) || canvas_pos.y < Math.min(myStatData.annotateStartPosY,myStatData.annotateEndPosY)-Math.ceil(ctx.chartSpaceScale*config.pointHitDetectionRadius) || canvas_pos.y > Math.max(myStatData.annotateStartPosY,myStatData.annotateEndPosY)+Math.ceil(ctx.chartSpaceScale*config.pointHitDetectionRadius)) {
					distance=Math.ceil(ctx.chartSpaceScale*config.pointHitDetectionRadius)+1;
				} else { 
					if(typeof myStatData.D1A=="undefined") {
						distance=Math.abs(canvas_pos.x-myStatData.posX);
					} else if(typeof myStatData.D2A=="undefined") {
						distance=Math.abs(canvas_pos.y-myStatData.posY);
					} else {
						var D2B=-myStatData.D2A*canvas_pos.x+canvas_pos.y;
						var g=-(myStatData.D1B-D2B)/(myStatData.D1A-myStatData.D2A);
						var h=myStatData.D2A*g+D2B;
						distance=Math.sqrt((canvas_pos.x - g) * (canvas_pos.x - g) + (canvas_pos.y - h) * (canvas_pos.y - h));
					}
				}
			} else {
				distance = Math.sqrt((canvas_pos.x - myStatData.posX) * (canvas_pos.x - myStatData.posX) + (canvas_pos.y - myStatData.posY) * (canvas_pos.y - myStatData.posY));
			}
			if (distance < Math.ceil(ctx.chartSpaceScale*config.pointHitDetectionRadius)) {
				myStatData.graphPosX = canvas_pos.x;
				myStatData.graphPosY = canvas_pos.y;
				pieceOfChartFound[pieceOfChartFound.length]={
					piece : i,
					myStatData: myStatData
				};
			}
		}
	}

	// search if mouse over one or more text;
	if(config.detectMouseOnText) {
		for(i=0;i<jsTextMousePos[ctx.ChartNewId]["length"];i++){
		        inRect=true;
			if(Math.abs(jsTextMousePos[ctx.ChartNewId][i][3].p1 - jsTextMousePos[ctx.ChartNewId][i][3].p2) < config.zeroValue) {
				// Horizontal;
				if(canvas_pos.x < Math.min(jsTextMousePos[ctx.ChartNewId][i][2].p1,jsTextMousePos[ctx.ChartNewId][i][2].p2))inRect=false; 
				if(canvas_pos.x > Math.max(jsTextMousePos[ctx.ChartNewId][i][2].p1,jsTextMousePos[ctx.ChartNewId][i][2].p2))inRect=false; 
				if(canvas_pos.y < Math.min(jsTextMousePos[ctx.ChartNewId][i][3].p1,jsTextMousePos[ctx.ChartNewId][i][3].p3))inRect=false; 
				if(canvas_pos.y > Math.max(jsTextMousePos[ctx.ChartNewId][i][3].p1,jsTextMousePos[ctx.ChartNewId][i][3].p3))inRect=false; 
			} else if(Math.abs(jsTextMousePos[ctx.ChartNewId][i][2].p1 - jsTextMousePos[ctx.ChartNewId][i][2].p2)<config.zeroValue) {
				// Vertical;
				if(canvas_pos.x < Math.min(jsTextMousePos[ctx.ChartNewId][i][2].p1,jsTextMousePos[ctx.ChartNewId][i][2].p3))inRect=false; 
				if(canvas_pos.x > Math.max(jsTextMousePos[ctx.ChartNewId][i][2].p1,jsTextMousePos[ctx.ChartNewId][i][2].p3))inRect=false; 
				if(canvas_pos.y < Math.min(jsTextMousePos[ctx.ChartNewId][i][3].p1,jsTextMousePos[ctx.ChartNewId][i][3].p2))inRect=false; 
				if(canvas_pos.y > Math.max(jsTextMousePos[ctx.ChartNewId][i][3].p1,jsTextMousePos[ctx.ChartNewId][i][3].p2))inRect=false; 
			} else {
				// D12 & D34;

				P12=Math.tan(jsTextMousePos[ctx.ChartNewId][i][4]);
				D12=jsTextMousePos[ctx.ChartNewId][i][3].p1-P12*jsTextMousePos[ctx.ChartNewId][i][2].p1;
				D34=jsTextMousePos[ctx.ChartNewId][i][3].p3-P12*jsTextMousePos[ctx.ChartNewId][i][2].p3;
				// D13 & D24;
				P13=-1/P12;
				D13=jsTextMousePos[ctx.ChartNewId][i][3].p1-P13*jsTextMousePos[ctx.ChartNewId][i][2].p1;
				D24=jsTextMousePos[ctx.ChartNewId][i][3].p4-P13*jsTextMousePos[ctx.ChartNewId][i][2].p4;
				// Check if in rectangle;
					
				y1=P12*canvas_pos.x+D12;
				y2=P12*canvas_pos.x+D34;
				y3=P13*canvas_pos.x+D13;
				y4=P13*canvas_pos.x+D24;
				
				if(canvas_pos.y < Math.min(y1,y2))inRect=false;
				if(canvas_pos.y > Math.max(y1,y2))inRect=false;
				if(canvas_pos.y < Math.min(y3,y4))inRect=false;
				if(canvas_pos.y > Math.max(y3,y4))inRect=false;
			}
			if(inRect)textOnChartFound[textOnChartFound.length]=i;
		}
	}

	function isAction(option,action) {
		return(option==action || (option=="mousemove" && (action=="mousewheel" || action=="mouseout")));
	}

	if(config.savePng && isAction(config.savePngFunction,realAction)) {
		// call savePng function;
		saveCanvas(ctx, data, config);
	}
	
	var whoToReferAnnotate=-1;
	var whoToReferHighLight=-1;
	var referAnnotateIsPoint=false;
	var referHighLightIsPoint=false;
	for(i=pieceOfChartFound.length-1;i>=0;i--) {
		if (jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[i].piece][4]) {
			if(referAnnotateIsPoint==false) {
				if(whoToReferAnnotate==-1)whoToReferAnnotate=i;
				if(jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[i].piece][0] == "POINT") {
					whoToReferAnnotate=i;
					referAnnotateIsPoint=true;
				}
			}
		}
		if(referHighLightIsPoint==false) {
			if(whoToReferHighLight==-1)whoToReferHighLight=i;
			if(jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[i].piece][0] == "POINT") {
				whoToReferHighLight=i;
				referHighLightIsPoint=true;
			}
		}
		
	}
	
	if(config.annotateDisplay && isAction(config.annotateFunction,realAction)) {
		// annotate display functionality;
		annotateDIV = document.getElementById('divCursor');
		annotateDIV.style.display = false ? '' : 'none';
		if(pieceOfChartFound.length>0) {
			annotateDIV.className = (config.annotateClassName) ? config.annotateClassName : '';
			annotateDIV.style.border = (config.annotateClassName) ? '' : config.annotateBorder;
			annotateDIV.style.padding = (config.annotateClassName) ? '' : config.annotatePadding;
			annotateDIV.style.borderRadius = (config.annotateClassName) ? '' : config.annotateBorderRadius;
			annotateDIV.style.backgroundColor = (config.annotateClassName) ? '' : config.annotateBackgroundColor;
			annotateDIV.style.color = (config.annotateClassName) ? '' : config.annotateFontColor;
			annotateDIV.style.fontFamily = (config.annotateClassName) ? '' : config.annotateFontFamily;
			annotateDIV.style.fontSize = (config.annotateClassName) ? '' : (Math.ceil(ctx.chartTextScale*config.annotateFontSize)).toString() + "pt";
			annotateDIV.style.fontStyle = (config.annotateClassName) ? '' : config.annotateFontStyle;
			annotateDIV.style.zIndex = 999;
			ctx.save();
			ctx.font= annotateDIV.style.fontStyle+" "+ annotateDIV.style.fontSize+" "+annotateDIV.style.fontFamily;
			var rect = ctx.canvas.getBoundingClientRect();
			showDiv=false;
			if(whoToReferAnnotate!=-1) {
				if (jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferAnnotate].piece][4]) {
					if (jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferAnnotate].piece][0] == "ARC") dispString = tmplbis(setOptionValue(true,1,"ANNOTATELABEL",ctx,data,jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferAnnotate].piece][3],undefined,config.annotateLabel,"annotateLabel",jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferAnnotate].piece][1],-1,{otherVal:true}), pieceOfChartFound[whoToReferAnnotate].myStatData,config);
					else dispString = tmplbis(setOptionValue(true,1,"ANNOTATELABEL",ctx,data,jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferAnnotate].piece][3],undefined,config.annotateLabel,"annotateLabel",jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferAnnotate].piece][1],jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferAnnotate].piece][2],{otherVal:true}), pieceOfChartFound[whoToReferAnnotate].myStatData,config);
					textMsr=ctx.measureTextMultiLine(dispString,1*annotateDIV.style.fontSize.replace("pt",""));
					ctx.restore();
					annotateDIV.innerHTML = dispString;
					x = bw.ns4 || bw.ns5 ? event.pageX : event.x;
					y = bw.ns4 || bw.ns5 ? event.pageY : event.y;
					if (bw.ie4 || bw.ie5) y = y + eval(scrolled);
					if(config.annotateRelocate===true) {
						var relocateX, relocateY;
						relocateX=0;relocateY=0;
				 		if(x+fromLeft+textMsr.textWidth > window.innerWidth-rect.left-fromLeft)relocateX=-textMsr.textWidth;
		 				if(y+fromTop+textMsr.textHeight > 1*window.innerHeight-1*rect.top+fromTop)relocateY-=(textMsr.textHeight+2*fromTop);
						oCursor.moveIt(Math.max(8-rect.left,x + fromLeft+relocateX), Math.max(8-rect.top,y + fromTop + relocateY));
					} else oCursor.moveIt(x + fromLeft, y + fromTop);
					annotateDIV.style.display = true ? '' : 'none'; 
					showDiv=true;
				}
			}
		}		
		

	}

	if(inMouseAction[ctx.ChartNewId]==false && mouseActionData[ctx.ChartNewId].prevShow>=0 && isAction("mousemove",realAction) && (pieceOfChartFound.length==0 || mouseActionData[ctx.ChartNewId].prevShow!=pieceOfChartFound[pieceOfChartFound.length-1].piece)) {
                inMouseAction[ctx.ChartNewId]=true;
		prevShow=mouseActionData[ctx.ChartNewId].prevShow;
		mouseActionData[ctx.ChartNewId].prevShow=-1;

	       	if(config.highLight && isAction(config.highLightMouseFunction,realAction) && pieceOfChartFound.length==0) {
			highLightAction("HIDE",ctx,data,config,null,null);
		}	
                	
		if(typeof config.annotateFunctionOut=="function") {
			if(jsGraphAnnotate[ctx.ChartNewId][prevShow][0] == "ARC")config.annotateFunctionOut("OUTANNOTATE",ctx,data,jsGraphAnnotate[ctx.ChartNewId][prevShow][3],jsGraphAnnotate[ctx.ChartNewId][prevShow][1],-1,null);
			else  config.annotateFunctionOut("OUTANNOTATE",ctx,data,jsGraphAnnotate[ctx.ChartNewId][prevShow][3],jsGraphAnnotate[ctx.ChartNewId][prevShow][1],jsGraphAnnotate[ctx.ChartNewId][prevShow][2],null);
		}
		inMouseAction[ctx.ChartNewId]=false;
	}
	

	if(pieceOfChartFound.length>0 && inMouseAction[ctx.ChartNewId]==false && mouseActionData[ctx.ChartNewId].prevShow!=pieceOfChartFound[whoToReferHighLight].piece && isAction("mousemove",realAction)) {
		inMouseAction[ctx.ChartNewId]=true;
		prevShow=mouseActionData[ctx.ChartNewId].prevShow;
	       	if(config.highLight && isAction(config.highLightMouseFunction,realAction)) {
			if(whoToReferHighLight!=-1) {
				if(jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferHighLight].piece][0] == "ARC") highLightAction("ARC",ctx,data,config,jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferHighLight].piece][1],-1);
				else highLightAction(jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferHighLight].piece][0],ctx,data,config,jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferHighLight].piece][1],jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferHighLight].piece][2]);
			}
		}	

		if(typeof config.annotateFunctionIn=="function") {
			if(jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[pieceOfChartFound.length-1].piece][0] == "ARC")config.annotateFunctionIn("INANNOTATE",ctx,data,jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[pieceOfChartFound.length-1].piece][3],jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[pieceOfChartFound.length-1].piece][1],-1,null);
			else  config.annotateFunctionIn("INANNOTATE",ctx,data,jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[pieceOfChartFound.length-1].piece][3],jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[pieceOfChartFound.length-1].piece][1],jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[pieceOfChartFound.length-1].piece][2],null);
		}
		inMouseAction[ctx.ChartNewId]=false;
		mouseActionData[ctx.ChartNewId].prevShow=pieceOfChartFound[whoToReferHighLight].piece;
	}

       	if (config.highLight && isAction(config.highLightMouseFunction,realAction) && isAction("mousemove",realAction)==false) {
		if(pieceOfChartFound.length==0)highLightAction("HIDE",ctx,data,config,null,null);
		else {
			if(whoToReferHighLight!=-1) {
				if(jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferHighLight].piece][0] == "ARC") highLightAction("ARC",ctx,data,config,jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferHighLight].piece][1],-1);
				else highLightAction(jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferHighLight].piece][0],ctx,data,config,jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferHighLight].piece][1],jsGraphAnnotate[ctx.ChartNewId][pieceOfChartFound[whoToReferHighLight].piece][2]);
			}
		}
	}


	function runFunction(toBeRun){
		var i;
		for(i=0;i<pieceOfChartFound.length;i++) {
			toBeRun(event, ctx, config, data, pieceOfChartFound[i].myStatData);
		}
		for(i=0;i<textOnChartFound.length;i++) {
			toBeRun(event, ctx, config, data, {type:"CLICKONTEXT",values:jsTextMousePos[ctx.ChartNewId][textOnChartFound[i]]});
		}
		if(pieceOfChartFound.length==0 && textOnChartFound.length==0) {
			toBeRun(event, ctx, config, data, null);
		}
	};

	if(typeof config.mouseMove=="function" && isAction("mousemove",realAction)) runFunction(config.mouseMove);
	if(typeof config.mouseDownLeft=="function" && isAction("mousedown left",realAction))runFunction(config.mouseDownLeft);
	if(typeof config.mouseDownRight=="function" && isAction("mousedown right",realAction)) runFunction(config.mouseDownRight);
	if(typeof config.mouseDownMiddle=="function" && isAction("mousedown middle",realAction)) runFunction(config.mouseDownMiddle);
	if(typeof config.mouseWheel=="function" && isAction("mousewheel",realAction)) runFunction(config.mouseWheel);
	if(typeof config.mouseOut=="function" && isAction("mouseout",realAction)) runFunction(config.mouseOut);
	if(typeof config.mouseDblClick=="function" && isAction("dblclick",realAction)) runFunction(config.mouseDblClick);
};
                         
///////// GRAPHICAL PART OF THE SCRIPT ///////////////////////////////////////////
//Define the global Chart Variable as a class.
window.Chart = function(context) {
	var chart = this;
	//Easing functions adapted from Robert Penner's easing equations
	//http://www.robertpenner.com/easing/
	var animationOptions = {
		linear: function(t) {
			return t;
		},
		easeInQuad: function(t) {
			return t * t;
		},
		easeOutQuad: function(t) {
			return -1 * t * (t - 2);
		},
		easeInOutQuad: function(t) {
			if ((t /= 1 / 2) < 1) return 1 / 2 * t * t;
			return -1 / 2 * ((--t) * (t - 2) - 1);
		},
		easeInCubic: function(t) {
			return t * t * t;
		},
		easeOutCubic: function(t) {
			return 1 * ((t = t / 1 - 1) * t * t + 1);
		},
		easeInOutCubic: function(t) {
			if ((t /= 1 / 2) < 1) return 1 / 2 * t * t * t;
			return 1 / 2 * ((t -= 2) * t * t + 2);
		},
		easeInQuart: function(t) {
			return t * t * t * t;
		},
		easeOutQuart: function(t) {
			return -1 * ((t = t / 1 - 1) * t * t * t - 1);
		},
		easeInOutQuart: function(t) {
			if ((t /= 1 / 2) < 1) return 1 / 2 * t * t * t * t;
			return -1 / 2 * ((t -= 2) * t * t * t - 2);
		},
		easeInQuint: function(t) {
			return 1 * (t /= 1) * t * t * t * t;
		},
		easeOutQuint: function(t) {
			return 1 * ((t = t / 1 - 1) * t * t * t * t + 1);
		},
		easeInOutQuint: function(t) {
			if ((t /= 1 / 2) < 1) return 1 / 2 * t * t * t * t * t;
			return 1 / 2 * ((t -= 2) * t * t * t * t + 2);
		},
		easeInSine: function(t) {
			return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;
		},
		easeOutSine: function(t) {
			return 1 * Math.sin(t / 1 * (Math.PI / 2));
		},
		easeInOutSine: function(t) {
			return -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);
		},
		easeInExpo: function(t) {
			return (t == 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));
		},
		easeOutExpo: function(t) {
			return (t == 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);
		},
		easeInOutExpo: function(t) {
			if (t == 0) return 0;
			if (t == 1) return 1;
			if ((t /= 1 / 2) < 1) return 1 / 2 * Math.pow(2, 10 * (t - 1));
			return 1 / 2 * (-Math.pow(2, -10 * --t) + 2);
		},
		easeInCirc: function(t) {
			if (t >= 1) return t;
			return -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);
		},
		easeOutCirc: function(t) {
			return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);
		},
		easeInOutCirc: function(t) {
			if ((t /= 1 / 2) < 1) return -1 / 2 * (Math.sqrt(1 - t * t) - 1);
			return 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);
		},
		easeInElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t == 0) return 0;
			if ((t /= 1) == 1) return 1;
			if (!p) p = 1 * .3;
			if (a < Math.abs(1)) {
				a = 1;
				s = p / 4;
			} else s = p / (2 * Math.PI) * Math.asin(1 / a);
			return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
		},
		easeOutElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t == 0) return 0;
			if ((t /= 1) == 1) return 1;
			if (!p) p = 1 * .3;
			if (a < Math.abs(1)) {
				a = 1;
				s = p / 4;
			} else s = p / (2 * Math.PI) * Math.asin(1 / a);
			return a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;
		},
		easeInOutElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t == 0) return 0;
			if ((t /= 1 / 2) == 2) return 1;
			if (!p) p = 1 * (.3 * 1.5);
			if (a < Math.abs(1)) {
				a = 1;
				s = p / 4;
			} else s = p / (2 * Math.PI) * Math.asin(1 / a);
			if (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
			return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * .5 + 1;
		},
		easeInBack: function(t) {
			var s = 1.70158;
			return 1 * (t /= 1) * t * ((s + 1) * t - s);
		},
		easeOutBack: function(t) {
			var s = 1.70158;
			return 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);
		},
		easeInOutBack: function(t) {
			var s = 1.70158;
			if ((t /= 1 / 2) < 1) return 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));
			return 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
		},
		easeInBounce: function(t) {
			return 1 - animationOptions.easeOutBounce(1 - t);
		},
		easeOutBounce: function(t) {
			if ((t /= 1) < (1 / 2.75)) {
				return 1 * (7.5625 * t * t);
			} else if (t < (2 / 2.75)) {
				return 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + .75);
			} else if (t < (2.5 / 2.75)) {
				return 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375);
			} else {
				return 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375);
			}
		},
		easeInOutBounce: function(t) {
			if (t < 1 / 2) return animationOptions.easeInBounce(t * 2) * .5;
			return animationOptions.easeOutBounce(t * 2 - 1) * .5 + 1 * .5;
		}
	};
	//Variables global to the chart
	
	var width = context.canvas.width;
	var height = context.canvas.height;
    
	this.PolarArea = function(data, options) {
		chart.PolarArea.defaults = {
			highLightSet : { color : "red" },
			inGraphDataShow: false,
			inGraphDataPaddingRadius: 5,
			inGraphDataPaddingAngle: 0,
			inGraphDataTmpl: "<%=(v1 == ''? '' : v1+':')+ v2 + ' (' + v6 + ' %)'%>",
			inGraphDataAlign: "off-center", // "right", "center", "left", "off-center" or "to-center"
			inGraphDataVAlign: "off-center", // "bottom", "center", "top", "off-center" or "to-center"
			inGraphDataRotate: 0, // rotateAngle value (0->360) , "inRadiusAxis" or "inRadiusAxisRotateLabels"
			inGraphDataFontFamily: "'Arial'",
			inGraphDataFontSize: 12,
			inGraphDataFontStyle: "normal",
			inGraphDataFontColor: "#666",
			inGraphDataRadiusPosition: 3,
			inGraphDataAnglePosition: 2,
			scaleOverlay: true,
			scaleOverride: false,
			scaleOverride2: false,
			scaleGridLinesStep : 1,
			scaleSteps: null,
			scaleStepWidth: null,
			scaleStartValue: null,
			scaleShowLine: true,
			scaleLineColor: "rgba(0,0,0,.1)",
			scaleLineWidth: 1,
			scaleLineStyle: "solid",
			scaleShowLabels: true,
			scaleShowLabels2: true,
			scaleLabel: "<%=value%>",
			scaleFontFamily: "'Arial'",
			scaleFontSize: 12,
			scaleFontStyle: "normal",
			scaleFontColor: "#666",
			scaleShowLabelBackdrop: true,
			scaleBackdropColor: "rgba(255,255,255,0.75)",
			scaleBackdropPaddingY: 2,
			scaleBackdropPaddingX: 2,
			segmentShowStroke: true,
			segmentStrokeColor: "#fff",
			segmentStrokeStyle: "solid",
			segmentStrokeWidth: 2,
			animation: true,
			animationByData : "ByArc",
			animationSteps: 100,
			animationEasing: "easeOutBounce",
			animateRotate: true,
			animateScale: false,
			onAnimationComplete: null,
			annotateLabel: "<%=(v1 == ''? '' : v1+':')+ v2 + ' (' + v6 + ' %)'%>",
			startAngle: 90,
			totalAmplitude : 360,
			radiusScale : 1
		};
		if(isIE()<9 && isIE() != false)chart.PolarArea.defaults = mergeChartConfig(chart.defaults.IExplorer8, chart.PolarArea.defaults);
		chart.PolarArea.defaults = mergeChartConfig(chart.defaults.commonOptions, chart.PolarArea.defaults);
		chart.PolarArea.defaults = mergeChartConfig(chart.PolarArea.defaults, charJSPersonalDefaultOptions);
		chart.PolarArea.defaults = mergeChartConfig(chart.PolarArea.defaults, charJSPersonalDefaultOptionsPolarArea);
		var config = (options) ? mergeChartConfig(chart.PolarArea.defaults, options) : chart.PolarArea.defaults;
		return new PolarArea(data, config, context);
	};
	this.Radar = function(data, options) {
		chart.Radar.defaults = {
			highLightSet : { pointDotRadius: 15, pointDot : true },
			inGraphDataShow: false,
			inGraphDataPaddingRadius: 5,
			inGraphDataTmpl: "<%=v3%>",
			inGraphDataAlign: "off-center", // "right", "center", "left", "off-center" or "to-center"
			inGraphDataVAlign: "off-center", // "right", "center", "left", "off-center" or "to-center"
			inGraphDataRotate: 0, // rotateAngle value (0->360) , "inRadiusAxis" or "inRadiusAxisRotateLabels"
			inGraphDataFontFamily: "'Arial'",
			inGraphDataFontSize: 12,
			inGraphDataFontStyle: "normal",
			inGraphDataFontColor: "#666",
			inGraphDataRadiusPosition: 3,
			yAxisMinimumInterval: "none",
			scaleGridLinesStep : 1,
			scaleOverlay: false,
			scaleOverride: false,
			scaleOverride2: false,
			scaleSteps: null,
			scaleStepWidth: null,
			scaleStartValue: null,
			scaleShowLine: true,
			scaleLineColor: "rgba(0,0,0,.1)",
			scaleLineStyle: "solid",
			scaleLineWidth: 1,
			scaleShowLabels: false,
			scaleShowLabels2: true,
			scaleLabel: "<%=value%>",
			scaleFontFamily: "'Arial'",
			scaleFontSize: 12,
			scaleFontStyle: "normal",
			scaleFontColor: "#666",
			scaleShowLabelBackdrop: true,
			scaleBackdropColor: "rgba(255,255,255,0.75)",
			scaleBackdropPaddingY: 2,
			scaleBackdropPaddingX: 2,
			angleShowLineOut: true,
			angleLineColor: "rgba(0,0,0,.1)",
			angleLineStyle: "solid",
			angleLineWidth: 1,
			pointLabelFontFamily: "'Arial'",
			pointLabelFontStyle: "normal",
			pointLabelFontSize: 12,
			pointLabelFontColor: "#666",
			pointDot: true,
			pointDotRadius: 3,
			pointDotStrokeWidth: 1,
			pointDotStrokeStyle:"solid",
			datasetFill: true,
			datasetStrokeWidth: 2,
			datasetStrokeStyle:"solid",
			animation: true,
			animationSteps: 60,
			animationEasing: "easeOutQuart",
			onAnimationComplete: null,
			annotateLabel: "<%=(v1 == '' ? '' : v1) + (v1!='' && v2 !='' ? ' - ' : '')+(v2 == '' ? '' : v2)+(v1!='' || v2 !='' ? ':' : '') + v3%>",
			pointHitDetectionRadius : 10,
			startAngle: 90
		};
		// merge annotate defaults
		if(isIE()<9 && isIE() != false)chart.Radar.defaults = mergeChartConfig(chart.defaults.IExplorer8, chart.Radar.defaults);
		chart.Radar.defaults = mergeChartConfig(chart.defaults.commonOptions, chart.Radar.defaults);
		chart.Radar.defaults = mergeChartConfig(chart.Radar.defaults, charJSPersonalDefaultOptions);
		chart.Radar.defaults = mergeChartConfig(chart.Radar.defaults, charJSPersonalDefaultOptionsRadar);
		var config = (options) ? mergeChartConfig(chart.Radar.defaults, options) : chart.Radar.defaults;
		return new Radar(data, config, context);
	};
	this.Pie = function(data, options) {
		chart.Pie.defaults = chart.defaults.PieAndDoughnut;
		// merge annotate defaults
		if(isIE()<9 && isIE() != false)chart.Pie.defaults = mergeChartConfig(chart.defaults.IExplorer8, chart.Pie.defaults);
		chart.Pie.defaults = mergeChartConfig(chart.defaults.commonOptions, chart.Pie.defaults);
		chart.Pie.defaults = mergeChartConfig(chart.Pie.defaults, charJSPersonalDefaultOptions);
		chart.Pie.defaults = mergeChartConfig(chart.Pie.defaults, charJSPersonalDefaultOptionsPie);
		var config = (options) ? mergeChartConfig(chart.Pie.defaults, options) : chart.Pie.defaults;
		return new Pie(data, config, context);
	};
	this.Doughnut = function(data, options) {
		chart.Doughnut.defaults = chart.defaults.PieAndDoughnut;
		// merge annotate defaults
		if(isIE()<9 && isIE() != false)chart.Doughnut.defaults = mergeChartConfig(chart.defaults.IExplorer8, chart.Doughnut.defaults);
		chart.Doughnut.defaults = mergeChartConfig(chart.defaults.commonOptions, chart.Doughnut.defaults);
		chart.Doughnut.defaults = mergeChartConfig(chart.Doughnut.defaults, charJSPersonalDefaultOptions);
		chart.Doughnut.defaults = mergeChartConfig(chart.Doughnut.defaults, charJSPersonalDefaultOptionsDoughnut);
		var config = (options) ? mergeChartConfig(chart.Doughnut.defaults, options) : chart.Doughnut.defaults;
		return new Doughnut(data, config, context);
	};
	this.Line = function(data, options) {
		chart.Line.defaults = {
			inGraphDataShow: false,
			highLightSet : { pointDotRadius: 15, pointDot : true },
			inGraphDataPaddingX: 3,
			inGraphDataPaddingY: 3,
			inGraphDataTmpl: "<%=v3%>",
			inGraphDataAlign: "left",
			inGraphDataVAlign: "bottom",
			inGraphDataRotate: 0,
			inGraphDataFontFamily: "'Arial'",
			inGraphDataFontSize: 12,
			inGraphDataFontStyle: "normal",
			inGraphDataFontColor: "#666",
			drawXScaleLine: [{
				position: "bottom"
			}],
			scaleOverlay: false,
			scaleOverride: false,
			scaleOverride2: false,
			scaleSteps: null,
			scaleStepWidth: null,
			scaleStartValue: null,
			scaleSteps2: null,
			scaleStepWidth2: null,
			scaleStartValue2: null,
			scaleLabel2 : "<%=value%>",
			scaleLineColor: "rgba(0,0,0,.1)",
			scaleLineStyle: "solid",
			scaleLineWidth: 1,
			scaleShowLabels: true,
			scaleShowLabels2: true,
			scaleLabel: "<%=value%>",
			scaleFontFamily: "'Arial'",
			scaleFontSize: 12,
			scaleFontStyle: "normal",
			scaleFontColor: "#666",
			scaleShowGridLines: true,
			scaleXGridLinesStep: 1,
			scaleYGridLinesStep: 1,
			scaleGridLineColor: "rgba(0,0,0,.05)",
			scaleGridLineStyle: "solid",
			scaleGridLineWidth: 1,
			showYAxisMin: true, // Show the minimum value on Y axis (in original version, this minimum is not displayed - it can overlap the X labels)
			rotateLabels: "smart", // smart <=> 0 degre if space enough; otherwise 45 degres if space enough otherwise90 degre; 
			// you can force an integer value between 0 and 180 degres
			logarithmic: false, // can be 'fuzzy',true and false ('fuzzy' => if the gap between min and maximum is big it's using a logarithmic y-Axis scale
			logarithmic2: false, // can be 'fuzzy',true and false ('fuzzy' => if the gap between min and maximum is big it's using a logarithmic y-Axis scale
			scaleTickSizeLeft: 5,
			scaleTickSizeRight: 5,
			scaleTickSizeBottom: 5,
			scaleTickSizeTop: 5,
			bezierCurve: true,
			linkType : 0,   //0 : direct point to point; 1 = vertical lines; 2=angular link;
			bezierCurveTension : 0.4,
			pointDot: true,
			pointDotRadius: 4,
			pointDotStrokeStyle: "solid",
			pointDotStrokeWidth: 2,
			datasetStrokeStyle: "solid",
			datasetStrokeWidth: 2,
			datasetFill: true,
			animation: true,
			animationSteps: 60,
			animationEasing: "easeOutQuart",
			extrapolateMissingData: true,
			onAnimationComplete: null,
			annotateLabel: "<%=(v1 == '' ? '' : v1) + (v1!='' && v2 !='' ? ' - ' : '')+(v2 == '' ? '' : v2)+(v1!='' || v2 !='' ? ':' : '') + v3%>",
			pointHitDetectionRadius : 10
		};
		// merge annotate defaults
		if(isIE()<9 && isIE() != false)chart.Line.defaults = mergeChartConfig(chart.defaults.IExplorer8, chart.Line.defaults);
		chart.Line.defaults = mergeChartConfig(chart.defaults.commonOptions, chart.Line.defaults);
		chart.Line.defaults = mergeChartConfig(chart.defaults.xyAxisCommonOptions, chart.Line.defaults);
		chart.Line.defaults = mergeChartConfig(chart.Line.defaults, charJSPersonalDefaultOptions);
		chart.Line.defaults = mergeChartConfig(chart.Line.defaults, charJSPersonalDefaultOptionsLine);
		var config = (options) ? mergeChartConfig(chart.Line.defaults, options) : chart.Line.defaults;
		return new Line(data, config, context);
	};
	this.StackedBar = function(data, options) {
		chart.StackedBar.defaults = {
			annotateBarMinimumDetectionHeight : 0,
			highLightSet : { pointDotRadius: 15, barStrokeWidth : 5, pointDot : true },
			inGraphDataShow: false,
			inGraphDataPaddingX: 0,
			inGraphDataPaddingY: -3,
			inGraphDataTmpl: "<%=v3%>",
			inGraphDataAlign: "center",
			inGraphDataVAlign: "top",
			inGraphDataRotate: 0,
			inGraphDataFontFamily: "'Arial'",
			inGraphDataFontSize: 12,
			inGraphDataFontStyle: "normal",
			inGraphDataFontColor: "#666",
			inGraphDataXPosition: 2,
			inGraphDataYPosition: 3,
			scaleOverlay: false,
			scaleOverride: false,
			scaleOverride2: false,
			scaleSteps: null,
			scaleStepWidth: null,
			scaleStartValue: null,
			scaleLineColor: "rgba(0,0,0,.1)",
			scaleLineStyle: "solid",
			scaleLineWidth: 1,
			scaleShowLabels: true,
			scaleShowLabels2: true,
			scaleLabel: "<%=value%>",
			scaleFontFamily: "'Arial'",
			scaleFontSize: 12,
			scaleFontStyle: "normal",
			scaleFontColor: "#666",
			scaleShowGridLines: true,
			scaleXGridLinesStep: 1,
			scaleYGridLinesStep: 1,
			scaleGridLineColor: "rgba(0,0,0,.05)",
			scaleGridLineStyle: "solid",
			scaleGridLineWidth: 1,
			showYAxisMin: true, // Show the minimum value on Y axis (in original version, this minimum is not displayed - it can overlap the X labels)
			rotateLabels: "smart", // smart <=> 0 degre if space enough; otherwise 45 degres if space enough otherwise90 degre; 
			// you can force an integer value between 0 and 180 degres
			scaleTickSizeLeft: 5,
			scaleTickSizeRight: 5,
			scaleTickSizeBottom: 5,
			scaleTickSizeTop: 5,
			pointDot: true,
			pointDotRadius: 4,
			pointDotStrokeStyle: "solid",
			pointDotStrokeWidth: 2,
			barShowStroke: true,
//			barStrokeStyle: "solid",
			barStrokeWidth: 2,
			barValueSpacing: 5,
			barDatasetSpacing: 1,
			spaceBetweenBar : 0,
			animation: true,
			animationSteps: 60,
			animationEasing: "easeOutQuart",
			onAnimationComplete: null,
			bezierCurve: true,
			linkType : 0,   //0 : direct point to point; 1 = vertical lines; 2=angular link;
			bezierCurveTension : 0.4,
			annotateLabel: "<%=(v1 == '' ? '' : v1) + (v1!='' && v2 !='' ? ' - ' : '')+(v2 == '' ? '' : v2)+(v1!='' || v2 !='' ? ':' : '') + v3 + ' (' + v6 + ' %)'%>",
			pointHitDetectionRadius : 10
		};
		// merge annotate defaults
		if(isIE()<9 && isIE() != false)chart.StackedBar.defaults = mergeChartConfig(chart.defaults.IExplorer8, chart.StackedBar.defaults);
		chart.StackedBar.defaults = mergeChartConfig(chart.defaults.commonOptions, chart.StackedBar.defaults);
		chart.StackedBar.defaults = mergeChartConfig(chart.defaults.xyAxisCommonOptions, chart.StackedBar.defaults);
		chart.StackedBar.defaults = mergeChartConfig(chart.StackedBar.defaults, charJSPersonalDefaultOptions);
		chart.StackedBar.defaults = mergeChartConfig(chart.StackedBar.defaults, charJSPersonalDefaultOptionsStackedBar);
		var config = (options) ? mergeChartConfig(chart.StackedBar.defaults, options) : chart.StackedBar.defaults;
		return new StackedBar(data, config, context);
	};
	this.HorizontalStackedBar = function(data, options) {
		chart.HorizontalStackedBar.defaults = {
			annotateBarMinimumDetectionHeight : 0,
			highLightSet : { pointDotRadius: 15, barStrokeWidth : 5, pointDot : true },
			inGraphDataShow: false,
			inGraphDataPaddingX: -3,
			inGraphDataPaddingY: 0,
			inGraphDataTmpl: "<%=v3%>",
			inGraphDataAlign: "right",
			inGraphDataVAlign: "middle",
			inGraphDataRotate: 0,
			inGraphDataFontFamily: "'Arial'",
			inGraphDataFontSize: 12,
			inGraphDataFontStyle: "normal",
			inGraphDataFontColor: "#666",
			inGraphDataXPosition: 3,
			inGraphDataYPosition: 2,
			scaleOverlay: false,
			scaleOverride: false,
			scaleOverride2: false,
			scaleSteps: null,
			scaleStepWidth: null,
			scaleStartValue: null,
			scaleLineColor: "rgba(0,0,0,.1)",
			scaleLineStyle: "solid",
			scaleLineWidth: 1,
			scaleShowLabels: true,
			scaleShowLabels2: true,
			scaleLabel: "<%=value%>",
			scaleFontFamily: "'Arial'",
			scaleFontSize: 12,
			scaleFontStyle: "normal",
			scaleFontColor: "#666",
			scaleShowGridLines: true,
			scaleXGridLinesStep: 1,
			scaleYGridLinesStep: 1,
			scaleGridLineColor: "rgba(0,0,0,.05)",
			scaleGridLineStyle: "solid",
			scaleGridLineWidth: 1,
			scaleTickSizeLeft: 5,
			scaleTickSizeRight: 5,
			scaleTickSizeBottom: 5,
			scaleTickSizeTop: 5,
			showYAxisMin: true, // Show the minimum value on Y axis (in original version, this minimum is not displayed - it can overlap the X labels)
			rotateLabels: "smart", // smart <=> 0 degre if space enough; otherwise 45 degres if space enough otherwise90 degre; 
			barShowStroke: true,
//			barStrokeStyle: "solid",
			barStrokeWidth: 2,
			barValueSpacing: 5,
			barDatasetSpacing: 1,
			spaceBetweenBar : 0,
			animation: true,
			animationSteps: 60,
			animationEasing: "easeOutQuart",
			onAnimationComplete: null,
			annotateLabel: "<%=(v1 == '' ? '' : v1) + (v1!='' && v2 !='' ? ' - ' : '')+(v2 == '' ? '' : v2)+(v1!='' || v2 !='' ? ':' : '') + v3 + ' (' + v6 + ' %)'%>",
			reverseOrder: false
		};
		// merge annotate defaults
		if(isIE()<9 && isIE() != false)chart.HorizontalStackedBar.defaults = mergeChartConfig(chart.defaults.IExplorer8, chart.HorizontalStackedBar.defaults);
		chart.HorizontalStackedBar.defaults = mergeChartConfig(chart.defaults.commonOptions, chart.HorizontalStackedBar.defaults);
		chart.HorizontalStackedBar.defaults = mergeChartConfig(chart.defaults.xyAxisCommonOptions, chart.HorizontalStackedBar.defaults);
		chart.HorizontalStackedBar.defaults = mergeChartConfig(chart.HorizontalStackedBar.defaults, charJSPersonalDefaultOptions);
		chart.HorizontalStackedBar.defaults = mergeChartConfig(chart.HorizontalStackedBar.defaults, charJSPersonalDefaultOptionsHorizontalStackedBar);
		var config = (options) ? mergeChartConfig(chart.HorizontalStackedBar.defaults, options) : chart.HorizontalStackedBar.defaults;
		return new HorizontalStackedBar(data, config, context);
	};
	this.Bar = function(data, options) {
		chart.Bar.defaults = {
			annotateBarMinimumDetectionHeight : 0,
			highLightSet : { pointDotRadius: 15, barStrokeWidth : 5, pointDot : true },
			inGraphDataShow: false,
			inGraphDataPaddingX: 0,
			inGraphDataPaddingY: 3,
			inGraphDataTmpl: "<%=v3%>",
			inGraphDataAlign: "center",
			inGraphDataVAlign: "bottom",
			inGraphDataRotate: 0,
			inGraphDataFontFamily: "'Arial'",
			inGraphDataFontSize: 12,
			inGraphDataFontStyle: "normal",
			inGraphDataFontColor: "#666",
			inGraphDataXPosition: 2,
			inGraphDataYPosition: 3,
			scaleOverlay: false,
			scaleOverride: false,
			scaleOverride2: false,
			scaleSteps: null,
			scaleStepWidth: null,
			scaleStartValue: null,
			scaleSteps2: null,
			scaleStepWidth2: null,
			scaleStartValue2: null,
			scaleLineColor: "rgba(0,0,0,.1)",
			scaleLineStyle: "solid",
			scaleLineWidth: 1,
			scaleShowLabels: true,
			scaleShowLabels2: true,
			scaleLabel: "<%=value%>",
			scaleLabel2: "<%=value%>",
			scaleFontFamily: "'Arial'",
			scaleFontSize: 12,
			scaleFontStyle: "normal",
			scaleFontColor: "#666",
			scaleShowGridLines: true,
			scaleXGridLinesStep: 1,
			scaleYGridLinesStep: 1,
			scaleGridLineColor: "rgba(0,0,0,.05)",
			scaleGridLineWidth: 1,
			scaleGridLineStyle: "solid",
			showYAxisMin: true, // Show the minimum value on Y axis (in original version, this minimum is not displayed - it can overlap the X labels)
			rotateLabels: "smart", // smart <=> 0 degre if space enough; otherwise 45 degres if space enough otherwise90 degre; 
			// you can force an integer value between 0 and 180 degres
			logarithmic: false, // can be 'fuzzy',true and false ('fuzzy' => if the gap between min and maximum is big it's using a logarithmic y-Axis scale
			logarithmic2: false, // can be 'fuzzy',true and false ('fuzzy' => if the gap between min and maximum is big it's using a logarithmic y-Axis scale
			scaleTickSizeLeft: 5,
			scaleTickSizeRight: 5,
			scaleTickSizeBottom: 5,
			scaleTickSizeTop: 5,
			barShowStroke: true,
//			barStrokeStyle: "solid",
			barStrokeWidth: 2,
			barValueSpacing: 5,
			barDatasetSpacing: 1,
			barBorderRadius: 0,
			pointDot: true,
			pointDotRadius: 4,
			pointDotStrokeStyle: "solid",
			pointDotStrokeWidth: 2,
			extrapolateMissingData: true,
			animation: true,
			animationSteps: 60,
			animationEasing: "easeOutQuart",
			onAnimationComplete: null,
			bezierCurve: true,
			linkType : 0,   //0 : direct point to point; 1 = vertical lines; 2=angular link;
			bezierCurveTension : 0.4,
			annotateLabel: "<%=(v1 == '' ? '' : v1) + (v1!='' && v2 !='' ? ' - ' : '')+(v2 == '' ? '' : v2)+(v1!='' || v2 !='' ? ':' : '') + v3 + ' (' + v6 + ' %)'%>",
			pointHitDetectionRadius : 10
		};
		// merge annotate defaults
		if(isIE()<9 && isIE() != false)chart.Bar.defaults = mergeChartConfig(chart.defaults.IExplorer8, chart.Bar.defaults);
		chart.Bar.defaults = mergeChartConfig(chart.defaults.commonOptions, chart.Bar.defaults);
		chart.Bar.defaults = mergeChartConfig(chart.defaults.xyAxisCommonOptions, chart.Bar.defaults);
		chart.Bar.defaults = mergeChartConfig(chart.Bar.defaults, charJSPersonalDefaultOptions);
		chart.Bar.defaults = mergeChartConfig(chart.Bar.defaults, charJSPersonalDefaultOptionsBar);
		var config = (options) ? mergeChartConfig(chart.Bar.defaults, options) : chart.Bar.defaults;
		return new Bar(data, config, context);
	};
	this.HorizontalBar = function(data, options) {
		chart.HorizontalBar.defaults = {
			annotateBarMinimumDetectionHeight : 0,
			highLightSet : { pointDotRadius: 15, barStrokeWidth : 5, pointDot : true },
			inGraphDataShow: false,
			inGraphDataPaddingX: 3,
			inGraphDataPaddingY: 0,
			inGraphDataTmpl: "<%=v3%>",
			inGraphDataAlign: "left",
			inGraphDataVAlign: "middle",
			inGraphDataRotate: 0,
			inGraphDataFontFamily: "'Arial'",
			inGraphDataFontSize: 12,
			inGraphDataFontStyle: "normal",
			inGraphDataFontColor: "#666",
			inGraphDataXPosition: 3,
			inGraphDataYPosition: 2,
			scaleOverlay: false,
			scaleOverride: false,
			scaleOverride2: false,
			scaleSteps: null,
			scaleStepWidth: null,
			scaleStartValue: null,
			scaleLineColor: "rgba(0,0,0,.1)",
			scaleLineStyle: "solid",
			scaleLineWidth: 1,
			scaleShowLabels: true,
			scaleShowLabels2: true,
			scaleLabel: "<%=value%>",
			scaleFontFamily: "'Arial'",
			scaleFontSize: 12,
			scaleFontStyle: "normal",
			scaleFontColor: "#666",
			scaleShowGridLines: true,
			scaleXGridLinesStep: 1,
			scaleYGridLinesStep: 1,
			scaleGridLineColor: "rgba(0,0,0,.05)",
			scaleGridLineStyle: "solid",
			scaleGridLineWidth: 1,
			scaleTickSizeLeft: 5,
			scaleTickSizeRight: 5,
			scaleTickSizeBottom: 5,
			scaleTickSizeTop: 5,
			showYAxisMin: true, // Show the minimum value on Y axis (in original version, this minimum is not displayed - it can overlap the X labels)
			rotateLabels: "smart", // smart <=> 0 degre if space enough; otherwise 45 degres if space enough otherwise90 degre; 
			barShowStroke: true,
//			barStrokeStyle: "solid",
			barStrokeWidth: 2,
			barValueSpacing: 5,
			barDatasetSpacing: 1,
			barBorderRadius: 0,
			animation: true,
			animationSteps: 60,
			animationEasing: "easeOutQuart",
			onAnimationComplete: null,
			annotateLabel: "<%=(v1 == '' ? '' : v1) + (v1!='' && v2 !='' ? ' - ' : '')+(v2 == '' ? '' : v2)+(v1!='' || v2 !='' ? ':' : '') + v3 + ' (' + v6 + ' %)'%>",
			reverseOrder: false
		};
		// merge annotate defaults
		if(isIE()<9 && isIE() != false)chart.HorizontalBar.defaults = mergeChartConfig(chart.defaults.IExplorer8, chart.HorizontalBar.defaults);
		chart.HorizontalBar.defaults = mergeChartConfig(chart.defaults.commonOptions, chart.HorizontalBar.defaults);
		chart.HorizontalBar.defaults = mergeChartConfig(chart.defaults.xyAxisCommonOptions, chart.HorizontalBar.defaults);
		chart.HorizontalBar.defaults = mergeChartConfig(chart.HorizontalBar.defaults, charJSPersonalDefaultOptions);
		chart.HorizontalBar.defaults = mergeChartConfig(chart.HorizontalBar.defaults, charJSPersonalDefaultOptionsHorizontalBar);
		var config = (options) ? mergeChartConfig(chart.HorizontalBar.defaults, options) : chart.HorizontalBar.defaults;
		return new HorizontalBar(data, config, context);
	};
	chart.defaults = {};
	
	chart.defaults.IExplorer8 ={
		annotateBackgroundColor : "black",
		annotateFontColor: "white"
	};
	chart.defaults.commonOptions = {
		chartTextScale : 1,
		chartLineScale : 1,
		chartSpaceScale : 1,
		multiGraph: false,
		clearRect: true, // do not change clearRect options; for internal use only
		dynamicDisplay: false,
		dynamicDisplayXPartOfChart : 0.5,
		dynamicDisplayYPartOfChart : 0.5,
		animationForceSetTimeOut : false,
		graphSpaceBefore: 5,
		graphSpaceAfter: 5,
		canvasBorders: false,
		canvasBackgroundColor: "none",
		canvasBordersRadius : 0,
		canvasBordersWidth: 3,
		canvasBordersStyle: "solid",
		canvasBordersColor: "black",
		zeroValue : 0.0000000001,
		graphTitle: "",
		graphTitleFontFamily: "'Arial'",
		graphTitleFontSize: 24,
		graphTitleFontStyle: "bold",
		graphTitleFontColor: "#666",
		graphTitleSpaceBefore: 5,
		graphTitleSpaceAfter: 5,
		graphTitleBorders : false,
		graphTitleBordersRadius : 0,
		graphTitleBordersColor : "black",
		graphTitleBordersXSpace : 3,
		graphTitleBordersYSpace : 3,
		graphTitleBordersWidth : 1,
		graphTitleBordersStyle : "solid",
		graphTitleBackgroundColor : "none",
   		graphSubTitle: "",
		graphSubTitleFontFamily: "'Arial'",
		graphSubTitleFontSize: 18,
		graphSubTitleFontStyle: "normal",
		graphSubTitleFontColor: "#666",
		graphSubTitleSpaceBefore: 5,
		graphSubTitleSpaceAfter: 5,
		graphSubTitleBorders : false,
		graphSubTitleBordersColor : "black",
                graphSubTitleBordersRadius : 0,
		graphSubTitleBordersXSpace : 3,
		graphSubTitleBordersYSpace : 3,
		graphSubTitleBordersWidth : 1,
		graphSubTitleBordersStyle : "solid",
		graphSubTitleBackgroundColor : "none",
		footNote: "",
		footNoteFontFamily: "'Arial'",
		footNoteFontSize: 8,
		footNoteFontStyle: "bold",
		footNoteFontColor: "#666",
		footNoteSpaceBefore: 5,
		footNoteSpaceAfter: 5,
		footNoteBorders : false,
		footNoteBordersColor : "black",
                footNoteBordersRadius : 0,
		footNoteBordersXSpace : 3,
		footNoteBordersYSpace : 3,
		footNoteBordersWidth : 1,
		footNoteBordersStyle : "solid",
		footNoteBackgroundColor : "none",
		legend : false,
		showSingleLegend: false,
		maxLegendCols : 999,
		legendPosY :4,
		legendPosX : -2, 
		legendFontFamily: "'Arial'",
		legendFontSize: 12,
		legendFontStyle: "normal",
		legendFontColor: "#666",
		legendBlockSize: 15,
                legendBlockRadius:0,
		legendBorders: true,
		legendBordersStyle: "solid",
		legendBordersWidth: 1,
		legendBordersColors: "#666",
                legendBordersRadius: 0,
		legendBordersSpaceBefore: 5,
		legendBordersSpaceAfter: 5,
		legendBordersSpaceLeft: 5,
		legendBordersSpaceRight: 5,
		legendSpaceBeforeText: 5,
		legendSpaceAfterText: 5,
		legendSpaceLeftText: 5,
		legendSpaceRightText: 5,
		legendSpaceBetweenTextVertical: 5,
		legendSpaceBetweenTextHorizontal: 5,
		legendSpaceBetweenBoxAndText: 5,
		legendFillColor : "rgba(0,0,0,0)",
		legendXPadding : 0,
		legendYPadding : 0,
		inGraphDataBorders : false,
                inGraphDataBordersRadius : 0,
		inGraphDataBordersColor : "black",
		inGraphDataBordersXSpace : 3,
		inGraphDataBordersYSpace : 3,
		inGraphDataBordersWidth : 1,
		inGraphDataBordersStyle : "solid",
		inGraphDataBackgroundColor : "none",
		annotateDisplay: false,
		annotateRelocate: false,
		savePng: false,
		savePngOutput: "NewWindow", // Allowed values : "NewWindow", "CurrentWindow", "Save"
		savePngFunction: "mousedown right",
		savePngBackgroundColor: 'WHITE',
		annotateFunction: "mousemove",
		annotateFontFamily: "'Arial'",
		annotateBorder: 'none',
		annotateBorderRadius: '2px',
		annotateBackgroundColor: 'rgba(0,0,0,0.8)',
		annotateFontSize: 12,
		annotateFontColor: 'white',
		annotateFontStyle: "normal",
		annotatePadding: "3px",
		annotateClassName: "",
		annotateFunctionIn: null,
		annotateFunctionOut : null,
		detectMouseOnText: false,
		crossText: [""],
		crossTextIter: ["all"],
		crossTextOverlay: [true],
		crossTextFontFamily: ["'Arial'"],
		crossTextFontSize: [12],
		crossTextFontStyle: ["normal"],
		crossTextFontColor: ["rgba(220,220,220,1)"],
		crossTextRelativePosX: [2],
		crossTextRelativePosY: [2],
		crossTextBaseline: ["middle"],
		crossTextAlign: ["center"],
		crossTextPosX: [0],
		crossTextPosY: [0],
		crossTextAngle: [0],
		crossTextFunction: null,
		crossTextBorders : [false],
		crossTextBordersColor : ["black"],
                crossTextBordersRadius : [0],
		crossTextBordersXSpace : [3],
		crossTextBordersYSpace : [3],
		crossTextBordersWidth : [1],
		crossTextBordersStyle : ["solid"],
		crossTextBackgroundColor : ["none"],
		crossImage: [undefined],
		crossImageIter: ["all"],
		crossImageOverlay: [true],
		crossImageRelativePosX: [2],
		crossImageRelativePosY: [2],
		crossImageBaseline: ["middle"],
		crossImageAlign: ["center"],
		crossImagePosX: [0],
		crossImagePosY: [0],
		crossImageAngle: [0],
		spaceTop: 0,
		spaceBottom: 0,
		spaceRight: 0,
		spaceLeft: 0,
		decimalSeparator: ".",
		thousandSeparator: "",
		currency : "\u20AC",    // 20AC= Euro
		currencyPosition : "after",
		roundNumber: "none",
		roundPct: -1,
		templatesOpenTag : "<%=",
		templatesCloseTag : "%>",
		fmtV1: "none",
		fmtV2: "none",
		fmtV3: "none",
		fmtV4: "none",
		fmtV5: "none",
		fmtV6: "none",
		fmtV6T: "none",
		fmtV7: "none",
		fmtV8: "none",
		fmtV8T: "none",
		fmtV9: "none",
		fmtV10: "none",
		fmtV11: "none",
		fmtV12: "none",
		fmtV13: "none",
		fmtXLabel: "none",
		fmtYLabel: "none",
		fmtYLabel2: "none",
		fmtLegend: "none",
		animationStartValue: 0,
		animationStopValue: 1,
		animationCount: 1,
		animationPauseTime: 5,
		animationBackward: false,
		animationStartWithDataset: 1,
		animationStartWithData: 1,
		animationLeftToRight: false,
		animationByDataset: false,
		defaultStrokeColor: "rgba(220,220,220,1)",
		defaultFillColor: "rgba(220,220,220,0.5)",
		defaultLineWidth : 2,
		graphMaximized: false,
		contextMenu: true,
		mouseDownRight: null,
		mouseDownLeft: null,
		mouseDownMiddle: null,
		mouseMove: null,
		mouseOut: null,
		mouseDblClick: null,
		mouseWheel : null,
		highLight : false,
		highLightMouseFunction : "mousemove",
		highLightFullLine : false,   // true, false or "group"
		highLightRerunEndFunction : false,
		savePngName: "canvas",
		responsive : false,
		responsiveMinWidth : 0,
		responsiveMinHeight : 0,
		responsiveMaxWidth : 9999999,
		responsiveMaxHeight : 9999999,
		maintainAspectRatio: true,
		responsiveScaleContent : false,
		responsiveWindowInitialWidth : false,
		pointMarker : "circle",    // "circle","cross","plus","diamond","triangle","square"
		initFunction : null,
		beforeDrawFunction : null,
		endDrawDataFunction : null,
		endDrawScaleFunction : null
	};


	chart.defaults.PieAndDoughnut = {
			highLightSet : { expandOutRadius : 0.10, expandInRadius : -0.10 },
			inGraphDataShow: false,
			inGraphDataPaddingRadius: 5,
			inGraphDataPaddingAngle: 0,
			inGraphDataTmpl: "<%=(v1 == ''? '' : v1+':')+ v2 + ' (' + v6 + ' %)'%>",
			inGraphDataAlign: "off-center", // "right", "center", "left", "off-center" or "to-center"
			inGraphDataVAlign: "off-center", // "bottom", "middle", "top", "off-center" or "to-center"
			inGraphDataRotate: 0, // rotateAngle value (0->360) , "inRadiusAxis" or "inRadiusAxisRotateLabels"
			inGraphDataFontFamily: "'Arial'",
			inGraphDataFontSize: 12,
			inGraphDataFontStyle: "normal",
			inGraphDataFontColor: "#666",
			inGraphDataRadiusPosition: 3,
			inGraphDataAnglePosition: 2,
		        inGraphDataMinimumAngle : 0,
			segmentShowStroke: true,
			segmentStrokeColor: "#fff",
			segmentStrokeStyle: "solid",
			segmentStrokeWidth: 2,
			percentageInnerCutout: 50,
			animation: true,
			animationByData : false,
			animationSteps: 100,
			animationEasing: "easeOutBounce",
			animateRotate: true,
			animateScale: false,
			onAnimationComplete: null,
			annotateLabel: "<%=(v1 == ''? '' : v1+':')+ v2 + ' (' + v6 + ' %)'%>",
			startAngle: 90,
			totalAmplitude : 360,
			radiusScale: 1
	};

	chart.defaults.xyAxisCommonOptions = {
		maxBarWidth : -1,
		yAxisMinimumInterval: "none",
		yAxisMinimumInterval2: "none",
		yScaleLabelsMinimumWidth: 0,
		xScaleLabelsMinimumWidth: 0,
		yAxisLeft: true,
		yAxisRight: false,
		xAxisBottom: true,
		xAxisTop: false,
		xAxisSpaceBetweenLabels: 5,
		fullWidthGraph: false,
		yAxisLabel: "",
		yAxisLabel2: "",
		yAxisFontFamily: "'Arial'",
		yAxisFontSize: 16,
		yAxisFontStyle: "normal",
		yAxisFontColor: "#666",
		yAxisLabelSpaceRight: 5,
		yAxisLabelSpaceLeft: 5,
		yAxisSpaceRight: 5,
		yAxisSpaceLeft: 5,
		yAxisLabelBorders : false,
		yAxisLabelBordersColor : "black",
                yAxisLabelBordersRadius : 0,
		yAxisLabelBordersXSpace : 3,
		yAxisLabelBordersYSpace : 3,
		yAxisLabelBordersWidth : 1,
		yAxisLabelBordersStyle : "solid",
		yAxisLabelBackgroundColor : "none",
		xAxisLabel: "",
		xAxisFontFamily: "'Arial'",
		xAxisFontSize: 16,
		xAxisFontStyle: "normal",
		xAxisFontColor: "#666",
		xAxisLabelSpaceBefore: 5,
		xAxisLabelSpaceAfter: 5,
		xAxisSpaceBefore: 5,
		xAxisSpaceAfter: 5,
		xAxisLabelBorders : false,
		xAxisLabelBordersColor : "black",
                xAxisLabelBordersRadius : 0,
		xAxisLabelBordersXSpace : 3,
		xAxisLabelBordersYSpace : 3,
		xAxisLabelBordersWidth : 1,
		xAxisLabelBordersStyle : "solid",
		xAxisLabelBackgroundColor : "none",
		showXLabels : 1,
		firstLabelToShow : 1,
		showYLabels : 1,
		firstYLabelToShow : 1,
		yAxisUnit: "",
		yAxisUnit2: "",
		yAxisUnitFontFamily: "'Arial'",
		yAxisUnitFontSize: 8,
		yAxisUnitFontStyle: "normal",
		yAxisUnitFontColor: "#666",
		yAxisUnitSpaceBefore: 5,
		yAxisUnitSpaceAfter: 5,
		yAxisUnitBorders : false,
		yAxisUnitBordersColor : "black",
                yAxisUnitBordersradius : 0,
		yAxisUnitBordersXSpace : 3,
		yAxisUnitBordersYSpace : 3,
		yAxisUnitBordersWidth : 1,
		yAxisUnitBordersStyle : "solid",
		yAxisUnitBackgroundColor : "none"
	};
	var clear = function(c) {
		c.clearRect(0, 0, width, height);
	};
	


	function init_and_start(ctx,data,config) {

		var i;

		if (typeof ctx.initialWidth == "undefined") ctx.initialWidth =ctx.canvas.width;
		if (typeof ctx.chartTextScale == "undefined") ctx.chartTextScale=config.chartTextScale;
		if (typeof ctx.chartLineScale == "undefined") ctx.chartLineScale=config.chartLineScale;
		if (typeof ctx.chartSpaceScale == "undefined") 	ctx.chartSpaceScale=config.chartSpaceScale;
	
		if(typeof ctx.firstPass=="undefined"){
			ctx.firstPass=0;
        		if(config.responsive && !config.multiGraph) {
				addResponsiveChart(ctx.ChartNewId,ctx,data,config);
			}
		} 

		if (typeof ctx.ChartNewId == "undefined") {
			ctx.runanimationcompletefunction=true;
			var cvdate = new Date();
			var cvmillsec = cvdate.getTime();
			ctx.ChartNewId = ctx.tpchart + '_' + cvmillsec;
			ctx._eventListeners = {};
		}

		resizeCtx(ctx,config);

		if (!dynamicFunction(data, config, ctx)) return false;   // if config.dynamicDisplay=true, chart has to be displayed only if in current screen;  

		if (!config.multiGraph && ctx.firstPass!=0) {	
			clearAnnotate(ctx.ChartNewId);
		}

		if (typeof jsGraphAnnotate[ctx.ChartNewId] == "undefined") {
			jsGraphAnnotate[ctx.ChartNewId] = new Array();
			jsTextMousePos[ctx.ChartNewId] = new Array();
		};
		
		// convert label to title - for compatibility reasons with Chart.js;
		switch(ctx.tpdata) {
			case 1:
				for(i=0;i<data.length;i++){
					if(typeof data[i].title == "undefined" && typeof data[i].label != "undefined") {
						data[i].title=data[i].label;
					}
				}
				break;
			case 0:
			default:
				for(i=0;i<data.datasets.length;i++){
					if(typeof data.datasets[i].title == "undefined" && typeof data.datasets[i].label != "undefined") {
						data.datasets[i].title=data.datasets[i].label;
					}
				}
				break;
		}

		defMouse(ctx, data, config);
		
		if(ctx.firstPass==0) {
			if(config.animation)ctx.firstPass=1;
			else ctx.firstPass=2;
		}

		setRect(ctx, config);
		
		return true;
	} ;

	var PolarArea = function(data, config, ctx) {
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, msr, midPosX, midPosY;

		ctx.tpchart="PolarArea";
		ctx.tpdata=1;
		
	        if (!init_and_start(ctx,data,config)) return;

		var realCumulativeAngle = (((config.startAngle * (Math.PI / 180) + 2 * Math.PI) % (2 * Math.PI)) + 2* Math.PI) % (2* Math.PI) ; 
		var realAmplitude = (((config.totalAmplitude * (Math.PI / 180) + 2 * Math.PI) % (2 * Math.PI)) + 2* Math.PI) % (2* Math.PI) ; 
		if(realAmplitude <= config.zeroValue)realAmplitude=2*Math.PI;
			
		var debAngle=((realCumulativeAngle-realAmplitude)+4*Math.PI)%(2*Math.PI);
		var finAngle=debAngle+realAmplitude;

		var statData=initPassVariableData_part1(data,config,ctx);

		valueBounds = getValueBounds();
		config.logarithmic = false;
		config.logarithmic2 = false;

		//Check and set the scale
		labelTemplateString = (config.scaleShowLabels) ? config.scaleLabel : "";
		if (!config.scaleOverride) {
			calculatedScale = calculateScale(1, config, valueBounds.maxSteps, valueBounds.minSteps, valueBounds.maxValue, valueBounds.minValue, labelTemplateString);
			msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, calculatedScale.labels, null, true, false, false, false, true, "PolarArea");
		} else {
			var scaleStartValue= setOptionValue(true,1,"SCALESTARTVALUE",ctx,data,statData,undefined,config.scaleStartValue,"scaleStartValue",-1,-1,{nullValue : true} );
			var scaleSteps =setOptionValue(true,1,"SCALESTEPS",ctx,data,statData,undefined,config.scaleSteps,"scaleSteps",-1,-1,{nullValue : true} );
			var scaleStepWidth = setOptionValue(true,1,"SCALESTEPWIDTH",ctx,data,statData,undefined,config.scaleStepWidth,"scaleStepWidth",-1,-1,{nullValue : true} );

			calculatedScale = {
				steps: scaleSteps,
				stepValue: scaleStepWidth,
				graphMin: scaleStartValue,
				graphMax: scaleStartValue + scaleSteps * scaleStepWidth,
				labels: []
			}
			populateLabels(1, config, labelTemplateString, calculatedScale.labels, calculatedScale.steps, scaleStartValue, calculatedScale.graphMax, scaleStepWidth);
			msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, calculatedScale.labels, null, true, false, false, false, true, "PolarArea");
		}

		var outerVal=calculatedScale.graphMin+calculatedScale.steps*calculatedScale.stepValue;
		var drwSize=calculatePieDrawingSize(ctx,msr,config,data,statData);
		midPosX=drwSize.midPieX;
		midPosY=drwSize.midPieY;

		scaleHop = Math.floor(drwSize.radius / calculatedScale.steps);
		//Wrap in an animation loop wrapper
 		if(scaleHop > 0) {
			initPassVariableData_part2(statData,data,config,ctx,{midPosX : midPosX,midPosY : midPosY,int_radius : 0,ext_radius : scaleHop*calculatedScale.steps, calculatedScale : calculatedScale, scaleHop : scaleHop,outerVal : outerVal});
			animationLoop(config, drawScale, drawAllSegments, ctx, msr.clrx, msr.clry, msr.clrwidth, msr.clrheight, midPosX, midPosY, midPosX - ((Min([msr.availableHeight, msr.availableWidth]) / 2) - 5), midPosY + ((Min([msr.availableHeight, msr.availableWidth]) / 2) - 5), data, statData);
		} else {
			testRedraw(ctx,data,config);
			ctx.firstPass=9;
		}

		function drawAllSegments(animationDecimal) {

			var prevAngle=statData[0].firstAngle;

			var fixAngle=0;
			var firstAngle=statData[0].firstAngle;
			if(1*config.animationStartWithData>1 && 1*config.animationStartWithData-1 < data.length) {
				fixAngle=(statData[config.animationStartWithData-1].startAngle-statData[0].firstAngle);
				firstAngle=statData[config.animationStartWithData-1].startAngle;
			}

			for (var i = 0; i < data.length; i++) {
				var	scaleAnimation = 1,
					rotateAnimation = 1;
                	
				if (config.animation) {
					if (config.animateScale) {
						scaleAnimation = animationDecimal;
					}
					if (config.animateRotate) {
						rotateAnimation = animationDecimal;
					}
				}
				correctedRotateAnimation = animationCorrection(rotateAnimation, data, config, i, -1,false).mainVal;
				if (!(typeof(data[i].value) == 'undefined')) {
					ctx.beginPath();
					if(config.animationByData == "ByArc") {
						endAngle=statData[i].startAngle+correctedRotateAnimation*statData[i].segmentAngle;
						ctx.arc(midPosX, midPosY, scaleAnimation * statData[i].radiusOffset, statData[i].startAngle, endAngle, false);
					} else if(config.animationByData) {
					        if (i<1*config.animationStartWithData-1) {
							ctx.arc(midPieX, midPieY, scaleAnimation * statData[i].radiusOffset, statData[i].startAngle, statData[i].endAngle,false);
						} else if(statData[i].startAngle <= firstAngle+correctedRotateAnimation*(2*Math.PI-fixAngle) ) {
							endAngle=statData[i].endAngle;
							if(statData[i].endAngle > firstAngle+correctedRotateAnimation*(2*Math.PI-fixAngle)) {
								endAngle=firstAngle+correctedRotateAnimation*(2*Math.PI-fixAngle);
							} 
							ctx.arc(midPieX, midPieY, scaleAnimation * statData[i].radiusOffset, statData[i].startAngle, endAngle,false);
						} else {
							continue; 
						}
					} else {
						ctx.arc(midPieX, midPieY, scaleAnimation * statData[i].radiusOffset, prevAngle, prevAngle+correctedRotateAnimation * (statData[i].endAngle-statData[i].startAngle),false);
						prevAngle=prevAngle+correctedRotateAnimation * (statData[i].endAngle-statData[i].startAngle);
					}
					ctx.lineTo(midPosX, midPosY);
					ctx.closePath();
					ctx.fillStyle=setOptionValue(true,1,"COLOR",ctx,data,statData,data[i].color,config.defaultFillColor,"color",i,-1,{animationDecimal: animationDecimal, scaleAnimation : scaleAnimation} );
					ctx.fill();

					if(config.segmentShowStroke=="merge") { /* avoid blank stripes between piece of chart */
						ctx.lineWidth =0;
						ctx.strokeStyle =setOptionValue(true,1,"COLOR",ctx,data,statData,data[i].color,config.defaultFillColor,"color",i,-1,{animationDecimal: animationDecimal, scaleAnimation : scaleAnimation} );
						ctx.setLineDash([]);
						ctx.stroke();
					}
					else if (config.segmentShowStroke) {
						ctx.strokeStyle = config.segmentStrokeColor;
						ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.segmentStrokeWidth);
						ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"SEGMENTSTROKESTYLE",ctx,data,statData,data[i].segmentStrokeStyle,config.segmentStrokeStyle,"segmentStrokeStyle",i,-1,{animationDecimal: animationDecimal, scaleAnimation : scaleAnimation} )));
						ctx.stroke();
						ctx.setLineDash([]);
					}
				}
			}


			if (animationDecimal >= config.animationStopValue) {
				for (i = 0; i < data.length; i++) {
					if (typeof(data[i].value) == 'undefined') continue;
					jsGraphAnnotate[ctx.ChartNewId][jsGraphAnnotate[ctx.ChartNewId].length] = ["ARC", i, -1,statData,setOptionValue(true,1,"ANNOTATEDISPLAY",ctx,data,statData,data[i].annotateDisplay,config.annotateDisplay,"annotateDisplay",i,-1,{nullValue : true})];
					if (setOptionValue(true,1,"INGRAPHDATASHOW",ctx,data,statData,data[i].inGraphDataShow,config.inGraphDataShow,"inGraphDataShow",i,-1,{nullValue : true})) {
						if (setOptionValue(true,1,"INGRAPHDATAANGLEPOSITION",ctx,data,statData,undefined,config.inGraphDataAnglePosition,"inGraphDataAnglePosition",i,-1,{nullValue : true} ) == 1) posAngle = statData[i].realStartAngle + setOptionValue(true,1,"INGRAPHDATAPADDINANGLE",ctx,data,statData,undefined,config.inGraphDataPaddingAngle,"inGraphDataPaddingAngle",i,-1,{nullValue: true  }) * (Math.PI / 180);
						else if (setOptionValue(true,1,"INGRAPHDATAANGLEPOSITION",ctx,data,statData,undefined,config.inGraphDataAnglePosition,"inGraphDataAnglePosition",i,-1,{nullValue : true} ) == 2) posAngle = (2*statData[i].realStartAngle - statData[i].segmentAngle) / 2 + setOptionValue(true,1,"INGRAPHDATAPADDINANGLE",ctx,data,statData,undefined,config.inGraphDataPaddingAngle,"inGraphDataPaddingAngle",i,-1,{nullValue: true  }) * (Math.PI / 180);
						else if (setOptionValue(true,1,"INGRAPHDATAANGLEPOSITION",ctx,data,statData,undefined,config.inGraphDataAnglePosition,"inGraphDataAnglePosition",i,-1,{nullValue : true} ) == 3) posAngle = statData[i].realStartAngle - statData[i].segmentAngle + setOptionValue(true,1,"INGRAPHDATAPADDINANGLE",ctx,data,statData,undefined,config.inGraphDataPaddingAngle,"inGraphDataPaddingAngle",i,-1,{nullValue: true  }) * (Math.PI / 180);
						if (setOptionValue(true,1,"INGRAPHDATARADIUSPOSITION",ctx,data,statData,undefined,config.inGraphDataRadiusPosition,"inGraphDataRadiusPosition",i,-1,{nullValue : true} ) == 1) labelRadius = 0 + setOptionValue(true,1,"INGRAPHDATAPADDINGRADIUS",ctx,data,statData,undefined,config.inGraphDataPaddingRadius,"inGraphDataPaddingRadius",i,-1,{nullValue: true} );
						else if (setOptionValue(true,1,"INGRAPHDATARADIUSPOSITION",ctx,data,statData,undefined,config.inGraphDataRadiusPosition,"inGraphDataRadiusPosition",i,-1,{nullValue : true} ) == 2) labelRadius = statData[i].radiusOffset / 2 + setOptionValue(true,1,"INGRAPHDATAPADDINGRADIUS",ctx,data,statData,undefined,config.inGraphDataPaddingRadius,"inGraphDataPaddingRadius",i,-1,{nullValue: true} );
						else if (setOptionValue(true,1,"INGRAPHDATARADIUSPOSITION",ctx,data,statData,undefined,config.inGraphDataRadiusPosition,"inGraphDataRadiusPosition",i,-1,{nullValue : true} ) == 3) labelRadius = statData[i].radiusOffset + setOptionValue(true,1,"INGRAPHDATAPADDINGRADIUS",ctx,data,statData,undefined,config.inGraphDataPaddingRadius,"inGraphDataPaddingRadius",i,-1,{nullValue: true} );
						else if (setOptionValue(true,1,"INGRAPHDATARADIUSPOSITION",ctx,data,statData,undefined,config.inGraphDataRadiusPosition,"inGraphDataRadiusPosition",i,-1,{nullValue : true} ) == 4) labelRadius = scaleHop * calculatedScale.steps + setOptionValue(true,1,"INGRAPHDATAPADDINGRADIUS",ctx,data,statData,undefined,config.inGraphDataPaddingRadius,"inGraphDataPaddingRadius",i,-1,{nullValue: true} );
						ctx.save()
						if (setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,-1,{nullValue: true  }) == "off-center") {
							if (setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,-1,{nullValue : true} ) == "inRadiusAxis" || (posAngle + 2 * Math.PI) % (2 * Math.PI) >= 3 * Math.PI / 2 || (posAngle + 2 * Math.PI) % (2 * Math.PI) <= Math.PI / 2) ctx.textAlign = "left";
					                                                                                                                                                                                                                                                   
							else ctx.textAlign = "right";
						} else if (setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,-1,{nullValue: true  }) == "to-center") {
							if (setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,-1,{nullValue : true} ) == "inRadiusAxis" || (posAngle + 2 * Math.PI) % (2 * Math.PI) >= 3 * Math.PI / 2 || (posAngle + 2 * Math.PI) % (2 * Math.PI) <= Math.PI / 2) ctx.textAlign = "right";
							else ctx.textAlign = "left";
						} else ctx.textAlign = setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,-1,{nullValue: true  });
						if (setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,-1,{nullValue : true} ) == "off-center") {
							if ((posAngle + 2 * Math.PI) % (2 * Math.PI) > Math.PI) ctx.textBaseline = "top";
							else ctx.textBaseline = "bottom";
						} else if (setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,-1,{nullValue : true} ) == "to-center") {
							if ((posAngle + 2 * Math.PI) % (2 * Math.PI) > Math.PI) ctx.textBaseline = "bottom";
							else ctx.textBaseline = "top";
						} else ctx.textBaseline = setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,-1,{nullValue : true} );
						ctx.font = setOptionValue(true,1,"INGRAPHDATAFONTSTYLE",ctx,data,statData,undefined,config.inGraphDataFontStyle,"inGraphDataFontStyle",i,-1,{nullValue : true} ) + ' ' + setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,-1,{nullValue : true} ) + 'px ' + setOptionValue(true,1,"INGRAPHDATAFONTFAMILY",ctx,data,statData,undefined,config.inGraphDataFontFamily,"inGraphDataFontFamily",i,-1,{nullValue : true} );
						ctx.fillStyle = setOptionValue(true,1,"INGRAPHDATAFONTCOLOR",ctx,data,statData,undefined,config.inGraphDataFontColor,"inGraphDataFontColor",i,-1,{nullValue : true} );
						var dispString = tmplbis(setOptionValue(true,1,"INGRAPHDATATMPL",ctx,data,statData,undefined,config.inGraphDataTmpl,"inGraphDataTmpl",i,-1,{nullValue : true} ), statData[i],config);
						ctx.translate(midPosX + labelRadius * Math.cos(posAngle), midPosY - labelRadius * Math.sin(posAngle));
						var rotateVal=0;
						if (setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,-1,{nullValue : true} ) == "inRadiusAxis") rotateVal=2 * Math.PI - posAngle;
						else if (setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,-1,{nullValue : true} ) == "inRadiusAxisRotateLabels") {
							if ((posAngle + 2 * Math.PI) % (2 * Math.PI) > Math.PI / 2 && (posAngle + 2 * Math.PI) % (2 * Math.PI) < 3 * Math.PI / 2) rotateVal=3 * Math.PI - posAngle;
							else rotateVal=2 * Math.PI - posAngle;
						} else rotateVal=setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,-1,{nullValue : true} ) * (Math.PI / 180);
						ctx.rotate(rotateVal);
						setTextBordersAndBackground(ctx,dispString,setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,-1,{nullValue : true} ),0,0,setOptionValue(true,1,"INGRAPHDATABORDERS",ctx,data,statData,undefined,config.inGraphDataBorders,"inGraphDataBorders",i,-1,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSCOLOR",ctx,data,statData,undefined,config.inGraphDataBordersColor,"inGraphDataBordersColor",i,-1,{nullValue : true} ),setOptionValue(true,ctx.chartLineScale,"INGRAPHDATABORDERSWIDTH",ctx,data,statData,undefined,config.inGraphDataBordersWidth,"inGraphDataBordersWidth",i,-1,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSXSPACE",ctx,data,statData,undefined,config.inGraphDataBordersXSpace,"inGraphDataBordersXSpace",i,-1,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSYSPACE",ctx,data,statData,undefined,config.inGraphDataBordersYSpace,"inGraphDataBordersYSpace",i,-1,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSSTYLE",ctx,data,statData,undefined,config.inGraphDataBordersStyle,"inGraphDataBordersStyle",i,-1,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABACKGROUNDCOLOR",ctx,data,statData,undefined,config.inGraphDataBackgroundColor,"inGraphDataBackgroundColor",i,-1,{nullValue : true} ),"INGRAPHDATA",config.inGraphDataBordersRadius);
						ctx.fillTextMultiLine(dispString, 0, 0, ctx.textBaseline, setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,-1,{nullValue : true} ), true,config.detectMouseOnText,ctx,"INGRAPHDATA_TEXTMOUSE",rotateVal,midPosX + labelRadius * Math.cos(posAngle), midPosY - labelRadius * Math.sin(posAngle),i,-1);
						ctx.restore();
					}
				}
			}
			if(msr.legendMsr.dispLegend)drawLegend(msr.legendMsr,data,config,ctx,"PolarArea");
		};

		function drawScale() {
			for (var i = 0; i < calculatedScale.steps; i++) {
				if (config.scaleShowLine && (i+1) % config.scaleGridLinesStep==0) {
					ctx.beginPath();
					ctx.arc(midPosX, midPosY, scaleHop * (i + 1), 4*Math.PI-debAngle, 4*Math.PI-finAngle, true);
					ctx.strokeStyle = config.scaleLineColor;
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleLineWidth);
					ctx.setLineDash(lineStyleFn(config.scaleLineStyle));

					ctx.stroke();
					ctx.setLineDash([]);
				}
				if (config.scaleShowLabels) {

					if(Math.abs(config.totalAmplitude-360)<config.zeroValue)scaleAngle=Math.PI/2;
					else scaleAngle=(debAngle+finAngle)/2;

					ctx.textAlign = "center";
					ctx.font = config.scaleFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.scaleFontSize)).toString() + "px " + config.scaleFontFamily;
					var label = calculatedScale.labels[i + 1];
					if (config.scaleShowLabelBackdrop) {
						var textWidth = ctx.measureTextMultiLine(label, Math.ceil(ctx.chartTextScale*config.scaleFontSize));
						ctx.fillStyle = config.scaleBackdropColor;
						ctx.beginPath();
						ctx.rect(
							Math.round(midPosX + Math.cos(scaleAngle)*(scaleHop*(i+1)) - textWidth / 2 - Math.ceil(ctx.chartSpaceScale*config.scaleBackdropPaddingX)), //X
							Math.round(midPosY - Math.sin(scaleAngle)*(scaleHop * (i + 1)) - (Math.ceil(ctx.chartTextScale*config.scaleFontSize)) * 0.5 - Math.ceil(ctx.chartSpaceScale*config.scaleBackdropPaddingY)), //Y
							Math.round(textWidth + (Math.ceil(ctx.chartSpaceScale*config.scaleBackdropPaddingX) * 2)), //Width
							Math.round((Math.ceil(ctx.chartTextScale*config.scaleFontSize)) + (Math.ceil(ctx.chartSpaceScale*config.scaleBackdropPaddingY) * 2)) //Height
						);
						ctx.fill();
					}
					ctx.textBaseline = "middle";
					ctx.fillStyle = config.scaleFontColor;
					ctx.fillTextMultiLine(label, midPosX + Math.cos(scaleAngle)*(scaleHop*(i+1)) , midPosY - Math.sin(scaleAngle)*(scaleHop * (i + 1)), ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"SCALE_TEXTMOUSE",0,0,0,i,-1);
				}
			}
		};

		function getValueBounds() {
			var upperValue = -Number.MAX_VALUE;
			var lowerValue = Number.MAX_VALUE;
			for (var i = 0; i < data.length; i++) {
				if(typeof data[i].value == "undefined") continue;
				if (1 * data[i].value > upperValue) {
					upperValue = 1 * data[i].value;
				}
				if (1 * data[i].value < lowerValue) {
					lowerValue = 1 * data[i].value;
				}
			};
			if(upperValue<lowerValue){upperValue=0;lowerValue=0;}
			if (Math.abs(upperValue - lowerValue) < config.zeroValue) {
				if(Math.abs(upperValue)< config.zeroValue) upperValue = .9;
				if(upperValue>0) {
					upperValue=upperValue*1.1;
					lowerValue=lowerValue*0.9;
				} else {
					upperValue=upperValue*0.9;
					lowerValue=lowerValue*1.1;
				}
			}
			if(typeof config.graphMin=="function") lowerValue= setOptionValue(true,1,"GRAPHMIN",ctx,data,statData,undefined,config.graphMin,"graphMin",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMin)) lowerValue = config.graphMin;
			if(typeof config.graphMax=="function") upperValue= setOptionValue(true,1,"GRAPHMAX",ctx,data,statData,undefined,config.graphMax,"graphMax",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMax)) upperValue = config.graphMax;
			var maxSteps = Math.floor((scaleHeight / (labelHeight * 0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight * 0.5));
			if(upperValue<lowerValue){lowerValue=upperValue-1;}

			return {
				maxValue: upperValue,
				minValue: lowerValue,
				maxSteps: maxSteps,
				minSteps: minSteps
			};
		};

		return {
			data:data,
			config:config,
			ctx:ctx
		};
	};
	var Radar = function(data, config, ctx) {
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, msr, midPosX, midPosY;

		ctx.tpchart="Radar";
		ctx.tpdata=0;

	        if (!init_and_start(ctx,data,config)) return;
		var statData=initPassVariableData_part1(data,config,ctx);
		valueBounds = getValueBounds();

		config.logarithmic = false;
		config.logarithmic2 = false;
		//If no labels are defined set to an empty array, so referencing length for looping doesn't blow up.
		if (!data.labels) data.labels = [];
		//Check and set the scale
		labelTemplateString = (config.scaleShowLabels) ? config.scaleLabel : "";
		if (!config.scaleOverride) {
			calculatedScale = calculateScale(1, config, valueBounds.maxSteps, valueBounds.minSteps, valueBounds.maxValue, valueBounds.minValue, labelTemplateString);
			msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, calculatedScale.labels, null, true, false, false, true, config.datasetFill, "Radar");
		} else {
			var scaleStartValue= setOptionValue(true,1,"SCALESTARTVALUE",ctx,data,statData,undefined,config.scaleStartValue,"scaleStartValue",-1,-1,{nullValue : true} );
			var scaleSteps =setOptionValue(true,1,"SCALESTEPS",ctx,data,statData,undefined,config.scaleSteps,"scaleSteps",-1,-1,{nullValue : true} );
			var scaleStepWidth = setOptionValue(true,1,"SCALESTEPWIDTH",ctx,data,statData,undefined,config.scaleStepWidth,"scaleStepWidth",-1,-1,{nullValue : true} );
			calculatedScale = {
				steps: scaleSteps,
				stepValue: scaleStepWidth,
				graphMin: scaleStartValue,
				graphMax: scaleStartValue + scaleSteps * scaleStepWidth,
				labels: []
			}
			populateLabels(1, config, labelTemplateString, calculatedScale.labels, calculatedScale.steps, scaleStartValue, calculatedScale.graphMax, scaleStepWidth);
			msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, calculatedScale.labels, null, true, false, false, true, config.datasetFill, "Radar");
		}

		calculateDrawingSizes();
		midPosY = msr.topNotUsableSize + (msr.availableHeight / 2);
		scaleHop = maxSize / (calculatedScale.steps);
		//Wrap in an animation loop wrapper
		initPassVariableData_part2(statData,data,config,ctx,{midPosX : midPosX, midPosY : midPosY, calculatedScale: calculatedScale, scaleHop: scaleHop, maxSize:maxSize,outerVal : -1});
		animationLoop(config, drawScale, drawAllDataPoints, ctx, msr.clrx, msr.clry, msr.clrwidth, msr.clrheight, midPosX, midPosY, midPosX - maxSize, midPosY + maxSize, data, statData);
		//Radar specific functions.
		function drawAllDataPoints(animationDecimal) {
			var rotationDegree = (2 * Math.PI) / data.datasets[0].data.length;
			ctx.save();
			//We accept multiple data sets for radar charts, so show loop through each set
			for (var i = 0; i < data.datasets.length; i++) {
				var fPt = -1;
				for (var j = 0; j < data.datasets[i].data.length; j++) {
					var currentAnimPc = animationCorrection(animationDecimal, data, config, i, j, false).animVal;
					if (currentAnimPc > 1) currentAnimPc = currentAnimPc - 1;
					if (!(typeof(data.datasets[i].data[j]) == 'undefined')) {
						if (fPt == -1) {
							ctx.beginPath();
							ctx.moveTo(midPosX + currentAnimPc * statData[i][j].offsetX, midPosY - currentAnimPc * statData[i][j].offsetY);
							fPt = j;
						} else {
							ctx.lineTo(midPosX + currentAnimPc * statData[i][j].offsetX, midPosY - currentAnimPc * statData[i][j].offsetY);
						}
					}
				}
				ctx.closePath();
				if (config.datasetFill) {
					ctx.fillStyle=setOptionValue(true,1,"COLOR",ctx,data,statData,data.datasets[i].fillColor,config.defaultFillColor,"fillColor",i,-1,{animationValue : currentAnimPc, midPosX : statData[i][0].midPosX, midPosY : statData[i][0].midPosY, ext_radius : (config.animationLeftToRight ? 1 : currentAnimPc) * (statData[i][0].calculated_offset_max)} );
				} else ctx.fillStyle = "rgba(0,0,0,0)";

				ctx.strokeStyle=setOptionValue(true,1,"STROKECOLOR",ctx,data,statData,data.datasets[i].strokeColor,config.defaultStrokeColor,"strokeColor",i,-1,{nullvalue : null} );
				ctx.lineWidth = Math.ceil(ctx.chartLineScale*setOptionValue(true,1,"LINEWIDTH",ctx,data,statData,data.datasets[i].datasetStrokeWidth,config.datasetStrokeWidth,"datasetStrokeWidth",i,-1,{nullvalue : null} ));
				ctx.fill();
				ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"LINEDASH",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
				ctx.stroke();
				ctx.setLineDash([]);
				if (animationDecimal >= config.animationStopValue) {
					ctx.beginPath();

					for (var k = 0; k < data.datasets[i].data.length; k++) {
						if (!(typeof(data.datasets[i].data[k]) == 'undefined')) {
							if(setOptionValue(true,1,"POINTDOT",ctx,data,statData,undefined,config.pointDot,"pointDot",i,k,{nullvalue : null} )) {
								ctx.beginPath();
								ctx.fillStyle=setOptionValue(true,1,"MARKERFILLCOLOR",ctx,data,statData,data.datasets[i].pointColor,config.defaultStrokeColor,"pointColor",i,k,{nullvalue: true} );
								ctx.strokeStyle=setOptionValue(true,1,"MARKERSTROKESTYLE",ctx,data,statData,data.datasets[i].pointStrokeColor,config.defaultStrokeColor,"pointStrokeColor",i,k,{nullvalue: true} );
								ctx.lineWidth=setOptionValue(true,ctx.chartLineScale,"MARKERLINEWIDTH",ctx,data,statData,data.datasets[i].pointDotStrokeWidth,config.pointDotStrokeWidth,"pointDotStrokeWidth",i,k,{nullvalue: true} );
								var markerShape=setOptionValue(true,1,"MARKERSHAPE",ctx,data,statData,data.datasets[i].markerShape,config.markerShape,"markerShape",i,k,{nullvalue: true} );
								var markerRadius=setOptionValue(true,ctx.chartSpaceScale,"MARKERRADIUS",ctx,data,statData,data.datasets[i].pointDotRadius,config.pointDotRadius,"pointDotRadius",i,k,{nullvalue: true} );
								var markerStrokeStyle=setOptionValue(true,1,"MARKERSTROKESTYLE",ctx,data,statData,data.datasets[i].pointDotStrokeStyle,config.pointDotStrokeStyle,"pointDotStrokeStyle",i,k,{nullvalue: true} );
								drawMarker(ctx,midPosX + currentAnimPc * statData[i][k].offsetX, midPosY - currentAnimPc * statData[i][k].offsetY, markerShape,markerRadius,markerStrokeStyle);							
							}
						}
					}
				}
			}
			ctx.restore();
			if (animationDecimal >= config.animationStopValue) {
				for (i = 0; i < data.datasets.length; i++) {
					for (j = 0; j < data.datasets[i].data.length; j++) {
						if (typeof(data.datasets[i].data[j]) == 'undefined') continue;
						jsGraphAnnotate[ctx.ChartNewId][jsGraphAnnotate[ctx.ChartNewId].length] = ["POINT", i,j,statData,setOptionValue(true,1,"ANNOTATEDISPLAY",ctx,data,statData,data.datasets[i].annotateDisplay,config.annotateDisplay,"annotateDisplay",i,j,{nullValue : true})];
						if(setOptionValue(true,1,"INGRAPHDATASHOW",ctx,data,statData,data.datasets[i].inGraphDataShow,config.inGraphDataShow,"inGraphDataShow",i,j,{nullValue : true})) {
							ctx.save();
							ctx.beginPath();
							ctx.textAlign = setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,j,{nullValue: true  });
							ctx.textBaseline = setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,j,{nullValue : true} );
							if (setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,j,{nullValue: true  }) == "off-center") {
								if (setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,j,{nullValue : true} ) == "inRadiusAxis" || (config.startAngle * Math.PI / 180 - j * rotationDegree + 4 * Math.PI) % (2 * Math.PI) > 3 * Math.PI / 2 || (config.startAngle * Math.PI / 180 - j * rotationDegree + 4 * Math.PI) % (2 * Math.PI) <= Math.PI / 2) ctx.textAlign = "left";
								else ctx.textAlign = "right";
							} else if (setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,j,{nullValue: true  }) == "to-center") {
								if (setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,j,{nullValue : true} ) == "inRadiusAxis" || (config.startAngle * Math.PI / 180 - j * rotationDegree + 4 * Math.PI) % (2 * Math.PI) > 3 * Math.PI / 2 || (config.startAngle * Math.PI / 180 - j * rotationDegree + 4 * Math.PI) % (2 * Math.PI) < Math.PI / 2) ctx.textAlign = "right";
								else ctx.textAlign = "left";
							} else ctx.textAlign = setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,j,{nullValue: true  });
							if (setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,j,{nullValue : true} ) == "off-center") {
								if ((config.startAngle * Math.PI / 180 - j * rotationDegree + 4 * Math.PI) % (2 * Math.PI) > Math.PI) ctx.textBaseline = "bottom";
								else ctx.textBaseline = "top";
							} else if (setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,j,{nullValue : true} ) == "to-center") {
								if ((config.startAngle * Math.PI / 180 - j * rotationDegree + 4 * Math.PI) % (2 * Math.PI) > Math.PI) ctx.textBaseline = "top";
								else ctx.textBaseline = "bottom";
							} else ctx.textBaseline = setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,j,{nullValue : true} );
							ctx.font = setOptionValue(true,1,"INGRAPHDATAFONTSTYLE",ctx,data,statData,undefined,config.inGraphDataFontStyle,"inGraphDataFontStyle",i,j,{nullValue : true} ) + ' ' + setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ) + 'px ' + setOptionValue(true,1,"INGRAPHDATAFONTFAMILY",ctx,data,statData,undefined,config.inGraphDataFontFamily,"inGraphDataFontFamily",i,j,{nullValue : true} );
							ctx.fillStyle = setOptionValue(true,1,"INGRAPHDATAFONTCOLOR",ctx,data,statData,undefined,config.inGraphDataFontColor,"inGraphDataFontColor",i,j,{nullValue : true} );
							var radiusPrt;
							if (setOptionValue(true,1,"INGRAPHDATARADIUSPOSITION",ctx,data,statData,undefined,config.inGraphDataRadiusPosition,"inGraphDataRadiusPosition",i,j,{nullValue : true} ) == 1) radiusPrt = 0 + setOptionValue(true,1,"INGRAPHDATAPADDINGRADIUS",ctx,data,statData,undefined,config.inGraphDataPaddingRadius,"inGraphDataPaddingRadius",i,j,{nullValue: true} );
							else if (setOptionValue(true,1,"INGRAPHDATARADIUSPOSITION",ctx,data,statData,undefined,config.inGraphDataRadiusPosition,"inGraphDataRadiusPosition",i,j,{nullValue : true} ) == 2) radiusPrt = (statData[i][j].calculated_offset) / 2 + setOptionValue(true,1,"INGRAPHDATAPADDINGRADIUS",ctx,data,statData,undefined,config.inGraphDataPaddingRadius,"inGraphDataPaddingRadius",i,j,{nullValue: true} );
							else if (setOptionValue(true,1,"INGRAPHDATARADIUSPOSITION",ctx,data,statData,undefined,config.inGraphDataRadiusPosition,"inGraphDataRadiusPosition",i,j,{nullValue : true} ) == 3) radiusPrt = (statData[i][j].calculated_offset) + setOptionValue(true,1,"INGRAPHDATAPADDINGRADIUS",ctx,data,statData,undefined,config.inGraphDataPaddingRadius,"inGraphDataPaddingRadius",i,j,{nullValue: true} );
							var x_pos,y_pos;
							if(statData[i][j].calculated_offset>0) {
							        x_pos=midPosX + statData[i][j].offsetX * (radiusPrt/statData[i][j].calculated_offset);
							        y_pos=midPosY - statData[i][j].offsetY * (radiusPrt/statData[i][j].calculated_offset);
//								ctx.translate(midPosX + statData[i][j].offsetX * (radiusPrt/statData[i][j].calculated_offset), midPosY - statData[i][j].offsetY * (radiusPrt/statData[i][j].calculated_offset));
							} else {
								x_pos=midPosX;
								y_pos=midPosY;
//								ctx.translate(midPosX, midPosY);
							}
							ctx.translate(x_pos,y_pos);
							var rotateVal=0;
							if (setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,j,{nullValue : true} ) == "inRadiusAxis") rotateVal= j * rotationDegree;
							else if (setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,j,{nullValue : true} ) == "inRadiusAxisRotateLabels") {
								if ((j * rotationDegree + 2 * Math.PI) % (2 * Math.PI) > Math.PI / 2 && (j * rotationDegree + 2 * Math.PI) % (2 * Math.PI) < 3 * Math.PI / 2) rotateVal= 3 * Math.PI + j * rotationDegree;
								else rotateVal = 2 * Math.PI + j * rotationDegree;
							} else rotateVal=setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,j,{nullValue : true} ) * (Math.PI / 180);
							ctx.rotate(rotateVal);
							var dispString = tmplbis(setOptionValue(true,1,"INGRAPHDATATMPL",ctx,data,statData,undefined,config.inGraphDataTmpl,"inGraphDataTmpl",i,j,{nullValue : true} ), statData[i][j],config);
							setTextBordersAndBackground(ctx,dispString,setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ),0,0,setOptionValue(true,1,"INGRAPHDATABORDERS",ctx,data,statData,undefined,config.inGraphDataBorders,"inGraphDataBorders",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSCOLOR",ctx,data,statData,undefined,config.inGraphDataBordersColor,"inGraphDataBordersColor",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartLineScale,"INGRAPHDATABORDERSWIDTH",ctx,data,statData,undefined,config.inGraphDataBordersWidth,"inGraphDataBordersWidth",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSXSPACE",ctx,data,statData,undefined,config.inGraphDataBordersXSpace,"inGraphDataBordersXSpace",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSYSPACE",ctx,data,statData,undefined,config.inGraphDataBordersYSpace,"inGraphDataBordersYSpace",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSSTYLE",ctx,data,statData,undefined,config.inGraphDataBordersStyle,"inGraphDataBordersStyle",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABACKGROUNDCOLOR",ctx,data,statData,undefined,config.inGraphDataBackgroundColor,"inGraphDataBackgroundColor",i,j,{nullValue : true} ),"INGRAPHDATA",config.inGraphDataBordersRadius);
							ctx.fillTextMultiLine(dispString, 0, 0, ctx.textBaseline, setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ),true,config.detectMouseOnText,ctx,"INGRAPHDATA_TEXTMOUSE",rotateVal,x_pos,y_pos,i,j);
							ctx.restore();
						}
					}
				}
			}
			if(msr.legendMsr.dispLegend)drawLegend(msr.legendMsr,data,config,ctx,"Radar");
		};

		function drawScale() {
			var rotationDegree = (2 * Math.PI) / data.datasets[0].data.length;
			ctx.save();
			ctx.translate(midPosX, midPosY);
			ctx.rotate((90 - config.startAngle) * Math.PI / 180);
			if (config.angleShowLineOut) {
				ctx.strokeStyle = config.angleLineColor;
				ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.angleLineWidth);
				for (var h = 0; h < data.datasets[0].data.length; h++) {
					ctx.rotate(rotationDegree);
					ctx.beginPath();
					ctx.moveTo(0, 0);
					ctx.lineTo(0, -maxSize);
//					ctx.setLineDash(lineStyleFn(config.angleLineStyle));
					ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"ANGLELINESTYLE",ctx,data,statData,undefined,config.angleLineStyle,"angleLineStyle",h,-1,{nullValue : true} )));
					ctx.stroke();
					ctx.setLineDash([]);
				}
			}
			for (var i = 0; i < calculatedScale.steps; i++) {
				ctx.beginPath();
				if (config.scaleShowLine && (i+1) % config.scaleGridLinesStep == 0 ) {
					ctx.strokeStyle = config.scaleLineColor;
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleLineWidth);
					ctx.moveTo(0, -scaleHop * (i + 1));
					for (var j = 0; j < data.datasets[0].data.length; j++) {
						ctx.rotate(rotationDegree);
						ctx.lineTo(0, -scaleHop * (i + 1));
					}
					ctx.closePath();
					ctx.setLineDash(lineStyleFn(config.scaleLineStyle));
					ctx.stroke();
					ctx.setLineDash([]);
				}
			}
			ctx.rotate(-(90 - config.startAngle) * Math.PI / 180);
			if (config.scaleShowLabels) {
				for (i = 0; i < calculatedScale.steps; i++) {
					ctx.textAlign = 'center';
					ctx.font = config.scaleFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.scaleFontSize)).toString() + "px " + config.scaleFontFamily;
					ctx.textBaseline = "middle";
					if (config.scaleShowLabelBackdrop) {
						var textWidth = ctx.measureTextMultiLine(calculatedScale.labels[i + 1], (Math.ceil(ctx.chartTextScale*config.scaleFontSize))).textWidth;
						ctx.fillStyle = config.scaleBackdropColor;
						ctx.beginPath();
						ctx.rect(
							Math.round(Math.cos(config.startAngle * Math.PI / 180) * (scaleHop * (i + 1)) - textWidth / 2 - Math.ceil(ctx.chartSpaceScale*config.scaleBackdropPaddingX)), //X
							Math.round((-Math.sin(config.startAngle * Math.PI / 180) * scaleHop * (i + 1)) - (Math.ceil(ctx.chartTextScale*config.scaleFontSize)) * 0.5 - Math.ceil(ctx.chartSpaceScale*config.scaleBackdropPaddingY)), //Y
							Math.round(textWidth + (Math.ceil(ctx.chartSpaceScale*config.scaleBackdropPaddingX) * 2)), //Width
							Math.round((Math.ceil(ctx.chartTextScale*config.scaleFontSize)) + (Math.ceil(ctx.chartSpaceScale*config.scaleBackdropPaddingY) * 2)) //Height
						);
						ctx.fill();
					}
					ctx.fillStyle = config.scaleFontColor;
					ctx.fillTextMultiLine(calculatedScale.labels[i + 1], Math.cos(config.startAngle * Math.PI / 180) * (scaleHop * (i + 1)), -Math.sin(config.startAngle * Math.PI / 180) * scaleHop * (i + 1), ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"SCALE_TEXTMOUSE",0,midPosX, midPosY,i,-1);
				}
			}
			for (var k = 0; k < data.labels.length; k++) {
				ctx.font = config.pointLabelFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.pointLabelFontSize)).toString() + "px " + config.pointLabelFontFamily;
				ctx.fillStyle = config.pointLabelFontColor;
				var opposite = Math.sin((90 - config.startAngle) * Math.PI / 180 + rotationDegree * k) * (maxSize + (Math.ceil(ctx.chartTextScale*config.pointLabelFontSize)));
				var adjacent = Math.cos((90 - config.startAngle) * Math.PI / 180 + rotationDegree * k) * (maxSize + (Math.ceil(ctx.chartTextScale*config.pointLabelFontSize)));
				var vangle = (90 - config.startAngle) * Math.PI / 180 + rotationDegree * k;
				while (vangle < 0) vangle = vangle + 2 * Math.PI;
				while (vangle > 2 * Math.PI) vangle = vangle - 2 * Math.PI;
				if (vangle == Math.PI || vangle == 0) {
					ctx.textAlign = "center";
				} else if (vangle > Math.PI) {
					ctx.textAlign = "right";
				} else {
					ctx.textAlign = "left";
				}
				ctx.textBaseline = "middle";
				ctx.fillTextMultiLine(data.labels[k], opposite, -adjacent, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.pointLabelFontSize)),true,config.detectMouseOnText,ctx,"LABEL_TEXTMOUSE",0,midPosX, midPosY,k,-1);
			}
			ctx.restore();
		};

		function calculateDrawingSizes() {
			var midX, mxlb, maxL, maxR, iter, nbiter, prevMaxSize, prevMidX,i,textMeasurement;
			var rotationDegree = (2 * Math.PI) / data.datasets[0].data.length;
			var rotateAngle = config.startAngle * Math.PI / 180;
			// Compute range for Mid Point of graph
			ctx.font = config.pointLabelFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.pointLabelFontSize)).toString() + "px " + config.pointLabelFontFamily;
			if (!config.graphMaximized) {
				maxR = msr.availableWidth / 2;
				maxL = msr.availableWidth / 2;
				nbiter = 1;
			} else {
				maxR = msr.availableWidth / 2;
				maxL = msr.availableWidth / 2;
				nbiter = 40;
				for (i = 0; i < data.labels.length; i++) {
					textMeasurement = ctx.measureTextMultiLine(data.labels[i], (Math.ceil(ctx.chartTextScale*config.scaleFontSize))).textWidth + ctx.measureTextMultiLine(data.labels[i], (Math.ceil(ctx.chartTextScale*config.scaleFontSize))).textHeight;
					mxlb = (msr.availableWidth - textMeasurement) / (1 + Math.abs(Math.cos(rotateAngle)));
					if ((rotateAngle < Math.PI / 2 && rotateAngle > -Math.PI / 2) || rotateAngle > 3 * Math.PI / 2) {
						if (mxlb < maxR) maxR = mxlb;
					} else if (Math.cos(rotateAngle) != 0) {
						if (mxlb < maxL) maxL = mxlb;
					}
					rotateAngle -= rotationDegree;
				}
			}
			// compute max Radius and midPoint in that range
			prevMaxSize = 0;
			prevMidX = 0;
			midPosX = maxR + msr.leftNotUsableSize;
			for (midX = maxR, iter = 0; iter < nbiter; ++iter, midX += (msr.availableWidth - maxL - maxR) / nbiter) {
				maxSize = Max([midX, msr.availableWidth - midX]);
				rotateAngle = config.startAngle * Math.PI / 180;
				mxlb = msr.available;
				for (i = 0; i < data.labels.length; i++) {
					textMeasurement = ctx.measureTextMultiLine(data.labels[i], (Math.ceil(ctx.chartTextScale*config.scaleFontSize))).textWidth + ctx.measureTextMultiLine(data.labels[i], (Math.ceil(ctx.chartTextScale*config.scaleFontSize))).textHeight;
					if ((rotateAngle < Math.PI / 2 && rotateAngle > -Math.PI / 2) || rotateAngle > 3 * Math.PI / 2) {
						mxlb = ((msr.availableWidth - midX) - textMeasurement) / Math.abs(Math.cos(rotateAngle));
					} else if (Math.cos(rotateAngle != 0)) {
						mxlb = (midX - textMeasurement) / Math.abs(Math.cos(rotateAngle));
					}
					if (mxlb < maxSize) maxSize = mxlb;
					if (Math.sin(rotateAngle) * msr.availableHeight / 2 > msr.availableHeight / 2 - (Math.ceil(ctx.chartTextScale*config.scaleFontSize)) * 2) {
						mxlb = Math.sin(rotateAngle) * msr.availableHeight / 2 - 1.5 * (Math.ceil(ctx.chartTextScale*config.scaleFontSize));
						if (mxlb < maxSize) maxSize = mxlb;
					}
					rotateAngle -= rotationDegree;
				}
				if (maxSize > prevMaxSize) {
					prevMaxSize = maxSize;
					midPosX = midX + msr.leftNotUsableSize;    
				}
			}
			maxSize = prevMaxSize - (Math.ceil(ctx.chartTextScale*config.scaleFontSize)) / 2;
			//If the label height is less than 5, set it to 5 so we don't have lines on top of each other.
			labelHeight = Default(labelHeight, 5);
		};

		function getValueBounds() {
			var upperValue = -Number.MAX_VALUE;
			var lowerValue = Number.MAX_VALUE;
			for (var i = 0; i < data.datasets.length; i++) {
				for (var j = 0; j < data.datasets[i].data.length; j++) {
					if(typeof data.datasets[i].data[j]=="undefined")continue;
					if (1 * data.datasets[i].data[j] > upperValue) {
						upperValue = 1 * data.datasets[i].data[j]
					}
					if (1 * data.datasets[i].data[j] < lowerValue) {
						lowerValue = 1 * data.datasets[i].data[j]
					}
				}
			}
			if(upperValue<lowerValue){upperValue=0;lowerValue=0;}
			if (Math.abs(upperValue - lowerValue) < config.zeroValue) {
				if(Math.abs(upperValue)< config.zeroValue){ upperValue = .9;lowerValue=-.9;}
				if(upperValue>0) {
					upperValue=upperValue*1.1;
					lowerValue=lowerValue*0.9;
				} else {
					upperValue=upperValue*0.9;
					lowerValue=lowerValue*1.1;
				}
			}
			if(typeof config.graphMin=="function") lowerValue= setOptionValue(true,1,"GRAPHMIN",ctx,data,statData,undefined,config.graphMin,"graphMin",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMin)) lowerValue = config.graphMin;
			if(typeof config.graphMax=="function") upperValue= setOptionValue(true,1,"GRAPHMAX",ctx,data,statData,undefined,config.graphMax,"graphMax",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMax)) upperValue = config.graphMax;
			var maxSteps = Math.floor((scaleHeight / (labelHeight * 0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight * 0.5));
			if(upperValue<lowerValue){lowerValue=upperValue-1;}
			return {
				maxValue: upperValue,
				minValue: lowerValue,
				maxSteps: maxSteps,
				minSteps: minSteps
			};
		};

		return {
			data:data,
			config:config,
			ctx:ctx
		};
	};


	var Pie = function(data, config, ctx) {
		var msr, midPieX, midPieY, pieRadius;
		ctx.tpchart="Pie";
		return(Doughnut(data,config,ctx));
	};
	
	var Doughnut = function(data, config, ctx) {
		var msr, midPieX, midPieY, doughnutRadius;

		if(typeof ctx.tpchart == "undefined")ctx.tpchart="Doughnut";
		ctx.tpdata=1;


	        if (!init_and_start(ctx,data,config)) return;

		var statData=initPassVariableData_part1(data,config,ctx);

		var realCumulativeAngle = (((config.startAngle * (Math.PI / 180) + 2 * Math.PI) % (2 * Math.PI)) + 2* Math.PI) % (2* Math.PI) ; 
		config.logarithmic = false;
		config.logarithmic2 = false;
		msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, "none", null, true, false, false, false, true, "Doughnut");

		var drwSize=calculatePieDrawingSize(ctx,msr,config,data,statData);

		midPieX=drwSize.midPieX;
		midPieY=drwSize.midPieY;
		doughnutRadius=drwSize.radius;
		
		var cutoutRadius;
                if(ctx.tpchart == "Pie")cutoutRadius=0;
		else cutoutRadius = doughnutRadius * (config.percentageInnerCutout / 100);
		if(doughnutRadius > 0) {
			initPassVariableData_part2(statData,data,config,ctx,{midPosX : midPieX,midPosY : midPieY ,int_radius : cutoutRadius ,ext_radius : doughnutRadius,outerVal : -1});
			animationLoop(config, null, drawPieSegments, ctx, msr.clrx, msr.clry, msr.clrwidth, msr.clrheight, midPieX, midPieY, midPieX - doughnutRadius, midPieY + doughnutRadius, data, statData);
		} else {
			testRedraw(ctx,data,config);
			ctx.firstPass=9;
		}


		function drawPieSegments(animationDecimal) {
			var cumulativeAngle = (((-config.startAngle * (Math.PI / 180) + 2 * Math.PI) % (2 * Math.PI)) + 2* Math.PI) % (2* Math.PI) ; 

			var dataCutoutRadius, dataDoughnutRadius;

			var prevAngle=statData[0].firstAngle;

			var fixAngle=0;
			var firstAngle=statData[0].firstAngle;
			if(1*config.animationStartWithData>1 && 1*config.animationStartWithData-1 < data.length) {
				fixAngle=(statData[config.animationStartWithData-1].startAngle-statData[0].firstAngle);
				firstAngle=statData[config.animationStartWithData-1].startAngle;
			}
			
						
			for (var i = 0; i < data.length; i++) {
				var	scaleAnimation = 1,
					rotateAnimation = 1;
				if (ctx.tpchart=="Pie")dataCutoutRadius=cutoutRadius;
				else dataCutoutRadius=cutoutRadius-(doughnutRadius-cutoutRadius)*setOptionValue(true,1,"EXPANDINRADIUS",ctx,data,statData,data[i].expandInRadius,0,"expandInRadius",i,-1,{animationDecimal: animationDecimal, scaleAnimation : scaleAnimation} );
                	        dataDoughnutRadius=doughnutRadius+(doughnutRadius-cutoutRadius)*setOptionValue(true,1,"EXPANDOUTRADIUS",ctx,data,statData,data[i].expandOutRadius,0,"expandOutRadius",i,-1,{animationDecimal: animationDecimal, scaleAnimation : scaleAnimation} );
				if (config.animation) {
					if (config.animateScale) {
						scaleAnimation = animationDecimal;
					}
					if (config.animateRotate) {
						rotateAnimation = animationDecimal;
					}
				}

				correctedRotateAnimation = animationCorrection(rotateAnimation, data, config, i, -1, false).mainVal;
				if (!(typeof(data[i].value) == 'undefined') && 1*data[i].value >=0) {
					ctx.beginPath();
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.segmentStrokeWidth);
					ctx.strokeStyle = "rgba(0,0,0,0)";
					if (config.animationByData == "ByArc") {
						endAngle=statData[i].startAngle+correctedRotateAnimation*statData[i].segmentAngle;
						ctx.arc(midPieX, midPieY, scaleAnimation * dataDoughnutRadius, statData[i].startAngle, endAngle,false);
						ctx.arc(midPieX, midPieY, scaleAnimation * dataCutoutRadius, endAngle,statData[i].startAngle, true);
					} else if(config.animationByData) {
					        if (i<1*config.animationStartWithData-1) {
							ctx.arc(midPieX, midPieY, scaleAnimation * dataDoughnutRadius, statData[i].startAngle, statData[i].endAngle,false);
							ctx.arc(midPieX, midPieY, scaleAnimation * dataCutoutRadius, statData[i].endAngle,statData[i].startAngle, true);
						} else if(statData[i].startAngle <= firstAngle+correctedRotateAnimation*(2*Math.PI-fixAngle) ) {
							endAngle=statData[i].endAngle;
							if(statData[i].endAngle > firstAngle+correctedRotateAnimation*(2*Math.PI-fixAngle)) {
								endAngle=firstAngle+correctedRotateAnimation*(2*Math.PI-fixAngle);
							} 
							ctx.arc(midPieX, midPieY, scaleAnimation * dataDoughnutRadius, statData[i].startAngle, endAngle,false);
							ctx.arc(midPieX, midPieY, scaleAnimation * dataCutoutRadius, endAngle,statData[i].startAngle, true);
														
						} else {
							continue; 
						}
					} else {
						ctx.arc(midPieX, midPieY, scaleAnimation * dataDoughnutRadius, prevAngle, prevAngle+correctedRotateAnimation * (statData[i].endAngle-statData[i].startAngle),false);
						ctx.arc(midPieX, midPieY, scaleAnimation * dataCutoutRadius, prevAngle+correctedRotateAnimation * (statData[i].endAngle-statData[i].startAngle), prevAngle, true);
						prevAngle=prevAngle+correctedRotateAnimation * (statData[i].endAngle-statData[i].startAngle);
					}
					ctx.closePath();  
					ctx.fillStyle=setOptionValue(true,1,"COLOR",ctx,data,statData,data[i].color,config.defaultFillColor,"color",i,-1,{animationDecimal: animationDecimal, scaleAnimation : scaleAnimation} );
					ctx.fill();
					if(config.segmentShowStroke=="merge") { /* avoid blank stripes between piece of chart */
						ctx.lineWidth =1.5;
						ctx.strokeStyle =setOptionValue(true,1,"COLOR",ctx,data,statData,data[i].color,config.defaultFillColor,"color",i,-1,{animationDecimal: animationDecimal, scaleAnimation : scaleAnimation} );
						ctx.setLineDash([]);
						ctx.stroke();
					}
					else if (config.segmentShowStroke) {
						ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.segmentStrokeWidth);
						ctx.strokeStyle = config.segmentStrokeColor;
						ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"SEGMENTSTROKESTYLE",ctx,data,statData,data[i].segmentStrokeStyle,config.segmentStrokeStyle,"segmentStrokeStyle",i,-1,{animationDecimal: animationDecimal, scaleAnimation : scaleAnimation} )));
						ctx.stroke();					 
						ctx.setLineDash([]);
					}
				}
			}
			if (animationDecimal >= config.animationStopValue) {
				for (i = 0; i < data.length; i++) {
					if (ctx.tpchart=="Pie")dataCutOutRadius=cutoutRadius;
					else dataCutoutRadius=cutoutRadius-(doughnutRadius-cutoutRadius)*setOptionValue(true,1,"EXPANDINRADIUS",ctx,data,statData,data[i].expandInRadius,0,"expandInRadius",i,-1,{animationDecimal: animationDecimal, scaleAnimation : scaleAnimation} );
        	        	        dataDoughnutRadius=doughnutRadius+(doughnutRadius-cutoutRadius)*setOptionValue(true,1,"EXPANDOUTRADIUS",ctx,data,statData,data[i].expandOutRadius,0,"expandOutRadius",i,-1,{animationDecimal: animationDecimal, scaleAnimation : scaleAnimation} );
					if (typeof(data[i].value) == 'undefined' || 1*data[i].value<0) continue;
					jsGraphAnnotate[ctx.ChartNewId][jsGraphAnnotate[ctx.ChartNewId].length] = ["ARC", i,-1,statData,setOptionValue(true,1,"ANNOTATEDISPLAY",ctx,data,statData,data[i].annotateDisplay,config.annotateDisplay,"annotateDisplay",i,-1,{nullValue : true})];
					if (setOptionValue(true,1,"INGRAPHDATASHOW",ctx,data,statData,data[i].inGraphDataShow,config.inGraphDataShow,"inGraphDataShow",i,-1,{nullValue : true}) && statData[i].segmentAngle >= (Math.PI/180) * setOptionValue(true,1,"INGRAPHDATAMINIMUMANGLE",ctx,data,statData,undefined,config.inGraphDataMinimumAngle,"inGraphDataMinimumAngle",i,-1,{nullValue : true} )) {
						if (setOptionValue(true,1,"INGRAPHDATAANGLEPOSITION",ctx,data,statData,undefined,config.inGraphDataAnglePosition,"inGraphDataAnglePosition",i,-1,{nullValue : true} ) == 1) posAngle = statData[i].realStartAngle + setOptionValue(true,1,"INGRAPHDATAPADDINANGLE",ctx,data,statData,undefined,config.inGraphDataPaddingAngle,"inGraphDataPaddingAngle",i,-1,{nullValue: true  }) * (Math.PI / 180);
						else if (setOptionValue(true,1,"INGRAPHDATAANGLEPOSITION",ctx,data,statData,undefined,config.inGraphDataAnglePosition,"inGraphDataAnglePosition",i,-1,{nullValue : true} ) == 2) posAngle = statData[i].realStartAngle- statData[i].segmentAngle / 2 + setOptionValue(true,1,"INGRAPHDATAPADDINANGLE",ctx,data,statData,undefined,config.inGraphDataPaddingAngle,"inGraphDataPaddingAngle",i,-1,{nullValue: true  }) * (Math.PI / 180);
						else if (setOptionValue(true,1,"INGRAPHDATAANGLEPOSITION",ctx,data,statData,undefined,config.inGraphDataAnglePosition,"inGraphDataAnglePosition",i,-1,{nullValue : true} ) == 3) posAngle = statData[i].realStartAngle - statData[i].segmentAngle + setOptionValue(true,1,"INGRAPHDATAPADDINANGLE",ctx,data,statData,undefined,config.inGraphDataPaddingAngle,"inGraphDataPaddingAngle",i,-1,{nullValue: true  }) * (Math.PI / 180);
						if (setOptionValue(true,1,"INGRAPHDATARADIUSPOSITION",ctx,data,statData,undefined,config.inGraphDataRadiusPosition,"inGraphDataRadiusPosition",i,-1,{nullValue : true} ) == 1) labelRadius = dataCutoutRadius + setOptionValue(true,1,"INGRAPHDATAPADDINGRADIUS",ctx,data,statData,undefined,config.inGraphDataPaddingRadius,"inGraphDataPaddingRadius",i,-1,{nullValue: true} );
						else if (setOptionValue(true,1,"INGRAPHDATARADIUSPOSITION",ctx,data,statData,undefined,config.inGraphDataRadiusPosition,"inGraphDataRadiusPosition",i,-1,{nullValue : true} ) == 2) labelRadius = dataCutoutRadius + (dataDoughnutRadius - dataCutoutRadius) / 2 + setOptionValue(true,1,"INGRAPHDATAPADDINGRADIUS",ctx,data,statData,undefined,config.inGraphDataPaddingRadius,"inGraphDataPaddingRadius",i,-1,{nullValue: true} );
						else if (setOptionValue(true,1,"INGRAPHDATARADIUSPOSITION",ctx,data,statData,undefined,config.inGraphDataRadiusPosition,"inGraphDataRadiusPosition",i,-1,{nullValue : true} ) == 3) labelRadius = dataDoughnutRadius + setOptionValue(true,1,"INGRAPHDATAPADDINGRADIUS",ctx,data,statData,undefined,config.inGraphDataPaddingRadius,"inGraphDataPaddingRadius",i,-1,{nullValue: true} );
						ctx.save();
						if (setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,-1,{nullValue: true  }) == "off-center") {
							if (setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,-1,{nullValue : true} ) == "inRadiusAxis" || (posAngle + 2 * Math.PI) % (2 * Math.PI) >= 3 * Math.PI / 2 || (posAngle + 2 * Math.PI) % (2 * Math.PI) <= Math.PI / 2) ctx.textAlign = "left";
							else ctx.textAlign = "right";
						} else if (setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,-1,{nullValue: true  }) == "to-center") {
							if (setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,-1,{nullValue : true} ) == "inRadiusAxis" || (posAngle + 2 * Math.PI) % (2 * Math.PI) >= 3 * Math.PI / 2 || (posAngle + 2 * Math.PI) % (2 * Math.PI) <= Math.PI / 2) ctx.textAlign = "right";
							else ctx.textAlign = "left";
						} else ctx.textAlign = setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,-1,{nullValue: true  });
						if (setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,-1,{nullValue : true} ) == "off-center") {
							if ((posAngle + 2 * Math.PI) % (2 * Math.PI) > Math.PI) ctx.textBaseline = "top";
							else ctx.textBaseline = "bottom";
						} else if (setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,-1,{nullValue : true} ) == "to-center") {
							if ((posAngle + 2 * Math.PI) % (2 * Math.PI) > Math.PI) ctx.textBaseline = "bottom";
							else ctx.textBaseline = "top";
						} else ctx.textBaseline = setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,-1,{nullValue : true} );
						ctx.font = setOptionValue(true,1,"INGRAPHDATAFONTSTYLE",ctx,data,statData,undefined,config.inGraphDataFontStyle,"inGraphDataFontStyle",i,-1,{nullValue : true} ) + ' ' + setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,-1,{nullValue : true} ) + 'px ' + setOptionValue(true,1,"INGRAPHDATAFONTFAMILY",ctx,data,statData,undefined,config.inGraphDataFontFamily,"inGraphDataFontFamily",i,-1,{nullValue : true} );
						ctx.fillStyle = setOptionValue(true,1,"INGRAPHDATAFONTCOLOR",ctx,data,statData,undefined,config.inGraphDataFontColor,"inGraphDataFontColor",i,-1,{nullValue : true} );
						var dispString = tmplbis(setOptionValue(true,1,"INGRAPHDATATMPL",ctx,data,statData,undefined,config.inGraphDataTmpl,"inGraphDataTmpl",i,-1,{nullValue : true} ), statData[i],config);
						ctx.translate(midPieX + labelRadius * Math.cos(posAngle), midPieY - labelRadius * Math.sin(posAngle));
						var rotateVal=0;
						if (setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,-1,{nullValue : true} ) == "inRadiusAxis") rotateVal=2 * Math.PI - posAngle;
						else if (setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,-1,{nullValue : true} ) == "inRadiusAxisRotateLabels") {
							if ((posAngle + 2 * Math.PI) % (2 * Math.PI) > Math.PI / 2 && (posAngle + 2 * Math.PI) % (2 * Math.PI) < 3 * Math.PI / 2) rotateVal=3 * Math.PI - posAngle;
							else rotateVal=2 * Math.PI - posAngle;
						} else rotateVal=setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,-1,{nullValue : true} ) * (Math.PI / 180);
						ctx.rotate(rotateVal);
						setTextBordersAndBackground(ctx,dispString,setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,-1,{nullValue : true} ),0,0,setOptionValue(true,1,"INGRAPHDATABORDERS",ctx,data,statData,undefined,config.inGraphDataBorders,"inGraphDataBorders",i,-1,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSCOLOR",ctx,data,statData,undefined,config.inGraphDataBordersColor,"inGraphDataBordersColor",i,-1,{nullValue : true} ),setOptionValue(true,ctx.chartLineScale,"INGRAPHDATABORDERSWIDTH",ctx,data,statData,undefined,config.inGraphDataBordersWidth,"inGraphDataBordersWidth",i,-1,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSXSPACE",ctx,data,statData,undefined,config.inGraphDataBordersXSpace,"inGraphDataBordersXSpace",i,-1,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSYSPACE",ctx,data,statData,undefined,config.inGraphDataBordersYSpace,"inGraphDataBordersYSpace",i,-1,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSSTYLE",ctx,data,statData,undefined,config.inGraphDataBordersStyle,"inGraphDataBordersStyle",i,-1,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABACKGROUNDCOLOR",ctx,data,statData,undefined,config.inGraphDataBackgroundColor,"inGraphDataBackgroundColor",i,-1,{nullValue : true} ),"INGRAPHDATA",config.inGraphDataBordersRadius);
						ctx.fillTextMultiLine(dispString, 0, 0, ctx.textBaseline, setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,-1,{nullValue : true} ),true,config.detectMouseOnText,ctx,"INGRAPHDATA_TEXTMOUSE",rotateVal,midPieX + labelRadius * Math.cos(posAngle), midPieY - labelRadius * Math.sin(posAngle),i,-1);
						ctx.restore();
					}
				}
			}
			if(msr.legendMsr.dispLegend)drawLegend(msr.legendMsr,data,config,ctx,"Doughnut");
		};
		
		return {
			data:data,
			config:config,
			ctx:ctx
		};
	};
	var Line = function(data, config, ctx) {
		var maxSize, scaleHop, scaleHop2, calculatedScale, calculatedScale2, labelHeight, scaleHeight, valueBounds, labelTemplateString, labelTemplateString2;
		var valueHop, widestXLabel, xAxisLength, yAxisPosX, xAxisPosY, rotateLabels = 0,
			msr;
		var zeroY = 0;
		var zeroY2 = 0;
		ctx.tpchart="Line";
		ctx.tpdata=0;

	        if (!init_and_start(ctx,data,config)) return;
		// adapt data when length is 1;
		var mxlgt = 0;
		for (var i = 0; i < data.datasets.length; i++) {mxlgt = Max([mxlgt, data.datasets[i].data.length]);}
		if (mxlgt == 1) {
			if (typeof(data.labels[0]) == "string") data.labels = ["", data.labels[0], ""];
			for (i = 0; i < data.datasets.length; i++) {
				if (typeof(data.datasets[i].data[0] != "undefined")) data.datasets[i].data = [undefined, data.datasets[i].data[0], undefined];
			}
			mxlgt=3;
		}
		var statData=initPassVariableData_part1(data,config,ctx);
		for (i = 0; i < data.datasets.length; i++) statData[i][0].tpchart="Line";
		msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, "nihil", [""], false, false, true, true, config.datasetFill, "Line");
		valueBounds = getValueBounds();
		// true or fuzzy (error for negativ values (included 0))
		if (config.logarithmic !== false) {
			if (valueBounds.minValue <= 0) {
				config.logarithmic = false;
			}
		}
		if (config.logarithmic2 !== false) {
			if (valueBounds.minValue2 <= 0) {
				config.logarithmic2 = false;
			}
		}
		// Check if logarithmic is meanigful
		var OrderOfMagnitude = calculateOrderOfMagnitude(Math.pow(10, calculateOrderOfMagnitude(valueBounds.maxValue) + 1)) - calculateOrderOfMagnitude(Math.pow(10, calculateOrderOfMagnitude(valueBounds.minValue)));
		if ((config.logarithmic == 'fuzzy' && OrderOfMagnitude < 4) || config.scaleOverride) {
			config.logarithmic = false;
		}
		// Check if logarithmic is meanigful
		var OrderOfMagnitude2 = calculateOrderOfMagnitude(Math.pow(10, calculateOrderOfMagnitude(valueBounds.maxValue2) + 1)) - calculateOrderOfMagnitude(Math.pow(10, calculateOrderOfMagnitude(valueBounds.minValue2)));
		if ((config.logarithmic2 == 'fuzzy' && OrderOfMagnitude2 < 4) || config.scaleOverride2) {
			config.logarithmic2 = false;
		}
		//Check and set the scale
		labelTemplateString = (config.scaleShowLabels) ? config.scaleLabel : "";
		labelTemplateString2 = (config.scaleShowLabels2) ? config.scaleLabel2 : "";
		if (!config.scaleOverride) {
			if(valueBounds.maxSteps>0 && valueBounds.minSteps>0) {
				calculatedScale = calculateScale(1, config, valueBounds.maxSteps, valueBounds.minSteps, valueBounds.maxValue, valueBounds.minValue, labelTemplateString);
			}
		} else {
			var scaleStartValue= setOptionValue(true,1,"SCALESTARTVALUE",ctx,data,statData,undefined,config.scaleStartValue,"scaleStartValue",-1,-1,{nullValue : true} );
			var scaleSteps =setOptionValue(true,1,"SCALESTEPS",ctx,data,statData,undefined,config.scaleSteps,"scaleSteps",-1,-1,{nullValue : true} );
			var scaleStepWidth = setOptionValue(true,1,"SCALESTEPWIDTH",ctx,data,statData,undefined,config.scaleStepWidth,"scaleStepWidth",-1,-1,{nullValue : true} );
			calculatedScale = {
				steps: scaleSteps,
				stepValue: scaleStepWidth,
				graphMin: scaleStartValue,
				graphMax: scaleStartValue + scaleSteps * scaleStepWidth,
				labels: []
			}
			populateLabels(1, config, labelTemplateString, calculatedScale.labels, calculatedScale.steps, scaleStartValue, calculatedScale.graphMax, scaleStepWidth);
		}

		if (valueBounds.dbAxis) {
			if (!config.scaleOverride2) {
				if(valueBounds.maxSteps>0 && valueBounds.minSteps>0) {
					calculatedScale2 = calculateScale(2, config, valueBounds.maxSteps, valueBounds.minSteps, valueBounds.maxValue2, valueBounds.minValue2, labelTemplateString2);
				}
			} else {
				var scaleStartValue2= setOptionValue(true,1,"SCALESTARTVALUE2",ctx,data,statData,undefined,config.scaleStartValue2,"scaleStartValue2",-1,-1,{nullValue : true} );
				var scaleSteps2 =setOptionValue(true,1,"SCALESTEPS2",ctx,data,statData,undefined,config.scaleSteps2,"scaleSteps2",-1,-1,{nullValue : true} );
				var scaleStepWidth2 = setOptionValue(true,1,"SCALESTEPWIDTH2",ctx,data,statData,undefined,config.scaleStepWidth2,"scaleStepWidth2",-1,-1,{nullValue : true} );

				calculatedScale2 = {
					steps: scaleSteps2,
					stepValue: scaleStepWidth2,
					graphMin: scaleStartValue2,
					graphMax: scaleStartValue2 + scaleSteps2 * scaleStepWidth2,
					labels: []
				}
				populateLabels(2, config, labelTemplateString2, calculatedScale2.labels, calculatedScale2.steps, scaleStartValue2, calculatedScale2.graphMax, scaleStepWidth2);
			}
		} else {
			calculatedScale2 = {
				steps: 0,
				stepValue: 0,
				graphMin: 0,
				graphMax: 0,
				labels: null
			}
		}
		if(valueBounds.maxSteps>0 && valueBounds.minSteps>0) {
			msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, calculatedScale.labels, calculatedScale2.labels, false, false, true, true, config.datasetFill, "Line");
			var prevHeight=msr.availableHeight;
			msr.availableHeight = msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom) - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop);
			msr.availableWidth = msr.availableWidth - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft) - Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight);
			scaleHop = Math.floor(msr.availableHeight / calculatedScale.steps);
			scaleHop2 = Math.floor(msr.availableHeight / calculatedScale2.steps);
			valueHop = Math.floor(msr.availableWidth / (data.labels.length - 1));
			if (valueHop == 0 || config.fullWidthGraph) valueHop = (msr.availableWidth / (data.labels.length - 1));
			msr.clrwidth = msr.clrwidth - (msr.availableWidth - (data.labels.length - 1) * valueHop);
			msr.availableWidth = (data.labels.length - 1) * valueHop;
			msr.availableHeight = (calculatedScale.steps) * scaleHop;
			msr.xLabelPos+=(Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom) + Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop) - (prevHeight-msr.availableHeight));
			msr.clrheight+=(Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom) + Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop) - (prevHeight-msr.availableHeight));
  			yAxisPosX = msr.leftNotUsableSize + Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft);
			xAxisPosY = msr.topNotUsableSize + msr.availableHeight + Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop);
			drawLabels();

			zeroY = calculateOffset(config.logarithmic, 0, calculatedScale, scaleHop);
			if(typeof calculatedScale2 ==="object")zeroY2 = calculateOffset(config.logarithmic2, 0, calculatedScale2, scaleHop2);
			initPassVariableData_part2(statData,data,config,ctx,{
				xAxisPosY : xAxisPosY,
				yAxisPosX : yAxisPosX,
				valueHop : valueHop,
				nbValueHop : data.labels.length - 1,
				scaleHop : scaleHop,
				zeroY : zeroY,
				calculatedScale : calculatedScale,
				logarithmic  : config.logarithmic,
				scaleHop2: scaleHop2,
				zeroY2: zeroY2,
				msr : msr,
				calculatedScale2: calculatedScale2,
				logarithmic2: config.logarithmic2} );
			animationLoop(config, drawScale, drawLines, ctx, msr.clrx, msr.clry, msr.clrwidth, msr.clrheight, yAxisPosX + msr.availableWidth / 2, xAxisPosY - msr.availableHeight / 2, yAxisPosX, xAxisPosY, data, statData);
		} else {
			testRedraw(ctx,data,config);
			ctx.firstPass=9;
		}


		function drawLines(animPc) {
		
			drawLinesDataset(animPc, data, config, ctx, statData,{xAxisPosY : xAxisPosY,yAxisPosX : yAxisPosX, valueHop : valueHop, nbValueHop : data.labels.length - 1 });
			if (animPc >= 1) {
				if (typeof drawMath == "function") {
					drawMath(ctx, config, data, msr, {
						xAxisPosY: xAxisPosY,
						yAxisPosX: yAxisPosX,
						valueHop: valueHop,
						scaleHop: scaleHop,
						zeroY: zeroY,
						calculatedScale: calculatedScale,
						calculateOffset: calculateOffset,
						statData : statData

					});
				}
			}
			if(msr.legendMsr.dispLegend)drawLegend(msr.legendMsr,data,config,ctx,"Line");
		};

		function drawScale() {
			//X axis line
			// if the xScale should be drawn
			if (config.drawXScaleLine !== false) {
				for (var s = 0; s < config.drawXScaleLine.length; s++) {
					// get special lineWidth and lineColor for this xScaleLine
					ctx.lineWidth = config.drawXScaleLine[s].lineWidth ? config.drawXScaleLine[s].lineWidth : Math.ceil(ctx.chartLineScale*config.scaleLineWidth);
					ctx.strokeStyle = config.drawXScaleLine[s].lineColor ? config.drawXScaleLine[s].lineColor : config.scaleLineColor;
					ctx.beginPath();
					var yPosXScale;
					switch (config.drawXScaleLine[s].position) {
						case "bottom":
							yPosXScale = xAxisPosY;
							break;
						case "top":
							yPosXScale = xAxisPosY - msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop);
							break;
						case "0":
						case 0:
							// check if zero exists
							if (zeroY != 0) yPosXScale = xAxisPosY - zeroY;
							break;
					}
					// draw the scale line
					ctx.moveTo(yAxisPosX - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft), yPosXScale);
					ctx.lineTo(yAxisPosX + msr.availableWidth + Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight), yPosXScale);
					ctx.setLineDash(lineStyleFn(config.scaleLineStyle));
					ctx.stroke();
					ctx.setLineDash([]);
 
				}
			}
			for (var i = 0; i < data.labels.length; i++) {
				ctx.beginPath();
				ctx.moveTo(yAxisPosX + i * valueHop, xAxisPosY + Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom));
				ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth);
				ctx.strokeStyle = config.scaleGridLineColor;
				//Check i isnt 0, so we dont go over the Y axis twice.
				if (config.scaleShowGridLines && i > 0 && i % config.scaleXGridLinesStep == 0) {
					ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY - msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop));
				} else {
					ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY);
				}
				ctx.setLineDash(lineStyleFn(config.scaleGridLineStyle));
				ctx.stroke();
            			ctx.setLineDash([]);
            			
			}
			//Y axis
			ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleLineWidth);
			ctx.strokeStyle = config.scaleLineColor;
			ctx.beginPath();
			ctx.moveTo(yAxisPosX, xAxisPosY + Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom));
			ctx.lineTo(yAxisPosX, xAxisPosY - msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop));
			ctx.setLineDash(lineStyleFn(config.scaleLineStyle));
			ctx.stroke();
			ctx.setLineDash([]);
			for (var j = 0; j < calculatedScale.steps; j++) {
				ctx.beginPath();
				ctx.moveTo(yAxisPosX - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft), xAxisPosY - ((j + 1) * scaleHop));
				ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth);
				ctx.strokeStyle = config.scaleGridLineColor;
				if (config.scaleShowGridLines && (j+1) % config.scaleYGridLinesStep == 0) {
					ctx.lineTo(yAxisPosX + msr.availableWidth + Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight), xAxisPosY - ((j + 1) * scaleHop));
				} else {
					ctx.lineTo(yAxisPosX, xAxisPosY - ((j + 1) * scaleHop));
				}
				ctx.setLineDash(lineStyleFn(config.scaleGridLineStyle));
				ctx.stroke();
            			ctx.setLineDash([]);
			}
		};

		function drawLabels() {
			ctx.font = config.scaleFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.scaleFontSize)).toString() + "px " + config.scaleFontFamily;
			//X Labels     
			if (config.xAxisTop || config.xAxisBottom) {
				ctx.textBaseline = "top";
				if (msr.rotateLabels > 90) {
					ctx.save();
					ctx.textAlign = "left";
				} else if (msr.rotateLabels > 0) {
					ctx.save();
					ctx.textAlign = "right";
				} else {
					ctx.textAlign = "center";
				}
				ctx.fillStyle = config.scaleFontColor;
				if (config.xAxisBottom) {
					for (var i = 0; i < data.labels.length; i++) {
						if(showLabels(ctx,data,config,i)){
							ctx.save();
							if (msr.rotateLabels > 0) {
								ctx.translate(yAxisPosX + i * valueHop - msr.highestXLabel / 2, msr.xLabelPos);
								ctx.rotate(-(msr.rotateLabels * (Math.PI / 180)));
								ctx.fillTextMultiLine(fmtChartJS(config, data.labels[i], config.fmtXLabel), 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"XSCALE_TEXTMOUSE",-(msr.rotateLabels * (Math.PI / 180)),yAxisPosX + i * valueHop - msr.highestXLabel / 2, msr.xLabelPos,i,-1);
							} else {
								ctx.fillTextMultiLine(fmtChartJS(config, data.labels[i], config.fmtXLabel), yAxisPosX + i * valueHop, msr.xLabelPos, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"XSCALE_TEXTMOUSE",0,0,0,i,-1);
							}
							ctx.restore();
						}
					}
				}
			}
			//Y Labels
			ctx.textAlign = "right";
			ctx.textBaseline = "middle";
			for (var j = ((config.showYAxisMin) ? -1 : 0); j < calculatedScale.steps; j++) {
				if (config.scaleShowLabels) {
					if(showYLabels(ctx,data,config,j+1,calculatedScale.labels[j + 1])) {				
						if (config.yAxisLeft) {
							ctx.textAlign = "right";
							ctx.fillTextMultiLine(calculatedScale.labels[j + 1], yAxisPosX - (Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight)), xAxisPosY - ((j + 1) * scaleHop), ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"YLEFTAXIS_TEXTMOUSE",0,0,0,-1,j);
						}
						if (config.yAxisRight && !valueBounds.dbAxis) {
							ctx.textAlign = "left";
							ctx.fillTextMultiLine(calculatedScale.labels[j + 1], yAxisPosX + msr.availableWidth + (Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight)), xAxisPosY - ((j + 1) * scaleHop), ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"YRIGHTAXIS_TEXTMOUSE",0,0,0,-1,j);
						}
					}
				}
			}
			if (config.yAxisRight && valueBounds.dbAxis) {
				for (j = ((config.showYAxisMin) ? -1 : 0); j < calculatedScale2.steps; j++) {
					if (config.scaleShowLabels) {
						ctx.textAlign = "left";
						ctx.fillTextMultiLine(calculatedScale2.labels[j + 1], yAxisPosX + msr.availableWidth + (Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight)), xAxisPosY - ((j + 1) * scaleHop2), ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"YRIGHTAXIS_TEXTMOUSE",0,0,0,-1,j);
					}
				}
			}
		};

		function getValueBounds() {
			var upperValue = -Number.MAX_VALUE;
			var lowerValue = Number.MAX_VALUE;
			var upperValue2 = -Number.MAX_VALUE;
			var lowerValue2 = Number.MAX_VALUE;
			var secondAxis = false;
			var firstAxis = false;
			var mathValueHeight;
			for (var i = 0; i < data.datasets.length; i++) {
				var mathFctName = data.datasets[i].drawMathDeviation;
				var mathValueHeight = 0;
				if (typeof eval(mathFctName) == "function") {
					var parameter = {
						data: data,
						datasetNr: i
					};
					mathValueHeightVal = window[mathFctName](parameter);
				} else mathValueHeightVal=0;
				for (var j = 0; j < data.datasets[i].data.length; j++) {
					if(typeof mathValueHeightVal=="object") mathValueHeight=mathValueHeightVal[Math.min(mathValueHeightVal.length,j)];
					else mathValueHeight=mathValueHeightVal;
					
					if(typeof data.datasets[i].data[j] == "undefined") continue;
					if (data.datasets[i].axis == 2) {
						secondAxis = true;
						if (1 * data.datasets[i].data[j] + mathValueHeight > upperValue2) {
							upperValue2 = 1 * data.datasets[i].data[j] + mathValueHeight
						};
						if (1 * data.datasets[i].data[j] - mathValueHeight < lowerValue2) {
							lowerValue2 = 1 * data.datasets[i].data[j] - mathValueHeight
						};
					} else {
						firstAxis = true;
						if (1 * data.datasets[i].data[j] + mathValueHeight > upperValue) {
							upperValue = 1 * data.datasets[i].data[j] + mathValueHeight
						};
						if (1 * data.datasets[i].data[j] - mathValueHeight < lowerValue) {
							lowerValue = 1 * data.datasets[i].data[j] - mathValueHeight
						};
					}
				}
			};
			if(upperValue<lowerValue){upperValue=0;lowerValue=0;}
			if (Math.abs(upperValue - lowerValue) < config.zeroValue) {
				if(Math.abs(upperValue)< config.zeroValue) upperValue = .9;
				if(upperValue>0) {
					upperValue=upperValue*1.1;
					lowerValue=lowerValue*0.9;
				} else {
					upperValue=upperValue*0.9;
					lowerValue=lowerValue*1.1;
				}
				
			}
			if(typeof config.graphMin=="function")lowerValue= setOptionValue(true,1,"GRAPHMIN",ctx,data,statData,undefined,config.graphMin,"graphMin",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMin)) lowerValue = config.graphMin;
			if(typeof config.graphMax=="function") upperValue= setOptionValue(true,1,"GRAPHMAX",ctx,data,statData,undefined,config.graphMax,"graphMax",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMax)) upperValue = config.graphMax;
			if (secondAxis) {
				if(upperValue2<lowerValue2){upperValue2=0;lowerValue2=0;}
				if (Math.abs(upperValue2 - lowerValue2) < config.zeroValue) {
					if(Math.abs(upperValue2)< config.zeroValue) upperValue2 = .9;
					if(upperValue2>0) {
						upperValue2=upperValue2*1.1;
						lowerValue2=lowerValue2*0.9;
					} else {
						upperValue2=upperValue2*0.9;
						lowerValue2=lowerValue2*1.1;
					}
				}
				if(typeof config.graphMin2=="function")lowerValue2= setOptionValue(true,1,"GRAPHMIN",ctx,data,statData,undefined,config.graphMin2,"graphMin2",-1,-1,{nullValue : true})
				else if (!isNaN(config.graphMin2)) lowerValue2 = config.graphMin2;
				if(typeof config.graphMax2=="function") upperValue2= setOptionValue(true,1,"GRAPHMAX",ctx,data,statData,undefined,config.graphMax2,"graphMax2",-1,-1,{nullValue : true})
				else if (!isNaN(config.graphMax2)) upperValue2 = config.graphMax2;
			}
			if (!firstAxis && secondAxis) {
				upperValue = upperValue2;
				lowerValue = lowerValue2;
			}
			labelHeight = (Math.ceil(ctx.chartTextScale*config.scaleFontSize));
			scaleHeight = msr.availableHeight;
			var maxSteps = Math.floor((scaleHeight / (labelHeight * 0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight * 0.5));
			if(upperValue<lowerValue){lowerValue=upperValue-1;}
			if(upperValue2<lowerValue2){lowerValue2=upperValue2-1;}
			return {
				maxValue: upperValue,
				minValue: lowerValue,
				maxValue2: upperValue2,
				minValue2: lowerValue2,
				dbAxis: secondAxis,
				maxSteps: maxSteps,
				minSteps: minSteps
			};
		};
		return {
			data:data,
			config:config,
			ctx:ctx
		};
	};
	var StackedBar = function(data, config, ctx) {
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, valueHop, widestXLabel, xAxisLength, yAxisPosX, xAxisPosY, barWidth, rotateLabels = 0,
			msr;

		ctx.tpchart="StackedBar";
		ctx.tpdata=0;

	        if (!init_and_start(ctx,data,config)) return;
		var statData=initPassVariableData_part1(data,config,ctx);

		var nrOfBars = data.datasets.length;
		for (var i = 0; i < data.datasets.length; i++) {
			if (data.datasets[i].type == "Line") { statData[i][0].tpchart="Line";nrOfBars--;}
			else statData[i][0].tpchart="Bar";	
		}                               
		config.logarithmic = false;
		msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, "nihil", [""], true, false, true, true, true, "StackedBar");
		valueBounds = getValueBounds();
		if(valueBounds.maxSteps>0 && valueBounds.minSteps>0) {
			//Check and set the scale
			labelTemplateString = (config.scaleShowLabels) ? config.scaleLabel : "";
			if (!config.scaleOverride) {
				calculatedScale = calculateScale(1, config, valueBounds.maxSteps, valueBounds.minSteps, valueBounds.maxValue, valueBounds.minValue, labelTemplateString);
				msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, calculatedScale.labels, null, true, false, true, true, true, "StackedBar");
			} else {
				var scaleStartValue= setOptionValue(true,1,"SCALESTARTVALUE",ctx,data,statData,undefined,config.scaleStartValue,"scaleStartValue",-1,-1,{nullValue : true} );
				var scaleSteps =setOptionValue(true,1,"SCALESTEPS",ctx,data,statData,undefined,config.scaleSteps,"scaleSteps",-1,-1,{nullValue : true} );
				var scaleStepWidth = setOptionValue(true,1,"SCALESTEPWIDTH",ctx,data,statData,undefined,config.scaleStepWidth,"scaleStepWidth",-1,-1,{nullValue : true} );

				calculatedScale = {
					steps: scaleSteps,
					stepValue: scaleStepWidth,
					graphMin: scaleStartValue,
					labels: []
				}

				for (var i = 0; i <= calculatedScale.steps; i++) {
					if (labelTemplateString) {
						calculatedScale.labels.push(tmpl(labelTemplateString, {
							value: fmtChartJS(config, 1 * ((scaleStartValue + (scaleStepWidth * i)).toFixed(getDecimalPlaces(scaleStepWidth))), config.fmtYLabel)
						},config));
					}
				}
				msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, calculatedScale.labels, null, true, false, true, true, true, "StackedBar");
			}
			var prevHeight=msr.availableHeight;
       	
			msr.availableHeight = msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom) - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop);
			msr.availableWidth = msr.availableWidth - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft) - Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight);
			scaleHop = Math.floor(msr.availableHeight / calculatedScale.steps);
			valueHop = Math.floor(msr.availableWidth / (data.labels.length));
			if (valueHop == 0 || config.fullWidthGraph) valueHop = (msr.availableWidth / data.labels.length);
			msr.clrwidth = msr.clrwidth - (msr.availableWidth - ((data.labels.length) * valueHop));
			msr.availableWidth = (data.labels.length) * valueHop;

			msr.availableHeight = (calculatedScale.steps) * scaleHop;
			msr.xLabelPos+=(Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom) + Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop) - (prevHeight-msr.availableHeight));
			msr.clrheight+=(Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom) + Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop) - (prevHeight-msr.availableHeight));
       	
			yAxisPosX = msr.leftNotUsableSize + Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft);
			xAxisPosY = msr.topNotUsableSize + msr.availableHeight + Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop);
			barWidth = (valueHop - Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth) * 2 - (Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) * 2) - (Math.ceil(ctx.chartSpaceScale*config.barDatasetSpacing) * 1 - 1) - (Math.ceil(ctx.chartLineScale*config.barStrokeWidth) / 2) - 1);
			if(barWidth>=0 && barWidth<=1)barWidth=1;
			if(barWidth<0 && barWidth>=-1)barWidth=-1;
			var additionalSpaceBetweenBars;
			if(1*config.maxBarWidth >0 && barWidth > 1*config.maxBarWidth) {
				additionalSpaceBetweenBars=(barWidth-1*config.maxBarWidth)/2;
				barWidth=1*config.maxBarWidth;
			} else additionalSpaceBetweenBars=0;

			var zeroY = 0;
			var zeroY2 = 0;

			zeroY = calculateOffset(false, 0, calculatedScale, scaleHop);
			if(typeof calculatedScale2 ==="object") zeroY2 = calculateOffset(config.logarithmic2, 0, calculatedScale2, scaleHop2);       	
			drawLabels();
			initPassVariableData_part2(statData,data,config,ctx,{ 
				msr: msr,
				zeroY : zeroY,
				zeroY2 : zeroY2,
				logarithmic  : false,
				logarithmic2 : false,
				calculatedScale : calculatedScale,
				additionalSpaceBetweenBars : additionalSpaceBetweenBars,
				scaleHop : scaleHop,
				valueHop : valueHop,
				yAxisPosX : yAxisPosX,
				xAxisPosY : xAxisPosY,
				barWidth : barWidth
			 });
			animationLoop(config, drawScale, drawBars, ctx, msr.clrx, msr.clry, msr.clrwidth, msr.clrheight, yAxisPosX + msr.availableWidth / 2, xAxisPosY - msr.availableHeight / 2, yAxisPosX, xAxisPosY, data, statData);
		} else {
			testRedraw(ctx,data,config);
			ctx.firstPass=9;
		}
		function drawBars(animPc) {
			var prevTopPos = new Array();
			var prevTopNeg = new Array();

			for (var i = 0; i < data.datasets.length; i++) {
				if(data.datasets[i].type=="Line") continue;
				for (var j = 0; j < data.datasets[i].data.length; j++) {
					ctx.save();
					ctx.lineWidth=Math.ceil(ctx.chartLineScale*setOptionValue(true,1,"BARSTROKEWIDTH",ctx,data,statData,data.datasets[i].barStrokeWidth,config.barStrokeWidth,"barStrokeWidth",i,j,{animationValue: currentAnimPc, xPosLeft : statData[i][j].xPosLeft, yPosBottom : botBar, xPosRight : statData[i][j].xPosRight, yPosTop : topBar} ));					
					var currentAnimPc = animationCorrection(animPc, data, config, i, j, false).animVal;
					if (currentAnimPc > 1) currentAnimPc = currentAnimPc - 1;
					if ((typeof data.datasets[i].data[j] == 'undefined') || 1*data.datasets[i].data[j] == 0 ) continue;
					if(typeof prevTopPos[j]=="undefined"){
						prevTopPos[j]=statData[statData[i][j].firstNotMissing][j].yPosBottom;
						prevTopNeg[j]=statData[statData[i][j].firstNotMissing][j].yPosBottom;
					}
					var botBar, topBar;
					if(1*data.datasets[i].data[j] > 0) botBar=prevTopPos[j];
					else botBar=prevTopNeg[j];
					topBar=botBar+currentAnimPc*(statData[i][j].yPosTop-statData[i][j].yPosBottom);
					if(1*data.datasets[i].data[j] > 0) prevTopPos[j]=topBar;
					else prevTopNeg[j]=topBar;
					ctx.fillStyle=setOptionValue(true,1,"COLOR",ctx,data,statData,data.datasets[i].fillColor,config.defaultFillColor,"fillColor",i,j,{animationValue: currentAnimPc, xPosLeft : statData[i][j].xPosLeft, yPosBottom : botBar, xPosRight : statData[i][j].xPosRight, yPosTop : topBar} );
					ctx.strokeStyle=setOptionValue(true,1,"STROKECOLOR",ctx,data,statData,data.datasets[i].strokeColor,config.defaultStrokeColor,"strokeColor",i,j,{nullvalue : null} );

					if(currentAnimPc !=0 && botBar!=topBar) {
						ctx.beginPath();
						ctx.moveTo(statData[i][j].xPosLeft, botBar+(topBar-botBar)/2);
						ctx.lineTo(statData[i][j].xPosLeft, topBar);
						ctx.lineTo(statData[i][j].xPosRight, topBar);
						ctx.lineTo(statData[i][j].xPosRight, botBar);
						ctx.lineTo(statData[i][j].xPosLeft, botBar);
						ctx.lineTo(statData[i][j].xPosLeft, botBar+(topBar-botBar)/2);
						if (config.barShowStroke) { 
							ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"STROKESTYLE",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
							ctx.stroke();
							ctx.setLineDash([]);
						};
						ctx.closePath();
						ctx.fill();
					}
					ctx.restore();
				}
			}
			drawLinesDataset(animPc, data, config, ctx, statData,{xAxisPosY : xAxisPosY,yAxisPosX : yAxisPosX, valueHop : valueHop, nbValueHop : data.labels.length });

			if (animPc >= config.animationStopValue) {
				var 	yPos = 0,
					xPos = 0;
				for (i = 0; i < data.datasets.length; i++) {
					for (j = 0; j < data.datasets[i].data.length; j++) {
						if (typeof(data.datasets[i].data[j]) == 'undefined') continue;
						jsGraphAnnotate[ctx.ChartNewId][jsGraphAnnotate[ctx.ChartNewId].length] = ["RECT", i, j, statData,setOptionValue(true,1,"ANNOTATEDISPLAY",ctx,data,statData,data.datasets[i].annotateDisplay,config.annotateDisplay,"annotateDisplay",i,j,{nullValue : true})];
						if(setOptionValue(true,1,"INGRAPHDATASHOW",ctx,data,statData,data.datasets[i].inGraphDataShow,config.inGraphDataShow,"inGraphDataShow",i,j,{nullValue : true})) {
							ctx.save();
							ctx.textAlign = setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,j,{nullValue: true  });
							ctx.textBaseline = setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,j,{nullValue : true} );
							ctx.font = setOptionValue(true,1,"INGRAPHDATAFONTSTYLE",ctx,data,statData,undefined,config.inGraphDataFontStyle,"inGraphDataFontStyle",i,j,{nullValue : true} ) + ' ' + setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ) + 'px ' + setOptionValue(true,1,"INGRAPHDATAFONTFAMILY",ctx,data,statData,undefined,config.inGraphDataFontFamily,"inGraphDataFontFamily",i,j,{nullValue : true} );
							ctx.fillStyle = setOptionValue(true,1,"INGRAPHDATAFONTCOLOR",ctx,data,statData,undefined,config.inGraphDataFontColor,"inGraphDataFontColor",i,j,{nullValue : true} );
							var dispString = tmplbis(setOptionValue(true,1,"INGRAPHDATATMPL",ctx,data,statData,undefined,config.inGraphDataTmpl,"inGraphDataTmpl",i,j,{nullValue : true} ), statData[i][j],config);
							ctx.beginPath();
							ctx.beginPath();
							yPos = 0;
							xPos = 0;
							if (setOptionValue(true,1,"INGRAPHDATAXPOSITION",ctx,data,statData,undefined,config.inGraphDataXPosition,"inGraphDataXPosition",i,j,{nullValue : true} ) == 1) {
								xPos = statData[i][j].xPosLeft + setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAXPOSITION",ctx,data,statData,undefined,config.inGraphDataXPosition,"inGraphDataXPosition",i,j,{nullValue : true} ) == 2) {
								xPos = statData[i][j].xPosLeft + barWidth / 2 + setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAXPOSITION",ctx,data,statData,undefined,config.inGraphDataXPosition,"inGraphDataXPosition",i,j,{nullValue : true} ) == 3) {
								xPos = statData[i][j].xPosLeft+ barWidth + setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} );
							}
							if (setOptionValue(true,1,"INGRAPHDATAYPOSITION",ctx,data,statData,undefined,config.inGraphDataYPosition,"inGraphDataYPosition",i,j,{nullValue : true} ) == 1) {
								yPos = statData[i][j].yPosBottom - setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAYPOSITION",ctx,data,statData,undefined,config.inGraphDataYPosition,"inGraphDataYPosition",i,j,{nullValue : true} ) == 2) {
								yPos = (statData[i][j].yPosTop + statData[i][j].yPosBottom)/2 - setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAYPOSITION",ctx,data,statData,undefined,config.inGraphDataYPosition,"inGraphDataYPosition",i,j,{nullValue : true} ) == 3) {
								yPos = statData[i][j].yPosTop - setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} );
							}
							if(yPos>msr.topNotUsableSize) {
								ctx.translate(xPos, yPos);
								var rotateVal=setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,j,{nullValue : true} ) * (Math.PI / 180);
								ctx.rotate(rotateVal);
								setTextBordersAndBackground(ctx,dispString,setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ),0,0,setOptionValue(true,1,"INGRAPHDATABORDERS",ctx,data,statData,undefined,config.inGraphDataBorders,"inGraphDataBorders",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSCOLOR",ctx,data,statData,undefined,config.inGraphDataBordersColor,"inGraphDataBordersColor",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartLineScale,"INGRAPHDATABORDERSWIDTH",ctx,data,statData,undefined,config.inGraphDataBordersWidth,"inGraphDataBordersWidth",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSXSPACE",ctx,data,statData,undefined,config.inGraphDataBordersXSpace,"inGraphDataBordersXSpace",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSYSPACE",ctx,data,statData,undefined,config.inGraphDataBordersYSpace,"inGraphDataBordersYSpace",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSSTYLE",ctx,data,statData,undefined,config.inGraphDataBordersStyle,"inGraphDataBordersStyle",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABACKGROUNDCOLOR",ctx,data,statData,undefined,config.inGraphDataBackgroundColor,"inGraphDataBackgroundColor",i,j,{nullValue : true} ),"INGRAPHDATA",config.inGraphDataBordersRadius);
								ctx.fillTextMultiLine(dispString, 0, 0, ctx.textBaseline, setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ),true,config.detectMouseOnText,ctx,"INGRAPHDATA_TEXTMOUSE",rotateVal,xPos, yPos,i,j);
							}
							ctx.restore();
						}
					}
				}
			}
			if(msr.legendMsr.dispLegend)drawLegend(msr.legendMsr,data,config,ctx,"StackedBar");
		};

		function drawScale() {
			//X axis line                                                          
			ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleLineWidth);
			ctx.strokeStyle = config.scaleLineColor;
			ctx.setLineDash(lineStyleFn(config.scaleLineStyle));
			ctx.beginPath();
			ctx.moveTo(yAxisPosX - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft), xAxisPosY);
			ctx.lineTo(yAxisPosX + msr.availableWidth + Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight), xAxisPosY);
			ctx.stroke();
			ctx.setLineDash([]);
			ctx.setLineDash(lineStyleFn(config.scaleGridLineStyle));
			for (var i = 0; i < data.labels.length; i++) {
				ctx.beginPath();
				ctx.moveTo(yAxisPosX + i * valueHop, xAxisPosY + Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom));
				ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth);
				ctx.strokeStyle = config.scaleGridLineColor;
				//Check i isnt 0, so we dont go over the Y axis twice.
				if (config.scaleShowGridLines && i > 0 && i % config.scaleXGridLinesStep == 0) {
					ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY - msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop));
				} else {
					ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY);
				}
				ctx.stroke();
			}
			ctx.setLineDash([]);
			
			//Y axis
			ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleLineWidth);
			ctx.strokeStyle = config.scaleLineColor;
			ctx.setLineDash(lineStyleFn(config.scaleLineStyle));
			ctx.beginPath();
			ctx.moveTo(yAxisPosX, xAxisPosY + Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom));
			ctx.lineTo(yAxisPosX, xAxisPosY - msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop));
			ctx.stroke();
			ctx.setLineDash([]);
			
			ctx.setLineDash(lineStyleFn(config.scaleGridLineStyle));
			for (var j = ((config.showYAxisMin) ? -1 : 0); j < calculatedScale.steps; j++) {
				ctx.beginPath();
				ctx.moveTo(yAxisPosX - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft), xAxisPosY - ((j + 1) * scaleHop));
				ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth);
				ctx.strokeStyle = config.scaleGridLineColor;
				if (config.scaleShowGridLines && (j+1) % config.scaleYGridLinesStep == 0) {
					ctx.lineTo(yAxisPosX + msr.availableWidth + Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight), xAxisPosY - ((j + 1) * scaleHop));
				} else {
					ctx.lineTo(yAxisPosX, xAxisPosY - ((j + 1) * scaleHop));
				}
				ctx.stroke();
			}
			ctx.setLineDash([]);
		};

		function drawLabels() {
			ctx.font = config.scaleFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.scaleFontSize)).toString() + "px " + config.scaleFontFamily;
			//X axis labels                                                          
			if (config.xAxisTop || config.xAxisBottom) {
				ctx.textBaseline = "top";
				if (msr.rotateLabels > 90) {
					ctx.save();
					ctx.textAlign = "left";
				} else if (msr.rotateLabels > 0) {
					ctx.save();
					ctx.textAlign = "right";
				} else {
					ctx.textAlign = "center";
				}
				ctx.fillStyle = config.scaleFontColor;
				if (config.xAxisBottom) {
					for (var i = 0; i < data.labels.length; i++) {
						if(showLabels(ctx,data,config,i)){
							ctx.save();
							if (msr.rotateLabels > 0) {
								ctx.translate(yAxisPosX + Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) + i * valueHop + additionalSpaceBetweenBars+ (barWidth / 2) - msr.highestXLabel / 2, msr.xLabelPos);
								ctx.rotate(-(msr.rotateLabels * (Math.PI / 180)));
								ctx.fillTextMultiLine(fmtChartJS(config, data.labels[i], config.fmtXLabel), 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"XAXIS_TEXTMOUSE",-(msr.rotateLabels * (Math.PI / 180)),yAxisPosX + Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) + i * valueHop + additionalSpaceBetweenBars+(barWidth / 2) - msr.highestXLabel / 2, msr.xLabelPos,i,-1);
							} else {
								ctx.fillTextMultiLine(fmtChartJS(config, data.labels[i], config.fmtXLabel), yAxisPosX + Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) + i * valueHop + additionalSpaceBetweenBars+(barWidth / 2), msr.xLabelPos, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"XAXIS_TEXTMOUSE",0,0,0,i,-1);
							}
							ctx.restore();
						}
					}
				}
			}
			//Y axis
			ctx.textAlign = "right";
			ctx.textBaseline = "middle";
			for (var j = ((config.showYAxisMin) ? -1 : 0); j < calculatedScale.steps; j++) {
				if (config.scaleShowLabels) {
					if(showYLabels(ctx,data,config,j+1,calculatedScale.labels[j + 1])) {				
						if (config.yAxisLeft) {
							ctx.textAlign = "right";
							ctx.fillTextMultiLine(calculatedScale.labels[j + 1], yAxisPosX - (Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight)), xAxisPosY - ((j + 1) * scaleHop), ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"YLEFTAXIS_TEXTMOUSE",0,0,0,-1,j);
						}
						if (config.yAxisRight) {
							ctx.textAlign = "left";
							ctx.fillTextMultiLine(calculatedScale.labels[j + 1], yAxisPosX + msr.availableWidth + (Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight)), xAxisPosY - ((j + 1) * scaleHop), ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"YRIGHTAXIS_TEXTMOUSE",0,0,0,-1,j);
						}
					}
				}
			}
		};

		function getValueBounds() {
			var maxValp = -Number.MAX_VALUE;
			var minValp = Number.MAX_VALUE;
			var maxValn = -Number.MAX_VALUE;
			var minValn = Number.MAX_VALUE;

			var tempp=[];
			var tempn=[];
			var inp=0;
			var inn=0;

			for (var i = 0; i < data.datasets.length; i++) {
				for (var j = 0; j < data.datasets[i].data.length; j++) {
					if(1 * data.datasets[i].data[j] > 0) {
						if(statData[i][0].tpchart=="Bar") {
							if(typeof tempp[j] == "undefined") tempp[j]=0;
							tempp[j] += 1 * data.datasets[i].data[j];
							maxValp=Math.max(maxValp,tempp[j]);
						} else maxValp=Math.max(maxValp,1 * data.datasets[i].data[j]);
						minValp=Math.min(minValp,1 * data.datasets[i].data[j]);
						inp=1;
					} else if(typeof (1 * data.datasets[i].data[j])==="number" && typeof data.datasets[i].data[j]!="undefined") {
						if(statData[i][0].tpchart=="Bar") {
							if(typeof tempn[j] == "undefined") tempn[j]=0;
							tempn[j] += (1 * data.datasets[i].data[j]);
							minValn=Math.min(minValn,tempn[j]);
						} else minValn=Math.min(minValn,1 * data.datasets[i].data[j]);
						maxValn=Math.max(maxValn,1 * data.datasets[i].data[j]);
						inn=1;
					}
				}
			};
			var upperValue, lowerValue;
			if (inp==0){upperValue=maxValn;lowerValue=minValn;}
			else if(inn==0) { upperValue=maxValp;lowerValue=minValp;}
			else { upperValue=maxValp;lowerValue=minValn; }

			if(typeof config.graphMin=="function")lowerValue= setOptionValue(true,1,"GRAPHMIN",ctx,data,statData,undefined,config.graphMin,"graphMin",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMin)) lowerValue = config.graphMin;
			if(typeof config.graphMax=="function") upperValue= setOptionValue(true,1,"GRAPHMAX",ctx,data,statData,undefined,config.graphMax,"graphMax",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMax)) upperValue = config.graphMax;

			if(upperValue<lowerValue){upperValue=0;lowerValue=0;}
			if (Math.abs(upperValue - lowerValue) < config.zeroValue) {
				if(Math.abs(upperValue)< config.zeroValue) upperValue = .9;
				if(upperValue>0) {
					upperValue=upperValue*1.1;
					lowerValue=lowerValue*0.9;
				} else {
					upperValue=upperValue*0.9;
					lowerValue=lowerValue*1.1;
				}
			}

			labelHeight = (Math.ceil(ctx.chartTextScale*config.scaleFontSize));
			scaleHeight = msr.availableHeight;
			var maxSteps = Math.floor((scaleHeight / (labelHeight * 0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight * 0.5));
			if(upperValue<lowerValue){lowerValue=upperValue-1;}

			return {
				maxValue: upperValue,
				minValue: lowerValue,
				maxSteps: maxSteps,
				minSteps: minSteps
			};
		};
		return {
			data:data,
			config:config,
			ctx:ctx
		};
	};
	/**
	 * Reverse the data structure for horizontal charts
	 * - reverse labels and every array inside datasets
	 * @param {object} data datasets and labels for the chart
	 * @return return the reversed data
	 */
	function reverseData(data) {
		data.labels = data.labels.reverse();
		for (var i = 0; i < data.datasets.length; i++) {
			for (var key in data.datasets[i]) {
				if (Array.isArray(data.datasets[i][key])) {
					data.datasets[i][key] = data.datasets[i][key].reverse();
				}
			}
		}
		return data;
	};
	var HorizontalStackedBar = function(data, config, ctx) {
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, valueHop, widestXLabel, xAxisLength, yAxisPosX, xAxisPosY, barWidth, rotateLabels = 0,
			msr;

		if (config.reverseOrder && typeof ctx.reversed == "undefined") {
			ctx.reversed=true;
			data = reverseData(data);
		}

		ctx.tpchart="HorizontalStackedBar";
		ctx.tpdata=0;
	        if (!init_and_start(ctx,data,config)) return;
		var statData=initPassVariableData_part1(data,config,ctx);

		config.logarithmic = false;
		msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, "nihil", [""], true, true, true, true, true, "HorizontalStackedBar");
 		valueBounds = getValueBounds();
		
		if(valueBounds.maxSteps>0 && valueBounds.minSteps>0) {
			//Check and set the scale
			labelTemplateString = (config.scaleShowLabels) ? config.scaleLabel : "";
			if (!config.scaleOverride) {
				calculatedScale = calculateScale(1, config, valueBounds.maxSteps, valueBounds.minSteps, valueBounds.maxValue, valueBounds.minValue, labelTemplateString);
				msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, calculatedScale.labels, null, true, true, true, true, true, "HorizontalStackedBar");
			} else {
				var scaleStartValue= setOptionValue(true,1,"SCALESTARTVALUE",ctx,data,statData,undefined,config.scaleStartValue,"scaleStartValue",-1,-1,{nullValue : true} );
				var scaleSteps =setOptionValue(true,1,"SCALESTEPS",ctx,data,statData,undefined,config.scaleSteps,"scaleSteps",-1,-1,{nullValue : true} );
				var scaleStepWidth = setOptionValue(true,1,"SCALESTEPWIDTH",ctx,data,statData,undefined,config.scaleStepWidth,"scaleStepWidth",-1,-1,{nullValue : true} );

				calculatedScale = {
					steps: scaleSteps,
					stepValue: scaleStepWidth,
					graphMin: scaleStartValue,
					labels: []
				}
				for (var i = 0; i <= calculatedScale.steps; i++) {
					if (labelTemplateString) {
						calculatedScale.labels.push(tmpl(labelTemplateString, {
							value: fmtChartJS(config, 1 * ((scaleStartValue + (scaleStepWidth * i)).toFixed(getDecimalPlaces(scaleStepWidth))), config.fmtYLabel)
						},config));
					}
				}
				msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, calculatedScale.labels, null, true, true, true, true, true, "HorizontalStackedBar");
			}
			msr.availableHeight = msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom) - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop);
			msr.availableWidth = msr.availableWidth - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft) - Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight);
			scaleHop = Math.floor(msr.availableHeight / data.labels.length);
			valueHop = Math.floor(msr.availableWidth / (calculatedScale.steps));
			if (valueHop == 0 || config.fullWidthGraph) valueHop = (msr.availableWidth / (calculatedScale.steps));
			msr.clrwidth = msr.clrwidth - (msr.availableWidth - (calculatedScale.steps * valueHop));
			msr.availableWidth = (calculatedScale.steps) * valueHop;
			msr.availableHeight = (data.labels.length) * scaleHop;
			yAxisPosX = msr.leftNotUsableSize + Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft);
			xAxisPosY = msr.topNotUsableSize + msr.availableHeight + Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop);
			barWidth = (scaleHop - Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth) * 2 - (Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) * 2) - (Math.ceil(ctx.chartSpaceScale*config.barDatasetSpacing) * 1 - 1) - (Math.ceil(ctx.chartLineScale*config.barStrokeWidth) / 2) - 1);
			if(barWidth>=0 && barWidth<=1)barWidth=1;
			if(barWidth<0 && barWidth>=-1)barWidth=-1;
			var additionalSpaceBetweenBars;
			if(1*config.maxBarWidth >0 && barWidth > 1*config.maxBarWidth) {
				additionalSpaceBetweenBars= (barWidth-1*config.maxBarWidth)/2;
				barWidth=1*config.maxBarWidth;
			} else additionalSpaceBetweenBars=0;

			drawLabels();
			var zeroY=  HorizontalCalculateOffset(0 , calculatedScale, scaleHop);
			initPassVariableData_part2(statData,data,config,ctx,{ 
				yAxisPosX : yAxisPosX,
				additionalSpaceBetweenBars : additionalSpaceBetweenBars,
				xAxisPosY : xAxisPosY,
				barWidth : barWidth,
				zeroY : zeroY,
				scaleHop : scaleHop,
				valueHop : valueHop,
				calculatedScale : calculatedScale
			});
			
			animationLoop(config, drawScale, drawBars, ctx, msr.clrx, msr.clry, msr.clrwidth, msr.clrheight, yAxisPosX + msr.availableWidth / 2, xAxisPosY - msr.availableHeight / 2, yAxisPosX, xAxisPosY, data, statData);
		} else {
			testRedraw(ctx,data,config);
			ctx.firstPass=9;
		}
		function HorizontalCalculateOffset(val, calculatedScale, scaleHop) {
			var outerValue = calculatedScale.steps * calculatedScale.stepValue;
			var adjustedValue = val - calculatedScale.graphMin;
			var scalingFactor = CapValue(adjustedValue / outerValue, 1, 0);
			return (scaleHop * calculatedScale.steps) * scalingFactor;
		};

		function drawBars(animPc) {
			var prevLeftPos = new Array();
			var prevLeftNeg = new Array();

//			ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.barStrokeWidth);
			for (var i = 0; i < data.datasets.length; i++) {
				for (var j = 0; j < data.datasets[i].data.length; j++) {
					ctx.lineWidth=Math.ceil(ctx.chartLineScale*setOptionValue(true,1,"BARSTROKEWIDTH",ctx,data,statData,data.datasets[i].barStrokeWidth,config.barStrokeWidth,"barStrokeWidth",i,j,{animationValue: currentAnimPc, xPosLeft : leftBar, yPosBottom : statData[i][j].yPosBottom, xPosRight : rightBar, yPosTop : statData[i][j].yPosBottom} ));
					var currentAnimPc = animationCorrection(animPc, data, config, i, j, false).animVal;
					if (currentAnimPc > 1) currentAnimPc = currentAnimPc - 1;
					if ((typeof(data.datasets[i].data[j]) == 'undefined') || 1*data.datasets[i].data[j] == 0 ) continue;
					if(typeof prevLeftPos[j]=="undefined"){
						prevLeftPos[j]=statData[statData[i][j].firstNotMissing][j].xPosLeft;
						prevLeftNeg[j]=statData[statData[i][j].firstNotMissing][j].xPosLeft;
					}

					var leftBar, rightBar;
////					if(config.animationByDataset) {
////						leftBar= statData[i][j].xPosLeft;
////						rightBar= statData[i][j].xPosRight;
////						rightBar=leftBar+currentAnimPc*(rightBar-leftBar);
////					} else {
						if(1*data.datasets[i].data[j] > 0) leftBar=prevLeftPos[j];
						else leftBar=prevLeftNeg[j];
//						leftBar=statData[statData[i][j].firstNotMissing][j].xPosLeft + currentAnimPc*(statData[i][j].xPosLeft-statData[statData[i][j].firstNotMissing][j].xPosLeft);
//						rightBar=statData[statData[i][j].firstNotMissing][j].xPosLeft + currentAnimPc*(statData[i][j].xPosRight-statData[statData[i][j].firstNotMissing][j].xPosLeft);
						rightBar=leftBar+currentAnimPc*(statData[i][j].xPosRight-statData[i][j].xPosLeft);

						if(1*data.datasets[i].data[j] > 0) prevLeftPos[j]=rightBar;
						else prevLeftNeg[j]=rightBar;
////					}
					ctx.fillStyle=setOptionValue(true,1,"COLOR",ctx,data,statData,data.datasets[i].fillColor,config.defaultFillColor,"fillColor",i,j,{animationValue: currentAnimPc, xPosLeft : leftBar, yPosBottom : statData[i][j].yPosBottom, xPosRight : rightBar, yPosTop : statData[i][j].yPosBottom} );

					ctx.strokeStyle=setOptionValue(true,1,"STROKECOLOR",ctx,data,statData,data.datasets[i].strokeColor,config.defaultStrokeColor,"strokeColor",i,j,{nullvalue : null} );

					if(currentAnimPc !=0 && statData[i][j].xPosLeft!=statData[i][j].xPosRight ) {
						ctx.beginPath();
						ctx.moveTo(leftBar+(rightBar-leftBar)/2, statData[i][j].yPosTop);
						ctx.lineTo(rightBar, statData[i][j].yPosTop);
						ctx.lineTo(rightBar, statData[i][j].yPosBottom);
						ctx.lineTo(leftBar, statData[i][j].yPosBottom);
						ctx.lineTo(leftBar, statData[i][j].yPosTop);
						ctx.lineTo(leftBar+(rightBar-leftBar)/2, statData[i][j].yPosTop);
						if (config.barShowStroke){  
							ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"STROKESTYLE",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
							ctx.stroke(); 
							ctx.setLineDash([]);
						}
						ctx.closePath();
						ctx.fill();
					}
				}
			}
			if (animPc >= config.animationStopValue) {
				var yPos = 0,
					xPos = 0;
				for (i = 0; i < data.datasets.length; i++) {
					for (j = 0; j < data.datasets[i].data.length; j++) {
						if ((typeof(data.datasets[i].data[j]) == 'undefined')) continue;
						jsGraphAnnotate[ctx.ChartNewId][jsGraphAnnotate[ctx.ChartNewId].length] = ["RECT", i ,j, statData,setOptionValue(true,1,"ANNOTATEDISPLAY",ctx,data,statData,data.datasets[i].annotateDisplay,config.annotateDisplay,"annotateDisplay",i,j,{nullValue : true})];
						if(setOptionValue(true,1,"INGRAPHDATASHOW",ctx,data,statData,data.datasets[i].inGraphDataShow,config.inGraphDataShow,"inGraphDataShow",i,j,{nullValue : true})) {
							ctx.save();
							ctx.textAlign = setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,j,{nullValue: true  });
							ctx.textBaseline = setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,j,{nullValue : true} );
							ctx.font = setOptionValue(true,1,"INGRAPHDATAFONTSTYLE",ctx,data,statData,undefined,config.inGraphDataFontStyle,"inGraphDataFontStyle",i,j,{nullValue : true} ) + ' ' + setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ) + 'px ' + setOptionValue(true,1,"INGRAPHDATAFONTFAMILY",ctx,data,statData,undefined,config.inGraphDataFontFamily,"inGraphDataFontFamily",i,j,{nullValue : true} );
							ctx.fillStyle = setOptionValue(true,1,"INGRAPHDATAFONTCOLOR",ctx,data,statData,undefined,config.inGraphDataFontColor,"inGraphDataFontColor",i,j,{nullValue : true} );
							var dispString = tmplbis(setOptionValue(true,1,"INGRAPHDATATMPL",ctx,data,statData,undefined,config.inGraphDataTmpl,"inGraphDataTmpl",i,j,{nullValue : true} ),statData[i][j],config);
							ctx.beginPath();
							yPos = 0;
							xPos = 0;
							if (setOptionValue(true,1,"INGRAPHDATAXPOSITION",ctx,data,statData,undefined,config.inGraphDataXPosition,"inGraphDataXPosition",i,j,{nullValue : true} ) == 1) {
								xPos = statData[i][j].xPosLeft + setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAXPOSITION",ctx,data,statData,undefined,config.inGraphDataXPosition,"inGraphDataXPosition",i,j,{nullValue : true} ) == 2) {
								xPos = statData[i][j].xPosLeft + (statData[i][j].xPosRight-statData[i][j].xPosLeft)/2 + setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAXPOSITION",ctx,data,statData,undefined,config.inGraphDataXPosition,"inGraphDataXPosition",i,j,{nullValue : true} ) == 3) {
								xPos = statData[i][j].xPosRight + setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} );
							}
							if (setOptionValue(true,1,"INGRAPHDATAYPOSITION",ctx,data,statData,undefined,config.inGraphDataYPosition,"inGraphDataYPosition",i,j,{nullValue : true} ) == 1) {
								yPos = statData[i][j].yPosBottom - setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAYPOSITION",ctx,data,statData,undefined,config.inGraphDataYPosition,"inGraphDataYPosition",i,j,{nullValue : true} ) == 2) {
								yPos = statData[i][j].yPosBottom - barWidth / 2 - setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAYPOSITION",ctx,data,statData,undefined,config.inGraphDataYPosition,"inGraphDataYPosition",i,j,{nullValue : true} ) == 3) {
								yPos = statData[i][j].yPosTop - setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} );
							}
//								if(xPos<=msr.availableWidth+msr.leftNotUsableSize) {
								ctx.translate(xPos, yPos);
								rotateVal=setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,j,{nullValue : true} ) * (Math.PI / 180);
								ctx.rotate(rotateVal);
								setTextBordersAndBackground(ctx,dispString,setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ),0,0,setOptionValue(true,1,"INGRAPHDATABORDERS",ctx,data,statData,undefined,config.inGraphDataBorders,"inGraphDataBorders",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSCOLOR",ctx,data,statData,undefined,config.inGraphDataBordersColor,"inGraphDataBordersColor",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartLineScale,"INGRAPHDATABORDERSWIDTH",ctx,data,statData,undefined,config.inGraphDataBordersWidth,"inGraphDataBordersWidth",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSXSPACE",ctx,data,statData,undefined,config.inGraphDataBordersXSpace,"inGraphDataBordersXSpace",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSYSPACE",ctx,data,statData,undefined,config.inGraphDataBordersYSpace,"inGraphDataBordersYSpace",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSSTYLE",ctx,data,statData,undefined,config.inGraphDataBordersStyle,"inGraphDataBordersStyle",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABACKGROUNDCOLOR",ctx,data,statData,undefined,config.inGraphDataBackgroundColor,"inGraphDataBackgroundColor",i,j,{nullValue : true} ),"INGRAPHDATA",config.inGraphDataBordersRadius);
								ctx.fillTextMultiLine(dispString, 0, 0, ctx.textBaseline, setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ),true,config.detectMouseOnText,ctx,"INGRAPHDATA_TEXTMOUSE",rotateVal,xPos, yPos,i,j);
								ctx.restore();
//							}
						}
					}
				}
			}
			if(msr.legendMsr.dispLegend)drawLegend(msr.legendMsr,data,config,ctx,"HorizontalStackedBar");
		};

		function drawScale() {
			//X axis line                                                          
			ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleLineWidth);
			ctx.strokeStyle = config.scaleLineColor;
			ctx.setLineDash(lineStyleFn(config.scaleLineStyle));
			ctx.beginPath();
			ctx.moveTo(yAxisPosX - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft), xAxisPosY);
			ctx.lineTo(yAxisPosX + msr.availableWidth, xAxisPosY);
			ctx.stroke();
			ctx.setLineDash([]);
			
			ctx.setLineDash(lineStyleFn(config.scaleGridLineStyle));
			for (var i = ((config.showYAxisMin) ? -1 : 0); i < calculatedScale.steps; i++) {
				if (i >= 0) {
					ctx.beginPath();
					ctx.moveTo(yAxisPosX + i * valueHop, xAxisPosY + Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom));
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth);
					ctx.strokeStyle = config.scaleGridLineColor;
					//Check i isnt 0, so we dont go over the Y axis twice.
					if (config.scaleShowGridLines && i > 0 && i % config.scaleXGridLinesStep == 0) {
						ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY - msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop));
					} else {
						ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY);
					}
					ctx.stroke();
				}
				ctx.setLineDash([]);
			}
			//Y axis
			ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleLineWidth);
			ctx.strokeStyle = config.scaleLineColor;
			ctx.setLineDash(lineStyleFn(config.scaleLineStyle));
			ctx.beginPath();
			ctx.moveTo(yAxisPosX, xAxisPosY + Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom));
			ctx.lineTo(yAxisPosX, xAxisPosY - msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop));
			ctx.stroke();
			ctx.setLineDash([]);
			ctx.setLineDash(lineStyleFn(config.scaleGridLineStyle));
			for (var j = 0; j < data.labels.length; j++) {
				ctx.beginPath();
				ctx.moveTo(yAxisPosX - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft), xAxisPosY - ((j + 1) * scaleHop));
				ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth);
				ctx.strokeStyle = config.scaleGridLineColor;
				if (config.scaleShowGridLines && (j+1) % config.scaleYGridLinesStep == 0) {
					ctx.lineTo(yAxisPosX + msr.availableWidth, xAxisPosY - ((j + 1) * scaleHop));
				} else {
					ctx.lineTo(yAxisPosX, xAxisPosY - ((j + 1) * scaleHop));
				}
				ctx.stroke();
			}
			ctx.setLineDash([]);
		};

		function drawLabels() {
			ctx.font = config.scaleFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.scaleFontSize)).toString() + "px " + config.scaleFontFamily;
			//X axis line                                                          
			if (config.scaleShowLabels && (config.xAxisTop || config.xAxisBottom)) {
				ctx.textBaseline = "top";
				if (msr.rotateLabels > 90) {
					ctx.save();
					ctx.textAlign = "left";
				} else if (msr.rotateLabels > 0) {
					ctx.save();
					ctx.textAlign = "right";
				} else {
					ctx.textAlign = "center";
				}
				ctx.fillStyle = config.scaleFontColor;
				if (config.xAxisBottom) {
					for (var i = ((config.showYAxisMin) ? -1 : 0); i < calculatedScale.steps; i++) {
						if(showYLabels(ctx,data,config,i+1,calculatedScale.labels[i+ 1])) {				
							ctx.save();
							if (msr.rotateLabels > 0) {
								ctx.translate(yAxisPosX + (i + 1) * valueHop - msr.highestXLabel / 2, msr.xLabelPos);
								ctx.rotate(-(msr.rotateLabels * (Math.PI / 180)));
								ctx.fillTextMultiLine(calculatedScale.labels[i + 1], 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"XAXIS_TEXTMOUSE",-(msr.rotateLabels * (Math.PI / 180)),yAxisPosX + (i + 1) * valueHop - msr.highestXLabel / 2, msr.xLabelPos,i,-1);
							} else {
								ctx.fillTextMultiLine(calculatedScale.labels[i + 1], yAxisPosX + ((i + 1) * valueHop), msr.xLabelPos, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"XAXIS_TEXTMOUSE",0,0,0,i,-1);
							}
							ctx.restore();
						}
					}
				}
			}
			//Y axis
			ctx.textAlign = "right";
			ctx.textBaseline = "middle";
			for (var j = 0; j < data.labels.length; j++) {
				if(showLabels(ctx,data,config,j)){
					if (config.yAxisLeft) {
						ctx.textAlign = "right";
						ctx.fillTextMultiLine(fmtChartJS(config, data.labels[j], config.fmtXLabel), yAxisPosX - (Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight)), xAxisPosY - ((j + 1) * scaleHop) + Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) + additionalSpaceBetweenBars + (barWidth / 2), ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"YLEFTAXIS_TEXTMOUSE",0,0,0,-1,j);
					}
					if (config.yAxisRight) {
						ctx.textAlign = "left";
						ctx.fillTextMultiLine(fmtChartJS(config, data.labels[j], config.fmtXLabel), yAxisPosX + msr.availableWidth + (Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight)), xAxisPosY - ((j + 1) * scaleHop) + additionalSpaceBetweenBars+ (barWidth / 2), ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"YRIGHTAXIS_TEXTMOUSE",0,0,0,-1,j);
					}
				}
			}
		};

		function getValueBounds() {
			var upperValue = -Number.MAX_VALUE;
			var lowerValue = Number.MAX_VALUE;
			var minvl = new Array(data.datasets.length);
			var maxvl = new Array(data.datasets.length);
			for (var i = 0; i < data.datasets.length; i++) {
				for (var j = 0; j < data.datasets[i].data.length; j++) {
					var k = i;
					var tempp = 0;
					var tempn = 0;
					if (!(typeof(data.datasets[0].data[j]) == 'undefined')) {
						if(1 * data.datasets[0].data[j] > 0) {
							tempp += 1 * data.datasets[0].data[j];
							if (tempp > upperValue) {
								upperValue = tempp;
							};
							if (tempp < lowerValue) {
								lowerValue = tempp;
							};
						} else {
							tempn += 1 * data.datasets[0].data[j];
							if (tempn > upperValue) {
								upperValue = tempn;
							};
							if (tempn < lowerValue) {
								lowerValue = tempn;
							};
						}
					}
					while (k > 0) { //get max of stacked data
						if (!(typeof(data.datasets[k].data[j]) == 'undefined')) {
							if(1 * data.datasets[k].data[j] > 0) {
								tempp += 1 * data.datasets[k].data[j];
								if (tempp > upperValue) {
									upperValue = tempp;
								};
								if (tempp < lowerValue) {
									lowerValue = tempp;
								};
							} else {
								tempn += 1 * data.datasets[k].data[j];
								if (tempn > upperValue) {
									upperValue = tempn;
								};
								if (tempn < lowerValue) {
									lowerValue = tempn;
								};
							}
						}
						k--;
					}
				}
			};
			if(typeof config.graphMin=="function")lowerValue= setOptionValue(true,1,"GRAPHMIN",ctx,data,statData,undefined,config.graphMin,"graphMin",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMin)) lowerValue = config.graphMin;
			if(typeof config.graphMax=="function") upperValue= setOptionValue(true,1,"GRAPHMAX",ctx,data,statData,undefined,config.graphMax,"graphMax",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMax)) upperValue = config.graphMax;
			if(upperValue<lowerValue){upperValue=0;lowerValue=0;}
			if (Math.abs(upperValue - lowerValue) < config.zeroValue) {
				if(Math.abs(upperValue)< config.zeroValue) upperValue = .9;
				if(upperValue>0) {
					upperValue=upperValue*1.1;
					lowerValue=lowerValue*0.9;
				} else {
					upperValue=upperValue*0.9;
					lowerValue=lowerValue*1.1;
				}
			}
			labelHeight = (Math.ceil(ctx.chartTextScale*config.scaleFontSize));
			scaleHeight = msr.availableHeight;
			var maxSteps = Math.floor((scaleHeight / (labelHeight * 0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight * 0.5));
			if(upperValue<lowerValue){lowerValue=upperValue-1;}
			return {
				maxValue: upperValue,
				minValue: lowerValue,
				maxSteps: maxSteps,
				minSteps: minSteps
			};


		};
		return {
			data:data,
			config:config,
			ctx:ctx
		};
	};
	var Bar = function(data, config, ctx) {

		var maxSize, scaleHop, scaleHop2, calculatedScale, calculatedScale2, labelHeight, scaleHeight, valueBounds, labelTemplateString, labelTemplateString2, valueHop, widestXLabel, xAxisLength, yAxisPosX, xAxisPosY, barWidth, rotateLabels = 0,
			msr;
	
		ctx.tpchart="Bar";
		ctx.tpdata=0;

	        if (!init_and_start(ctx,data,config)) return;

		var statData=initPassVariableData_part1(data,config,ctx);

		var nrOfBars = data.datasets.length;
		for (var i = 0; i < data.datasets.length; i++) {
			if (data.datasets[i].type == "Line") { statData[i][0].tpchart="Line";nrOfBars--;}
			else statData[i][0].tpchart="Bar";	
		}                               


		// change the order (at first all bars then the lines) (form of BubbleSort)
		var bufferDataset, l = 0;
		
		msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, "nihil", [""], true, false, true, true, true, "Bar");
		valueBounds = getValueBounds();
		if(valueBounds.minValue<=0)config.logarithmic=false;
		if(valueBounds.maxSteps>0 && valueBounds.minSteps>0) {
			// true or fuzzy (error for negativ values (included 0))
			if (config.logarithmic !== false) {
				if (valueBounds.minValue <= 0) {
					config.logarithmic = false;
				}
			}
			if (config.logarithmic2 !== false) {
				if (valueBounds.minValue2 <= 0) {
					config.logarithmic2 = false;
				}
			}
			// Check if logarithmic is meanigful
			var OrderOfMagnitude = calculateOrderOfMagnitude(Math.pow(10, calculateOrderOfMagnitude(valueBounds.maxValue) + 1)) - calculateOrderOfMagnitude(Math.pow(10, calculateOrderOfMagnitude(valueBounds.minValue)));
			if ((config.logarithmic == 'fuzzy' && OrderOfMagnitude < 4) || config.scaleOverride) {
				config.logarithmic = false;
			}
			// Check if logarithmic is meanigful
			var OrderOfMagnitude2 = calculateOrderOfMagnitude(Math.pow(10, calculateOrderOfMagnitude(valueBounds.maxValue2) + 1)) - calculateOrderOfMagnitude(Math.pow(10, calculateOrderOfMagnitude(valueBounds.minValue2)));
			if ((config.logarithmic2 == 'fuzzy' && OrderOfMagnitude2 < 4) || config.scaleOverride2) {
				config.logarithmic2 = false;
			}

			//Check and set the scale
			labelTemplateString = (config.scaleShowLabels) ? config.scaleLabel : "";
			labelTemplateString2 = (config.scaleShowLabels2) ? config.scaleLabel2 : "";
			if (!config.scaleOverride) {
				calculatedScale = calculateScale(1, config, valueBounds.maxSteps, valueBounds.minSteps, valueBounds.maxValue, valueBounds.minValue, labelTemplateString);
			} else {
				var scaleStartValue= setOptionValue(true,1,"SCALESTARTVALUE",ctx,data,statData,undefined,config.scaleStartValue,"scaleStartValue",-1,-1,{nullValue : true} );
				var scaleSteps =setOptionValue(true,1,"SCALESTEPS",ctx,data,statData,undefined,config.scaleSteps,"scaleSteps",-1,-1,{nullValue : true} );
				var scaleStepWidth = setOptionValue(true,1,"SCALESTEPWIDTH",ctx,data,statData,undefined,config.scaleStepWidth,"scaleStepWidth",-1,-1,{nullValue : true} );

				calculatedScale = {
					steps: scaleSteps,
					stepValue: scaleStepWidth,
					graphMin: scaleStartValue,
					graphMax: scaleStartValue + scaleSteps * scaleStepWidth,
					labels: []
				}
				populateLabels(1, config, labelTemplateString, calculatedScale.labels, calculatedScale.steps, scaleStartValue, calculatedScale.graphMax, scaleStepWidth);
			}
			if (valueBounds.dbAxis) {
				if (!config.scaleOverride2) {
					calculatedScale2 = calculateScale(2, config, valueBounds.maxSteps, valueBounds.minSteps, valueBounds.maxValue2, valueBounds.minValue2, labelTemplateString2);
				} else {
					var scaleStartValue2= setOptionValue(true,1,"SCALESTARTVALUE2",ctx,data,statData,undefined,config.scaleStartValue2,"scaleStartValue2",-1,-1,{nullValue : true} );
					var scaleSteps2 =setOptionValue(true,1,"SCALESTEPS2",ctx,data,statData,undefined,config.scaleSteps2,"scaleSteps2",-1,-1,{nullValue : true} );
					var scaleStepWidth2 = setOptionValue(true,1,"SCALESTEPWIDTH2",ctx,data,statData,undefined,config.scaleStepWidth2,"scaleStepWidth2",-1,-1,{nullValue : true} );

					calculatedScale2 = {
						steps: scaleSteps2,
						stepValue: scaleStepWidth2,
						graphMin: scaleStartValue2,
						graphMax: scaleStartValue2 + scaleSteps2 * scaleStepWidth2,
						labels: []
					}
					populateLabels(2, config, labelTemplateString2, calculatedScale2.labels, calculatedScale2.steps, scaleStartValue2, calculatedScale2.graphMax, scaleStepWidth2);
				}
			} else {
				calculatedScale2 = {
					steps: 0,
					stepValue: 0,
					graphMin: 0,
					graphMax: 0,
					labels: null
				}
			}
			msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, calculatedScale.labels, calculatedScale2.labels, true, false, true, true, true, "Bar");

			var prevHeight=msr.availableHeight;

			msr.availableHeight = msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom) - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop);
			msr.availableWidth = msr.availableWidth - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft) - Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight);
			scaleHop = Math.floor(msr.availableHeight / calculatedScale.steps);
			scaleHop2 = Math.floor(msr.availableHeight / calculatedScale2.steps);
			valueHop = Math.floor(msr.availableWidth / (data.labels.length));
			if (valueHop == 0 || config.fullWidthGraph) valueHop = (msr.availableWidth / data.labels.length);
			msr.clrwidth = msr.clrwidth - (msr.availableWidth - ((data.labels.length) * valueHop));
			msr.availableWidth = (data.labels.length) * valueHop;
			msr.availableHeight = (calculatedScale.steps) * scaleHop;
			msr.xLabelPos+=(Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom) + Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop) - (prevHeight-msr.availableHeight));
			msr.clrheight+=(Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom) + Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop) - (prevHeight-msr.availableHeight));

			yAxisPosX = msr.leftNotUsableSize + Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft);
			xAxisPosY = msr.topNotUsableSize + msr.availableHeight + Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop);
			barWidth = (valueHop - Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth) * 2 - (Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) * 2) - (Math.ceil(ctx.chartSpaceScale*config.barDatasetSpacing) * nrOfBars - 1) - ((Math.ceil(ctx.chartLineScale*config.barStrokeWidth) / 2) * nrOfBars - 1)) / nrOfBars;
			if(barWidth>=0 && barWidth<=1)barWidth=1;
			if(barWidth<0 && barWidth>=-1)barWidth=-1;
			var additionalSpaceBetweenBars;
			if(1*config.maxBarWidth >0 && barWidth > 1*config.maxBarWidth) {
				additionalSpaceBetweenBars=nrOfBars*(barWidth-1*config.maxBarWidth)/2;
				barWidth=1*config.maxBarWidth;
			} else additionalSpaceBetweenBars=0;

			var zeroY2 = 0;
			var zeroY = calculateOffset(config.logarithmic, 0, calculatedScale, scaleHop);
			if(typeof calculatedScale2 ==="object") zeroY2 = calculateOffset(config.logarithmic2, 0, calculatedScale2, scaleHop2);
			initPassVariableData_part2(statData,data,config,ctx,{ 
				msr: msr,
				yAxisPosX : yAxisPosX,
				xAxisPosY : xAxisPosY,
				valueHop : valueHop,
				nbValueHop : data.labels.length - 1,
				barWidth : barWidth,
				additionalSpaceBetweenBars : additionalSpaceBetweenBars,
				zeroY : zeroY,
				zeroY2 : zeroY2,
				calculatedScale : calculatedScale,
				calculatedScale2 : calculatedScale2,
				scaleHop : scaleHop,	
				scaleHop2 : scaleHop2	
			});
			drawLabels();
			animationLoop(config, drawScale, drawBars, ctx, msr.clrx, msr.clry, msr.clrwidth, msr.clrheight, yAxisPosX + msr.availableWidth / 2, xAxisPosY - msr.availableHeight / 2, yAxisPosX, xAxisPosY, data, statData);
		} else {
			testRedraw(ctx,data,config);
			ctx.firstPass=9;
		}

		function drawBars(animPc) {
			var t1, t2, t3;


			for (var i = 0; i < data.datasets.length; i++) {
				if(data.datasets[i].type=="Line") continue;
				for (var j = 0; j < data.datasets[i].data.length; j++) {
					ctx.save();
					ctx.lineWidth=Math.ceil(ctx.chartLineScale*setOptionValue(true,1,"BARSTROKEWIDTH",ctx,data,statData,data.datasets[i].barStrokeWidth,config.barStrokeWidth,"barStrokeWidth",i,j,{animationValue: currentAnimPc, xPosLeft : statData[i][j].xPosLeft, yPosBottom : statData[i][j].yPosBottom, xPosRight : statData[i][j].xPosLeft+barWidth, yPosTop : statData[i][j].yPosBottom-barHeight} ));				
					if (!(typeof(data.datasets[i].data[j]) == 'undefined')) {
						var currentAnimPc = animationCorrection(animPc, data, config, i, j, false).animVal;
						if (currentAnimPc > 1) currentAnimPc = currentAnimPc - 1;
						var barHeight = currentAnimPc * (statData[i][j].barHeight) + (Math.ceil(ctx.chartLineScale*config.barStrokeWidth) / 2);
						ctx.fillStyle=setOptionValue(true,1,"COLOR",ctx,data,statData,data.datasets[i].fillColor,config.defaultFillColor,"fillColor",i,j,{animationValue: currentAnimPc, xPosLeft : statData[i][j].xPosLeft, yPosBottom : statData[i][j].yPosBottom, xPosRight : statData[i][j].xPosLeft+barWidth, yPosTop : statData[i][j].yPosBottom-barHeight} );
						ctx.strokeStyle=setOptionValue(true,1,"STROKECOLOR",ctx,data,statData,data.datasets[i].strokeColor,config.defaultStrokeColor,"strokeColor",i,j,{nullvalue : null} );
						roundRect(ctx, statData[i][j].xPosLeft, statData[i][j].yPosBottom, barWidth, barHeight, config.barShowStroke, config.barBorderRadius,i,j,(data.datasets[i].data[j] < 0 ? -1  : 1));
					}
					ctx.restore();
				}
			}
			drawLinesDataset(animPc, data, config, ctx, statData,{xAxisPosY : xAxisPosY,yAxisPosX : yAxisPosX, valueHop : valueHop, nbValueHop : data.labels.length });

			if (animPc >= config.animationStopValue) {

				for (i = 0; i < data.datasets.length; i++) {
					for (j = 0; j < data.datasets[i].data.length; j++) {
						if (typeof(data.datasets[i].data[j]) == 'undefined') continue;
						if (data.datasets[i].type == "Line") continue;
						jsGraphAnnotate[ctx.ChartNewId][jsGraphAnnotate[ctx.ChartNewId].length] = ["RECT", i , j, statData,setOptionValue(true,1,"ANNOTATEDISPLAY",ctx,data,statData,data.datasets[i].annotateDisplay,config.annotateDisplay,"annotateDisplay",i,j,{nullValue : true})];
						if(setOptionValue(true,1,"INGRAPHDATASHOW",ctx,data,statData,data.datasets[i].inGraphDataShow,config.inGraphDataShow,"inGraphDataShow",i,j,{nullValue : true})) {
							ctx.save();
							ctx.textAlign = setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,j,{nullValue: true  });
							ctx.textBaseline = setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,j,{nullValue : true} );
							ctx.font = setOptionValue(true,1,"INGRAPHDATAFONTSTYLE",ctx,data,statData,undefined,config.inGraphDataFontStyle,"inGraphDataFontStyle",i,j,{nullValue : true} ) + ' ' + setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ) + 'px ' + setOptionValue(true,1,"INGRAPHDATAFONTFAMILY",ctx,data,statData,undefined,config.inGraphDataFontFamily,"inGraphDataFontFamily",i,j,{nullValue : true} );
							ctx.fillStyle = setOptionValue(true,1,"INGRAPHDATAFONTCOLOR",ctx,data,statData,undefined,config.inGraphDataFontColor,"inGraphDataFontColor",i,j,{nullValue : true} );
							t1 = statData[i][j].yPosBottom;
							t2 = statData[i][j].yPosTop;
							ctx.beginPath();
							var yPos = 0,
								xPos = 0;
							if (setOptionValue(true,1,"INGRAPHDATAXPOSITION",ctx,data,statData,undefined,config.inGraphDataXPosition,"inGraphDataXPosition",i,j,{nullValue : true} ) == 1) {
								xPos = statData[i][j].xPosLeft + setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAXPOSITION",ctx,data,statData,undefined,config.inGraphDataXPosition,"inGraphDataXPosition",i,j,{nullValue : true} ) == 2) {
								xPos = statData[i][j].xPosLeft + barWidth / 2 + setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAXPOSITION",ctx,data,statData,undefined,config.inGraphDataXPosition,"inGraphDataXPosition",i,j,{nullValue : true} ) == 3) {
								xPos = statData[i][j].xPosLeft + barWidth + setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} );
							}
							if (setOptionValue(true,1,"INGRAPHDATAYPOSITION",ctx,data,statData,undefined,config.inGraphDataYPosition,"inGraphDataYPosition",i,j,{nullValue : true} ) == 1) {
								yPos = statData[i][j].yPosBottom - setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAYPOSITION",ctx,data,statData,undefined,config.inGraphDataYPosition,"inGraphDataYPosition",i,j,{nullValue : true} ) == 2) {
								yPos = (statData[i][j].yPosBottom+statData[i][j].yPosTop)/2 - setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAYPOSITION",ctx,data,statData,undefined,config.inGraphDataYPosition,"inGraphDataYPosition",i,j,{nullValue : true} ) == 3) {
								yPos = statData[i][j].yPosTop - setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} );
							}
							ctx.translate(xPos, yPos);
							var dispString = tmplbis(setOptionValue(true,1,"INGRAPHDATATMPL",ctx,data,statData,undefined,config.inGraphDataTmpl,"inGraphDataTmpl",i,j,{nullValue : true} ), statData[i][j],config);
							rotateVal=setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,j,{nullValue : true} ) * (Math.PI / 180);
							ctx.rotate(rotateVal);
							setTextBordersAndBackground(ctx,dispString,setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ),0,0,setOptionValue(true,1,"INGRAPHDATABORDERS",ctx,data,statData,undefined,config.inGraphDataBorders,"inGraphDataBorders",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSCOLOR",ctx,data,statData,undefined,config.inGraphDataBordersColor,"inGraphDataBordersColor",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartLineScale,"INGRAPHDATABORDERSWIDTH",ctx,data,statData,undefined,config.inGraphDataBordersWidth,"inGraphDataBordersWidth",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSXSPACE",ctx,data,statData,undefined,config.inGraphDataBordersXSpace,"inGraphDataBordersXSpace",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSYSPACE",ctx,data,statData,undefined,config.inGraphDataBordersYSpace,"inGraphDataBordersYSpace",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSSTYLE",ctx,data,statData,undefined,config.inGraphDataBordersStyle,"inGraphDataBordersStyle",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABACKGROUNDCOLOR",ctx,data,statData,undefined,config.inGraphDataBackgroundColor,"inGraphDataBackgroundColor",i,j,{nullValue : true} ),"INGRAPHDATA",config.inGraphDataBordersRadius);
							ctx.fillTextMultiLine(dispString, 0, 0, ctx.textBaseline, setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ),true,config.detectMouseOnText,ctx,"INGRAPHDATA_TEXTMOUSE",rotateVal,xPos, yPos,i,j);
							ctx.restore();
						}
					}
				}
			}
			if (animPc >= 1 && typeof drawMath == "function") {
				drawMath(ctx, config, data, msr, {
					xAxisPosY: xAxisPosY,
					yAxisPosX: yAxisPosX,
					valueHop: valueHop,
					scaleHop: scaleHop,
					zeroY: zeroY,
					calculatedScale: calculatedScale,
					calculateOffset: calculateOffset,
					additionalSpaceBetweenBars : additionalSpaceBetweenBars,
					barWidth: barWidth
				});
			}
			if(msr.legendMsr.dispLegend)drawLegend(msr.legendMsr,data,config,ctx,"Bar");
		};

		function roundRect(ctx, x, y, w, h, stroke, radius,i,j,fact) {
			ctx.beginPath();
			ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"STROKESTYLE",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
			ctx.moveTo(x + (w/2), y);
			ctx.lineTo(x + w , y);
			ctx.lineTo(x + w, y - h + fact*radius);
			ctx.quadraticCurveTo(x + w, y - h, x + w - radius, y - h);
			ctx.lineTo(x + radius, y - h);
			ctx.quadraticCurveTo(x, y - h, x, y - h + fact*radius);
			ctx.lineTo(x, y);
			ctx.lineTo(x + (w/2), y);
			if (stroke) ctx.stroke();
			ctx.closePath();
			ctx.fill();
			ctx.setLineDash([]);
		};

		function drawScale() {
			//X axis line                                                          
			ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleLineWidth);
			ctx.strokeStyle = config.scaleLineColor;
			ctx.setLineDash(lineStyleFn(config.scaleLineStyle));

			ctx.beginPath();
			ctx.moveTo(yAxisPosX - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft), xAxisPosY);
			ctx.lineTo(yAxisPosX + msr.availableWidth + Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight), xAxisPosY);
			ctx.stroke();
			ctx.setLineDash([]);
			
			ctx.setLineDash(lineStyleFn(config.scaleGridLineStyle));
			for (var i = 0; i < data.labels.length; i++) {
				ctx.beginPath();
				ctx.moveTo(yAxisPosX + i * valueHop, xAxisPosY + Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom));
				ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth);
				ctx.strokeStyle = config.scaleGridLineColor;
				//Check i isnt 0, so we dont go over the Y axis twice.
				if (config.scaleShowGridLines && i > 0 && i % config.scaleXGridLinesStep == 0) {
					ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY - msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop));
				} else {
					ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY);
				}
				ctx.stroke();
			}
			ctx.setLineDash([]);
			
			//Y axis
			ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleLineWidth);
			ctx.strokeStyle = config.scaleLineColor;
			ctx.setLineDash(lineStyleFn(config.scaleLineStyle));
			ctx.beginPath();
			ctx.moveTo(yAxisPosX, xAxisPosY + Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom));
			ctx.lineTo(yAxisPosX, xAxisPosY - msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop));
			ctx.stroke();
			ctx.setLineDash([]);
			
			ctx.setLineDash(lineStyleFn(config.scaleGridLineStyle));
			for (var j = 0; j < calculatedScale.steps; j++) {
				ctx.beginPath();
				ctx.moveTo(yAxisPosX - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft), xAxisPosY - ((j + 1) * scaleHop));
				ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth);
				ctx.strokeStyle = config.scaleGridLineColor;
				if (config.scaleShowGridLines && (j+1) % config.scaleYGridLinesStep == 0) {
					ctx.lineTo(yAxisPosX + msr.availableWidth + Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight), xAxisPosY - ((j + 1) * scaleHop));
				} else {
					ctx.lineTo(yAxisPosX, xAxisPosY - ((j + 1) * scaleHop));
				}
				ctx.stroke();
			}
			ctx.setLineDash([]);
		};

		function drawLabels() {
			ctx.font = config.scaleFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.scaleFontSize)).toString() + "px " + config.scaleFontFamily;
			//X axis line                                                          
			if (config.xAxisTop || config.xAxisBottom) {
				ctx.textBaseline = "top";
				if (msr.rotateLabels > 90) {
					ctx.save();
					ctx.textAlign = "left";
				} else if (msr.rotateLabels > 0) {
					ctx.save();
					ctx.textAlign = "right";
				} else {
					ctx.textAlign = "center";
				}
				ctx.fillStyle = config.scaleFontColor;
				if (config.xAxisBottom) {
					for (var i = 0; i < data.labels.length; i++) {
						if(showLabels(ctx,data,config,i)){
							ctx.save();
							if (msr.rotateLabels > 0) {
								ctx.translate(yAxisPosX + i * valueHop + (valueHop / 2) - msr.highestXLabel / 2, msr.xLabelPos);
								ctx.rotate(-(msr.rotateLabels * (Math.PI / 180)));
								ctx.fillTextMultiLine(fmtChartJS(config, data.labels[i], config.fmtXLabel), 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"XAXIS_TEXTMOUSE",-(msr.rotateLabels * (Math.PI / 180)),yAxisPosX + i * valueHop + (valueHop / 2) - msr.highestXLabel / 2, msr.xLabelPos,i,-1);
							} else {
								ctx.fillTextMultiLine(fmtChartJS(config, data.labels[i], config.fmtXLabel), yAxisPosX + i * valueHop + (valueHop / 2), msr.xLabelPos, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"XAXIS_TEXTMOUSE",0,0,0,i,-1);
							}
							ctx.restore();
						}
					}
				}
			}
			//Y axis
			ctx.textAlign = "right";
			ctx.textBaseline = "middle";
			for (var j = ((config.showYAxisMin) ? -1 : 0); j < calculatedScale.steps; j++) {
				if (config.scaleShowLabels) {
					if(showYLabels(ctx,data,config,j+1,calculatedScale.labels[j+ 1])) {				
						if (config.yAxisLeft) {
							ctx.textAlign = "right";
							ctx.fillTextMultiLine(calculatedScale.labels[j + 1], yAxisPosX - (Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight)), xAxisPosY - ((j + 1) * scaleHop), ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"YLEFTAXIS_TEXTMOUSE",0,0,0,-1,j);
						}
						if (config.yAxisRight && !valueBounds.dbAxis) {
							ctx.textAlign = "left";
							ctx.fillTextMultiLine(calculatedScale.labels[j + 1], yAxisPosX + msr.availableWidth + (Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight)), xAxisPosY - ((j + 1) * scaleHop), ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"YRIGHTAXIS_TEXTMOUSE",0,0,0,-1,j);
						}
					}
				}
			}
			if (config.yAxisRight && valueBounds.dbAxis) {
				for (j = ((config.showYAxisMin) ? -1 : 0); j < calculatedScale2.steps; j++) {
					if (config.scaleShowLabels) {
						ctx.textAlign = "left";
						ctx.fillTextMultiLine(calculatedScale2.labels[j + 1], yAxisPosX + msr.availableWidth + (Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight)), xAxisPosY - ((j + 1) * scaleHop2), ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"YRIGHTAXIS_TEXTMOUSE",0,0,0,-1,j);
					}
				}
			}
		};

		function getValueBounds() {
			var upperValue = -Number.MAX_VALUE;
			var lowerValue = Number.MAX_VALUE;
			var upperValue2 = -Number.MAX_VALUE;
			var lowerValue2 = Number.MAX_VALUE;
			var secondAxis = false;
			var firstAxis = false;
			var mathValueHeight;			
			for (var i = 0; i < data.datasets.length; i++) {
				var mathFctName = data.datasets[i].drawMathDeviation;
				var mathValueHeight = 0;
				if (typeof eval(mathFctName) == "function") {
					var parameter = {
						data: data,
						datasetNr: i
					};
					mathValueHeightVal = window[mathFctName](parameter);
				} else mathValueHeightVal=0;
				for (var j = 0; j < data.datasets[i].data.length; j++) {
					if(typeof mathValueHeightVal=="object") mathValueHeight=mathValueHeightVal[Math.min(mathValueHeightVal.length,j)];
					else mathValueHeight=mathValueHeightVal;
					if(typeof data.datasets[i].data[j]=="undefined")continue;
					if (data.datasets[i].axis == 2) {
						secondAxis = true;
						if (1 * data.datasets[i].data[j] + mathValueHeight > upperValue2) {
							upperValue2 = 1 * data.datasets[i].data[j] + mathValueHeight;
						};
						if (1 * data.datasets[i].data[j] - mathValueHeight < lowerValue2) {
							lowerValue2 = 1 * data.datasets[i].data[j] - mathValueHeight;
						};
					} else {
						firstAxis=true;
						if (1 * data.datasets[i].data[j] + mathValueHeight > upperValue) {
							upperValue = 1 * data.datasets[i].data[j] + mathValueHeight;
						};
						if (1 * data.datasets[i].data[j] - mathValueHeight < lowerValue) {
							lowerValue = 1 * data.datasets[i].data[j] - mathValueHeight;
						};
					}
				}
			};
			if(upperValue<lowerValue){upperValue=0;lowerValue=0;}
			if (Math.abs(upperValue - lowerValue) < config.zeroValue) {
				if(Math.abs(upperValue)< config.zeroValue) upperValue = .9;
				if(upperValue>0) {
					upperValue=upperValue*1.1;
					lowerValue=lowerValue*0.9;
				} else {
					upperValue=upperValue*0.9;
					lowerValue=lowerValue*1.1;
				}
			}
			if(typeof config.graphMin=="function")lowerValue= setOptionValue(true,1,"GRAPHMIN",ctx,data,statData,undefined,config.graphMin,"graphMin",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMin)) lowerValue = config.graphMin;
			if(typeof config.graphMax=="function") upperValue= setOptionValue(true,1,"GRAPHMAX",ctx,data,statData,undefined,config.graphMax,"graphMax",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMax)) upperValue = config.graphMax;

			if (secondAxis) {
				if(upperValue2<lowerValue2){upperValue2=0;lowerValue2=0;}
				if (Math.abs(upperValue2 - lowerValue2) < config.zeroValue) {
					if(Math.abs(upperValue2)< config.zeroValue) upperValue2 = .9;
					if(upperValue2>0) {
						upperValue2=upperValue2*1.1;
						lowerValue2=lowerValue2*0.9;
					} else {
						upperValue2=upperValue2*0.9;
						lowerValue2=lowerValue2*1.1;
					}
				}
				if(typeof config.graphMin2=="function")lowerValue2= setOptionValue(true,1,"GRAPHMIN",ctx,data,statData,undefined,config.graphMin2,"graphMin2",-1,-1,{nullValue : true})
				else if (!isNaN(config.graphMin2)) lowerValue2 = config.graphMin2;
				if(typeof config.graphMax2=="function") upperValue2= setOptionValue(true,1,"GRAPHMAX",ctx,data,statData,undefined,config.graphMax2,"graphMax2",-1,-1,{nullValue : true})
				else if (!isNaN(config.graphMax2)) upperValue2 = config.graphMax2;
			}
			if (!firstAxis && secondAxis) {
				upperValue = upperValue2;
				lowerValue = lowerValue2;
			}

			labelHeight = (Math.ceil(ctx.chartTextScale*config.scaleFontSize));
			scaleHeight = msr.availableHeight;
			var maxSteps = Math.floor((scaleHeight / (labelHeight * 0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight * 0.5));
			if(upperValue<lowerValue){lowerValue=upperValue-1;}
			if(upperValue2<lowerValue2){lowerValue2=upperValue2-1;}
			return {
				maxValue: upperValue,
				minValue: lowerValue,
				maxValue2: upperValue2,
				minValue2: lowerValue2,
				dbAxis: secondAxis,
				maxSteps: maxSteps,
				minSteps: minSteps
			};
		};

		return {
			data:data,
			config:config,
			ctx:ctx
		};
	};

	var HorizontalBar = function(data, config, ctx) {
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, valueHop, widestXLabel, xAxisLength, yAxisPosX, xAxisPosY, barWidth, rotateLabels = 0,
			msr;
		ctx.tpchart="HorizontalBar";
		ctx.tpdata=0;

	        if (!init_and_start(ctx,data,config)) return;

		if (config.reverseOrder && typeof ctx.reversed == "undefined") {
			ctx.reversed=true;
			data = reverseData(data);
		}

		var statData=initPassVariableData_part1(data,config,ctx);

		msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, "nihil", [""], true, true, true, true, true, "StackedBar");
		valueBounds = getValueBounds();
		if(valueBounds.minValue<=0)config.logarithmic=false;
		if(valueBounds.maxSteps>0 && valueBounds.minSteps>0) {
			if (config.logarithmic !== false) {
				if (valueBounds.minValue <= 0) {
					config.logarithmic = false;
				}
			}
			//Check and set the scale
			labelTemplateString = (config.scaleShowLabels) ? config.scaleLabel : "";
			if (!config.scaleOverride) {
				calculatedScale = calculateScale(1, config, valueBounds.maxSteps, valueBounds.minSteps, valueBounds.maxValue, valueBounds.minValue, labelTemplateString);
				msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, calculatedScale.labels, null, true, true, true, true, true, "HorizontalBar");
			} else {
				var scaleStartValue= setOptionValue(true,1,"SCALESTARTVALUE",ctx,data,statData,undefined,config.scaleStartValue,"scaleStartValue",-1,-1,{nullValue : true} );
				var scaleSteps =setOptionValue(true,1,"SCALESTEPS",ctx,data,statData,undefined,config.scaleSteps,"scaleSteps",-1,-1,{nullValue : true} );
				var scaleStepWidth = setOptionValue(true,1,"SCALESTEPWIDTH",ctx,data,statData,undefined,config.scaleStepWidth,"scaleStepWidth",-1,-1,{nullValue : true} );

				calculatedScale = {
					steps: scaleSteps,
					stepValue: scaleStepWidth,
					graphMin: scaleStartValue,
					graphMax: scaleStartValue + scaleSteps * scaleStepWidth,
					labels: []
				}
				populateLabels(1, config, labelTemplateString, calculatedScale.labels, calculatedScale.steps, scaleStartValue, calculatedScale.graphMax, scaleStepWidth);
				msr = setMeasures(data, config, ctx, ctx.canvas.height, ctx.canvas.width, calculatedScale.labels, null, true, true, true, true, true, "HorizontalBar");
			}
			msr.availableHeight = msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom) - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop);
			msr.availableWidth = msr.availableWidth - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft) - Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight);
			scaleHop = Math.floor(msr.availableHeight / data.labels.length);
			valueHop = Math.floor(msr.availableWidth / (calculatedScale.steps));
			if (valueHop == 0 || config.fullWidthGraph) valueHop = (msr.availableWidth / calculatedScale.steps);
			msr.clrwidth = msr.clrwidth - (msr.availableWidth - (calculatedScale.steps * valueHop));
			msr.availableWidth = (calculatedScale.steps) * valueHop;
			msr.availableHeight = (data.labels.length) * scaleHop;
			yAxisPosX = msr.leftNotUsableSize + Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft);
			xAxisPosY = msr.topNotUsableSize + msr.availableHeight + Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop);
			barWidth = (scaleHop - Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth) * 2 - (Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) * 2) - (Math.ceil(ctx.chartSpaceScale*config.barDatasetSpacing) * data.datasets.length - 1) - ((Math.ceil(ctx.chartLineScale*config.barStrokeWidth) / 2) * data.datasets.length - 1)) / data.datasets.length;
			if(barWidth>=0 && barWidth<=1)barWidth=1;
			if(barWidth<0 && barWidth>=-1)barWidth=-1;
			var additionalSpaceBetweenBars;
			if(1*config.maxBarWidth >0 && barWidth > 1*config.maxBarWidth) {
				additionalSpaceBetweenBars=data.datasets.length*(barWidth-1*config.maxBarWidth)/2;
				barWidth=1*config.maxBarWidth;
			} else additionalSpaceBetweenBars=0;

			var zeroY = 0;
			zeroY = calculateOffset(config.logarithmic, 0, calculatedScale, valueHop);
			drawLabels();
			initPassVariableData_part2(statData,data,config,ctx,{ 
				yAxisPosX : yAxisPosX,
				xAxisPosY : xAxisPosY,
				barWidth : barWidth,
				additionalSpaceBetweenBars : additionalSpaceBetweenBars,
				zeroY : zeroY,
				scaleHop : scaleHop,
				valueHop : valueHop,
				calculatedScale : calculatedScale
			});
			animationLoop(config, drawScale, drawBars, ctx, msr.clrx, msr.clry, msr.clrwidth, msr.clrheight, yAxisPosX + msr.availableWidth / 2, xAxisPosY - msr.availableHeight / 2, yAxisPosX, xAxisPosY, data, statData);
		} else {
			testRedraw(ctx,data,config);
			ctx.firstPass=9;
		}

		function drawBars(animPc) {
			for (var i = 0; i < data.datasets.length; i++) {
				for (var j = 0; j < data.datasets[i].data.length; j++) {
//					ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.barStrokeWidth);
ctx.lineWidth=Math.ceil(ctx.chartLineScale*setOptionValue(true,1,"BARSTROKEWIDTH",ctx,data,statData,data.datasets[i].barStrokeWidth,config.barStrokeWidth,"barStrokeWidth",i,j,{animationValue: currentAnimPc, xPosLeft : statData[i][j].xPosLeft, yPosBottom : statData[i][j].yPosBottom, xPosRight : statData[i][j].xPosLeft+barWidth, yPosTop : statData[i][j].yPosBottom-barHeight} ));				
					var currentAnimPc = animationCorrection(animPc, data, config, i, j, false).animVal;
					if (currentAnimPc > 1) currentAnimPc = currentAnimPc - 1;
					var barHeight = currentAnimPc * statData[i][j].barWidth + (Math.ceil(ctx.chartLineScale*config.barStrokeWidth) / 2);
					ctx.fillStyle=setOptionValue(true,1,"COLOR",ctx,data,statData,data.datasets[i].fillColor,config.defaultFillColor,"fillColor",i,j,{animationValue: currentAnimPc, xPosLeft : statData[i][j].xPosLeft, yPosBottom : statData[i][j].yPosBottom, xPosRight : statData[i][j].xPosLeft+barHeight, yPosTop : statData[i][j].yPosBottom} );
					ctx.strokeStyle=setOptionValue(true,1,"STROKECOLOR",ctx,data,statData,data.datasets[i].strokeColor,config.defaultStrokeColor,"strokeColor",i,j,{nullvalue : null} );

					if (!(typeof(data.datasets[i].data[j]) == 'undefined')) {
						roundRect(ctx, statData[i][j].yPosTop, statData[i][j].xPosLeft , barWidth, barHeight, config.barShowStroke, config.barBorderRadius, 0,i,j,(data.datasets[i].data[j] < 0 ? -1  : 1));
					}
				}
			}
			if (animPc >= config.animationStopValue) {
				for (i = 0; i < data.datasets.length; i++) {
					for (j = 0; j < data.datasets[i].data.length; j++) {
						if (typeof(data.datasets[i].data[j]) == 'undefined') continue;
						jsGraphAnnotate[ctx.ChartNewId][jsGraphAnnotate[ctx.ChartNewId].length] = ["RECT", i ,j ,statData,setOptionValue(true,1,"ANNOTATEDISPLAY",ctx,data,statData,data.datasets[i].annotateDisplay,config.annotateDisplay,"annotateDisplay",i,j,{nullValue : true})];
                       				if(setOptionValue(true,1,"INGRAPHDATASHOW",ctx,data,statData,data.datasets[i].inGraphDataShow,config.inGraphDataShow,"inGraphDataShow",i,j,{nullValue : true}))  {
							ctx.save();
							ctx.textAlign = setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,j,{nullValue: true  });
							ctx.textBaseline = setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,j,{nullValue : true} );
							ctx.font = setOptionValue(true,1,"INGRAPHDATAFONTSTYLE",ctx,data,statData,undefined,config.inGraphDataFontStyle,"inGraphDataFontStyle",i,j,{nullValue : true} ) + ' ' + setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ) + 'px ' + setOptionValue(true,1,"INGRAPHDATAFONTFAMILY",ctx,data,statData,undefined,config.inGraphDataFontFamily,"inGraphDataFontFamily",i,j,{nullValue : true} );
							ctx.fillStyle = setOptionValue(true,1,"INGRAPHDATAFONTCOLOR",ctx,data,statData,undefined,config.inGraphDataFontColor,"inGraphDataFontColor",i,j,{nullValue : true} );
							ctx.beginPath();
							var yPos = 0,
								xPos = 0;
							if (setOptionValue(true,1,"INGRAPHDATAYPOSITION",ctx,data,statData,undefined,config.inGraphDataYPosition,"inGraphDataYPosition",i,j,{nullValue : true} ) == 1) {
								yPos = statData[i][j].yPosTop - setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} ) + barWidth;
							} else if (setOptionValue(true,1,"INGRAPHDATAYPOSITION",ctx,data,statData,undefined,config.inGraphDataYPosition,"inGraphDataYPosition",i,j,{nullValue : true} ) == 2) {
								yPos = statData[i][j].yPosTop + barWidth / 2 - setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAYPOSITION",ctx,data,statData,undefined,config.inGraphDataYPosition,"inGraphDataYPosition",i,j,{nullValue : true} ) == 3) {
								yPos = statData[i][j].yPosTop - setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} );
							}
							if (setOptionValue(true,1,"INGRAPHDATAXPOSITION",ctx,data,statData,undefined,config.inGraphDataXPosition,"inGraphDataXPosition",i,j,{nullValue : true} ) == 1) {
								xPos = statData[i][j].xPosLeft + setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAXPOSITION",ctx,data,statData,undefined,config.inGraphDataXPosition,"inGraphDataXPosition",i,j,{nullValue : true} ) == 2) {
								xPos = (statData[i][j].xPosLeft+statData[i][j].xPosRight)/2 + setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} );
							} else if (setOptionValue(true,1,"INGRAPHDATAXPOSITION",ctx,data,statData,undefined,config.inGraphDataXPosition,"inGraphDataXPosition",i,j,{nullValue : true} ) == 3) {
								xPos = statData[i][j].xPosRight + setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} );
							}
							ctx.translate(xPos, yPos);
							var dispString = tmplbis(setOptionValue(true,1,"INGRAPHDATATMPL",ctx,data,statData,undefined,config.inGraphDataTmpl,"inGraphDataTmpl",i,j,{nullValue : true} ), statData[i][j],config);
							var rotateVal=setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,j,{nullValue : true} ) * (Math.PI / 180);
							ctx.rotate(rotateVal);
							setTextBordersAndBackground(ctx,dispString,setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ),0,0,setOptionValue(true,1,"INGRAPHDATABORDERS",ctx,data,statData,undefined,config.inGraphDataBorders,"inGraphDataBorders",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSCOLOR",ctx,data,statData,undefined,config.inGraphDataBordersColor,"inGraphDataBordersColor",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartLineScale,"INGRAPHDATABORDERSWIDTH",ctx,data,statData,undefined,config.inGraphDataBordersWidth,"inGraphDataBordersWidth",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSXSPACE",ctx,data,statData,undefined,config.inGraphDataBordersXSpace,"inGraphDataBordersXSpace",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSYSPACE",ctx,data,statData,undefined,config.inGraphDataBordersYSpace,"inGraphDataBordersYSpace",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSSTYLE",ctx,data,statData,undefined,config.inGraphDataBordersStyle,"inGraphDataBordersStyle",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABACKGROUNDCOLOR",ctx,data,statData,undefined,config.inGraphDataBackgroundColor,"inGraphDataBackgroundColor",i,j,{nullValue : true} ),"INGRAPHDATA",config.inGraphDataBordersRadius);
							ctx.fillTextMultiLine(dispString, 0, 0, ctx.textBaseline, setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ),true,config.detectMouseOnText,ctx,"INGRAPHDATA_TEXTMOUSE",rotateVal,xPos, yPos,i,j);
							ctx.restore();
						}
					}
				}
			}
			if(msr.legendMsr.dispLegend)drawLegend(msr.legendMsr,data,config,ctx,"HorizontalBar");
		};

		function roundRect(ctx, x, y, w, h, stroke, radius, zeroY,i,j,fact) {
			ctx.beginPath();
			ctx.moveTo(y + zeroY, x );
			ctx.lineTo(y + zeroY, x + w);
			ctx.lineTo(y + h - fact*radius, x + w);
			ctx.quadraticCurveTo(y + h, x + w, y + h, x + w - radius);
			ctx.lineTo(y + h, x + radius);
			ctx.quadraticCurveTo(y + h, x, y + h - fact*radius, x);
			ctx.lineTo(y + zeroY, x);
			ctx.quadraticCurveTo(y + zeroY, x, y + zeroY, x + w);

			if (stroke) { 
				ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"STROKESTYLE",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
				ctx.stroke();
				ctx.setLineDash([]);
			};
			ctx.closePath();
			ctx.fill();
		};

		function drawScale() {
			//X axis line                                                          
			ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleLineWidth);
			ctx.strokeStyle = config.scaleLineColor;
			ctx.setLineDash(lineStyleFn(config.scaleLineStyle));
			ctx.beginPath();
			ctx.moveTo(yAxisPosX - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft), xAxisPosY);
			ctx.lineTo(yAxisPosX + msr.availableWidth + Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight), xAxisPosY);
			ctx.stroke();
			ctx.setLineDash([]);
			
			ctx.setLineDash(lineStyleFn(config.scaleGridLineStyle));
			for (var i = ((config.showYAxisMin) ? -1 : 0); i < calculatedScale.steps; i++) {
				if (i >= 0) {
					ctx.beginPath();
					ctx.moveTo(yAxisPosX + i * valueHop, xAxisPosY + Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom));
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth);
					ctx.strokeStyle = config.scaleGridLineColor;
					//Check i isnt 0, so we dont go over the Y axis twice.
					if (config.scaleShowGridLines && i > 0 && i % config.scaleXGridLinesStep == 0) {
						ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY - msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop));
					} else {
						ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY);
					}
					ctx.stroke();
				}

			}
			ctx.setLineDash([]);
			//Y axis
			ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleLineWidth);
			ctx.strokeStyle = config.scaleLineColor;
			ctx.setLineDash(lineStyleFn(config.scaleLineStyle));
			ctx.beginPath();
			ctx.moveTo(yAxisPosX, xAxisPosY + Math.ceil(ctx.chartLineScale*config.scaleTickSizeBottom));
			ctx.lineTo(yAxisPosX, xAxisPosY - msr.availableHeight - Math.ceil(ctx.chartLineScale*config.scaleTickSizeTop));
			ctx.stroke();
			ctx.setLineDash([]);
			ctx.setLineDash(lineStyleFn(config.scaleGridLineStyle));
			for (var j = 0; j < data.labels.length; j++) {
				ctx.beginPath();
				ctx.moveTo(yAxisPosX - Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft), xAxisPosY - ((j + 1) * scaleHop));
				ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.scaleGridLineWidth);
				ctx.strokeStyle = config.scaleGridLineColor;
				if (config.scaleShowGridLines && (j+1) % config.scaleYGridLinesStep == 0) {
					ctx.lineTo(yAxisPosX + msr.availableWidth + Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight), xAxisPosY - ((j + 1) * scaleHop));
				} else {
					ctx.lineTo(yAxisPosX, xAxisPosY - ((j + 1) * scaleHop));
				}
				ctx.stroke();
			}
			ctx.setLineDash([]);
		};

		function drawLabels() {
			ctx.font = config.scaleFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.scaleFontSize)).toString() + "px " + config.scaleFontFamily;
			//X axis line                                                          
			if (config.scaleShowLabels && (config.xAxisTop || config.xAxisBottom)) {
				ctx.textBaseline = "top";
				if (msr.rotateLabels > 90) {
					ctx.save();
					ctx.textAlign = "left";
				} else if (msr.rotateLabels > 0) {
					ctx.save();
					ctx.textAlign = "right";
				} else {
					ctx.textAlign = "center";
				}
				ctx.fillStyle = config.scaleFontColor;
				if (config.xAxisBottom) {
					for (var i = ((config.showYAxisMin) ? -1 : 0); i < calculatedScale.steps; i++) {
						if(showYLabels(ctx,data,config,i+1,calculatedScale.labels[i+ 1])) {				
							ctx.save();
							if (msr.rotateLabels > 0) {
								ctx.translate(yAxisPosX + (i + 1) * valueHop - msr.highestXLabel / 2, msr.xLabelPos);
								ctx.rotate(-(msr.rotateLabels * (Math.PI / 180)));
								ctx.fillTextMultiLine(calculatedScale.labels[i + 1], 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"XAXIS_TEXTMOUSE",-(msr.rotateLabels * (Math.PI / 180)),yAxisPosX + (i + 1) * valueHop - msr.highestXLabel / 2, msr.xLabelPos,i,-1);
							} else {
								ctx.fillTextMultiLine(calculatedScale.labels[i + 1], yAxisPosX + (i + 1) * valueHop, msr.xLabelPos, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"XAXIS_TEXTMOUSE",0,0,0,i,-1);
							}
							ctx.restore();
						}
					}
				}
			}
			//Y axis
			ctx.textAlign = "right";
			ctx.textBaseline = "middle";
			for (var j = 0; j < data.labels.length; j++) {
				if(showLabels(ctx,data,config,j)){
					if (config.yAxisLeft) {
						ctx.textAlign = "right";
						ctx.fillTextMultiLine(fmtChartJS(config, data.labels[j], config.fmtXLabel), yAxisPosX - (Math.ceil(ctx.chartLineScale*config.scaleTickSizeLeft) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight)), xAxisPosY - (j * scaleHop) - scaleHop / 2, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"YLEFTAXIS_TEXTMOUSE",0,0,0,-1,j);
					}
					if (config.yAxisRight) {
						ctx.textAlign = "left";
						ctx.fillTextMultiLine(fmtChartJS(config, data.labels[j], config.fmtXLabel), yAxisPosX + msr.availableWidth + (Math.ceil(ctx.chartLineScale*config.scaleTickSizeRight) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight)), xAxisPosY - (j * scaleHop) - scaleHop / 2, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.scaleFontSize)),true,config.detectMouseOnText,ctx,"YRIGHTAXIS_TEXTMOUSE",0,0,0,-1,j);
					}
				}
			}
		};

		function getValueBounds() {
			var upperValue = -Number.MAX_VALUE;
			var lowerValue = Number.MAX_VALUE;
			for (var i = 0; i < data.datasets.length; i++) {
				for (var j = 0; j < data.datasets[i].data.length; j++) {
					if(typeof data.datasets[i].data[j]=="undefined")continue;
					if (1 * data.datasets[i].data[j] > upperValue) {
						upperValue = 1 * data.datasets[i].data[j]
					};
					if (1 * data.datasets[i].data[j] < lowerValue) {
						lowerValue = 1 * data.datasets[i].data[j]
					};
				}
			};
			if(upperValue<lowerValue){upperValue=0;lowerValue=0;}
			if (Math.abs(upperValue - lowerValue) < config.zeroValue) {
				if(Math.abs(upperValue)< config.zeroValue) upperValue = .9;
				if(upperValue>0) {
					upperValue=upperValue*1.1;
					lowerValue=lowerValue*0.9;
				} else {
					upperValue=upperValue*0.9;
					lowerValue=lowerValue*1.1;
				}
			}
			// AJOUT CHANGEMENT
			if(typeof config.graphMin=="function")lowerValue= setOptionValue(true,1,"GRAPHMIN",ctx,data,statData,undefined,config.graphMin,"graphMin",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMin)) lowerValue = config.graphMin;                                                            
			if(typeof config.graphMax=="function") upperValue= setOptionValue(true,1,"GRAPHMAX",ctx,data,statData,undefined,config.graphMax,"graphMax",-1,-1,{nullValue : true})
			else if (!isNaN(config.graphMax)) upperValue = config.graphMax;

			labelHeight = (Math.ceil(ctx.chartTextScale*config.scaleFontSize));
			scaleHeight = msr.availableHeight;

			var maxSteps = Math.floor((scaleHeight / (labelHeight * 0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight * 0.5));
			if(upperValue<lowerValue){lowerValue=upperValue-1;}
			return {
				maxValue: upperValue,
				minValue: lowerValue,
				maxSteps: maxSteps,
				minSteps: minSteps
			};
		};

		return {
			data:data,
			config:config,
			ctx:ctx
		};
	};

	function calculateOffset(logarithmic, val, calculatedScale, scaleHop) {
		if (!logarithmic) { // no logarithmic scale
			var outerValue = calculatedScale.steps * calculatedScale.stepValue;
			var adjustedValue = val - calculatedScale.graphMin;
			var scalingFactor = CapValue(adjustedValue / outerValue, 1, 0);
			return (scaleHop * calculatedScale.steps) * scalingFactor;
		} else { // logarithmic scale
//			return CapValue(log10(val) * scaleHop - calculateOrderOfMagnitude(calculatedScale.graphMin) * scaleHop, undefined, 0);
			return CapValue(log10(val) * scaleHop - log10(calculatedScale.graphMin) * scaleHop, undefined, 0);
		}
	};

	function animationLoop(config, drawScale, drawData, ctx, clrx, clry, clrwidth, clrheight, midPosX, midPosY, borderX, borderY, data, statData) {
		var cntiter = 0;
		var animationCount = 1;
		var multAnim = 1;
		if (config.animationStartValue < 0 || config.animationStartValue > 1) config.animation.StartValue = 0;
		if (config.animationStopValue < 0 || config.animationStopValue > 1) config.animation.StopValue = 1;
		if (config.animationStopValue < config.animationStartValue) config.animationStopValue = config.animationStartValue;
		if (isIE() < 9 && isIE() != false) config.animation = false;
		var animFrameAmount = (config.animation) ? 1 / CapValue(config.animationSteps, Number.MAX_VALUE, 1) : 1,
			easingFunction = animationOptions[config.animationEasing],
			percentAnimComplete = (config.animation) ? 0 : 1;
		if (config.animation && config.animationStartValue > 0 && config.animationStartValue <= 1) {
			while (percentAnimComplete < config.animationStartValue) {
				cntiter++;
				percentAnimComplete += animFrameAmount;
			}
		}
		var beginAnim = cntiter;
		var beginAnimPct = percentAnimComplete;
		if (typeof drawScale !== "function") drawScale = function() {};
		if (config.clearRect) {
			if(config.animationForceSetTimeOut)requestAnimFrameSetTimeOut(animLoop);
			else requestAnimFrame(animLoop);
		} else animLoop();

		function animateFrame() {
			var easeAdjustedAnimationPercent = (config.animation) ? CapValue(easingFunction(percentAnimComplete), null, 0) : 1;
			if (1 * cntiter >= 1 * CapValue(config.animationSteps, Number.MAX_VALUE, 1) || config.animation == false || ctx.firstPass%10!=1) easeAdjustedAnimationPercent = 1;
			else if (easeAdjustedAnimationPercent >= 1) easeAdjustedAnimationPercent = 0.9999;
			if (config.animation && !(isIE() < 9 && isIE() != false) && config.clearRect) {
				ctx.clearRect(clrx, clry, clrwidth, clrheight);
			}
			dispCrossImage(ctx, config, midPosX, midPosY, borderX, borderY, false, data, easeAdjustedAnimationPercent, cntiter);
			dispCrossText(ctx, config, midPosX, midPosY, borderX, borderY, false, data, easeAdjustedAnimationPercent, cntiter);
			if(typeof config.beforeDrawFunction == "function") config.beforeDrawFunction("BEFOREDRAWFUNCTION",ctx,data,statData,-1,-1,{animationValue : easeAdjustedAnimationPercent, cntiter: cntiter, config : config, borderX : borderX, borderY : borderY, midPosX : midPosX, midPosY : midPosY});
			if (config.scaleOverlay) {
				drawData(easeAdjustedAnimationPercent);
				if(typeof config.endDrawDataFunction == "function")config.endDrawDataFunction("ENDDATAFUNCTION",ctx,data,statData,-1,-1,{animationValue : easeAdjustedAnimationPercent, cntiter: cntiter, config : config, borderX : borderX, borderY : borderY, midPosX : midPosX, midPosY : midPosY});
				drawScale();
				if(typeof config.endDrawScaleFunction == "function")config.endDrawScaleFunction("ENDSCALEFUNCTION",ctx,data,statData,-1,-1,{animationValue : easeAdjustedAnimationPercent, cntiter: cntiter, config : config, borderX : borderX, borderY : borderY, midPosX : midPosX, midPosY : midPosY});
			} else {
				drawScale();
				if(typeof config.endDrawScaleFunction == "function")config.endDrawScaleFunction("ENDSCALEFUNCTION",ctx,data,statData,-1,-1,{animationValue : easeAdjustedAnimationPercent, cntiter: cntiter, config : config, borderX : borderX, borderY : borderY, midPosX : midPosX, midPosY : midPosY});
				drawData(easeAdjustedAnimationPercent);
				if(typeof config.endDrawDataFunction == "function")config.endDrawDataFunction("ENDDATAFUNCTION",ctx,data,statData,-1,-1,{animationValue : easeAdjustedAnimationPercent, cntiter: cntiter, config : config, borderX : borderX, borderY : borderY, midPosX : midPosX, midPosY : midPosY});
			}
			dispCrossImage(ctx, config, midPosX, midPosY, borderX, borderY, true, data, easeAdjustedAnimationPercent, cntiter);
			dispCrossText(ctx, config, midPosX, midPosY, borderX, borderY, true, data, easeAdjustedAnimationPercent, cntiter);
		};

		function animLoop() {
			//We need to check if the animation is incomplete (less than 1), or complete (1).
			cntiter += multAnim;
			percentAnimComplete += multAnim * animFrameAmount;
			if (cntiter == config.animationSteps || config.animation == false || ctx.firstPass%10!=1) percentAnimComplete = 1;
			else if (percentAnimComplete >= 1) percentAnimComplete = 0.999;
			animateFrame();
			//Stop the loop continuing forever
			if (multAnim == -1 && cntiter <= beginAnim) {
				if (typeof config.onAnimationComplete == "function" && ctx.runanimationcompletefunction==true) config.onAnimationComplete(ctx, config, data, 0, animationCount + 1,statData);
				multAnim = 1;
				if(config.animationForceSetTimeOut)requestAnimFrameSetTimeOut(animLoop);
				else requestAnimFrame(animLoop);
			} else if (percentAnimComplete < config.animationStopValue) {
				if(config.animationForceSetTimeOut)requestAnimFrameSetTimeOut(animLoop);
				else requestAnimFrame(animLoop);
			} else {
				if ((animationCount < config.animationCount || config.animationCount == 0) && (ctx.firstPass%10==1)) {
					animationCount++;
					if (config.animationBackward && multAnim == 1) {
						percentAnimComplete -= animFrameAmount;
						multAnim = -1;
					} else {
						multAnim = 1;
						cntiter = beginAnim - 1;
						percentAnimComplete = beginAnimPct - animFrameAmount;
					}
					window.setTimeout(animLoop, config.animationPauseTime*1000);
				} else {
					if(!testRedraw(ctx,data,config)) {
						if (typeof config.onAnimationComplete == "function" && ctx.runanimationcompletefunction==true) {
							config.onAnimationComplete(ctx, config, data, 1, animationCount + 1,statData);

							ctx.runanimationcompletefunction=false;
						}
					}
					ctx.firstPass=9;
				}
				
			}
		};
	};
	//Declare global functions to be called within this namespace here.
	// shim layer with setTimeout fallback
	var requestAnimFrame = (function() {
		return window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(callback) {
				window.setTimeout(callback, 1000 / 60);
			};
	})();
	var requestAnimFrameSetTimeOut = (function() {
		return	function(callback) { window.setTimeout(callback, 1000 / 60); };
	})();


	function calculateScale(axis, config, maxSteps, minSteps, maxValue, minValue, labelTemplateString) {
		var graphMin, graphMax, graphRange, stepValue, numberOfSteps, valueRange, rangeOrderOfMagnitude, decimalNum;
		var logarithmic, yAxisMinimumInterval;
		if (axis == 2) {
			logarithmic = config.logarithmic2;
			yAxisMinimumInterval = config.yAxisMinimumInterval2;
		} else {
			logarithmic = config.logarithmic;
			yAxisMinimumInterval = config.yAxisMinimumInterval;
		}

		if (!logarithmic) { // no logarithmic scale
			valueRange = maxValue - minValue;
			rangeOrderOfMagnitude = calculateOrderOfMagnitude(valueRange);
			if(Math.abs(minValue)>config.zeroValue)graphMin = Math.floor(minValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude);
			else graphMin=0;
			if(Math.abs(maxValue)>config.zeroValue)graphMax = Math.ceil(maxValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude);
			else graphMax=0;
			if (typeof yAxisMinimumInterval == "number") {
				if(graphMax>=0) {
					graphMin = graphMin - (graphMin % yAxisMinimumInterval);
					while (graphMin > minValue) graphMin = graphMin - yAxisMinimumInterval;
					if (graphMax % yAxisMinimumInterval > config.zeroValue && graphMax % yAxisMinimumInterval < yAxisMinimumInterval - config.zeroValue) {
						graphMax = roundScale(config, (1 + Math.floor(graphMax / yAxisMinimumInterval)) * yAxisMinimumInterval);
					}
					while (graphMax < maxValue) graphMax = graphMax + yAxisMinimumInterval;
				}
			}
		} else { // logarithmic scale
			if(minValue==maxValue)maxValue=maxValue+1;
			if(minValue==0)minValue=0.01;
			var minMag = calculateOrderOfMagnitude(minValue);
			var maxMag = calculateOrderOfMagnitude(maxValue) + 1;
			graphMin = Math.pow(10, minMag);
			graphMax = Math.pow(10, maxMag);
			rangeOrderOfMagnitude = maxMag - minMag;
		}
		graphRange = graphMax - graphMin;
		stepValue = Math.pow(10, rangeOrderOfMagnitude);
		numberOfSteps = Math.round(graphRange / stepValue);
		if (!logarithmic) { // no logarithmic scale
			//Compare number of steps to the max and min for that size graph, and add in half steps if need be.
			var stopLoop = false;
			while (!stopLoop && (numberOfSteps < minSteps || numberOfSteps > maxSteps)) {
				if (numberOfSteps < minSteps) {
					if (typeof yAxisMinimumInterval == "number") {
						if (stepValue / 2 < yAxisMinimumInterval) {
							stopLoop = true;
							stepValue=yAxisMinimumInterval;
							numberOfSteps=Math.ceil(graphRange / stepValue);
						}
					}
					if (!stopLoop) {
						stepValue /=2;
						numberOfSteps = Math.round(graphRange / stepValue);
					}
				} else {
					stepValue *= 2;
					numberOfSteps = Math.round(graphRange / stepValue);
				}
	
			}

			if (typeof yAxisMinimumInterval == "number") {
				if (stepValue < yAxisMinimumInterval) {
					stepValue = yAxisMinimumInterval;
					numberOfSteps = Math.ceil(graphRange / stepValue);
				} 
				if (stepValue % yAxisMinimumInterval > config.zeroValue && stepValue % yAxisMinimumInterval < yAxisMinimumInterval - config.zeroValue) {
					if ((2 * stepValue) % yAxisMinimumInterval < config.zeroValue || (2 * stepValue) % yAxisMinimumInterval > yAxisMinimumInterval - config.zeroValue) {
						stepValue = 2 * stepValue;
						numberOfSteps = Math.ceil(graphRange / stepValue);
					} else {
						stepValue = roundScale(config, (1 + Math.floor(stepValue / yAxisMinimumInterval)) * yAxisMinimumInterval);
						numberOfSteps = Math.ceil(graphRange / stepValue);
					}
				}
			}
			if(config.graphMaximized==true || config.graphMaximized=="bottom" || typeof config.graphMin!=="undefined") {
				while (graphMin+stepValue < minValue && numberOfSteps>=3){graphMin+=stepValue;numberOfSteps--};
			}
			if(config.graphMaximized==true || config.graphMaximized=="top" || typeof config.graphMax!=="undefined") {

				while (graphMin+(numberOfSteps-1)*stepValue >= maxValue && numberOfSteps>=3) numberOfSteps--;
			}
		} else { // logarithmic scale
			numberOfSteps = rangeOrderOfMagnitude; // so scale is 10,100,1000,...
		}
		var labels = [];
		populateLabels(1, config, labelTemplateString, labels, numberOfSteps, graphMin, graphMax, stepValue);
		return {
			steps: numberOfSteps,
			stepValue: stepValue,
			graphMin: graphMin,
			labels: labels,
			maxValue: maxValue
		}
	};

	function roundScale(config, value) {
		var scldec = 0;
		var sscl = "" + config.yAxisMinimumInterval;
		if (sscl.indexOf(".") > 0) {
			scldec = sscl.substr(sscl.indexOf(".")).length;
		}
		return (Math.round(value * Math.pow(10, scldec)) / Math.pow(10, scldec));
	} ;

	function calculateOrderOfMagnitude(val) {
		if (val==0)return 0;
		return Math.floor(Math.log(val) / Math.LN10);
	};
	//Populate an array of all the labels by interpolating the string.
	function populateLabels(axis, config, labelTemplateString, labels, numberOfSteps, graphMin, graphMax, stepValue) {
		var logarithmic;
		if (axis == 2) {
			logarithmic = config.logarithmic2;
			fmtYLabel = config.fmtYLabel2;
		} else {
			logarithmic = config.logarithmic;
			fmtYLabel = config.fmtYLabel;
		}
		if (labelTemplateString) {
			//Fix floating point errors by setting to fixed the on the same decimal as the stepValue.
			var i;
			if (!logarithmic) { // no logarithmic scale
				for (i = 0; i < numberOfSteps + 1; i++) {
					labels.push(tmpl(labelTemplateString, {
						value: fmtChartJS(config, 1 * ((graphMin + (stepValue * i)).toFixed(getDecimalPlaces(stepValue))), fmtYLabel)
					},config));
				}
			} else { // logarithmic scale 10,100,1000,...
				var value = graphMin;
				for (i = 0; i < numberOfSteps + 1; i++) {
					labels.push(tmpl(labelTemplateString, {
						value: fmtChartJS(config, 1 * value.toFixed(getDecimalPlaces(value)), fmtYLabel)
					},config));
					value *= 10;
				}
			}
		}
	};
	//Max value from array
	function Max(array) {
		return Math.max.apply(Math, array);
	};
	//Min value from array
	function Min(array) {
		return Math.min.apply(Math, array);
	};
	//Default if undefined
	function Default(userDeclared, valueIfFalse) {
		if (!userDeclared) {
			return valueIfFalse;
		} else {
			return userDeclared;
		}
	};
	//Apply cap a value at a high or low number
	function CapValue(valueToCap, maxValue, minValue) {
		if (isNumber(maxValue)) {
			if (valueToCap > maxValue) {
				return maxValue;
			}
		}
		if (isNumber(minValue)) {
			if (valueToCap < minValue) {
				return minValue;
			}
		}
		return valueToCap;
	};

	function getDecimalPlaces(num) {
		var match = (''+num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
		if (!match) { 
			return 0;
		}
		return Math.max(
			0,
			(match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0)
		);
	};

	function mergeChartConfig(defaults, userDefined) {
		var returnObj = {};
		for (var attrname in defaults) {
			returnObj[attrname] = defaults[attrname];
		}
		for (var attrnameBis in userDefined) {
			returnObj[attrnameBis] = userDefined[attrnameBis];
		}
		return returnObj;
	};
	//Javascript micro templating by John Resig - source at http://ejohn.org/blog/javascript-micro-templating/
	var cache = {};
	
	function tmpl(str, data,config) {
		newstr=str;
		if(newstr.substr(0,config.templatesOpenTag.length)==config.templatesOpenTag)newstr="<%="+newstr.substr(config.templatesOpenTag.length,newstr.length-config.templatesOpenTag.length);
		if(newstr.substr(newstr.length-config.templatesCloseTag.length,config.templatesCloseTag.length)==config.templatesCloseTag)newstr=newstr.substr(0,newstr.length-config.templatesCloseTag.length)+"%>";
		return tmplpart2(newstr,data);
	}

	function tmplpart2(str, data) {
		// Figure out if we're getting a template, or if we need to
		// load the template - and be sure to cache the result.
		var fn = !/\W/.test(str) ?
			cache[str] = cache[str] ||
			tmplpart2(document.getElementById(str).innerHTML) :
			// Generate a reusable function that will serve as a template
			// generator (and which will be cached).
			new Function("obj",
				"var p=[],print=function(){p.push.apply(p,arguments);};" +
				// Introduce the data as local variables using with(){}
				"with(obj){p.push('" +
				// Convert the template into pure JavaScript
				str
				.replace(/[\r\t\n]/g, " ")
				.split("<%").join("\t")
				.replace(/((^|%>)[^\t]*)'/g, "$1\r")
				.replace(/\t=(.*?)%>/g, "',$1,'")
				.split("\t").join("');")
				.split("%>").join("p.push('")
				.split("\r").join("\\'") + "');}return p.join('');");
		// Provide some basic currying to the user
		return data ? fn(data) : fn;
	};

	function dispCrossText(ctx, config, posX, posY, borderX, borderY, overlay, data, animPC, cntiter) {
		var i, disptxt, txtposx, txtposy, textAlign, textBaseline;
		for (i = 0; i < config.crossText.length; i++) {
			if (config.crossText[i] != "" && config.crossTextOverlay[Min([i, config.crossTextOverlay.length - 1])] == overlay && ((cntiter == 1 && config.crossTextIter[Min([i, config.crossTextIter.length - 1])] == "first") || config.crossTextIter[Min([i, config.crossTextIter.length - 1])] == cntiter || config.crossTextIter[Min([i, config.crossTextIter.length - 1])] == "all" || (animPC == 1 && config.crossTextIter[Min([i, config.crossTextIter.length - 1])] == "last"))) {
				ctx.save();
				ctx.beginPath();
				ctx.font = config.crossTextFontStyle[Min([i, config.crossTextFontStyle.length - 1])] + " " + (Math.ceil(ctx.chartTextScale*config.crossTextFontSize[Min([i, config.crossTextFontSize.length - 1])])).toString() + "px " + config.crossTextFontFamily[Min([i, config.crossTextFontFamily.length - 1])];
				ctx.fillStyle = config.crossTextFontColor[Min([i, config.crossTextFontColor.length - 1])];
				textAlign = config.crossTextAlign[Min([i, config.crossTextAlign.length - 1])];
				textBaseline = config.crossTextBaseline[Min([i, config.crossTextBaseline.length - 1])];
				txtposx = 1 * Math.ceil(ctx.chartSpaceScale*config.crossTextPosX[Min([i, config.crossTextPosX.length - 1])]);
				txtposy = 1 * Math.ceil(ctx.chartSpaceScale*config.crossTextPosY[Min([i, config.crossTextPosY.length - 1])]);
				switch (1 * config.crossTextRelativePosX[Min([i, config.crossTextRelativePosX.length - 1])]) {
					case 0:
						if (textAlign == "default") textAlign = "left";
						break;
					case 1:
						txtposx += borderX;
						if (textAlign == "default") textAlign = "right";
						break;
					case 2:
						txtposx += posX;
						if (textAlign == "default") textAlign = "center";
						break;
					case -2:
						txtposx += context.canvas.width / 2;
						if (textAlign == "default") textAlign = "center";
						break;
					case 3:
						txtposx += txtposx + 2 * posX - borderX;
						if (textAlign == "default") textAlign = "left";
						break;
					case 4:
						txtposx += context.canvas.width;
						if (textAlign == "default") textAlign = "right";
						break;
					default:
						txtposx += posX;
						if (textAlign == "default") textAlign = "center";
						break;
				}
				switch (1 * config.crossTextRelativePosY[Min([i, config.crossTextRelativePosY.length - 1])]) {
					case 0:
						if (textBaseline == "default") textBaseline = "top";
						break;
					case 3:
						txtposy += borderY;
						if (textBaseline == "default") textBaseline = "top";
						break;
					case 2:
						txtposy += posY;
						if (textBaseline == "default") textBaseline = "middle";
						break;
					case -2:
						txtposy += context.canvas.height / 2;
						if (textBaseline == "default") textBaseline = "middle";
						break;
					case 1:
						txtposy += txtposy + 2 * posY - borderY;
						if (textBaseline == "default") textBaseline = "bottom";
						break;
					case 4:
						txtposy += context.canvas.height;
						if (textBaseline == "default") textBaseline = "bottom";
						break;
					default:
						txtposy += posY;
						if (textBaseline == "default") textBaseline = "middle";
						break;
				}
				ctx.textAlign = textAlign;
				ctx.textBaseline = textBaseline;
				ctx.translate(1 * txtposx, 1 * txtposy);
				var rotateVal=Math.PI * config.crossTextAngle[Min([i, config.crossTextAngle.length - 1])] / 180;
				ctx.rotate(rotateVal);
				if (config.crossText[i].substring(0, 1) == "%") {
					if (typeof config.crossTextFunction == "function") disptxt = config.crossTextFunction(i, config.crossText[i], ctx, config, posX, posY, borderX, borderY, overlay, data, animPC);
				} else disptxt = config.crossText[i];

				setTextBordersAndBackground(ctx,disptxt,Math.ceil(ctx.chartTextScale*config.crossTextFontSize[Min([i, config.crossTextFontSize.length - 1])]),0,0,config.crossTextBorders[Min([i, config.crossTextBorders.length - 1])],config.crossTextBordersColor[Min([i, config.crossTextBordersColor.length - 1])],Math.ceil(ctx.chartLineScale*config.crossTextBordersWidth[Min([i, config.crossTextBordersWidth.length - 1])]),Math.ceil(ctx.chartSpaceScale*config.crossTextBordersXSpace[Min([i, config.crossTextBordersXSpace.length - 1])]),Math.ceil(ctx.chartSpaceScale*config.crossTextBordersYSpace[Min([i, config.crossTextBordersYSpace.length - 1])]),config.crossTextBordersStyle[Min([i, config.crossTextBordersStyle.length - 1])],config.crossTextBackgroundColor[Min([i, config.crossTextBackgroundColor.length - 1])],"CROSSTEXT",config.crossTextBordersRadius);
				if((animPC==1 && config.crossTextIter[Min([i, config.crossTextIter.length - 1])] == "all") || config.crossTextIter[Min([i, config.crossTextIter.length - 1])] != "last") {
				       ctx.fillTextMultiLine(disptxt, 0, 0, ctx.textBaseline, Math.ceil(ctx.chartTextScale*config.crossTextFontSize[Min([i, config.crossTextFontSize.length - 1])]),true,config.detectMouseOnText,ctx,"CROSSTEXT_TEXTMOUSE",rotateVal,1 * txtposx, 1 * txtposy,i,-1);
				} else ctx.fillTextMultiLine(disptxt, 0, 0, ctx.textBaseline, Math.ceil(ctx.chartTextScale*config.crossTextFontSize[Min([i, config.crossTextFontSize.length - 1])]),true,false,ctx,"CROSSTEXT_TEXTMOUSE",rotateVal,1 * txtposx, 1 * txtposy,i,-1);
				ctx.restore();
			}
		}
	};

	function dispCrossImage(ctx, config, posX, posY, borderX, borderY, overlay, data, animPC, cntiter) {
		var i, disptxt, imageposx, imageposy, imageAlign, imageBaseline;
		for (i = 0; i < config.crossImage.length; i++) {
			if (typeof config.crossImage[i] != "undefined" && config.crossImageOverlay[Min([i, config.crossImageOverlay.length - 1])] == overlay && ((cntiter == -1 && config.crossImageIter[Min([i, config.crossImageIter.length - 1])] == "background") || (cntiter == 1 && config.crossImageIter[Min([i, config.crossImageIter.length - 1])] == "first") || config.crossImageIter[Min([i, config.crossImageIter.length - 1])] == cntiter || (cntiter != -1 && config.crossImageIter[Min([i, config.crossImageIter.length - 1])] == "all") || (animPC == 1 && config.crossImageIter[Min([i, config.crossImageIter.length - 1])] == "last"))) {
				ctx.save();
				ctx.beginPath();
				imageAlign = config.crossImageAlign[Min([i, config.crossImageAlign.length - 1])];
				imageBaseline = config.crossImageBaseline[Min([i, config.crossImageBaseline.length - 1])];
				imageposx = 1 * Math.ceil(ctx.chartSpaceScale*config.crossImagePosX[Min([i, config.crossImagePosX.length - 1])]);
				imageposy = 1 * Math.ceil(ctx.chartSpaceScale*config.crossImagePosY[Min([i, config.crossImagePosY.length - 1])]);
				switch (1 * config.crossImageRelativePosX[Min([i, config.crossImageRelativePosX.length - 1])]) {
					case 0:
						if (imageAlign == "default") imageAlign = "left";
						break;
					case 1:
						imageposx += borderX;
						if (imageAlign == "default") imageAlign = "right";
						break;
					case 2:
						imageposx += posX;
						if (imageAlign == "default") imageAlign = "center";
						break;
					case -2:
						imageposx += context.canvas.width / 2;
						if (imageAlign == "default") imageAlign = "center";
						break;
					case 3:
						imageposx += imageposx + 2 * posX - borderX;
						if (imageAlign == "default") imageAlign = "left";
						break;
					case 4:
						imageposx += context.canvas.width;
						if (imageAlign == "default") imageAlign = "right";
						break;
					default:
						imageposx += posX;
						if (imageAlign == "default") imageAlign = "center";
						break;
				}
				switch (1 * config.crossImageRelativePosY[Min([i, config.crossImageRelativePosY.length - 1])]) {
					case 0:
						if (imageBaseline == "default") imageBaseline = "top";
						break;
					case 3:
						imageposy += borderY;
						if (imageBaseline == "default") imageBaseline = "top";
						break;
					case 2:
						imageposy += posY;
						if (imageBaseline == "default") imageBaseline = "middle";
						break;
					case -2:
						imageposy += context.canvas.height / 2;
						if (imageBaseline == "default") imageBaseline = "middle";
						break;
					case 1:
						imageposy += imageposy + 2 * posY - borderY;
						if (imageBaseline == "default") imageBaseline = "bottom";
						break;
					case 4:
						imageposy += context.canvas.height;
						if (imageBaseline == "default") imageBaseline = "bottom";
						break;
					default:
						imageposy += posY;
						if (imageBaseline == "default") imageBaseline = "middle";
						break;
				}
				var imageWidth = config.crossImage[i].width;
				switch (imageAlign) {
					case "left":
						break;
					case "right":
						imageposx -= imageWidth;
						break;
					case "center":
						imageposx -= (imageWidth / 2);
						break;
					default:
						break;
				}
				var imageHeight = config.crossImage[i].height;
				switch (imageBaseline) {
					case "top":
						break;
					case "bottom":
						imageposy -= imageHeight;
						break;
					case "middle":
						imageposy -= (imageHeight / 2);
						break;
					default:
						break;
				}
				ctx.translate(1 * imageposx, 1 * imageposy);
				ctx.rotate(Math.PI * config.crossImageAngle[Min([i, config.crossImageAngle.length - 1])] / 180);
				ctx.drawImage(config.crossImage[i], 0, 0);
				ctx.restore();
			}
		}
	};
	//****************************************************************************************
	function setMeasures(data, config, ctx, canvasheight, canvaswidth, ylabels, ylabels2, reverseLegend, reverseAxis, drawAxis, drawLegendOnData, legendBox, typegraph) {

        	var height=canvasheight;
        	var width=canvaswidth;
		if (window.devicePixelRatio>1) {
			height=height/window.devicePixelRatio;
			width=width/window.devicePixelRatio;
		}


        	
		if (config.canvasBackgroundColor != "none") ctx.canvas.style.background = config.canvasBackgroundColor;
		var borderWidth = 0;
		var xAxisLabelPos = 0;
		var graphTitleHeight = 0;
		var graphTitlePosY = 0;
		var graphSubTitleHeight = 0;
		var graphSubTitlePosY = 0;
		var footNoteHeight = 0;
		var footNotePosY = 0;
		var yAxisUnitHeight = 0;
		var yAxisUnitPosY = 0;
		var widestLegend = 0;
		var nbeltLegend = 0;
		var nbLegendLines = 0;
		var nbLegendCols = 0;
		var spaceLegendHeight = 0;
		var xFirstLegendTextPos = 0;
		var yFirstLegendTextPos = 0;
		var xLegendBorderPos = 0;
		var yLegendBorderPos = 0;
		var yAxisLabelWidth = 0;
		var yAxisLabelPosLeft = 0;
		var yAxisLabelPosRight = 0;
		var xAxisLabelHeight = 0;
		var xLabelHeight = 0;
		var widestXLabel = 1;
		var highestXLabel = 1;
		var widestYLabel = 0;
		var highestYLabel = 1;
		var widestYLabel2 = 0;
		var highestYLabel2 = 1;
		var leftNotUsableSize = 0;
		var rightNotUsableSize = 0;
		var rotateLabels = 0;
		var xLabelPos = 0;
		var legendBorderWidth = 0;
		var legendBorderHeight = 0;

		ctx.widthAtSetMeasures=width;
		ctx.heightAtSetMeasures=height;
		
		// Borders
		if (config.canvasBorders) borderWidth = Math.ceil(ctx.chartLineScale*config.canvasBordersWidth);
		// compute widest X label
		var textMsr,i;
		if (drawAxis) {
			ctx.font = config.scaleFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.scaleFontSize)).toString() + "px " + config.scaleFontFamily;
			for (i = 0; i < data.labels.length; i++) {
				if(showLabels(ctx,data,config,i) === true) {
					textMsr = ctx.measureTextMultiLine(fmtChartJS(config, data.labels[i], config.fmtXLabel), (Math.ceil(ctx.chartTextScale*config.scaleFontSize)));
					//If the text length is longer - make that equal to longest text!
					widestXLabel = (textMsr.textWidth > widestXLabel) ? textMsr.textWidth : widestXLabel;
					highestXLabel = (textMsr.textHeight > highestXLabel) ? textMsr.textHeight : highestXLabel;
				} 
			}
			if (widestXLabel < Math.ceil(ctx.chartTextScale*config.xScaleLabelsMinimumWidth)) widestXLabel = Math.ceil(ctx.chartTextScale*config.xScaleLabelsMinimumWidth);
		}
		// compute Y Label Width
		if (drawAxis) {
			widestYLabel = 1;
			if (ylabels != null && ylabels != "nihil") {
				ctx.font = config.scaleFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.scaleFontSize)).toString() + "px " + config.scaleFontFamily;
				for (i = ylabels.length - 1; i >= 0; i--) {
					if (typeof(ylabels[i]) == "string") {
						if(showYLabels(ctx,data,config,i,ylabels[i])) {
							if (ylabels[i].trim() != "") {
								textMsr = ctx.measureTextMultiLine(fmtChartJS(config, ylabels[i], config.fmtYLabel), (Math.ceil(ctx.chartTextScale*config.scaleFontSize)));
								//If the text length is longer - make that equal to longest text!
								widestYLabel = (textMsr.textWidth > widestYLabel) ? textMsr.textWidth : widestYLabel;
								highestYLabel = (textMsr.textHeight > highestYLabel) ? textMsr.textHeight : highestYLabel;
							}
						}
					}
				}
			}
			if (widestYLabel < Math.ceil(ctx.chartTextScale*config.yScaleLabelsMinimumWidth)) {
				widestYLabel = Math.ceil(ctx.chartTextScale*config.yScaleLabelsMinimumWidth);
			}
			widestYLabel2 = 1;
			if (ylabels2 != null && config.yAxisRight) {
				ctx.font = config.scaleFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.scaleFontSize)).toString() + "px " + config.scaleFontFamily;
				for (i = ylabels2.length - 1; i >= 0; i--) {
					if (typeof(ylabels2[i]) == "string") {
						if (ylabels2[i].trim() != "") {
							textMsr = ctx.measureTextMultiLine(fmtChartJS(config, ylabels2[i], config.fmtYLabel2), (Math.ceil(ctx.chartTextScale*config.scaleFontSize)));
							//If the text length is longer - make that equal to longest text!
							widestYLabel2 = (textMsr.textWidth > widestYLabel2) ? textMsr.textWidth : widestYLabel2;
							highestYLabel2 = (textMsr.textHeight > highestYLabel2) ? textMsr.textHeight : highestYLabel2;
						}
					}
				}
			} else {
				widestYLabel2 = widestYLabel;
			}
			if (widestYLabel2 < Math.ceil(ctx.chartTextScale*config.yScaleLabelsMinimumWidth)) {
				widestYLabel2 = Math.ceil(ctx.chartTextScale*config.yScaleLabelsMinimumWidth);
			}
		}
		// yAxisLabel
		leftNotUsableSize = borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceLeft)
		rightNotUsableSize = borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceRight);
		if (drawAxis) {
			if (typeof(config.yAxisLabel) != "undefined") {
				if (config.yAxisLabel.trim() != "") {
					yAxisLabelWidth = (Math.ceil(ctx.chartTextScale*config.yAxisFontSize)) * (config.yAxisLabel.split("\n").length || 1) + Math.ceil(ctx.chartSpaceScale*config.yAxisLabelSpaceLeft) + Math.ceil(ctx.chartSpaceScale*config.yAxisLabelSpaceRight);
					yAxisLabelPosLeft = borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + Math.ceil(ctx.chartSpaceScale*config.yAxisLabelSpaceLeft) + (Math.ceil(ctx.chartTextScale*config.yAxisFontSize));
					yAxisLabelPosRight = width - borderWidth - Math.ceil(ctx.chartSpaceScale*config.spaceRight) - Math.ceil(ctx.chartSpaceScale*config.yAxisLabelSpaceLeft) - (Math.ceil(ctx.chartTextScale*config.yAxisFontSize));
				}
				if(config.yAxisLabelBackgroundColor !="none" || config.yAxisLabelBorders) {
					yAxisLabelWidth+=2*(Math.ceil(ctx.chartSpaceScale*config.yAxisLabelBordersYSpace));
					yAxisLabelPosLeft+=Math.ceil(ctx.chartSpaceScale*config.yAxisLabelBordersYSpace);
					yAxisLabelPosRight-=Math.ceil(ctx.chartSpaceScale*config.yAxisLabelBordersYSpace);
				}

				if(config.graphTitleBorders) {
					yAxisLabelWidth+=2*(Math.ceil(ctx.chartLineScale*config.yAxisLabelBordersWidth));
					yAxisLabelPosLeft+=Math.ceil(ctx.chartLineScale*config.yAxisLabelBordersWidth);
					yAxisLabelPosRight-=Math.ceil(ctx.chartLineScale*config.yAxisLabelBordersWidth);
				}
			}
			if (config.yAxisLeft) {
				if (reverseAxis == false) leftNotUsableSize = borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + yAxisLabelWidth + widestYLabel + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceLeft) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight);
				else                      leftNotUsableSize = borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + yAxisLabelWidth + widestXLabel + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceLeft) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight);
			}
			if (config.yAxisRight) {
				if (reverseAxis == false) rightNotUsableSize = borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceRight) + yAxisLabelWidth + widestYLabel2 + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceLeft) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight);
				else                      rightNotUsableSize = borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceRight) + yAxisLabelWidth + widestXLabel  + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceLeft) + Math.ceil(ctx.chartSpaceScale*config.yAxisSpaceRight);
			}
		}
		availableWidth = width - leftNotUsableSize - rightNotUsableSize;
		// Title
		if (config.graphTitle.trim() != "") {
			graphTitleHeight = (Math.ceil(ctx.chartTextScale*config.graphTitleFontSize)) * (config.graphTitle.split("\n").length || 1) + Math.ceil(ctx.chartSpaceScale*config.graphTitleSpaceBefore) + Math.ceil(ctx.chartSpaceScale*config.graphTitleSpaceAfter);
			graphTitlePosY = borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceTop) + graphTitleHeight - Math.ceil(ctx.chartSpaceScale*config.graphTitleSpaceAfter);
			if(config.graphTitleBackgroundColor !="none" || config.graphTitleBorders) {
				graphTitleHeight+=2*(Math.ceil(ctx.chartSpaceScale*config.graphTitleBordersYSpace));
				graphTitlePosY+=Math.ceil(ctx.chartSpaceScale*config.graphTitleBordersYSpace);
			}

			if(config.graphTitleBorders) {
				graphTitleHeight+=2*(Math.ceil(ctx.chartLineScale*config.graphTitleBordersWidth));
				graphTitlePosY+=Math.ceil(ctx.chartLineScale*config.graphTitleBordersWidth);
			}
		}
		// subTitle
		if (config.graphSubTitle.trim() != "") {
			graphSubTitleHeight = (Math.ceil(ctx.chartTextScale*config.graphSubTitleFontSize)) * (config.graphSubTitle.split("\n").length || 1) + Math.ceil(ctx.chartSpaceScale*config.graphSubTitleSpaceBefore) + Math.ceil(ctx.chartSpaceScale*config.graphSubTitleSpaceAfter);
			graphSubTitlePosY = borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceTop) + graphTitleHeight + graphSubTitleHeight - Math.ceil(ctx.chartSpaceScale*config.graphSubTitleSpaceAfter);
			if(config.graphSubTitleBackgroundColor !="none" || config.graphSubTitleBorders) {
				graphSubTitleHeight+=2*(Math.ceil(ctx.chartSpaceScale*config.graphSubTitleBordersYSpace));
				graphSubTitlePosY+=Math.ceil(ctx.chartSpaceScale*config.graphSubTitleBordersYSpace);
			}

			if(config.graphSubTitleBorders) {
				graphSubTitleHeight+=2*(Math.ceil(ctx.chartLineScale*config.graphSubTitleBordersWidth));
				graphSubTitlePosY+=Math.ceil(ctx.chartLineScale*config.graphSubTitleBordersWidth);
			}
		}
		// yAxisUnit
		if (drawAxis) {
			if (config.yAxisUnit.trim() != "") {
				yAxisUnitHeight = (Math.ceil(ctx.chartTextScale*config.yAxisUnitFontSize)) * (config.yAxisUnit.split("\n").length || 1) + Math.ceil(ctx.chartSpaceScale*config.yAxisUnitSpaceBefore) + Math.ceil(ctx.chartSpaceScale*config.yAxisUnitSpaceAfter);
				yAxisUnitPosY = borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceTop) + graphTitleHeight + graphSubTitleHeight + yAxisUnitHeight - Math.ceil(ctx.chartSpaceScale*config.yAxisUnitSpaceAfter);
			}
			if(config.yAxisUnitBackgroundColor !="none" || config.yAxisUnitBorders) {
				yAxisUnitHeight+=2*(Math.ceil(ctx.chartSpaceScale*config.yAxisUnitBordersYSpace));
				yAxisUnitPosY+=Math.ceil(ctx.chartSpaceScale*config.yAxisUnitBordersYSpace);
			}

			if(config.yAxisUnitBorders) {
				yAxisUnitHeight+=2*(Math.ceil(ctx.chartLineScale*config.yAxisUnitBordersWidth));
				yAxisUnitPosY+=Math.ceil(ctx.chartLineScale*config.yAxisUnitBordersWidth);
			}


		}
		topNotUsableSize = borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceTop) + graphTitleHeight + graphSubTitleHeight + yAxisUnitHeight + Math.ceil(ctx.chartTextScale*config.graphSpaceBefore);
		// footNote
		if (typeof(config.footNote) != "undefined") {
			if (config.footNote.trim() != "") {
				footNoteHeight = (Math.ceil(ctx.chartTextScale*config.footNoteFontSize)) * (config.footNote.split("\n").length || 1) + Math.ceil(ctx.chartSpaceScale*config.footNoteSpaceBefore) + Math.ceil(ctx.chartSpaceScale*config.footNoteSpaceAfter);
				footNotePosY = height - Math.ceil(ctx.chartSpaceScale*config.spaceBottom) - borderWidth - Math.ceil(ctx.chartSpaceScale*config.footNoteSpaceAfter);
				if(config.footNoteBackgroundColor !="none" || config.footNoteBorders) {
					footNoteHeight+=2*(Math.ceil(ctx.chartSpaceScale*config.footNoteBordersYSpace));
					footNotePosY-=Math.ceil(ctx.chartSpaceScale*config.footNoteBordersYSpace);
				}
				if(config.footNoteBorders) {
					footNoteHeight+=2*(Math.ceil(ctx.chartLineScale*config.footNoteBordersWidth));
					footNotePosY-=Math.ceil(ctx.chartLineScale*config.footNoteBordersWidth);
				}
			}
		}
		
		// xAxisLabel
		if (drawAxis) {
			if (typeof(config.xAxisLabel) != "undefined") {
				if (config.xAxisLabel.trim() != "") {
					xAxisLabelHeight = (Math.ceil(ctx.chartTextScale*config.xAxisFontSize)) * (config.xAxisLabel.split("\n").length || 1) + Math.ceil(ctx.chartSpaceScale*config.xAxisLabelSpaceBefore) + Math.ceil(ctx.chartSpaceScale*config.xAxisLabelSpaceAfter);
					xAxisLabelPos = height - borderWidth - Math.ceil(ctx.chartSpaceScale*config.spaceBottom) - footNoteHeight - Math.ceil(ctx.chartSpaceScale*config.xAxisLabelSpaceAfter);
					if(config.xAxisLabelBackgroundColor !="none" || config.footNoteBorders) {
						xAxisLabelHeight+=2*(Math.ceil(ctx.chartSpaceScale*config.xAxisLabelBordersYSpace));
						xAxisLabelPos-=Math.ceil(ctx.chartSpaceScale*config.xAxisLabelBordersYSpace);
					}
					if(config.footNoteBorders) {
						xAxisLabelHeight+=2*(Math.ceil(ctx.chartLineScale*config.xAxisLabelBordersWidth));
						xAxisLabelPos-=Math.ceil(ctx.chartLineScale*config.xAxisLabelBordersWidth);
					}
				}
			}
		}

		bottomNotUsableHeightWithoutXLabels = borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceBottom) + footNoteHeight + xAxisLabelHeight + Math.ceil(ctx.chartTextScale*config.graphSpaceAfter);

		// compute space for Legend
		if (typeof(config.legend) != "undefined") {
			if (config.legend == true) {
				ctx.font = config.legendFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.legendFontSize)).toString() + "px " + config.legendFontFamily;
				var textLength;
				if (drawLegendOnData) {
					for (i = data.datasets.length - 1; i >= 0; i--) {
						if (typeof(data.datasets[i].title) == "string") {
							if (data.datasets[i].title.trim() != "") {
								nbeltLegend++;
								textLength = ctx.measureText(fmtChartJS(config, data.datasets[i].title, config.fmtLegend)).width;
								//If the text length is longer - make that equal to longest text!
								widestLegend = (textLength > widestLegend) ? textLength : widestLegend;
							}
						}
					}
				} else {
					for (i = data.length - 1; i >= 0; i--) {
						if (typeof(data[i].title) == "string") {
							if (data[i].title.trim() != "") {
								nbeltLegend++;
								textLength = ctx.measureText(fmtChartJS(config, data[i].title, config.fmtLegend)).width;
								//If the text length is longer - make that equal to longest text!
								widestLegend = (textLength > widestLegend) ? textLength : widestLegend;
							}
						}
					}
				}
				if (nbeltLegend > 1 || (nbeltLegend == 1 && config.showSingleLegend)) {
					widestLegend += Math.ceil(ctx.chartTextScale*config.legendBlockSize) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenBoxAndText);
					if(config.legendPosY==1 || config.legendPosY==2 || config.legendPosY==3) {
						availableLegendWidth = availableWidth- Math.ceil(ctx.chartSpaceScale*Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText)) - Math.ceil(ctx.chartSpaceScale*config.legendSpaceRightText);
					} else {
						availableLegendWidth = width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight) - 2 * (borderWidth) - Math.ceil(ctx.chartSpaceScale*Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText)) - Math.ceil(ctx.chartSpaceScale*config.legendSpaceRightText);
					}
					if (config.legendBorders == true) availableLegendWidth -= 2 * (Math.ceil(ctx.chartLineScale*config.legendBordersWidth)) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceLeft) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceRight);
					maxLegendOnLine = Min([Math.floor((availableLegendWidth + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) / (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal))),config.maxLegendCols]);
					nbLegendLines = Math.ceil(nbeltLegend / maxLegendOnLine);
					nbLegendCols = Math.ceil(nbeltLegend / nbLegendLines);
				
					var legendHeight = nbLegendLines * ((Math.ceil(ctx.chartTextScale*config.legendFontSize)) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextVertical)) - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextVertical) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBeforeText) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceAfterText);

					switch (config.legendPosY) {
						case 0:
							xFirstLegendTextPos = Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + (width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight) - nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) / 2;
							spaceLegendHeight = legendHeight;
							if (config.legendBorders == true) {
								yLegendBorderPos = topNotUsableSize + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) + (Math.ceil(ctx.chartLineScale*config.legendBordersWidth)/2);
								yFirstLegendTextPos = yLegendBorderPos  + (Math.ceil(ctx.chartLineScale*config.legendBordersWidth)/2) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBeforeText)+(Math.ceil(ctx.chartTextScale*config.legendFontSize));
								spaceLegendHeight += 2 * Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								xLegendBorderPos = Math.floor(xFirstLegendTextPos - Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText) - (Math.ceil(ctx.chartLineScale*config.legendBordersWidth) / 2));
								legendBorderHeight = Math.ceil(spaceLegendHeight - Math.ceil(ctx.chartLineScale*config.legendBordersWidth)) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								legendBorderWidth = Math.ceil(nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal))) - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal) + Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceRightText) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText);
							} else {
								yFirstLegendTextPos = topNotUsableSize + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) + (Math.ceil(ctx.chartLineScale*config.legendBordersWidth)/2);
							}
							if(yAxisUnitHeight>0) {
								yAxisUnitPosY+=spaceLegendHeight;
								if(config.legendBorders==true)yLegendBorderPos-=yAxisUnitHeight;
								yFirstLegendTextPos-=yAxisUnitHeight;
							}
							topNotUsableSize += spaceLegendHeight;
							break;
						case 1:
							spaceLegendHeight = legendHeight;
							xFirstLegendTextPos = Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + (width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight) - nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) / 2;
							yFirstLegendTextPos = topNotUsableSize + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBeforeText)+(Math.ceil(ctx.chartTextScale*config.legendFontSize));
							if (config.legendBorders == true) {
								yFirstLegendTextPos += Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore)+Math.ceil(ctx.chartLineScale*config.legendBordersWidth);
								yLegendBorderPos = yFirstLegendTextPos - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBeforeText) - (Math.ceil(ctx.chartTextScale*config.legendFontSize)) - (Math.ceil(ctx.chartLineScale*config.legendBordersWidth) /2 );
								spaceLegendHeight += 2 * Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								xLegendBorderPos = Math.floor(xFirstLegendTextPos - Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText) - (Math.ceil(ctx.chartLineScale*config.legendBordersWidth) / 2));
								legendBorderHeight = Math.ceil(spaceLegendHeight - Math.ceil(ctx.chartLineScale*config.legendBordersWidth)) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								legendBorderWidth = Math.ceil(nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal))) - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal) + Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceRightText) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText);
							}
							break;
						case 2:
							spaceLegendHeight = legendHeight;
							xFirstLegendTextPos = Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + (width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight) - nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) / 2;
							yFirstLegendTextPos = topNotUsableSize + (height - topNotUsableSize - bottomNotUsableHeightWithoutXLabels - spaceLegendHeight) /2 + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBeforeText)+(Math.ceil(ctx.chartTextScale*config.legendFontSize));
							if (config.legendBorders == true) {
								yFirstLegendTextPos += Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								yLegendBorderPos = yFirstLegendTextPos - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBeforeText) - (Math.ceil(ctx.chartTextScale*config.legendFontSize)) - (Math.ceil(ctx.chartLineScale*config.legendBordersWidth) /2 );
								spaceLegendHeight += 2 * Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								xLegendBorderPos = Math.floor(xFirstLegendTextPos - Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText) - (Math.ceil(ctx.chartLineScale*config.legendBordersWidth) / 2));
								legendBorderHeight = Math.ceil(spaceLegendHeight - Math.ceil(ctx.chartLineScale*config.legendBordersWidth)) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								legendBorderWidth = Math.ceil(nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal))) - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal) + Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceRightText) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText);
							}
							break;
						case -2:
							spaceLegendHeight = legendHeight;
							xFirstLegendTextPos = Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + (width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight) - nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) / 2;
							yFirstLegendTextPos = (height - spaceLegendHeight) /2 + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBeforeText)+(Math.ceil(ctx.chartTextScale*config.legendFontSize));
							if (config.legendBorders == true) {
								yFirstLegendTextPos += Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								yLegendBorderPos = yFirstLegendTextPos - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBeforeText) - (Math.ceil(ctx.chartTextScale*config.legendFontSize)) - (Math.ceil(ctx.chartLineScale*config.legendBordersWidth) /2 );
								spaceLegendHeight += 2 * Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								xLegendBorderPos = Math.floor(xFirstLegendTextPos - Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText) - (Math.ceil(ctx.chartLineScale*config.legendBordersWidth) / 2));
								legendBorderHeight = Math.ceil(spaceLegendHeight - Math.ceil(ctx.chartLineScale*config.legendBordersWidth)) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								legendBorderWidth = Math.ceil(nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal))) - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal) + Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceRightText) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText);
							}
							break;
						case 3:
							spaceLegendHeight = legendHeight;
							xFirstLegendTextPos = Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + (width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight) - nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) / 2;
							availableHeight = height - topNotUsableSize - bottomNotUsableHeightWithoutXLabels;
							yFirstLegendTextPos = topNotUsableSize + availableHeight - spaceLegendHeight + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBeforeText)+(Math.ceil(ctx.chartTextScale*config.legendFontSize));
							if (config.legendBorders == true) {
								yFirstLegendTextPos -= (Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter)+Math.ceil(ctx.chartLineScale*config.legendBordersWidth));
								yLegendBorderPos = yFirstLegendTextPos - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBeforeText) - (Math.ceil(ctx.chartTextScale*config.legendFontSize)) - (Math.ceil(ctx.chartLineScale*config.legendBordersWidth) /2 );
								spaceLegendHeight += 2 * Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								xLegendBorderPos = Math.floor(xFirstLegendTextPos - Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText) - (Math.ceil(ctx.chartLineScale*config.legendBordersWidth) / 2));
								legendBorderHeight = Math.ceil(spaceLegendHeight - Math.ceil(ctx.chartLineScale*config.legendBordersWidth)) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								legendBorderWidth = Math.ceil(nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal))) - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal) + Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceRightText) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText);
							}
							break;
						default:
							spaceLegendHeight = legendHeight;
							yFirstLegendTextPos = height - borderWidth - Math.ceil(ctx.chartSpaceScale*config.spaceBottom) - footNoteHeight - spaceLegendHeight + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBeforeText) + (Math.ceil(ctx.chartTextScale*config.legendFontSize));
							xFirstLegendTextPos = Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + (width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight) - nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) / 2;
							if (config.legendBorders == true) {
								spaceLegendHeight += 2 * Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								yFirstLegendTextPos -= (Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter));
								yLegendBorderPos = Math.floor(height - borderWidth - Math.ceil(ctx.chartSpaceScale*config.spaceBottom) - footNoteHeight - spaceLegendHeight + (Math.ceil(ctx.chartLineScale*config.legendBordersWidth) / 2) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore));
								xLegendBorderPos = Math.floor(xFirstLegendTextPos - Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText) - (Math.ceil(ctx.chartLineScale*config.legendBordersWidth) / 2));
								legendBorderHeight = Math.ceil(spaceLegendHeight - Math.ceil(ctx.chartLineScale*config.legendBordersWidth)) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceBefore) - Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceAfter);
								legendBorderWidth = Math.ceil(nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal))) - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal) + Math.ceil(ctx.chartLineScale*config.legendBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceRightText) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText);
							} 
							xAxisLabelPos -= spaceLegendHeight;
							bottomNotUsableHeightWithoutXLabels +=spaceLegendHeight;
							break;
					}		
					var fullLegendWidth=Math.ceil(ctx.chartSpaceScale*config.legendSpaceRightText) + nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal) +Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText);
					if (config.legendBorders == true) {
						fullLegendWidth+=2*Math.ceil(ctx.chartLineScale*config.legendBordersWidth)+Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceLeft)+Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceRight);
					}

					switch (config.legendPosX) {
						case 0:
						case 1:
							xFirstLegendTextPos = Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + config.canvasBorders * Math.ceil(ctx.chartLineScale*config.canvasBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText);  
							if (config.legendBorders == true) {
								xFirstLegendTextPos += (Math.ceil(ctx.chartLineScale*config.legendBordersWidth)/2)+Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceLeft);
								xLegendBorderPos = Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + config.canvasBorders * Math.ceil(ctx.chartLineScale*config.canvasBordersWidth) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceLeft);
							}
							if(config.legendPosX==0 && ((config.legendPosY>=1 && config.legendPosY <=3) || config.legendPosY==-2)) {
								leftNotUsableSize+=fullLegendWidth;
								yAxisLabelPosLeft+=fullLegendWidth;
							}
							break;
						case 2:
							xFirstLegendTextPos = leftNotUsableSize + (width - rightNotUsableSize - leftNotUsableSize)/2 - (Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText)-Math.ceil(ctx.chartSpaceScale*config.legendSpaceRightText)) - (nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) - Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) / 2;  
							if (config.legendBorders == true) {
								xFirstLegendTextPos -= ((Math.ceil(ctx.chartLineScale*config.legendBordersWidth)/2) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceRight));
								xLegendBorderPos = xFirstLegendTextPos - Math.ceil(ctx.chartLineScale*config.legendBordersWidth)/2 - Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText) ;
							}
							break;
							if((config.legendPosY>=1 && config.legendPosY <=3) || config.legendPosY==-2) {
								rightNotUsableSize+=fullLegendWidth;
								yAxisLabelPosRight-=fullLegendWidth;
							}
						case 3:
						case 4:
							xFirstLegendTextPos = width - rightNotUsableSize - Math.ceil(ctx.chartSpaceScale*config.legendSpaceRightText) - nbLegendCols * (widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal)) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal) / 2;  
							if (config.legendBorders == true) {
								xFirstLegendTextPos -= ((Math.ceil(ctx.chartLineScale*config.legendBordersWidth)/2) + Math.ceil(ctx.chartSpaceScale*config.legendBordersSpaceRight));
								xLegendBorderPos = xFirstLegendTextPos - Math.ceil(ctx.chartLineScale*config.legendBordersWidth)/2 - Math.ceil(ctx.chartSpaceScale*config.legendSpaceLeftText) ;
							}
							if(config.legendPosX==4 && ((config.legendPosY>=1 && config.legendPosY <=3) || config.legendPosY==-2)) {
								rightNotUsableSize+=fullLegendWidth;
								yAxisLabelPosRight-=fullLegendWidth;
							}
							break;
						default:
							break;
					}
					if(config.legendBorders==true) {
						yLegendBorderPos+=Math.ceil(ctx.chartSpaceScale*config.legendYPadding);
						xLegendBorderPos+=Math.ceil(ctx.chartSpaceScale*config.legendXPadding);
						
					}
					yFirstLegendTextPos+=Math.ceil(ctx.chartSpaceScale*config.legendYPadding);	
					xFirstLegendTextPos+=Math.ceil(ctx.chartSpaceScale*config.legendXPadding);	
					
				}
			}
			
		}
		xLabelWidth = 0;
		bottomNotUsableHeightWithXLabels = bottomNotUsableHeightWithoutXLabels;
		if (drawAxis && (config.xAxisBottom || config.xAxisTop)) {
			var widestLabel,highestLabel;		
			if (reverseAxis == false) {
				widestLabel = widestXLabel;
				highestLabel = highestXLabel;
				nblab = data.labels.length;
			} else {
				widestLabel = widestYLabel;
				highestLabel = highestYLabel;
				nblab = ylabels.length;
			}
			if (config.rotateLabels == "smart") {
				rotateLabels = 0;
				if ((availableWidth + Math.ceil(ctx.chartTextScale*config.xAxisSpaceBetweenLabels)) / nblab < (widestLabel + Math.ceil(ctx.chartTextScale*config.xAxisSpaceBetweenLabels))) {
					rotateLabels = 45;
					if (availableWidth / nblab < Math.abs(Math.cos(rotateLabels * Math.PI / 180) * widestLabel)) {
						rotateLabels = 90;
					}
				}
			} else {
				rotateLabels = config.rotateLabels
				if (rotateLabels < 0) rotateLabels = 0;
				if (rotateLabels > 180) rotateLabels = 180;
			}
			if (rotateLabels > 90) rotateLabels += 180;
			xLabelHeight = Math.abs(Math.sin(rotateLabels * Math.PI / 180) * widestLabel) + Math.abs(Math.sin((rotateLabels + 90) * Math.PI / 180) * highestLabel) + Math.ceil(ctx.chartSpaceScale*config.xAxisSpaceBefore) + Math.ceil(ctx.chartSpaceScale*config.xAxisSpaceAfter);
			xLabelPos = height - borderWidth - Math.ceil(ctx.chartSpaceScale*config.spaceBottom) - footNoteHeight - xAxisLabelHeight - (xLabelHeight - Math.ceil(ctx.chartSpaceScale*config.xAxisSpaceBefore)) - Math.ceil(ctx.chartTextScale*config.graphSpaceAfter);
			xLabelWidth = Math.abs(Math.cos(rotateLabels * Math.PI / 180) * widestLabel) + Math.abs(Math.cos((rotateLabels + 90) * Math.PI / 180) * highestLabel);
			leftNotUsableSize = Max([leftNotUsableSize, borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + xLabelWidth / 2]);
			rightNotUsableSize = Max([rightNotUsableSize, borderWidth + Math.ceil(ctx.chartSpaceScale*config.spaceRight) + xLabelWidth / 2]);
			availableWidth = width - leftNotUsableSize - rightNotUsableSize;
			if (config.legend && config.xAxisBottom && config.legendPosY==4) {
				xLabelPos-=spaceLegendHeight;
			} 
			bottomNotUsableHeightWithXLabels = bottomNotUsableHeightWithoutXLabels + xLabelHeight ;
		}  else {
			availableWidth = width - leftNotUsableSize - rightNotUsableSize;
		}

		availableHeight = height - topNotUsableSize - bottomNotUsableHeightWithXLabels;

		// ----------------------- DRAW EXTERNAL ELEMENTS -------------------------------------------------
		dispCrossImage(ctx, config, width / 2, height / 2, width / 2, height / 2, false, data, -1, -1);

		if(typeof config.initFunction == "function") config.initFunction("INITFUNCTION",ctx,data,null,-1,-1,{animationValue : 0, cntiter: 0, config : config, borderX : 0, borderY : 0, midPosX : 0, midPosY : 0});

 		
		 if (ylabels != "nihil") {
			// Draw Borders
			if (borderWidth > 0) {
				ctx.save();
				ctx.beginPath();
				ctx.setLineDash(lineStyleFn(config.canvasBordersStyle));
				ctx.strokeStyle = config.canvasBordersColor;
				ctx.lineWidth = borderWidth;
				ctx.setLineDash(lineStyleFn(config.canvasBordersStyle));
				ctx.strokeStyle = config.canvasBordersColor;
				ctx.drawRectangle({x:0+borderWidth/2,y:0+borderWidth/2,width:width-borderWidth,height:height-borderWidth,borderRadius:config.canvasBordersRadius,fill:false,stroke:true})
				ctx.setLineDash([]);
				ctx.restore();
			}
			// Draw Graph Title
			if (graphTitleHeight > 0) {
				ctx.save();
				ctx.beginPath();
				ctx.font = config.graphTitleFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.graphTitleFontSize)).toString() + "px " + config.graphTitleFontFamily;
				ctx.fillStyle = config.graphTitleFontColor;
				ctx.textAlign = "center";
				ctx.textBaseline = "bottom";

				setTextBordersAndBackground(ctx,config.graphTitle,(Math.ceil(ctx.chartTextScale*config.graphTitleFontSize)),Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + (width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight)) / 2,graphTitlePosY,config.graphTitleBorders,config.graphTitleBordersColor,Math.ceil(ctx.chartLineScale*config.graphTitleBordersWidth),Math.ceil(ctx.chartSpaceScale*config.graphTitleBordersXSpace),Math.ceil(ctx.chartSpaceScale*config.graphTitleBordersYSpace),config.graphTitleBordersStyle,config.graphTitleBackgroundColor,"GRAPHTITLE",config.graphTitleBordersRadius);

				ctx.translate(Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + (width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight)) / 2, graphTitlePosY);
				ctx.fillTextMultiLine(config.graphTitle, 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.graphTitleFontSize)),true,config.detectMouseOnText,ctx,"TITLE_TEXTMOUSE",0,Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + (width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight)) / 2, graphTitlePosY,-1,-1);

				ctx.stroke();
				ctx.restore();
			}
			// Draw Graph Sub-Title
			if (graphSubTitleHeight > 0) {
				ctx.save();
				ctx.beginPath();
				ctx.font = config.graphSubTitleFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.graphSubTitleFontSize)).toString() + "px " + config.graphSubTitleFontFamily;
				ctx.fillStyle = config.graphSubTitleFontColor;
				ctx.textAlign = "center";
				ctx.textBaseline = "bottom";
				setTextBordersAndBackground(ctx,config.graphSubTitle,(Math.ceil(ctx.chartTextScale*config.graphSubTitleFontSize)),Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + (width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight)) / 2,graphSubTitlePosY,config.graphSubTitleBorders,config.graphSubTitleBordersColor,Math.ceil(ctx.chartLineScale*config.graphSubTitleBordersWidth),Math.ceil(ctx.chartSpaceScale*config.graphSubTitleBordersXSpace),Math.ceil(ctx.chartSpaceScale*config.graphSubTitleBordersYSpace),config.graphSubTitleBordersStyle,config.graphSubTitleBackgroundColor,"GRAPHSUBTITLE",config.graphSubTitleBordersRadius);

				ctx.translate(Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + (width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight)) / 2, graphSubTitlePosY);
				ctx.fillTextMultiLine(config.graphSubTitle, 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.graphSubTitleFontSize)),true,config.detectMouseOnText,ctx,"SUBTITLE_TEXTMOUSE",0,Math.ceil(ctx.chartSpaceScale*config.spaceLeft) + (width - Math.ceil(ctx.chartSpaceScale*config.spaceLeft) - Math.ceil(ctx.chartSpaceScale*config.spaceRight)) / 2, graphSubTitlePosY,-1,-1);
				ctx.stroke();
				ctx.restore();
			}
			// Draw Y Axis Unit
			if (yAxisUnitHeight > 0) {
				if (config.yAxisLeft) {
					ctx.save();
					ctx.beginPath();
					ctx.font = config.yAxisUnitFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.yAxisUnitFontSize)).toString() + "px " + config.yAxisUnitFontFamily;
					ctx.fillStyle = config.yAxisUnitFontColor;
					ctx.textAlign = "center";
					ctx.textBaseline = "bottom";
		
					setTextBordersAndBackground(ctx,config.yAxisUnit,(Math.ceil(ctx.chartTextScale*config.yAxisUnitFontSize)),leftNotUsableSize, yAxisUnitPosY,config.yAxisUnitBorders,config.yAxisUnitBordersColor,Math.ceil(ctx.chartLineScale*config.yAxisUnitBordersWidth),Math.ceil(ctx.chartSpaceScale*config.yAxisUnitBordersXSpace),Math.ceil(ctx.chartSpaceScale*config.yAxisUnitBordersYSpace),config.yAxisUnitBordersStyle,config.yAxisUnitBackgroundColor,"YAXISUNIT",config.yAxisUnitBordersRadius);
					ctx.translate(leftNotUsableSize, yAxisUnitPosY);
					ctx.fillTextMultiLine(config.yAxisUnit, 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.yAxisUnitFontSize)),true,config.detectMouseOnText,ctx,"YLEFTAXISUNIT_TEXTMOUSE",0,leftNotUsableSize, yAxisUnitPosY,-1,-1);
					ctx.stroke();
					ctx.restore();
				}
				if (config.yAxisRight) {
					if (config.yAxisUnit2 == '') config.yAxisUnit2 = config.yAxisUnit;
					ctx.save();
					ctx.beginPath();
					ctx.font = config.yAxisUnitFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.yAxisUnitFontSize)).toString() + "px " + config.yAxisUnitFontFamily;
					ctx.fillStyle = config.yAxisUnitFontColor;
					ctx.textAlign = "center";
					ctx.textBaseline = "bottom";
					setTextBordersAndBackground(ctx,config.yAxisUnit2,(Math.ceil(ctx.chartTextScale*config.yAxisUnitFontSize)),width - rightNotUsableSize, yAxisUnitPosY,config.yAxisUnitBorders,config.yAxisUnitBordersColor,Math.ceil(ctx.chartLineScale*config.yAxisUnitBordersWidth),Math.ceil(ctx.chartSpaceScale*config.yAxisUnitBordersXSpace),Math.ceil(ctx.chartSpaceScale*config.yAxisUnitBordersYSpace),config.yAxisUnitBordersStyle,config.yAxisUnitBackgroundColor,"YAXISUNIT",config.yAxisUnitBordersRadius);
					ctx.translate(width - rightNotUsableSize, yAxisUnitPosY);
					ctx.fillTextMultiLine(config.yAxisUnit2, 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.yAxisUnitFontSize)),true,config.detectMouseOnText,ctx,"YRIGHTAXISUNIT_TEXTMOUSE",0,width - rightNotUsableSize, yAxisUnitPosY,-1,-1);
					ctx.stroke();
					ctx.restore();
				}
			}
			// Draw Y Axis Label
			if (yAxisLabelWidth > 0) {
				if (config.yAxisLeft) {
					ctx.save();
					ctx.beginPath();
					ctx.font = config.yAxisFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.yAxisFontSize)).toString() + "px " + config.yAxisFontFamily;
					ctx.fillStyle = config.yAxisFontColor;
					ctx.textAlign = "center";
					ctx.textBaseline = "bottom";

					ctx.translate(yAxisLabelPosLeft, topNotUsableSize + (availableHeight / 2));
					ctx.rotate(-(90 * (Math.PI / 180)));
					setTextBordersAndBackground(ctx,config.yAxisLabel,(Math.ceil(ctx.chartTextScale*config.yAxisFontSize)), 0,0, config.yAxisLabelBorders,config.yAxisLabelBordersColor,Math.ceil(ctx.chartLineScale*config.yAxisLabelBordersWidth),Math.ceil(ctx.chartSpaceScale*config.yAxisLabelBordersXSpace),Math.ceil(ctx.chartSpaceScale*config.yAxisLabelBordersYSpace),config.yAxisLabelBordersStyle,config.yAxisLabelBackgroundColor,"YAXISLABELLEFT",config.yAxisLabelBordersRadius);
					ctx.fillTextMultiLine(config.yAxisLabel, 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.yAxisFontSize)),false,config.detectMouseOnText,ctx,"YLEFTAXISLABEL_TEXTMOUSE",-(90 * (Math.PI / 180)),yAxisLabelPosLeft, topNotUsableSize + (availableHeight / 2),-1,-1);
					ctx.stroke();
					ctx.restore();
				}
				if (config.yAxisRight) {
					if (config.yAxisLabel2 == '') config.yAxisLabel2 = config.yAxisLabel;
					ctx.save();
					ctx.beginPath();
					ctx.font = config.yAxisFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.yAxisFontSize)).toString() + "px " + config.yAxisFontFamily;
					ctx.fillStyle = config.yAxisFontColor;
					ctx.textAlign = "center";
					ctx.textBaseline = "bottom";
					ctx.translate(yAxisLabelPosRight, topNotUsableSize + (availableHeight / 2));
					ctx.rotate(+(90 * (Math.PI / 180)));
					setTextBordersAndBackground(ctx,config.yAxisLabel2,(Math.ceil(ctx.chartTextScale*config.yAxisFontSize)), 0,0, config.yAxisLabelBorders,config.yAxisLabelBordersColor,Math.ceil(ctx.chartLineScale*config.yAxisLabelBordersWidth),Math.ceil(ctx.chartSpaceScale*config.yAxisLabelBordersXSpace),Math.ceil(ctx.chartSpaceScale*config.yAxisLabelBordersYSpace),config.yAxisLabelBordersStyle,config.yAxisLabelBackgroundColor,"YAXISLABELLEFT",config.yAxisLabelBordersRadius);
					ctx.fillTextMultiLine(config.yAxisLabel2, 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.yAxisFontSize)),false,config.detectMouseOnText,ctx,"YRIGHTAXISLABEL_TEXTMOUSE",+(90 * (Math.PI / 180)),yAxisLabelPosRight, topNotUsableSize + (availableHeight / 2),-1,-1);
					ctx.stroke();
					ctx.restore();
				}
			}
			// Draw X Axis Label
			if (xAxisLabelHeight > 0) {
				if (config.xAxisBottom) {
					ctx.save();
					ctx.beginPath();
					ctx.font = config.xAxisFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.xAxisFontSize)).toString() + "px " + config.xAxisFontFamily;
					ctx.fillStyle = config.xAxisFontColor;
					ctx.textAlign = "center";
					ctx.textBaseline = "bottom";
					setTextBordersAndBackground(ctx,config.xAxisLabel,(Math.ceil(ctx.chartTextScale*config.xAxisFontSize)),leftNotUsableSize + (availableWidth / 2), xAxisLabelPos,config.xAxisLabelBorders,config.xAxisLabelBordersColor,Math.ceil(ctx.chartLineScale*config.xAxisLabelBordersWidth),Math.ceil(ctx.chartSpaceScale*config.xAxisLabelBordersXSpace),Math.ceil(ctx.chartSpaceScale*config.xAxisLabelBordersYSpace),config.xAxisLabelBordersStyle,config.xAxisLabelBackgroundColor,"XAXISLABEL",config.xAxisLabelBordersRadius);
					ctx.translate(leftNotUsableSize + (availableWidth / 2), xAxisLabelPos);
					ctx.fillTextMultiLine(config.xAxisLabel, 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.xAxisFontSize)),true,config.detectMouseOnText,ctx,"XAXISLABEL_TEXTMOUSE",0,leftNotUsableSize + (availableWidth / 2), xAxisLabelPos,-1,-1);
					ctx.stroke();
					ctx.restore();
				}
			}
			// Draw Legend
                        var legendMsr;
			if (nbeltLegend > 1 || (nbeltLegend == 1 && config.showSingleLegend)) {
				legendMsr={dispLegend : true, xLegendBorderPos : xLegendBorderPos,
					   yLegendBorderPos : yLegendBorderPos, legendBorderWidth : legendBorderWidth, legendBorderHeight : legendBorderHeight, 
					   nbLegendCols: nbLegendCols, xFirstLegendTextPos : xFirstLegendTextPos , yFirstLegendTextPos : yFirstLegendTextPos, 
					   drawLegendOnData : drawLegendOnData, reverseLegend : reverseLegend, legendBox : legendBox, widestLegend : widestLegend };
				if(config.legendPosY==0 || config.legendPosY==4 || config.legendPosX==0 || config.legendPosX==4) {

					drawLegend(legendMsr,data,config,ctx,typegraph);
					legendMsr={dispLegend : false};
				} 
			} else {
				legendMsr={dispLegend : false };
			}
			// Draw FootNote
			if (config.footNote.trim() != "") {
				ctx.save();
				ctx.font = config.footNoteFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.footNoteFontSize)).toString() + "px " + config.footNoteFontFamily;
				ctx.fillStyle = config.footNoteFontColor;
				ctx.textAlign = "center";
				ctx.textBaseline = "bottom";

				setTextBordersAndBackground(ctx,config.footNote,(Math.ceil(ctx.chartTextScale*config.footNoteFontSize)),leftNotUsableSize + (availableWidth / 2), footNotePosY,config.footNoteBorders,config.footNoteBordersColor,Math.ceil(ctx.chartLineScale*config.footNoteBordersWidth),Math.ceil(ctx.chartSpaceScale*config.footNoteBordersXSpace),Math.ceil(ctx.chartSpaceScale*config.footNoteBordersYSpace),config.footNoteBordersStyle,config.footNoteBackgroundColor,"FOOTNOTE",config.footNoteBordersRadius);

				ctx.translate(leftNotUsableSize + (availableWidth / 2), footNotePosY);
				ctx.fillTextMultiLine(config.footNote, 0, 0, ctx.textBaseline, (Math.ceil(ctx.chartTextScale*config.footNoteFontSize)),true,config.detectMouseOnText,ctx,"FOOTNOTE_TEXTMOUSE",0,leftNotUsableSize + (availableWidth / 2), footNotePosY,-1,-1);
				ctx.stroke();
				ctx.restore();
			}
		}
		clrx = leftNotUsableSize;
		clrwidth = availableWidth;
		clry = topNotUsableSize;
		clrheight = availableHeight;
		return {
			leftNotUsableSize: leftNotUsableSize,
			rightNotUsableSize: rightNotUsableSize,
			availableWidth: availableWidth,
			topNotUsableSize: topNotUsableSize,
			bottomNotUsableHeightWithoutXLabels: bottomNotUsableHeightWithoutXLabels,
			bottomNotUsableHeightWithXLabels: bottomNotUsableHeightWithXLabels,
			availableHeight: availableHeight,
			widestXLabel: widestXLabel,
			highestXLabel: highestXLabel,
			widestYLabel: widestYLabel,
			widestYLabel2: widestYLabel2,
			highestYLabel: highestYLabel,
			rotateLabels: rotateLabels,
			xLabelPos: xLabelPos,
			clrx: clrx,
			clry: clry,
			clrwidth: clrwidth,
			clrheight: clrheight,
			legendMsr : legendMsr
		};
	};


	// Function for drawing lines (BarLine|Line)

	function drawLinesDataset(animPc, data, config, ctx, statData,vars) {
		var y1,y2,y3,diffnb,diffnbj,fact, currentAnimPc;
		var prevypos;
		var pts=[];
		for (var i = 0; i < data.datasets.length; i++) {
			if(setOptionValue(true,1,"ANIMATION",ctx,data,statData,data.datasets[i].animation,config.animation,"animation",i,-1,{nullvalue : null} )==true || animPc >= 1) {
				prevypos="undefined";
				if(statData[i][0].tpchart!="Line")continue;
				if (statData[i].length == 0) continue;
				if (statData[i][0].firstNotMissing == -1) continue;
				ctx.save();
				ctx.beginPath();

				prevAnimPc={ mainVal:0 , subVal : 0,animVal : 0 };
				var firstpt=-1;
				var lastxPos=-1;
				for (var j = statData[i][0].firstNotMissing; j <= statData[i][0].lastNotMissing; j++) {
					if(prevAnimPc.animVal==0 && j>statData[i][0].firstNotMissing) continue;	
					currentAnimPc = animationCorrection(animPc, data, config, i, j, true);
					if (currentAnimPc.mainVal == 0  && (prevAnimPc.mainVal > 0 && firstpt !=-1)) {
						ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"LINEDASH",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
						ctx.stroke();
						ctx.setLineDash([]);
						if(config.extrapolateMissingData) {
							y1=statData[i][statData[i][j].prevNotMissing].yAxisPos - prevAnimPc.mainVal*statData[i][statData[i][j].prevNotMissing].yPosOffset;					
							y2=statData[i][j].yAxisPos - prevAnimPc.mainVal*statData[i][statData[i][j-1].nextNotMissing].yPosOffset;
							diffnb=statData[i][j-1].nextNotMissing-statData[i][j].prevNotMissing;
							diffnbj=(j-1)-statData[i][j].prevNotMissing;
							fact=(diffnbj+prevAnimPc.subVal)/diffnb;
							y3=y1+fact*(y2-y1);					
							traceLine(pts,ctx,statData[i][statData[i][j].prevNotMissing].xPos + fact*(statData[i][statData[i][j-1].nextNotMissing].xPos-statData[i][statData[i][j].prevNotMissing].xPos) , y3,config,data,statData,i,setYposOrigin(i,j,data,statData));
							closebz(pts,ctx,config,i);
							ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"LINEDASH",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
							ctx.stroke();
							ctx.setLineDash([]);
							ctx.strokeStyle = "rgba(0,0,0,0)";
							if(config.datasetFill && setOptionValue(true,1,"LINKTYPE",ctx,data,statData,data.datasets[i].linkType,config.linkType,"linkType",i,j,{nullvalue : null} )!=1) {
								ctx.lineTo(statData[i][statData[i][j].prevNotMissing].xPos + fact*(statData[i][statData[i][j-1].nextNotMissing].xPos-statData[i][statData[i][j].prevNotMissing].xPos) , statData[i][j].yAxisPos );
								ctx.lineTo(statData[i][firstpt].xPos, statData[i][firstpt].xAxisPosY-statData[i][0].zeroY);
								ctx.closePath();

								ctx.fillStyle=setOptionValue(true,1,"COLOR",ctx,data,statData,data.datasets[i].fillColor,config.defaultFillColor,"fillColor",i,j,{animationValue: currentAnimPc.mainVal, xPosLeft : statData[i][0].xPos, yPosBottom : Math.max(statData[i][0].yAxisPos,statData[i][0].yAxisPos- ((config.animationLeftToRight) ? 1 : 1*currentAnimPc.mainVal) * statData[i][0].lminvalue_offset), xPosRight : statData[i][data.datasets[i].data.length-1].xPos, yPosTop : Math.min(statData[i][0].yAxisPos, statData[i][0].yAxisPos - ((config.animationLeftToRight) ? 1 : 1*currentAnimPc.mainVal) * statData[i][0].lmaxvalue_offset)} );
								ctx.fill();
								firstpt=-1;
							}
						} else if (!(typeof statData[i][j].value == "undefined")) {
							traceLine(pts,ctx,statData[i][j-1].xPos + prevAnimPc.subVal*(statData[i][j].xPos-statData[i][j-1].xPos) , statData[i][j].yAxisPos - prevAnimPc.mainVal*statData[i][statData[i][j-1].nextNotMissing].yPosOffset,config,data,statData,i,setYposOrigin(i,j,data,statData));
							closebz(pts,ctx,config,i);
							ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"LINEDASH",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
							ctx.stroke();
							ctx.setLineDash([]);
							ctx.strokeStyle = "rgba(0,0,0,0)";
							if(config.datasetFill && setOptionValue(true,1,"LINKTYPE",ctx,data,statData,data.datasets[i].linkType,config.linkType,"linkType",i,j,{nullvalue : null} )!=1) {
								ctx.lineTo(statData[i][j-1].xPos + prevAnimPc.subVal*(statData[i][j].xPos-statData[i][j-1].xPos) , statData[i][j].yAxisPos );
								ctx.lineTo(statData[i][firstpt].xPos, statData[i][firstpt].xAxisPosY-statData[i][0].zeroY);
								ctx.closePath();
								ctx.fillStyle=setOptionValue(true,1,"COLOR",ctx,data,statData,data.datasets[i].fillColor,config.defaultFillColor,"fillColor",i,j,{animationValue: currentAnimPc.mainVal, xPosLeft : statData[i][0].xPos, yPosBottom : Math.max(statData[i][0].yAxisPos,statData[i][0].yAxisPos- ((config.animationLeftToRight) ? 1 : 1*currentAnimPc.mainVal) * statData[i][0].lminvalue_offset), xPosRight : statData[i][data.datasets[i].data.length-1].xPos, yPosTop : Math.min(statData[i][0].yAxisPos, statData[i][0].yAxisPos - ((config.animationLeftToRight) ? 1 : 1*currentAnimPc.mainVal) * statData[i][0].lmaxvalue_offset)} );
								ctx.fill();
							}
						}
						prevAnimPc = currentAnimPc;
						continue;
					} else if(currentAnimPc.totVal ==0) {
						ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"LINEDASH",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
						ctx.stroke();
						ctx.setLineDash([]);
						ctx.strokeStyle = "rgba(0,0,0,0)";
					} else {
						ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"LINEDASH",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
						ctx.stroke();
						ctx.setLineDash([]);
						ctx.strokeStyle=setOptionValue(true,1,"STROKECOLOR",ctx,data,statData,data.datasets[i].strokeColor,config.defaultStrokeColor,"strokeColor",i,j,{nullvalue : null} );
					}
					prevAnimPc = currentAnimPc;

					switch(typeof data.datasets[i].data[j]) {
						case "undefined" :
							if (!config.extrapolateMissingData) {
								if(firstpt==-1) continue;
								closebz(pts,ctx,config,i);
								ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"LINEDASH",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
								ctx.stroke();
								ctx.setLineDash([]);
								if (config.datasetFill && firstpt != -1 && setOptionValue(true,1,"LINKTYPE",ctx,data,statData,data.datasets[i].linkType,config.linkType,"linkType",i,j,{nullvalue : null} )!=1) {
									lastxPos=-1;
									ctx.strokeStyle = "rgba(0,0,0,0)";
									ctx.lineTo(statData[i][j-1].xPos, statData[i][j-1].yAxisPos);
									ctx.lineTo(statData[i][firstpt].xPos, statData[i][firstpt].yAxisPos);
									ctx.closePath();
									ctx.fillStyle=setOptionValue(true,1,"COLOR",ctx,data,statData,data.datasets[i].fillColor,config.defaultFillColor,"fillColor",i,j,{animationValue: currentAnimPc.mainVal, xPosLeft : statData[i][0].xPos, yPosBottom : Math.max(statData[i][0].yAxisPos,statData[i][0].yAxisPos- ((config.animationLeftToRight) ? 1 : 1*currentAnimPc.mainVal) * statData[i][0].lminvalue_offset), xPosRight : statData[i][data.datasets[i].data.length-1].xPos, yPosTop : Math.min(statData[i][0].yAxisPos, statData[i][0].yAxisPos - ((config.animationLeftToRight) ? 1 : 1*currentAnimPc.mainVal) * statData[i][0].lmaxvalue_offset)} );
									ctx.fill();
								}
								ctx.beginPath();
								prevAnimPc={ mainVal:0 , subVal : 0 };
								firstpt=-1;
							} else if (currentAnimPc.subVal > 0) {
								lastxPos=statData[i][j].xPos + currentAnimPc.subVal*(statData[i][j+1].xPos-statData[i][j].xPos);
								y1=statData[i][statData[i][j+1].prevNotMissing].yAxisPos - statData[i][statData[i][j+1].prevNotMissing].yPosOffset;					
								y2=statData[i][statData[i][j].nextNotMissing].yAxisPos - statData[i][statData[i][j].nextNotMissing].yPosOffset;
								diffnb=statData[i][j].nextNotMissing-statData[i][j+1].prevNotMissing;
								diffnbj=(j)-statData[i][j+1].prevNotMissing;
								fact=(diffnbj+prevAnimPc.subVal)/diffnb;
								y3=y1+fact*(y2-y1);					
//								traceLine(pts,ctx,statData[i][j].xPos + currentAnimPc.subVal*(statData[i][j+1].xPos-statData[i][j].xPos), y3,config,data,statData,i);
								traceLine(pts,ctx,statData[i][statData[i][j].prevNotMissing].xPos + fact*(statData[i][statData[i][j-1].nextNotMissing].xPos-statData[i][statData[i][j].prevNotMissing].xPos) , y3,config,data,statData,i,setYposOrigin(i,j,data,statData));
							}
							break;
						default : 
							ctx.lineWidth = Math.ceil(ctx.chartLineScale*setOptionValue(true,1,"LINEWIDTH",ctx,data,statData,data.datasets[i].datasetStrokeWidth,config.datasetStrokeWidth,"datasetStrokeWidth",i,j,{nullvalue : null} ));
							if (firstpt==-1) {
								firstpt=j;
								ctx.beginPath();
								if(setOptionValue(true,1,"LINKTYPE",ctx,data,statData,data.datasets[i].linkType,config.linkType,"linkType",i,j,{nullvalue : null} )==1) {
									if(typeof statData[i][j].yPosOffsetOrigin != "undefined")ctx.moveTo(statData[i][j].xPos, statData[i][j].yAxisPos - currentAnimPc.mainVal * statData[i][j].yPosOffsetOrigin);
									else ctx.moveTo(statData[i][firstpt].xPos, statData[i][firstpt].xAxisPosY-statData[i][0].zeroY);
									ctx.lineTo(statData[i][j].xPos, statData[i][j].yAxisPos - currentAnimPc.mainVal * statData[i][j].yPosOffset);											
								} else ctx.moveTo(statData[i][j].xPos, statData[i][j].yAxisPos - currentAnimPc.mainVal * statData[i][j].yPosOffset);
								initbz(pts,statData[i][j].xPos, statData[i][j].yAxisPos - currentAnimPc.mainVal * statData[i][j].yPosOffset,i);							
								lastxPos=statData[i][j].xPos;
							} else {
								lastxPos=statData[i][j].xPos;
								traceLine(pts,ctx,statData[i][j].xPos, statData[i][j].yAxisPos - currentAnimPc.mainVal * statData[i][j].yPosOffset,config,data,statData,i,setYposOrigin(i,j,data,statData));
							}	
							if (currentAnimPc.subVal > 0 && statData[i][j].nextNotMissing !=-1 && (config.extrapolateMissing || statData[i][j].nextNotMissing==j+1)) {
								lastxPos=statData[i][j].xPos + currentAnimPc.subVal*(statData[i][j+1].xPos-statData[i][j].xPos);
								y1=statData[i][statData[i][j+1].prevNotMissing].yAxisPos - statData[i][statData[i][j+1].prevNotMissing].yPosOffset;					
								y2=statData[i][statData[i][j].nextNotMissing].yAxisPos - statData[i][statData[i][j].nextNotMissing].yPosOffset;
								y3=y1+currentAnimPc.subVal*(y2-y1);					
								traceLine(pts,ctx,statData[i][j].xPos + currentAnimPc.subVal*(statData[i][statData[i][j].nextNotMissing].xPos-statData[i][j].xPos) , y3,config,data,statData,i,setYposOrigin(i,j,data,statData));
							}
							break
					}
				}
				closebz(pts,ctx,config,i);
				ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"LINEDASH",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
				ctx.stroke();
				ctx.setLineDash([]);
				if (config.datasetFill  && setOptionValue(true,1,"LINKTYPE",ctx,data,statData,data.datasets[i].linkType,config.linkType,"linkType",i,j,{nullvalue : null} )!=1) {
					if (firstpt>=0 ) {
						ctx.strokeStyle = "rgba(0,0,0,0)";
						ctx.lineTo(lastxPos, statData[i][0].xAxisPosY-statData[i][0].zeroY);
						ctx.lineTo(statData[i][firstpt].xPos, statData[i][firstpt].xAxisPosY-statData[i][0].zeroY);
						ctx.closePath();
						ctx.fillStyle=setOptionValue(true,1,"COLOR",ctx,data,statData,data.datasets[i].fillColor,config.defaultFillColor,"fillColor",i,-1,{animationValue: currentAnimPc.mainVal, xPosLeft : statData[i][0].xPos, yPosBottom : Math.max(statData[i][0].yAxisPos,statData[i][0].yAxisPos- ((config.animationLeftToRight) ? 1 : 1*currentAnimPc.mainVal) * statData[i][0].lminvalue_offset), xPosRight : statData[i][data.datasets[i].data.length-1].xPos, yPosTop : Math.min(statData[i][0].yAxisPos, statData[i][0].yAxisPos - ((config.animationLeftToRight) ? 1 : 1*currentAnimPc.mainVal) * statData[i][0].lmaxvalue_offset)} );
						ctx.fill();
					}
				} 
				ctx.restore();
				if (animPc >= 1) {
					for (j = 0; j < data.datasets[i].data.length; j++) {
						if (!(typeof(data.datasets[i].data[j]) == 'undefined')) {
							currentAnimPc = animationCorrection(animPc, data, config, i, j, true);
							if (currentAnimPc.mainVal > 0 || !config.animationLeftToRight) {
								if(setOptionValue(true,1,"POINTDOT",ctx,data,statData,undefined,config.pointDot,"pointDot",i,j,{nullvalue : null} )) {
									ctx.beginPath();
									ctx.fillStyle=setOptionValue(true,1,"MARKERFILLCOLOR",ctx,data,statData,data.datasets[i].pointColor,config.defaultStrokeColor,"pointColor",i,j,{nullvalue: true} );
									ctx.strokeStyle=setOptionValue(true,1,"MARKERSTROKESTYLE",ctx,data,statData,data.datasets[i].pointStrokeColor,config.defaultStrokeColor,"pointStrokeColor",i,j,{nullvalue: true} );
									ctx.lineWidth=setOptionValue(true,ctx.chartLineScale,"MARKERLINEWIDTH",ctx,data,statData,data.datasets[i].pointDotStrokeWidth,config.pointDotStrokeWidth,"pointDotStrokeWidth",i,j,{nullvalue: true} );
									var markerShape=setOptionValue(true,1,"MARKERSHAPE",ctx,data,statData,data.datasets[i].markerShape,config.markerShape,"markerShape",i,j,{nullvalue: true} );
									var markerRadius=setOptionValue(true,ctx.chartSpaceScale,"MARKERRADIUS",ctx,data,statData,data.datasets[i].pointDotRadius,config.pointDotRadius,"pointDotRadius",i,j,{nullvalue: true} );
									var markerStrokeStyle=setOptionValue(true,1,"MARKERSTROKESTYLE",ctx,data,statData,data.datasets[i].pointDotStrokeStyle,config.pointDotStrokeStyle,"pointDotStrokeStyle",i,j,{nullvalue: true} );
									drawMarker(ctx, statData[i][j].xPos , statData[i][j].yAxisPos - currentAnimPc.mainVal * statData[i][j].yPosOffset, markerShape,markerRadius,markerStrokeStyle);							
								}
        						}
						}
					}
				}

				if (animPc >= config.animationStopValue) {
					for (j = 0; j < data.datasets[i].data.length; j++) {
						if (typeof(data.datasets[i].data[j]) == 'undefined') continue;
						if(!(data.datasets[i].mouseDetection==false))jsGraphAnnotate[ctx.ChartNewId][jsGraphAnnotate[ctx.ChartNewId].length] = ["POINT", i, j, statData,setOptionValue(true,1,"ANNOTATEDISPLAY",ctx,data,statData,data.datasets[i].annotateDisplay,config.annotateDisplay,"annotateDisplay",i,j,{nullValue : true})];
						if (setOptionValue(true,1,"INGRAPHDATASHOW",ctx,data,statData,data.datasets[i].inGraphDataShow,config.inGraphDataShow,"inGraphDataShow",i,j,{nullValue : true})) {
	 						ctx.save();
							ctx.textAlign = setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",i,j,{nullValue: true  });
							ctx.textBaseline = setOptionValue(true,1,"INGRAPHDATAVALIGN",ctx,data,statData,undefined,config.inGraphDataVAlign,"inGraphDataVAlign",i,j,{nullValue : true} );
							ctx.font = setOptionValue(true,1,"INGRAPHDATAFONTSTYLE",ctx,data,statData,undefined,config.inGraphDataFontStyle,"inGraphDataFontStyle",i,j,{nullValue : true} ) + ' ' + setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ) + 'px ' + setOptionValue(true,1,"INGRAPHDATAFONTFAMILY",ctx,data,statData,undefined,config.inGraphDataFontFamily,"inGraphDataFontFamily",i,j,{nullValue : true} );
							ctx.fillStyle = setOptionValue(true,1,"INGRAPHDATAFONTCOLOR",ctx,data,statData,undefined,config.inGraphDataFontColor,"inGraphDataFontColor",i,j,{nullValue : true} );
							var paddingTextX = setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGX",ctx,data,statData,undefined,config.inGraphDataPaddingX,"inGraphDataPaddingX",i,j,{nullValue : true} ),
							    paddingTextY = setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATAPADDINGY",ctx,data,statData,undefined,config.inGraphDataPaddingY,"inGraphDataPaddingY",i,j,{nullValue : true} );
							var dispString = tmplbis(setOptionValue(true,1,"INGRAPHDATATMPL",ctx,data,statData,undefined,config.inGraphDataTmpl,"inGraphDataTmpl",i,j,{nullValue : true} ), statData[i][j],config);
							ctx.translate(statData[i][j].xPos + paddingTextX, statData[i][j].yAxisPos - currentAnimPc.mainVal * statData[i][j].yPosOffset - paddingTextY);
							var rotateVal=setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",i,j,{nullValue : true} ) * (Math.PI / 180);
							ctx.rotate(rotateVal);
							setTextBordersAndBackground(ctx,dispString,setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ),0,0,setOptionValue(true,1,"INGRAPHDATABORDERS",ctx,data,statData,undefined,config.inGraphDataBorders,"inGraphDataBorders",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSCOLOR",ctx,data,statData,undefined,config.inGraphDataBordersColor,"inGraphDataBordersColor",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartLineScale,"INGRAPHDATABORDERSWIDTH",ctx,data,statData,undefined,config.inGraphDataBordersWidth,"inGraphDataBordersWidth",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSXSPACE",ctx,data,statData,undefined,config.inGraphDataBordersXSpace,"inGraphDataBordersXSpace",i,j,{nullValue : true} ),setOptionValue(true,ctx.chartSpaceScale,"INGRAPHDATABORDERSYSPACE",ctx,data,statData,undefined,config.inGraphDataBordersYSpace,"inGraphDataBordersYSpace",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABORDERSSTYLE",ctx,data,statData,undefined,config.inGraphDataBordersStyle,"inGraphDataBordersStyle",i,j,{nullValue : true} ),setOptionValue(true,1,"INGRAPHDATABACKGROUNDCOLOR",ctx,data,statData,undefined,config.inGraphDataBackgroundColor,"inGraphDataBackgroundColor",i,j,{nullValue : true} ),"INGRAPHDATA",config.inGraphDataBordersRadius);
							ctx.fillTextMultiLine(dispString, 0, 0, ctx.textBaseline, setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,j,{nullValue : true} ),true,config.detectMouseOnText,ctx,"INGRAPHDATA_TEXTMOUSE",rotateVal,statData[i][j].xPos + paddingTextX, statData[i][j].yAxisPos - currentAnimPc.mainVal * statData[i][j].yPosOffset - paddingTextY,i,j);
							ctx.restore();
						}
					}
				}
			}
		};

		
		function initbz(pts,xpos,ypos,i) {
			if (setOptionValue(true,1,"LINKTYPE",ctx,data,statData,data.datasets[i].linkType,config.linkType,"linkType",i,j,{nullvalue : null} )==0 && setOptionValue(true,1,"BEZIERCURVE",ctx,data,statData,undefined,config.bezierCurve,"bezierCurve",i,-1,{nullValue : true})) {
				pts.length=0;
				pts.push(xpos);pts.push(ypos);
			}
			prevypos=ypos;
		} ;
		
		function setYposOrigin(i,j,data,statData) {
			yposOrigin="undefined";
			if(typeof statData[i][j].yPosOffsetOrigin != "undefined")yposOrigin= statData[i][j].yAxisPos - currentAnimPc.mainVal * statData[i][j].yPosOffsetOrigin;
			return(yposOrigin);
		};
		
		
		function traceLine(pts,ctx,xpos,ypos,config,data,statData,i,yposOrigin) {
			if (setOptionValue(true,1,"LINKTYPE",ctx,data,statData,data.datasets[i].linkType,config.linkType,"linkType",i,j,{nullvalue : null} )==0 && setOptionValue(true,1,"BEZIERCURVE",ctx,data,statData,undefined,config.bezierCurve,"bezierCurve",i,-1,{nullValue : true})) {
				pts.push(xpos);	pts.push(ypos);
			} else {
				if(setOptionValue(true,1,"LINKTYPE",ctx,data,statData,data.datasets[i].linkType,config.linkType,"linkType",i,j,{nullvalue : null} )==0)ctx.lineTo(xpos,ypos);
				else if(setOptionValue(true,1,"LINKTYPE",ctx,data,statData,data.datasets[i].linkType,config.linkType,"linkType",i,j,{nullvalue : null} )==1){
					if(yposOrigin != "undefined")ctx.moveTo(xpos, yposOrigin);
					else ctx.moveTo(xpos, statData[i][0].xAxisPosY-statData[i][0].zeroY);
//					ctx.moveTo(xpos, statData[i][0].xAxisPosY-statData[i][0].zeroY);
					ctx.lineTo(xpos,ypos);
				} else if (setOptionValue(true,1,"LINKTYPE",ctx,data,statData,data.datasets[i].linkType,config.linkType,"linkType",i,j,{nullvalue : null} )==2 && typeof prevypos!="undefined"){
					ctx.lineTo(xpos,prevypos);
					ctx.lineTo(xpos,ypos);
					prevypos=ypos;
				}
			}
		} ;
		
		function closebz(pts,ctx,config,i){
		
			if(setOptionValue(true,1,"LINKTYPE",ctx,data,statData,data.datasets[i].linkType,config.linkType,"linkType",i,j,{nullvalue : null} )==0 && setOptionValue(true,1,"BEZIERCURVE",ctx,data,statData,undefined,config.bezierCurve,"bezierCurve",i,-1,{nullValue : true})) {
				minimumpos= statData[i][0].xAxisPosY;
				maximumpos= statData[i][0].xAxisPosY - statData[i][0].calculatedScale.steps*statData[i][0].scaleHop;
				drawSpline(ctx,pts,setOptionValue(true,1,"BEZIERCURVETENSION",ctx,data,statData,undefined,config.bezierCurveTension,"bezierCurveTension",i,-1,{nullValue : true}),minimumpos,maximumpos);
				pts.length=0;			
			}
			prevypos=undefined;
		};		

		//Props to Rob Spencer at scaled innovation for his post on splining between points
		//http://scaledinnovation.com/analytics/splines/aboutSplines.html

		function getControlPoints(x0,y0,x1,y1,x2,y2,t){
			//  x0,y0,x1,y1 are the coordinates of the end (knot) pts of this segment
			//  x2,y2 is the next knot -- not connected here but needed to calculate p2
			//  p1 is the control point calculated here, from x1 back toward x0.
			//  p2 is the next control point, calculated here and returned to become the 
			//  next segment's p1.
			//  t is the 'tension' which controls how far the control points spread.
        	
			//  Scaling factors: distances from this knot to the previous and following knots.
			var d01=Math.sqrt(Math.pow(x1-x0,2)+Math.pow(y1-y0,2));
			var d12=Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2));
   
			var fa=t*d01/(d01+d12);
			var fb=t-fa;
  
			var p1x=x1+fa*(x0-x2);
			var p1y=y1+fa*(y0-y2);

			var p2x=x1-fb*(x0-x2);
			var p2y=y1-fb*(y0-y2);  
    
			return [p1x,p1y,p2x,p2y]
		};

		function drawSpline(ctx,pts,t,minimumpos,maximumpos){
			var cp=[];   // array of control points, as x0,y0,x1,y1,...
			var n=pts.length;

			pts.push(2*pts[n-2]-pts[n-4]);
			pts.push(2*pts[n-1]-pts[n-3]);

			if (n==4){
				ctx.moveTo(pts[0],pts[1]);
				ctx.lineTo(pts[2],pts[3]);
				return;
			}
			// Draw an open curve, not connected at the ends
			for(var ti=0;ti<n-2;ti+=2){
				cp=cp.concat(getControlPoints(pts[ti],pts[ti+1],pts[ti+2],pts[ti+3],pts[ti+4],pts[ti+5],t));
        		}    
			//  For first is a simple quadratics.

			ctx.beginPath();
			ctx.strokeStyle=setOptionValue(true,1,"STROKECOLOR",ctx,data,statData,data.datasets[i].strokeColor,config.defaultStrokeColor,"strokeColor",i,j,{nullvalue : null} );
			ctx.lineWidth = Math.ceil(ctx.chartLineScale*setOptionValue(true,1,"LINEWIDTH",ctx,data,statData,data.datasets[i].datasetStrokeWidth,config.datasetStrokeWidth,"datasetStrokeWidth",i,j,{nullvalue : null} ));
			ctx.moveTo(pts[0],pts[1]);
			ctx.quadraticCurveTo(cp[0],Math.max(Math.min(cp[1],minimumpos),maximumpos),pts[2],pts[3]);
			
//        		ctx.setLineDash(lineStyleFn(config.datasetStrokeStyle));
			ctx.setLineDash(lineStyleFn(setOptionValue(true,1,"LINEDASH",ctx,data,statData,data.datasets[i].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",i,j,{nullvalue : null} )));
			for(ti=2;ti<pts.length-4;ti+=2){
				y1=Math.max(Math.min(cp[2*ti-1],minimumpos),maximumpos);
				y2=Math.max(Math.min(cp[2*ti+1],minimumpos),maximumpos);
				ctx.bezierCurveTo(cp[2*ti-2],y1,cp[2*ti],y2,pts[ti+2],pts[ti+3]);
			}
			ctx.stroke();
		};
 		ctx.setLineDash([]);
	};

	function log10(val) {
		return Math.log(val) / Math.LN10;
	};

	function setRect(ctx, config) {
		if (config.clearRect) {
			if (!config.multiGraph) {

				clear(ctx);
				ctx.clearRect(0, 0, width, height);
			}
		} else {
			clear(ctx);
			ctx.clearRect(0, 0, width, height);
	
			ctx.fillStyle = config.savePngBackgroundColor;
			ctx.strokeStyle = config.savePngBackgroundColor;
			ctx.beginPath();
			ctx.moveTo(0, 0);
			ctx.lineTo(0, ctx.canvas.height);
			ctx.lineTo(ctx.canvas.width, ctx.canvas.height);
			ctx.lineTo(ctx.canvas.width, 0);
			ctx.lineTo(0, 0);
			ctx.stroke();
			ctx.fill();
		}
	};


	function defMouse(ctx,data,config) {

		var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel" 


        	// reset mouseAction to check;

        	if(typeof ctx.mouseAction=="undefined") { ctx.mouseAction=[];}
        	else {
        		for(var i=0;i<ctx.mouseAction;i++){
				if(ctx.mouseAction.substring(0,1)!="/")ctx.mouseAction[i]="/"+ctx.mouseAction[i];
			}
		}

        	// liste mouse options;
		// ----------------------------------------------------		
		// - annotateDisplay : true, annotateFunction: "mousemove"
		// ----------------------------------------------------		
		// - saveScreen : savePngFunction: "mousedown right" - savePng=true
		// ----------------------------------------------------		
                // highLight : false, 	highLightMouseFunction : "mousemove",
		// ----------------------------------------------------		
		// - mouse sortir ou entrer dans une pice => Pas d'influence sur une action de souris. C'est li  l'action de annotateFunction
		//      	annotateFunctionIn : inBar,
      		//		annotateFunctionOut : outBar,
		// ----------------------------------------------------		
		// - mouseDownRight	mouseDownLeft: null  mouseDownMiddle: null  
		// - mouseMove: null 	mouseWheel : null    mouseOut: null (lorsque la souris sort du canvas) 	
		// ----------------------------------------------------		
		//  mouse sur texte : detectMouseOnText => Pas d'influence sur une action de souris. C'est li  une autre action;
		// ----------------------------------------------------		

		function setAction(ctx,action){
			if(ctx.mouseAction.indexOf("/"+action)>=0)ctx.mouseAction[ctx.mouseAction.indexOf("/"+action)]=action;
			else if(ctx.mouseAction.indexOf(action)<0)ctx.mouseAction[ctx.mouseAction.length]=action;
		};
		
		function add_listener(ctx,action) {
			if (isIE() < 9 && isIE() != false) ctx.canvas.attachEvent("on" + action.split(' ')[0], function(event) {
				doMouseAction(event,ctx.ChartNewId, action.split(' ')[0]);
			});
			else ctx.canvas.addEventListener(action.split(' ')[0], function(event) {
				doMouseAction(event,ctx, action.split(' ')[0]);
			}, false);
		};

		// - saveScreen : savePngFunction: "mousedown right" - savePng=true
		if(config.savePng==true) {
			     if(config.savePngFunction=="mousedown left")setAction(ctx,"mousedown 1");
			else if(config.savePngFunction=="mousedown middle")setAction(ctx,"mousedown 2");
			else if(config.savePngFunction=="mousedown right")setAction(ctx,"mousedown 3");
		}
		

		// - annotateDisplay : true, annotateFunction: "mousemove"
		if(config.annotateDisplay==true) {
			if (cursorDivCreated == false) oCursor = new makeCursorObj('divCursor');
			     if(config.annotateFunction=="mousedown left")setAction(ctx,"mousedown 1");
			else if(config.annotateFunction=="mousedown middle")setAction(ctx,"mousedown 2");
			else if(config.annotateFunction=="mousedown right")setAction(ctx,"mousedown 3");
			else if(config.annotateFunction=="mousemove")setAction(ctx,"mousemove");
		}

                // highLight : false, 	highLightMouseFunction : "mousemove",
		if(config.highLight==true) {
			     if(config.highLightMouseFunction=="mousedown left")setAction(ctx,"mousedown 1");
			else if(config.highLightMouseFunction=="mousedown middle")setAction(ctx,"mousedown 2");
			else if(config.highLightMouseFunction=="mousedown right")setAction(ctx,"mousedown 3");
			else if(config.highLightMouseFunction=="mousemove")setAction(ctx,"mousemove");
		}
		
		// mouse actions;
		if(typeof config.mouseMove=="function") setAction(ctx,"mousemove");
		if(typeof config.mouseDownLeft=="function") setAction(ctx,"mousedown 1");
		if(typeof config.mouseDownMiddle=="function") setAction(ctx,"mousedown 2");
		if(typeof config.mouseDownRight=="function") setAction(ctx,"mousedown 3");
		if(typeof config.mouseWheel=="function") setAction(ctx,mousewheelevt);
		if(typeof config.mouseOut=="function") setAction(ctx,"mouseout");
		if(typeof config.mouseDblClick=="function") setAction(ctx,"dblclick");

		var mouseAction=false;		

		// add mouse event
		if((ctx.mouseAction.indexOf("mousemove")>=0 && ctx.mouseAction.indexOf("/mousemove")<0) || (ctx.mouseAction.indexOf("mouseout")>=0 && ctx.mouseAction.indexOf("/mouseout")<0)) {
			setAction(ctx,"mouseout");
			mouseAction=true;
			add_listener(ctx,"mouseout");
			// mouseOut action;			
		}


		if((ctx.mouseAction.indexOf("mousemove")>=0 && ctx.mouseAction.indexOf("/mousemove")<0) || (ctx.mouseAction.indexOf(mousewheelevt)>=0 && ctx.mouseAction.indexOf("/"+mousewheelevt)<0)) {
			setAction(ctx,mousewheelevt);
			mouseAction=true;
			add_listener(ctx,mousewheelevt);
			// mouseWheel action;			
		}

		if(ctx.mouseAction.indexOf("mousemove")>=0 && ctx.mouseAction.indexOf("/mousemove")<0) {
			mouseAction=true;
			add_listener(ctx,"mousemove");
			// mouseMove action;			
		}

		if(ctx.mouseAction.indexOf("dblclick")>=0 && ctx.mouseAction.indexOf("/dblclick")<0) {
			mouseAction=true;
			add_listener(ctx,"dblclick");
			// mouseMove action;			
		}

		if((ctx.mouseAction.indexOf("mousedown 1")>=0 && ctx.mouseAction.indexOf("/mousedown 1")<0) || (ctx.mouseAction.indexOf("mousedown 2")>=0 && ctx.mouseAction.indexOf("/mousedown 2")<0) || (ctx.mouseAction.indexOf("mousedown 3")>=0 && ctx.mouseAction.indexOf("/mousedown 3")<0)) {
			mouseAction=true;
			add_listener(ctx,"mousedown");
			// mouseDown action;			
		}

		// remove contextMenu if forced with option contextMenu or if mouseDownRight is defined
		if((config.contextMenu==false || ctx.mouseAction.indexOf("mousedown 3")>=0) && ctx.mouseAction.indexOf("/removeContextMenu")<0){
			ctx.mouseAction[ctx.mouseAction.length]="removeContextMenu";
			ctx.canvas.oncontextmenu = function (e) {
    				e.preventDefault();
			};
		}
		
		// initialiser les variables ncessaires pour l'action doMouseAction;
                inMouseAction[ctx.ChartNewId]=false;
		mouseActionData[ctx.ChartNewId]={ data : data, config: config, prevShow : -1 };
	};

};

function animationCorrection(animationValue, data, config, vdata, vsubdata, isline) {
	var animValue=animationValue;
	var animSubValue = 0;
	
	if(vsubdata<0) {
		if(vdata < 1*config.animationStartWithData-1) animValue = 1;
		else {
			switch (config.animationByDataset) {
				case "ByArc" :
					animValue = animationValue;
					break;
				case true:
					animValue = animationValue;
					break;
				case false:
				default:
					animValue = animationValue;
					break;
			}
		}
	} else {
		var startVal=Math.max(1,config.animationStartWithDataset);
		var startSubVal=Math.max(1,config.animationStartWithData);
	
		if(vdata < 1*config.animationStartWithDataset-1) animValue = 1;
		else if(vsubdata <1*config.animationStartWithData-1) animValue = 1;
		else {
		        var maxData=0;
			if(config.animationLeftToRight) {
				for(var i=0;i<data.datasets.length;i++)	maxData=Math.max(maxData,data.datasets[i].data.length)
			}
			switch (config.animationByDataset) {
				case true:
					switch(config.animationLeftToRight) {
						case true: 
							var curpos=(vdata-(startVal-1))*(maxData-(startSubVal-1))+(vsubdata-(startSubVal-1));
							maxData=(maxData-(startSubVal-1))*(data.datasets.length-(startVal-1));
							if(animationValue < (curpos/maxData)) {
								animValue=0;
								if(isline && vsubdata+1==startSubVal)animValue=1;
							} else if(animationValue < ((curpos+1)/maxData)) {
								animValue=(animationValue-(curpos/maxData))*maxData;
								if(isline){
									animSubValue=animValue;
									animValue=1;
								}
							} else animValue=1;
							break;
						case false:
						default:
							if(animationValue < (vdata-(startVal-1))/(data.datasets.length-(startVal-1))) {
								animValue=0.001;
							} else if(animationValue < (vdata-(startVal-1)+1)/(data.datasets.length-(startVal-1))) {
								animValue=(data.datasets.length-(startVal-1))*(animationValue-(vdata-(startVal-1))/(data.datasets.length-(startVal-1)));
							} else animValue=1;
							break;
					}
					break;
				case false:
				default:
					switch(config.animationLeftToRight) {
						case true: 
							var curpos=(vsubdata-(startSubVal-1));
							maxData=(maxData-(startSubVal-1));
							if(animationValue < (curpos/maxData)) animValue=0;
							else if(animationValue < ((curpos+1)/maxData)) {
								animValue=(animationValue-(curpos/maxData))*maxData;
								if(isline){
									animSubValue=animValue;
									animValue=1;
								}
							} else animValue=1;
							break;
						case false:
						default:
							animValue = animationValue;
							break;
					}
					break;
			}
		}
	}
	return {
		mainVal: animValue,
		subVal: animSubValue,
		animVal: animValue + animSubValue
	};

};


function showLabels(ctx,data,config,i) {
	var doShowLabels=setOptionValue(true,1,"SHOWLABEL",ctx,data,undefined,undefined,config.showXLabels,"showXLabels",i,-1,undefined,{labelValue: fmtChartJS(config, data.labels[i], config.fmtXLabel), unformatedLabelValue:data.labels[i]});
	if(typeof doShowLabels=="number") {
		if(i>=config.firstLabelToShow-1)doShowLabels=((i+config.firstLabelToShow-1) % parseInt(doShowLabels) ==0 ? true : false);
		else doShowLabels=false;
	}
	return doShowLabels;
};

function showYLabels(ctx,data,config,i,text) {
	var doShowLabels=setOptionValue(true,1,"SHOWYLABEL",ctx,data,undefined,undefined,config.showYLabels,"showYLabels",-1,i,undefined,{labelValue: text});
	if(typeof doShowLabels=="number") {
		if(i>=config.firstYLabelToShow-1)doShowLabels=((i+config.firstYLabelToShow-1) % parseInt(doShowLabels) ==0 ? true : false);
		else doShowLabels=false;
	}
	return doShowLabels;
};


function drawLegend(legendMsr,data,config,ctx,typegraph) {
	var lgtxt;
	if (config.legendBorders == true) {
		ctx.save();
		ctx.setLineDash(lineStyleFn(config.legendBordersStyle));
		ctx.beginPath();
		ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.legendBordersWidth);
		ctx.strokeStyle = config.legendBordersColors;
		ctx.moveTo(legendMsr.xLegendBorderPos, legendMsr.yLegendBorderPos);
		ctx.lineTo(legendMsr.xLegendBorderPos, legendMsr.yLegendBorderPos + legendMsr.legendBorderHeight);
		ctx.lineTo(legendMsr.xLegendBorderPos + legendMsr.legendBorderWidth, legendMsr.yLegendBorderPos + legendMsr.legendBorderHeight);
		ctx.lineTo(legendMsr.xLegendBorderPos + legendMsr.legendBorderWidth, legendMsr.yLegendBorderPos);
		ctx.lineTo(legendMsr.xLegendBorderPos, legendMsr.yLegendBorderPos);
		//ctx.lineTo(legendMsr.xLegendBorderPos + legendMsr.legendBorderWidth, legendMsr.yLegendBorderPos);
		//ctx.lineTo(legendMsr.xLegendBorderPos, legendMsr.yLegendBorderPos);
		//ctx.lineTo(legendMsr.xLegendBorderPos, legendMsr.yLegendBorderPos + legendMsr.legendBorderHeight);

					
		ctx.stroke();
		ctx.closePath();
		ctx.setLineDash([]);
		
		ctx.fillStyle = "rgba(0,0,0,0)"; // config.legendFillColor;
		ctx.fillStyle = config.legendFillColor;
		ctx.fill();
		ctx.restore();
	}
	nbcols = legendMsr.nbLegendCols - 1;
	ypos = legendMsr.yFirstLegendTextPos - ((Math.ceil(ctx.chartTextScale*config.legendFontSize)) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextVertical));
	xpos = 0;
	if (legendMsr.drawLegendOnData) fromi = data.datasets.length;
	else fromi = data.length;
	for (var i = fromi - 1; i >= 0; i--) {
		orderi = i;
		if (legendMsr.reverseLegend) {
			if (legendMsr.drawLegendOnData) orderi = data.datasets.length - i - 1;
			else orderi = data.length - i - 1;
		}
		if (legendMsr.drawLegendOnData) tpof = typeof(data.datasets[orderi].title);
		else tpof = typeof(data[orderi].title)
		if (tpof == "string") {
			if (legendMsr.drawLegendOnData) lgtxt = fmtChartJS(config, data.datasets[orderi].title, config.fmtLegend).trim();
			else lgtxt = fmtChartJS(config, data[orderi].title, config.fmtLegend).trim();
			if (lgtxt != "") {
				nbcols++;
				if (nbcols == legendMsr.nbLegendCols) {
					nbcols = 0;
					xpos = legendMsr.xFirstLegendTextPos;
					ypos += (Math.ceil(ctx.chartTextScale*config.legendFontSize)) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextVertical);
				} else {
					xpos += legendMsr.widestLegend + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenTextHorizontal);
				}
				ctx.save();
				ctx.beginPath();
				var lgdbox=legendMsr.legendBox;
				if(ctx.tpchart=="Bar" || ctx.tpchart=="StackedBar") if (data.datasets[orderi].type=="Line" && (!config.datasetFill || setOptionValue(false,1,"LINKTYPE",ctx,data,undefined,data.datasets[orderi].linkType,config.linkType,"linkType",orderi,-1,{nullvalue : null} )==1)) lgdbox=false;
				if (lgdbox) {
					if (legendMsr.drawLegendOnData) {
	 					ctx.lineWidth = Math.ceil(ctx.chartLineScale*setOptionValue(false,1,"LINEWIDTH",ctx,data,undefined,data.datasets[orderi].datasetStrokeWidth,config.datasetStrokeWidth,"datasetStrokeWidth",orderi,-1,{nullvalue : null} ));
					} else {
						ctx.lineWidth = Math.ceil(ctx.chartLineScale*config.datasetStrokeWidth);
					}
					ctx.beginPath();
					if (legendMsr.drawLegendOnData) {
						ctx.strokeStyle=setOptionValue(false,1,"LEGENDSTROKECOLOR",ctx,data,undefined,data.datasets[orderi].strokeColor,config.defaultFillColor,"strokeColor",orderi,-1,{animationValue: 1, xPosLeft : xpos, yPosBottom : ypos, xPosRight : xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize), yPosTop : ypos - (Math.ceil(ctx.chartTextScale*config.legendFontSize))} );
						ctx.setLineDash(lineStyleFn(setOptionValue(false,1,"LEGENDLINEDASH",ctx,data,undefined,data.datasets[orderi].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",orderi,-1,{animationValue: 1, xPosLeft : xpos, yPosBottom : ypos, xPosRight : xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize), yPosTop : ypos - (Math.ceil(ctx.chartTextScale*config.legendFontSize))} )));

					} else {
						ctx.strokeStyle=setOptionValue(false,1,"LEGENDSTROKECOLOR",ctx,data,undefined,data[orderi].strokeColor,config.defaultFillColor,"strokeColor",orderi,-1,{animationValue: 1, xPosLeft : xpos, yPosBottom : ypos, xPosRight : xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize), yPosTop : ypos - (Math.ceil(ctx.chartTextScale*config.legendFontSize))} );
						ctx.setLineDash(lineStyleFn(setOptionValue(false,1,"LEGENDSEGMENTTROKESTYLE",ctx,data,undefined,data[orderi].segmentStrokeStyle,config.segmentStrokeStyle,"segmentStrokeStyle",orderi,-1,{animationValue: 1, xPosLeft : xpos, yPosBottom : ypos, xPosRight : xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize), yPosTop : ypos - (Math.ceil(ctx.chartTextScale*config.legendFontSize))} )));
					}
					ctx.moveTo(xpos, ypos);
					ctx.lineTo(xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize), ypos);
					ctx.lineTo(xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize), ypos - (Math.ceil(ctx.chartTextScale*config.legendFontSize)));
					ctx.lineTo(xpos, ypos - (Math.ceil(ctx.chartTextScale*config.legendFontSize)));
					ctx.lineTo(xpos, ypos);
					ctx.stroke();
					ctx.closePath();
					if (legendMsr.drawLegendOnData) {
						ctx.fillStyle=setOptionValue(false,1,"LEGENDFILLCOLOR",ctx,data,undefined,data.datasets[orderi].fillColor,config.defaultFillColor,"fillColor",orderi,-1,{animationValue: 1, xPosLeft : xpos, yPosBottom : ypos, xPosRight : xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize), yPosTop : ypos - (Math.ceil(ctx.chartTextScale*config.legendFontSize))} );
					} else {
						ctx.fillStyle=setOptionValue(false,1,"LEGENDFILLCOLOR",ctx,data,undefined,data[orderi].color,config.defaultFillColor,"color",orderi,-1,{animationValue: 1, xPosLeft : xpos, yPosBottom : ypos, xPosRight : xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize), yPosTop : ypos - (Math.ceil(ctx.chartTextScale*config.legendFontSize))} );
					}
					ctx.fill();
				} else {
					ctx.lineWidth = config.legendColorIndicatorStrokeWidth ?
						config.legendColorIndicatorStrokeWidth : Math.ceil(ctx.chartLineScale*setOptionValue(false,1,"LINEWIDTH",ctx,data,undefined,data.datasets[orderi].datasetStrokeWidth,config.datasetStrokeWidth,"datasetStrokeWidth",orderi,-1,{nullvalue : null} ));
					if (config.legendColorIndicatorStrokeWidth && config.legendColorIndicatorStrokeWidth > (Math.ceil(ctx.chartTextScale*config.legendFontSize))) {
						ctx.lineWidth = (Math.ceil(ctx.chartTextScale*config.legendFontSize));
					}
					if (legendMsr.drawLegendOnData) {
						ctx.strokeStyle=setOptionValue(false,1,"LEGENDSTROKECOLOR",ctx,data,undefined,data.datasets[orderi].strokeColor,config.defaultFillColor,"strokeColor",orderi,-1,{animationValue: 1, xPosLeft : xpos, yPosBottom : ypos, xPosRight : xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize), yPosTop : ypos - (Math.ceil(ctx.chartTextScale*config.legendFontSize))} );
						ctx.setLineDash(lineStyleFn(setOptionValue(false,1,"LEGENDLINEDASH",ctx,data,undefined,data.datasets[orderi].datasetStrokeStyle,config.datasetStrokeStyle,"datasetStrokeStyle",orderi,-1,{animationValue: 1, xPosLeft : xpos, yPosBottom : ypos, xPosRight : xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize), yPosTop : ypos - (Math.ceil(ctx.chartTextScale*config.legendFontSize))} )));
					} else {
						ctx.strokeStyle=setOptionValue(false,1,"LEGENDSTROKECOLOR",ctx,data,undefined,data[orderi].strokeColor,config.defaultFillColor,"strokeColor",orderi,-1,{animationValue: 1, xPosLeft : xpos, yPosBottom : ypos, xPosRight : xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize), yPosTop : ypos - (Math.ceil(ctx.chartTextScale*config.legendFontSize))} );
						ctx.setLineDash(lineStyleFn(setOptionValue(false,1,"LEGENDSEGMENTTROKESTYLE",ctx,data,undefined,data[orderi].segmentStrokeStyle,config.segmentStrokeStyle,"segmentStrokeStyle",orderi,-1,{animationValue: 1, xPosLeft : xpos, yPosBottom : ypos, xPosRight : xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize), yPosTop : ypos - (Math.ceil(ctx.chartTextScale*config.legendFontSize))} )));
					}

					ctx.moveTo(xpos + 2, ypos - ((Math.ceil(ctx.chartTextScale*config.legendFontSize)) / 2));
					ctx.lineTo(xpos + 2 + Math.ceil(ctx.chartTextScale*config.legendBlockSize), ypos - ((Math.ceil(ctx.chartTextScale*config.legendFontSize)) / 2));
					ctx.stroke();

					
					ctx.fill();

					if(config.pointDot) {
						ctx.beginPath();
				 		ctx.fillStyle=setOptionValue(false,1,"LEGENDMARKERFILLCOLOR",ctx,data,undefined,data.datasets[orderi].pointColor,config.defaultStrokeColor,"pointColor",orderi,-1,{nullvalue: true} );
						ctx.strokeStyle=setOptionValue(false,1,"LEGENDMARKERSTROKESTYLE",ctx,data,undefined,data.datasets[orderi].pointStrokeColor,config.defaultStrokeColor,"pointStrokeColor",orderi,-1,{nullvalue: true} );
						ctx.lineWidth=setOptionValue(false,ctx.chartLineScale,"LEGENDMARKERLINEWIDTH",ctx,data,undefined,data.datasets[orderi].pointDotStrokeWidth,config.pointDotStrokeWidth,"pointDotStrokeWidth",orderi,-1,{nullvalue: true} );
                        	
						var markerShape=setOptionValue(false,1,"LEGENDMARKERSHAPE",ctx,data,undefined,data.datasets[orderi].markerShape,config.markerShape,"markerShape",orderi,-1,{nullvalue: true} );
						var markerRadius=setOptionValue(false,ctx.chartSpaceScale,"LEGENDMARKERRADIUS",ctx,data,undefined,data.datasets[orderi].pointDotRadius,config.pointDotRadius,"pointDotRadius",orderi,-1,{nullvalue: true} );
						var markerStrokeStyle=setOptionValue(false,1,"LEGENDMARKERSTROKESTYLE",ctx,data,undefined,data.datasets[orderi].pointDotStrokeStyle,config.pointDotStrokeStyle,"pointDotStrokeStyle",orderi,-1,{nullvalue: true} );
						drawMarker(ctx,xpos + 2 + Math.ceil(ctx.chartTextScale*config.legendBlockSize)/2, ypos - ((Math.ceil(ctx.chartTextScale*config.legendFontSize)) / 2), markerShape,markerRadius,markerStrokeStyle);							
					}
					ctx.fill();

				}
				ctx.restore();
				ctx.save();
				ctx.beginPath();
				ctx.font = config.legendFontStyle + " " + (Math.ceil(ctx.chartTextScale*config.legendFontSize)).toString() + "px " + config.legendFontFamily;
				ctx.fillStyle = setOptionValue(false,1,"LEGENDFONTCOLOR",ctx,data,undefined,undefined,config.legendFontColor,"legendFontColor",orderi,-1,{nullvalue: true} );
				ctx.textAlign = "left";
				ctx.textBaseline = "bottom";
				ctx.translate(xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenBoxAndText), ypos);
//				ctx.fillText(lgtxt, 0, 0);
				ctx.fillTextMultiLine(lgtxt, 0, 0, ctx.textBaseline, Math.ceil(ctx.chartTextScale*config.legendFontSize), true,config.detectMouseOnText,ctx,"LEGEND_TEXTMOUSE",0,xpos + Math.ceil(ctx.chartTextScale*config.legendBlockSize) + Math.ceil(ctx.chartSpaceScale*config.legendSpaceBetweenBoxAndText), ypos,orderi,-1);

				ctx.restore();
			}
		}
	}
};

function drawMarker(ctx,xpos,ypos,marker,markersize,markerStrokeStyle) {
	ctx.setLineDash(lineStyleFn(markerStrokeStyle));
	switch (marker) {
		case "square":
			ctx.rect(xpos-markersize,ypos-markersize,2*markersize,2*markersize);
			ctx.stroke();
			ctx.fill();
			ctx.setLineDash([]);
			break;
		case "triangle":
			pointA_x=0;
			pointA_y=2/3*markersize;
			ctx.moveTo(xpos,ypos-pointA_y);
			ctx.lineTo(xpos+pointA_y*Math.sin(4/3),ypos+pointA_y*Math.cos(4/3));
			ctx.lineTo(xpos-pointA_y*Math.sin(4/3),ypos+pointA_y*Math.cos(4/3));
			ctx.lineTo(xpos,ypos-pointA_y);
			ctx.stroke();
			ctx.fill();
			ctx.setLineDash([]);
			break;
		case "diamond":
			ctx.moveTo(xpos, ypos+markersize);
			ctx.lineTo(xpos+markersize, ypos);
			ctx.lineTo(xpos, ypos-markersize);
			ctx.lineTo(xpos-markersize, ypos);
			ctx.lineTo(xpos, ypos+markersize);
			ctx.stroke();
			ctx.fill();
			ctx.setLineDash([]);
			break;
		case "plus":
			ctx.moveTo(xpos, ypos-markersize);
			ctx.lineTo(xpos, ypos+markersize);
			ctx.moveTo(xpos-markersize, ypos);
			ctx.lineTo(xpos+markersize, ypos);
			ctx.stroke();
			ctx.setLineDash([]);
			break;
		case "cross":
			ctx.moveTo(xpos-markersize, ypos-markersize);
			ctx.lineTo(xpos+markersize, ypos+markersize);
			ctx.moveTo(xpos-markersize, ypos+markersize);
			ctx.lineTo(xpos+markersize, ypos-markersize);
			ctx.stroke();
			ctx.setLineDash([]);
			break;
		case "circle":
		default:
			ctx.arc(xpos, ypos, markersize, 0, 2*Math.PI * 1, true);
			ctx.stroke();
			ctx.fill();
			ctx.setLineDash([]);
			break;
	}
};

function initPassVariableData_part1(data,config,ctx) {
var i,j,result, mxvalue ,mnvalue, cumvalue, totvalue,lmaxvalue,lminvalue,lgtxt,lgtxt2,tp,prevpos,firstNotMissingi,lastNotMissingi,firstNotMissingj,lastNotMissingj,grandtotal;
switch(ctx.tpdata) {
	case 1 :

		result=[];
		var segmentAngle,cumulativeAngle,realCumulativeAngle;

		var realAmplitude = (((config.totalAmplitude * (Math.PI / 180) + 2 * Math.PI) % (2 * Math.PI)) + 2* Math.PI) % (2* Math.PI) ; 
		if(realAmplitude <= config.zeroValue)realAmplitude=2*Math.PI;

		cumulativeAngle = (((-config.startAngle * (Math.PI / 180) + 2 * Math.PI) % (2 * Math.PI)) + 2* Math.PI) % (2* Math.PI) ; 
		realCumulativeAngle = (((config.startAngle * (Math.PI / 180) + 2 * Math.PI) % (2 * Math.PI)) + 2* Math.PI) % (2* Math.PI) ; 

		startAngle=cumulativeAngle;
		totvalue = 0;
		notemptyval=0;
		var firstNotMissing = -1;
		var lastNotMissing = -1;
		var prevNotMissing = -1;
		mxvalue=-Number.MAX_VALUE;
		mnvalue=Number.MAX_VALUE;
		for (i = 0; i < data.length; i++) {
			if(ctx.tpchart != "PolarArea" && 1*data[i].value<0)continue;
			if (!(typeof(data[i].value) == 'undefined')) { 
				if(firstNotMissing==-1)firstNotMissing=i;
				mxvalue=Math.max(mxvalue,1*data[i].value);
				mnvalue=Math.min(mnvalue,1*data[i].value);
				notemptyval++; 
				totvalue += 1 * data[i].value;
				lastNotMissing=i;
			}
		}
	
		cumvalue=0;
		var prevMissing=-1;
		for(i=0;i<data.length;i++) {
			if (typeof(data[i].title) == "string") lgtxt = data[i].title.trim();
			else lgtxt = "";
			if (!(typeof(data[i].value) == 'undefined') && (ctx.tpchart == "PolarArea" || 1*data[i].value>=0)) {
//				if(ctx.tpchart=="PolarArea") { if(notemptyval>0)segmentAngle= (Math.PI *2)/notemptyval; else segmentAngle=0; }
//				else segmentAngle = (1 * data[i].value / totvalue) * (Math.PI * 2);
				if(ctx.tpchart=="PolarArea") { if(notemptyval>0)segmentAngle= realAmplitude/notemptyval; else segmentAngle=0; }
				else segmentAngle = (1 * data[i].value / totvalue) * realAmplitude;
				if (segmentAngle >= Math.PI * 2) segmentAngle = Math.PI * 2 - 0.001; // bug on Android when segmentAngle is >= 2*PI;
				cumvalue += 1 * data[i].value;
				result[i]= {
					config: config,
					v1: fmtChartJS(config, lgtxt, config.fmtV1),
					v2: fmtChartJS(config, 1 * data[i].value, config.fmtV2),
					v3: fmtChartJS(config, cumvalue, config.fmtV3),
					v4: fmtChartJS(config, totvalue, config.fmtV4),
					v5: fmtChartJS(config, segmentAngle, config.fmtV5),
					v6: roundToWithThousands(config, fmtChartJS(config, 100 * data[i].value / totvalue, config.fmtV6), config.roundPct),
					v7 : 0,
					v8 : 0,
					v9 : 0,
					v10 : 0,
					v11: fmtChartJS(config, cumulativeAngle - segmentAngle, config.fmtV11),
					v12: fmtChartJS(config, cumulativeAngle, config.fmtV12),
					v13: fmtChartJS(config, i, config.fmtV13),
					lgtxt: lgtxt,
					datavalue: 1 * data[i].value,
					cumvalue: cumvalue,
					totvalue: totvalue,
					segmentAngle: segmentAngle,
					firstAngle : startAngle,
					pctvalue: 100 * data[i].value / totvalue,
					startAngle: cumulativeAngle,
					realStartAngle : realCumulativeAngle,
					endAngle: cumulativeAngle+segmentAngle,
					maxvalue : mxvalue,
					minvalue : mnvalue,
					i: i,
					firstNotMissing : firstNotMissing,
					lastNotMissing : lastNotMissing,
					prevNotMissing : prevNotMissing,
					prevMissing : prevMissing,
					nextNotMissing : -1,
				        radiusOffset : 0,
					midPosX : 0,
					midPosY : 0,
					int_radius : 0,
					ext_radius : 0,
					data: data
				};   
				cumulativeAngle += segmentAngle;
				realCumulativeAngle -= segmentAngle;
				if(prevNotMissing != -1) result[prevNotMissing].nextNotMissing=i;
				prevNotMissing = i;
        		} else {
				result[i]={ 
					v1:lgtxt,
					maxvalue : mxvalue,
					minvalue : mnvalue,
					i: i,
					firstNotMissing : firstNotMissing,
					lastNotMissing : lastNotMissing,
					prevNotMissing : prevNotMissing
				 }; 
				 prevMissing=i;
			}
		}
		break;
	case 0:
	default : 
		var axis;
		result=[];
		mxvalue=[];
		mxvalue[0]=[];
		mxvalue[1]=[];
		mnvalue=[];
		mnvalue[0]=[];
		mnvalue[1]=[];
		cumvalue=[];
		cumvalue[0]=[];
		cumvalue[1]=[];
		totvalue=[];
		totvalue[0]=[];
		totvalue[1]=[];
		lmaxvalue=[];
		lmaxvalue[0]=[];
		lmaxvalue[1]=[];
		lminvalue=[];
		lminvalue[0]=[];
		lminvalue[1]=[];
		prevpos=[];
		firstNotMissingi=[];
		lastNotMissingi=[];
		firstNotMissingj=[];
		lastNotMissingj=[];
		prevpos[0]=[];
		prevpos[1]=[];
		grandtotal=0;

		for (i = 0; i < data.datasets.length; i++) {
			// BUG when all data are missing !
			if (typeof data.datasets[i].xPos != "undefined" && tpdraw(ctx,data.datasets[i])=="Line") {
				for(j=data.datasets[i].data.length;j<data.datasets[i].xPos.length;j++)data.datasets[i].data.push(undefined);
			} else {
				for(j=data.datasets[i].data.length;j<data.labels.length;j++)data.datasets[i].data.push(undefined);
			}
				

			if(data.datasets[i].axis == 2) axis=0;else axis=1;
			result[i]=[];
			lmaxvalue[0][i]=-Number.MAX_VALUE;
			lmaxvalue[1][i]=-Number.MAX_VALUE;
			lminvalue[0][i]=Number.MAX_VALUE;
			lminvalue[1][i]=Number.MAX_VALUE;
			firstNotMissingi[i]=-1;
			lastNotMissingi[i]=-1;
			for (j = 0; j < data.datasets[i].data.length; j++) {

				if(typeof firstNotMissingj[j]== "undefined"){
					firstNotMissingj[j]=-1;
					lastNotMissingj[j]=-1;
					totvalue[0][j] = 0; 
					mxvalue[0][j]=-Number.MAX_VALUE;
					mnvalue[0][j]=Number.MAX_VALUE;
					totvalue[1][j] = 0; 
					mxvalue[1][j]=-Number.MAX_VALUE;
					mnvalue[1][j]=Number.MAX_VALUE;
				}
				if (!(typeof data.datasets[i].data[j] == 'undefined')) {
					grandtotal += 1 * data.datasets[i].data[j];
					if(firstNotMissingi[i]==-1)firstNotMissingi[i]=j;
					lastNotMissingi[i]=j;
					if(firstNotMissingj[j]==-1)firstNotMissingj[j]=i;
					lastNotMissingj[j]=i;
					totvalue[axis][j] += 1 * data.datasets[i].data[j]; 
					mxvalue[axis][j] =Math.max(mxvalue[axis][j],1 * data.datasets[i].data[j]);
					mnvalue[axis][j] =Math.min(mnvalue[axis][j],1 * data.datasets[i].data[j]);
					lmaxvalue[axis][i] =Math.max(lmaxvalue[axis][i],1 * data.datasets[i].data[j]);
					lminvalue[axis][i] =Math.min(lminvalue[axis][i],1 * data.datasets[i].data[j]);
				}
			}
		}
		
		for (i = 0; i < data.datasets.length; i++) {
			if(data.datasets[i].axis == 2) axis=0;else axis=1;
			if (typeof(data.datasets[i].title) == "string") lgtxt = data.datasets[i].title.trim();
			else lgtxt = "";
			var prevnotemptyj=-1;
			var prevemptyj=-1;
			for (j = 0; j < data.datasets[i].data.length; j++) {
			
				if(typeof cumvalue[0][j]== "undefined"){cumvalue[0][j] = 0; prevpos[0][j]=-1;cumvalue[1][j] = 0; prevpos[1][j]=-1; }
				lgtxt2 = "";
				if (typeof data.datasets[i].xPos != "undefined") {
					if (!(typeof data.datasets[i].xPos[j] == "undefined")) lgtxt2 = data.datasets[i].xPos[j];
				}
				if (lgtxt2 == "" && !(typeof(data.labels[j]) == "undefined")) lgtxt2 = data.labels[j];
				if (typeof lgtxt2 == "string") lgtxt2 = lgtxt2.trim();

//				if (!(typeof(data.datasets[i].data[j]) == 'undefined') && data.datasets[i].data[j] != 0) {
				if (!(typeof(data.datasets[i].data[j]) == 'undefined') ) {
					cumvalue[axis][j]+=1*data.datasets[i].data[j];
					switch(tpdraw(ctx,data.datasets[i]))  {
						case "Bar" :
						case "StackedBar" :
						case "HorizontalBar" :
						case "HorizontalStackedBar" :
							result[i][j]= {
								config: config,
								v1: fmtChartJS(config, lgtxt, config.fmtV1),
								v2: fmtChartJS(config, lgtxt2, config.fmtV2),
								v3: fmtChartJS(config, 1 * data.datasets[i].data[j], config.fmtV3),
								v4: fmtChartJS(config, cumvalue[axis][j], config.fmtV4),
								v5: fmtChartJS(config, totvalue[axis][j], config.fmtV5),
								v6: roundToWithThousands(config, fmtChartJS(config, 100 * data.datasets[i].data[j] / totvalue[axis][j], config.fmtV6), config.roundPct),
								v6T: roundToWithThousands(config, fmtChartJS(config, 100 * data.datasets[i].data[j] / grandtotal, config.fmtV6T), config.roundPct),
								v11: fmtChartJS(config, i, config.fmtV11),
								v12: fmtChartJS(config, j, config.fmtV12),
								lgtxt: lgtxt,
								lgtxt2: lgtxt2,
								datavalue: 1 * data.datasets[i].data[j],
								cumvalue: cumvalue[axis][j],
								totvalue: totvalue[axis][j],
								pctvalue: 100 * data.datasets[i].data[j] / totvalue[axis][j],
								pctvalueT: 100 * data.datasets[i].data[j] / grandtotal,
								maxvalue : mxvalue[axis][j],
								minvalue : mnvalue[axis][j],
								lmaxvalue : lmaxvalue[axis][i],
								lminvalue : lminvalue[axis][i],
								grandtotal : grandtotal,
								firstNotMissing : firstNotMissingj[j],
								lastNotMissing : lastNotMissingj[j],
								prevNotMissing : prevnotemptyj,
								prevMissing : prevemptyj,
								nextNotMissing : -1,
								j: j,
								i: i,
								data: data
							};
							if(1 * data.datasets[i].data[j]==0 && (tpdraw(ctx,data.datasets[i])=="HorizontalStackedBar" || tpdraw(ctx,data.datasets[i])=="StackedBar"))result[i][j].v3="";
							break;
						case "Line" :
						case "Radar" :
							result[i][j]= {
								config: config,
								v1: fmtChartJS(config, lgtxt, config.fmtV1),
								v2: fmtChartJS(config, lgtxt2, config.fmtV2),
								v3: fmtChartJS(config, 1 * data.datasets[i].data[j], config.fmtV3),
								v5: fmtChartJS(config, 1 * data.datasets[i].data[j], config.fmtV5),
								v6: fmtChartJS(config, mxvalue[axis][j], config.fmtV6),
								v7: fmtChartJS(config, totvalue[axis][j], config.fmtV7),
								v8: roundToWithThousands(config, fmtChartJS(config, 100 * data.datasets[i].data[j] / totvalue[axis][j], config.fmtV8), config.roundPct),
								v8T: roundToWithThousands(config, fmtChartJS(config, 100 * data.datasets[i].data[j] / grandtotal, config.fmtV8T), config.roundPct),
								v11: fmtChartJS(config, i, config.fmtV11),
								v12: fmtChartJS(config, j, config.fmtV12),
								lgtxt: lgtxt,
								lgtxt2: lgtxt2,
								datavalue: 1 * data.datasets[i].data[j],
								diffnext: 1 * data.datasets[i].data[j],
								pctvalue: 100 * data.datasets[i].data[j] / totvalue[axis][j],
								pctvalueT: 100 * data.datasets[i].data[j] / grandtotal,
								totvalue : totvalue[axis][j],
								cumvalue: cumvalue[axis][j],
								maxvalue : mxvalue[axis][j],
								minvalue : mnvalue[axis][j],
								lmaxvalue : lmaxvalue[axis][i],
								lminvalue : lminvalue[axis][i],
								grandtotal : grandtotal,
								firstNotMissing : firstNotMissingi[i],
								lastNotMissing : lastNotMissingi[i],
								prevNotMissing : prevnotemptyj,
								prevMissing : prevemptyj,
								nextNotMissing : -1,
								j: j,
								i: i,
								data: data
							};
							if(prevpos[axis][j]>=0){
								result[i][j].v4=fmtChartJS(config, (prevpos[axis][j] != -1 ? 1 * data.datasets[i].data[j]-result[prevpos[axis][j]][j].datavalue : 1 * data.datasets[i].data[j]), config.fmtV4);
								result[i][j].diffprev=(prevpos[axis][j] != -1 ? 1 * data.datasets[i].data[j]-result[prevpos[axis][j]][j].datavalue : 1 * data.datasets[i].data[j]);
								result[prevpos[axis][j]][j].diffnext=data.datasets[prevpos[axis][j]].data[j] - data.datasets[i].data[j];
								result[prevpos[axis][j]][j].v5=result[prevpos[axis][j]][j].diffnext;
							} else {
								result[i][j].v4=1 * data.datasets[i].data[j];
								
							}
							prevpos[axis][j]=i;
							break;
						default:
							break;
					}
					if(!(typeof(data.datasets[i].data[j]) == 'undefined')) {
						if(prevnotemptyj!= -1) {for(k=prevnotemptyj;k<j;k++) result[i][k].nextNotMissing=j;}	
						prevnotemptyj=j;
					}
				} else {
					prevemptyj=j; 
					switch(tpdraw(ctx,data.datasets[i]))  {
						case "Bar" :
						case "StackedBar" :
						case "HorizontalBar" :
						case "HorizontalStackedBar" :
							result[i][j] ={ 
								v1:lgtxt,
								lmaxvalue : lmaxvalue[axis][i],
								lminvalue : lminvalue[axis][i],
								firstNotMissing : firstNotMissingj[j],
								lastNotMissing : lastNotMissingj[j],
								prevNotMissing : prevnotemptyj,
								prevMissing : prevemptyj,
								grandtotal : grandtotal
								 }; 
							break;
						case "Line" :
						case "Radar" :
							result[i][j] ={ 
								v1:lgtxt,
								lmaxvalue : lmaxvalue[axis][i],
								lminvalue : lminvalue[axis][i],
								firstNotMissing : firstNotMissingi[i],
								lastNotMissing : lastNotMissingi[i],
								prevNotMissing : prevnotemptyj,
								prevMissing : prevemptyj,
								grandtotal : grandtotal
								 }; 
							break;
						}
				}
			}
		}
		break;
	}

	
return result;

};

function initPassVariableData_part2(statData,data,config,ctx,othervars) {
var realbars=0;
var i,j;
switch(ctx.tpdata) {
	case 1 :
		for(i=0;i<data.length;i++) {
			statData[i].v7= fmtChartJS(config, othervars.midPosX, config.fmtV7);
			statData[i].v8= fmtChartJS(config, othervars.midPosY, config.fmtV8),
			statData[i].v9= fmtChartJS(config, othervars.int_radius, config.fmtV9);
			statData[i].v10= fmtChartJS(config, othervars.ext_radius, config.fmtV10);
			if(ctx.tpchart=="PolarArea") {
				statData[i].radiusOffset= calculateOffset(config.logarithmic, 1 * data[i].value, othervars.calculatedScale, othervars.scaleHop);
				statData[i].v10= fmtChartJS(config, statData[i].radiusOffset, config.fmtV10); 
			}
			else {
				statData[i].v10= fmtChartJS(config, othervars.ext_radius, config.fmtV10); 
				statData[i].radiusOffset=othervars.ext_radius;
			}
			statData[i].outerVal= othervars.outerVal;
			statData[i].midPosX= othervars.midPosX;
			statData[i].midPosY= othervars.midPosY;
			statData[i].calculatedScale=othervars.calculatedScale;
			statData[i].scaleHop=othervars.scaleHop;
			statData[i].int_radius= othervars.int_radius;
			statData[i].ext_radius= othervars.ext_radius;
		}
		break;
	case 0:
	default :
		var tempp = new Array(data.datasets.length);
		var tempn = new Array(data.datasets.length);
		for (i = 0; i < data.datasets.length; i++) {
			switch(tpdraw(ctx,data.datasets[i])) {
				case "Line" :
					for (j = 0; j < data.datasets[i].data.length; j++) {
						statData[i][j].xAxisPosY = othervars.xAxisPosY;
						statData[i][j].yAxisPosX = othervars.yAxisPosX;
						statData[i][j].valueHop = othervars.valueHop;
						statData[i][j].nbValueHop = othervars.nbValueHop;
						if (data.datasets[i].axis == 2) {
							statData[i][j].scaleHop = othervars.scaleHop2;
							statData[i][j].zeroY = othervars.zeroY2;
							statData[i][j].calculatedScale = othervars.calculatedScale2;
							statData[i][j].logarithmic = othervars.logarithmic2;
						} else {
							statData[i][j].scaleHop = othervars.scaleHop;
							statData[i][j].zeroY = othervars.zeroY;
							statData[i][j].calculatedScale = othervars.calculatedScale;
							statData[i][j].logarithmic  = othervars.logarithmic;
						}
						statData[i][j].xPos=xPos(i,j,data,othervars.yAxisPosX,othervars.valueHop,othervars.nbValueHop);
						statData[i][j].yAxisPos=othervars.xAxisPosY - statData[i][j].zeroY;
						if(ctx.tpchart=="Bar" || ctx.tpchart=="StackedBar") {
							statData[i][j].xPos+=(othervars.valueHop/2);
							statData[i][j].yAxisPosX += (othervars.valueHop/2);
						}			
						if(j==0) {
							statData[i][j].lmaxvalue_offset=calculateOffset(statData[i][j].logarithmic, statData[i][j].lmaxvalue, statData[i][j].calculatedScale, statData[i][j].scaleHop) - statData[i][j].zeroY;
							statData[i][j].lminvalue_offset=calculateOffset(statData[i][j].logarithmic, statData[i][j].lminvalue, statData[i][j].calculatedScale, statData[i][j].scaleHop) - statData[i][j].zeroY;
						} else {
							statData[i][j].lmaxvalue_offset=statData[i][0].lmaxvalue_offset;
							statData[i][j].lminvalue_offset=statData[i][0].lminvalue_offset;
						}
						
						if (!(typeof(data.datasets[i].data[j]) == 'undefined')) {
							statData[i][j].yPosOffset= calculateOffset(statData[i][j].logarithmic, data.datasets[i].data[j], statData[i][j].calculatedScale, statData[i][j].scaleHop) - statData[i][j].zeroY;
							statData[i][j].posY=statData[i][j].yAxisPos - statData[i][j].yPosOffset;
						}
						if (typeof(data.datasets[i].origin) == 'object') {
							if (!(typeof(data.datasets[i].origin[j]) == 'undefined')) {
								statData[i][j].yPosOffsetOrigin= calculateOffset(statData[i][j].logarithmic, data.datasets[i].origin[j], statData[i][j].calculatedScale, statData[i][j].scaleHop) - statData[i][j].zeroY;
								statData[i][j].posYOrigin=statData[i][j].yAxisPos - statData[i][j].yPosOffsetOrigin;
							}
						}
						statData[i][j].posX=statData[i][j].xPos;
						
						statData[i][j].v9= statData[i][j].xPos;
						statData[i][j].v10=statData[i][j].posY;

						statData[i][j].annotateStartPosX = statData[i][j].xPos;
						statData[i][j].annotateEndPosX = statData[i][j].xPos;
						statData[i][j].annotateStartPosY = othervars.xAxisPosY;
						statData[i][j].annotateEndPosY = othervars.xAxisPosY-othervars.msr.availableHeight;
						statData[i][j].D1A=undefined;
						statData[i][j].D1B=undefined;
					}
					break;
				case "Radar" :
					var rotationDegree = (2 * Math.PI) / data.datasets[0].data.length;
					for (j = 0; j < data.datasets[i].data.length; j++) {
						statData[i][j].midPosX =  othervars.midPosX;
						statData[i][j].midPosY =  othervars.midPosY;
						statData[i][j].int_radius= 0;
						statData[i][j].ext_radius= othervars.maxSize;
						statData[i][j].radiusOffset= othervars.maxSize;
						statData[i][j].calculatedScale= othervars.calculatedScale;
						statData[i][j].scaleHop= othervars.scaleHop;
						statData[i][j].calculated_offset= calculateOffset(config.logarithmic, data.datasets[i].data[j], othervars.calculatedScale, othervars.scaleHop);
						statData[i][j].offsetX=Math.cos(config.startAngle * Math.PI / 180 - j * rotationDegree) * statData[i][j].calculated_offset;
						statData[i][j].offsetY=Math.sin(config.startAngle * Math.PI / 180 - j * rotationDegree) * statData[i][j].calculated_offset;
						statData[i][j].v9=statData[i][j].midPosX + statData[i][j].offsetX;
						statData[i][j].v10=statData[i][j].midPosY - statData[i][j].offsetY;
						statData[i][j].posX=statData[i][j].midPosX + statData[i][j].offsetX;
						statData[i][j].posY=statData[i][j].midPosY - statData[i][j].offsetY;
						if(j==0)statData[i][j].calculated_offset_max=calculateOffset(config.logarithmic, statData[i][j].lmaxvalue, othervars.calculatedScale, othervars.scaleHop);
						else    statData[i][j].calculated_offset_max=statData[0][j].calculated_offset_max;
						statData[i][j].annotateStartPosX = othervars.midPosX;
						statData[i][j].annotateEndPosX = othervars.midPosX+Math.cos(config.startAngle * Math.PI / 180 - j * rotationDegree) * othervars.maxSize;
						statData[i][j].annotateStartPosY = othervars.midPosY;
						statData[i][j].annotateEndPosY = othervars.midPosY-Math.sin(config.startAngle * Math.PI / 180 - j * rotationDegree) * othervars.maxSize;
						if(Math.abs(statData[i][j].annotateStartPosX-statData[i][j].annotateEndPosX)<config.zeroValue) {
							statData[i][j].D1A=undefined;
							statData[i][j].D1B=undefined;
							statData[i][j].D2A=0;
						} else {
							statData[i][j].D1A=(statData[i][j].annotateStartPosY-statData[i][j].annotateEndPosY)/(statData[i][j].annotateStartPosX-statData[i][j].annotateEndPosX);
							statData[i][j].D1B=-statData[i][j].D1A*statData[i][j].annotateStartPosX+statData[i][j].annotateStartPosY;
							if(Math.abs(statData[i][j].D1A)>=config.zeroValue)statData[i][j].D2A=-(1/statData[i][j].D1A);
							else statData[i][j].D2A=undefined;
						}

				        }
					break;
				case "Bar" :
					for (j = 0; j < data.datasets[i].data.length; j++) {

						statData[i][j].xAxisPosY = othervars.xAxisPosY;
						statData[i][j].yAxisPosX = othervars.yAxisPosX;
						statData[i][j].valueHop = othervars.valueHop;
						statData[i][j].barWidth = othervars.barWidth;
						statData[i][j].additionalSpaceBetweenBars= othervars.additionalSpaceBetweenBars;
						statData[i][j].nbValueHop = othervars.nbValueHop;
						statData[i][j].calculatedScale = othervars.calculatedScale;
						statData[i][j].scaleHop = othervars.scaleHop;
			
						statData[i][j].xPosLeft= othervars.yAxisPosX + Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) + othervars.valueHop * j + othervars.additionalSpaceBetweenBars+othervars.barWidth * realbars + Math.ceil(ctx.chartSpaceScale*config.barDatasetSpacing) * realbars + Math.ceil(ctx.chartLineScale*config.barStrokeWidth) * realbars;
						statData[i][j].xPosRight = statData[i][j].xPosLeft + othervars.barWidth;
						statData[i][j].yPosBottom =othervars.xAxisPosY - othervars.zeroY
						statData[i][j].barHeight=calculateOffset(config.logarithmic, 1 * data.datasets[i].data[j], othervars.calculatedScale, othervars.scaleHop) - othervars.zeroY;
						if (data.datasets[i].axis == 2) {
							statData[i][j].yPosBottom =othervars.xAxisPosY - othervars.zeroY2;
							statData[i][j].barHeight=calculateOffset(config.logarithmic2, 1 * data.datasets[i].data[j], othervars.calculatedScale2, othervars.scaleHop2) - othervars.zeroY2;
						} else {
							statData[i][j].yPosBottom =othervars.xAxisPosY - othervars.zeroY
							statData[i][j].barHeight=calculateOffset(config.logarithmic, 1 * data.datasets[i].data[j], othervars.calculatedScale, othervars.scaleHop) - othervars.zeroY;
						}
						statData[i][j].yPosTop = statData[i][j].yPosBottom - statData[i][j].barHeight + (Math.ceil(ctx.chartLineScale*config.barStrokeWidth) / 2);
						statData[i][j].v7=statData[i][j].xPosLeft;
						statData[i][j].v8=statData[i][j].yPosBottom;
						statData[i][j].v9=statData[i][j].xPosRight;
						statData[i][j].v10=statData[i][j].yPosTop;

					}
					realbars++;
					break;			
				case "StackedBar" :
					for (j = 0; j < data.datasets[i].data.length; j++) {
						statData[i][j].xAxisPosY = othervars.xAxisPosY;
						statData[i][j].yAxisPosX = othervars.yAxisPosX;
						statData[i][j].valueHop = othervars.valueHop;
						statData[i][j].barWidth = othervars.barWidth;
						statData[i][j].additionalSpaceBetweenBars= othervars.additionalSpaceBetweenBars;
						statData[i][j].nbValueHop = othervars.nbValueHop;
						statData[i][j].calculatedScale = othervars.calculatedScale;
						statData[i][j].scaleHop = othervars.scaleHop;
//						statData[i][j].nbValueHop = othervars.nbValueHop;
			
						if (typeof tempp[j]=="undefined") {
							tempp[j]=0;
							tempn[j]=0;
							zeroY=  calculateOffset(config.logarithmic, 0 , othervars.calculatedScale, othervars.scaleHop);
						}
						if ((typeof data.datasets[i].data[j] == 'undefined')) continue;
						statData[i][j].xPosLeft= othervars.yAxisPosX + Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) + othervars.valueHop * j+othervars.additionalSpaceBetweenBars;
						if (1*data.datasets[i].data[j]<0) {
							statData[i][j].botval=tempn[j];
							statData[i][j].topval=tempn[j]+1*data.datasets[i].data[j] ;
							tempn[j]=tempn[j]+1*data.datasets[i].data[j] ;
						} else {
							statData[i][j].botval=tempp[j];
							statData[i][j].topval=tempp[j]+1*data.datasets[i].data[j] ;
							tempp[j]=tempp[j]+1*data.datasets[i].data[j] ;
						}
						statData[i][j].xPosRight = statData[i][j].xPosLeft + othervars.barWidth;
						statData[i][j].botOffset = calculateOffset(config.logarithmic, statData[i][j].botval , othervars.calculatedScale, othervars.scaleHop);
						statData[i][j].topOffset = calculateOffset(config.logarithmic, statData[i][j].topval , othervars.calculatedScale, othervars.scaleHop);
						statData[i][j].yPosBottom =othervars.xAxisPosY - statData[i][j].botOffset;
						statData[i][j].yPosTop = othervars.xAxisPosY - statData[i][j].topOffset;
						// treat spaceBetweenBar 
						if(Math.ceil(ctx.chartSpaceScale*config.spaceBetweenBar) > 0)
						{
							if(1*data.datasets[i].data[j]<0) {
								statData[i][j].yPosBottom+=Math.ceil(ctx.chartSpaceScale*config.spaceBetweenBar);
								if(tempn[j]==1*data.datasets[i].data[j])statData[i][j].yPosBottom-=(Math.ceil(ctx.chartSpaceScale*config.spaceBetweenBar)/2);	
								if(statData[i][j].yPosTop<statData[i][j].yPosBottom)statData[i][j].yPosBottom=statData[i][j].yPosTop;
							} else if (1*data.datasets[i].data[j]>0) {
								statData[i][j].yPosBottom-=Math.ceil(ctx.chartSpaceScale*config.spaceBetweenBar);	
								if(tempp[j]==1*data.datasets[i].data[j])statData[i][j].yPosBottom+=(Math.ceil(ctx.chartSpaceScale*config.spaceBetweenBar)/2);	
								if(statData[i][j].yPosTop>statData[i][j].yPosBottom)statData[i][j].yPosBottom=statData[i][j].yPosTop;
							}
						}
						statData[i][j].v7=statData[i][j].xPosLeft;
						statData[i][j].v8=statData[i][j].yPosBottom;
						statData[i][j].v9=statData[i][j].xPosRight;
						statData[i][j].v10=statData[i][j].yPosTop;
					}
					break;			
				case "HorizontalBar" :
					for (j = 0; j < data.datasets[i].data.length; j++) {

						statData[i][j].xAxisPosY = othervars.xAxisPosY;
						statData[i][j].yAxisPosX = othervars.yAxisPosX;
						statData[i][j].valueHop = othervars.valueHop;
						statData[i][j].barWidth = othervars.barWidth;
						statData[i][j].additionalSpaceBetweenBars= othervars.additionalSpaceBetweenBars;
						statData[i][j].nbValueHop = othervars.nbValueHop;
						statData[i][j].calculatedScale = othervars.calculatedScale;
						statData[i][j].scaleHop = othervars.scaleHop;


						statData[i][j].xPosLeft= othervars.yAxisPosX + othervars.zeroY;
						statData[i][j].yPosTop=othervars.xAxisPosY + Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) - othervars.scaleHop * (j + 1) + othervars.additionalSpaceBetweenBars + othervars.barWidth * i + Math.ceil(ctx.chartSpaceScale*config.barDatasetSpacing) * i + Math.ceil(ctx.chartLineScale*config.barStrokeWidth) * i;
						statData[i][j].yPosBottom=statData[i][j].yPosTop+othervars.barWidth;
						statData[i][j].barWidth = calculateOffset(config.logarithmic, 1 * data.datasets[i].data[j], othervars.calculatedScale, othervars.valueHop) - othervars.zeroY;
						statData[i][j].xPosRight = statData[i][j].xPosLeft + statData[i][j].barWidth;

						statData[i][j].v7=statData[i][j].xPosLeft;
						statData[i][j].v8=statData[i][j].yPosBottom;
						statData[i][j].v9=statData[i][j].xPosRight;
						statData[i][j].v10=statData[i][j].yPosTop;
					}
					break;			
				case "HorizontalStackedBar" :
					for (j = 0; j < data.datasets[i].data.length; j++) {
						statData[i][j].xAxisPosY = othervars.xAxisPosY;
						statData[i][j].yAxisPosX = othervars.yAxisPosX;
						statData[i][j].valueHop = othervars.valueHop;
						statData[i][j].barWidth = othervars.barWidth;
						statData[i][j].additionalSpaceBetweenBars= othervars.additionalSpaceBetweenBars;
						statData[i][j].nbValueHop = othervars.nbValueHop;
						statData[i][j].calculatedScale = othervars.calculatedScale;
						statData[i][j].scaleHop = othervars.scaleHop;

						if (i == 0) {
							tempp[j]=0;
							tempn[j]=0;
						}
						if (typeof(data.datasets[i].data[j]) == 'undefined')  continue;
//						if ((typeof(data.datasets[i].data[j]) == 'undefined') || 1*data.datasets[i].data[j] == 0 ) continue;

						statData[i][j].xPosLeft= othervars.yAxisPosX + Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) + othervars.valueHop * j;
						if (1*data.datasets[i].data[j]<0) {
							statData[i][j].leftval=tempn[j];
							statData[i][j].rightval=tempn[j]+1*data.datasets[i].data[j] ;
							tempn[j]=tempn[j]+1*data.datasets[i].data[j] ;
						} else {
							statData[i][j].leftval=tempp[j];
							statData[i][j].rightval=tempp[j]+1*data.datasets[i].data[j] ;
							tempp[j]=tempp[j]+1*data.datasets[i].data[j] ;
						}
						statData[i][j].rightOffset = HorizontalCalculateOffset(statData[i][j].rightval , othervars.calculatedScale, othervars.valueHop);
						statData[i][j].leftOffset  = HorizontalCalculateOffset(statData[i][j].leftval , othervars.calculatedScale, othervars.valueHop);
						statData[i][j].xPosRight = othervars.yAxisPosX + statData[i][j].rightOffset;
						statData[i][j].xPosLeft  = othervars.yAxisPosX + statData[i][j].leftOffset;
						statData[i][j].yPosTop =othervars.xAxisPosY + Math.ceil(ctx.chartSpaceScale*config.barValueSpacing) - othervars.scaleHop * (j + 1) + othervars.additionalSpaceBetweenBars;
						statData[i][j].yPosBottom = statData[i][j].yPosTop+othervars.barWidth;
						// treat spaceBetweenBar 
						if(Math.ceil(ctx.chartSpaceScale*config.spaceBetweenBar) > 0)
						{
							if(1*data.datasets[i].data[j]<0) {
								statData[i][j].xPosLeft-=Math.ceil(ctx.chartSpaceScale*config.spaceBetweenBar);	
								if(tempn[j]==1*data.datasets[i].data[j])statData[i][j].xPosLeft+=(Math.ceil(ctx.chartSpaceScale*config.spaceBetweenBar)/2);	
								if(statData[i][j].xPosLeft<statData[i][j].xPosRight)statData[i][j].xPosLeft=statData[i][j].xPosRight;
							} else if (1*data.datasets[i].data[j]>0) {
								statData[i][j].xPosLeft+=Math.ceil(ctx.chartSpaceScale*config.spaceBetweenBar);	
								if(tempp[j]==1*data.datasets[i].data[j])statData[i][j].xPosLeft-=(Math.ceil(ctx.chartSpaceScale*config.spaceBetweenBar)/2);	
								if(statData[i][j].xPosLeft>statData[i][j].xPosRight)statData[i][j].xPosLeft=statData[i][j].xPosRight;
							}
						}

						statData[i][j].v7=statData[i][j].xPosLeft;
						statData[i][j].v8=statData[i][j].yPosBottom;
						statData[i][j].v9=statData[i][j].xPosRight;
						statData[i][j].v10=statData[i][j].yPosTop;
					}
					break;
				default : 
					break;
			}
	}
	
} ;



	function xPos(ival, iteration, data,yAxisPosX,valueHop,nbValueHop) {
//nbValueHop=8;
		if (typeof data.datasets[ival].xPos == "object") {
			if (!(typeof data.datasets[ival].xPos[Math.floor(iteration + config.zeroValue)] == "undefined")) {
				var width = valueHop * nbValueHop;

				var deb = (typeof data.xBegin != "undefined") ? data.xBegin : 1 * data.labels[0];
				var fin = (typeof data.xEnd != "undefined") ? data.xEnd : 1 * data.labels[data.labels.length - 1];
				if (fin <= deb) fin = deb + 100;
				if (1 * data.datasets[ival].xPos[Math.floor(iteration + config.zeroValue)] >= deb && data.datasets[ival].xPos[Math.floor(iteration + config.zeroValue)] <= fin) {
					var p1 = yAxisPosX + width * ((1 * data.datasets[ival].xPos[Math.floor(iteration + config.zeroValue)] - deb) / (fin - deb));
					var p2 = p1;
					if (Math.abs(iteration - Math.floor(iteration + config.zeroValue)) > config.zeroValue) {
						p2 = xPos(ival, Math.ceil(iteration - config.zeroValue), data);
					}
					return p1 + (iteration - Math.floor(iteration + config.zeroValue)) * (p2 - p1);
				}
			}
		}
		return yAxisPosX + (valueHop * iteration);
	};


	function calculateOrderOfMagnitude(val) {
		return Math.floor(Math.log(val) / Math.LN10);
	};

	function calculateOffset(logarithmic, val, calculatedScale, scaleHop) {
		if (!logarithmic) { // no logarithmic scale
			var outerValue = calculatedScale.steps * calculatedScale.stepValue;
			var adjustedValue = val - calculatedScale.graphMin;
			var scalingFactor = CapValue(adjustedValue / outerValue, 1, 0);
			return (scaleHop * calculatedScale.steps) * scalingFactor;
		} else { // logarithmic scale
//			return CapValue(log10(val) * scaleHop - calculateOrderOfMagnitude(calculatedScale.graphMin) * scaleHop, undefined, 0);
			return CapValue(log10(val) * scaleHop - log10(calculatedScale.graphMin) * scaleHop, undefined, 0);
		}
	};

	function HorizontalCalculateOffset(val, calculatedScale, scaleHop) {
		var outerValue = calculatedScale.steps * calculatedScale.stepValue;
		var adjustedValue = val - calculatedScale.graphMin;
		var scalingFactor = CapValue(adjustedValue / outerValue, 1, 0);
		return (scaleHop * calculatedScale.steps) * scalingFactor;
	};

	//Apply cap a value at a high or low number
	function CapValue(valueToCap, maxValue, minValue) {
		if (isNumber(maxValue)) {
			if (valueToCap > maxValue) {
				return maxValue;
			}
		}
		if (isNumber(minValue)) {
			if (valueToCap < minValue) {
				return minValue;
			}
		}
		return valueToCap;
	};
	function log10(val) {
		return Math.log(val) / Math.LN10;
	};
};

function isBooleanOptionTrue(optionVar,defaultvalue) {
	var j;
	if(typeof optionvar == "undefined") {
		if(typeof defaultvalue=="function") return true;
		else if(typeof defaultvalue == "object") { 
			for(j=0;j<defaultvalue.length;j++) if (defaultvalue[j])return true;
			return false;
		}
		else return defaultvalue;
	}
	if(typeof optionvar=="function") return true;
	else if(typeof optionvar == "object") {
			for(j=0;j<optionvar.length;j++) if (optionvar[j])return true;
			return false;
	} else return optionvar;
};

function setOptionValue(treat_special,rescale,reference,ctx,data,statData,optionvar,defaultvalue,varname,posi,posj,othervars) {
	var rv;     
	if(treat_special == true) {
		if(ctx.tpdata==0) {
			if(typeof (data.special)=="object") {
//				for(var t=0;t<data.special.length;t++){
				for(var t=data.special.length-1;t>=0;t--){
					if(typeof data.special[t].posi == "undefined" || typeof data.special[t].posj == "undefined") continue;
					if(data.special[t].posi!=posi || data.special[t].posj != posj || posi==-1 || posj==-1) continue;
					if(typeof data.special[t][varname]!="undefined") {
						return data.special[t][varname];
					}
					
				}
			}
		} else {
			if(typeof (data[0].special)=="object") {
				for(var t=0;t<data[0].special.length;t++){
					if(typeof data[0].special[t].posi == "undefined" ) continue;
					if(data[0].special[t].posi!=posi || posi==-1) continue;
					if(typeof data[0].special[t][varname]!="undefined") {
						return data[0].special[t][varname];
					}
					
				}
			}
		}
	}
	if(typeof optionvar == "undefined") {
		if(typeof defaultvalue=="function") return defaultvalue(reference,ctx,data,statData,posi,posj,othervars);
		else if(typeof defaultvalue == "object") {     
				rv=defaultvalue[Math.min(defaultvalue.length-1,Math.max(0,posi))];
		}
		else { 
			rv=defaultvalue;
		}
		if(rescale!=1)rv=Math.ceil(rv*rescale);
		return rv;
	}
	if(typeof optionvar=="function") rv=optionvar(reference,ctx,data,statData,posi,posj,othervars);
	else if(typeof optionvar == "object") {
		if (posj==-1) rv=optionvar[Math.min(optionvar.length-1,Math.max(0,posi))];
		else rv=optionvar[Math.min(optionvar.length-1,Math.max(0,posj))];
	}
	else rv=optionvar;
	if(rescale!=1)rv=Math.ceil(rv*rescale);
	return rv;

};

function tpdraw(ctx,dataval) {
	switch(ctx.tpchart)  {
		case "Bar" :
		case "StackedBar" :
			if (dataval.type=="Line") { tp="Line";} 	
			else {tp=ctx.tpchart;}
			break;
		default : 
			tp=ctx.tpchart;
			break;
	}
	return tp;
};

function setTextBordersAndBackground(ctx,text,fontsize,xpos,ypos,borders,borderscolor,borderswidth,bordersxspace,bordersyspace,bordersstyle,backgroundcolor,optiongroup,BordersRadius) {
	var textHeight,textWidth;
	// compute text width and text height;
	if(typeof text != "string") {
		var txt=text.toString();
		textHeight= fontsize * (txt.split("\n").length || 1);
		textWidth = ctx.measureText(txt).width;
	} else {
		textHeight= fontsize * (text.split("\n").length || 1);
		textWidth = ctx.measureText(text).width;
	}
	
	
	// compute xright, xleft, ytop, ybot;

        var xright, xleft, ytop, ybot;
	if(ctx.textAlign=="center") {
		xright=-textWidth/2;
		xleft=textWidth/2;
	} else if(ctx.textAlign=="left") {
		xright=0;
		xleft=textWidth;
	} else if(ctx.textAlign=="right") {
		xright=-textWidth;
		xleft=0;
	}
	
	if(ctx.textBaseline=="top") {
		ytop=0;
		ybottom=textHeight;	
	} else if (ctx.textBaseline=="center" || ctx.textBaseline=="middle") {
		ytop=-textHeight/2;
		ybottom=textHeight/2;	
	} else if (ctx.textBaseline=="bottom") {
		ytop=-textHeight;
		ybottom=0;	
	}

	ctx.save();
	ctx.beginPath();
 	ctx.translate(xpos,ypos);

	if(backgroundcolor != "none") {

		ctx.save();
		ctx.fillStyle=backgroundcolor;
//		ctx.fillRect(xright-bordersxspace,ybottom+bordersyspace,xleft-xright+2*bordersxspace,ytop-ybottom-2*bordersyspace);
//		ctx.stroke();
		ctx.drawRectangle({x:xright-bordersxspace,y:ybottom+bordersyspace,width:xleft-xright+2*bordersxspace,height:ytop-ybottom-2*bordersyspace,borderRadius:BordersRadius,fill:true,stroke:false})
		ctx.restore();
		ctx.fillStyle="black";
	}	

	// draw border;
	if (borders) {
		ctx.save();
		ctx.lineWidth = borderswidth;	
		ctx.strokeStyle= borderscolor;
		ctx.fillStyle= borderscolor;
		ctx.setLineDash(lineStyleFn(bordersstyle));
		ctx.drawRectangle({x:xright-bordersxspace,y:ybottom+bordersyspace,width:xleft-xright+2*bordersxspace,height:ytop-ybottom-2*bordersyspace,borderRadius:BordersRadius,fill:false,stroke:true})
//		ctx.rect(xright-borderswidth/2-bordersxspace,ytop-borderswidth/2-bordersyspace,xleft-xright+borderswidth+2*bordersxspace,ybottom-ytop+borderswidth+2*bordersyspace); 
//		ctx.stroke();
		ctx.setLineDash([]);
		ctx.restore();
	}
	
	ctx.restore();
};

function calculatePieDrawingSize(ctx,msr,config,data,statData) {

	var realCumulativeAngle = (((config.startAngle * (Math.PI / 180) + 2 * Math.PI) % (2 * Math.PI)) + 2* Math.PI) % (2* Math.PI) ; 
	var realAmplitude = (((config.totalAmplitude * (Math.PI / 180) + 2 * Math.PI) % (2 * Math.PI)) + 2* Math.PI) % (2* Math.PI) ; 
	if(realAmplitude <= config.zeroValue)realAmplitude=2*Math.PI;
			
	var debAngle=((realCumulativeAngle-realAmplitude)+4*Math.PI)%(2*Math.PI);
	var finAngle=debAngle+realAmplitude;
			
	var qposdeb=Math.floor(((debAngle+config.zeroValue)/(Math.PI/2))%4);
	var qposfin=Math.floor(((finAngle-config.zeroValue)/(Math.PI/2))%4);
	var q=[0,0,0,0];
	if(qposdeb<=qposfin)for(var i=qposdeb;i<=qposfin;i++)q[i]=1;
	else {
		for(var i=qposdeb;i<4;i++)q[i]=1;
		for(var i=0;i<=qposfin;i++)q[i]=1;
	}

	if(q[0]==0 && q[1]==0) {
		midPieY = msr.topNotUsableSize+5;
		doughnutRadius = msr.availableHeight-5;
	} else if(q[2]==0 && q[3]==0) {
		midPieY = msr.topNotUsableSize + msr.availableHeight;
		doughnutRadius = msr.availableHeight-5;
	}else {
		midPieY = msr.topNotUsableSize + (msr.availableHeight / 2);
		doughnutRadius = msr.availableHeight/2-5;
	}
	var realAvailableWidth;
	if(q[0]==0 && q[3]==0) {
		midPieX = msr.leftNotUsableSize + msr.availableWidth-5 ;
		doughnutRadius = Math.min(doughnutRadius, msr.availableWidth -5);
		realAvailableWidth=msr.availableWidth -5
		
	} else if(q[1]==0 && q[2]==0) {
		midPieX = msr.leftNotUsableSize+5 ;
		doughnutRadius = Math.min(doughnutRadius, msr.availableWidth -5);
		realAvailableWidth=msr.availableWidth -5
	} else {
		midPieX = msr.leftNotUsableSize + (msr.availableWidth / 2);
		doughnutRadius = Math.min(doughnutRadius, (msr.availableWidth/2) -5);
		realAvailableWidth=(msr.availableWidth/2) -5
	}

	// Computerange Pie Radius
	if (isBooleanOptionTrue(undefined,config.inGraphDataShow) && setOptionValue(true,1,"INGRAPHDATARADIUSPOSITION",ctx,data,statData,undefined,config.inGraphDataRadiusPosition,"inGraphDataRadiusPosition",0,-1,{nullValue : true} ) == 3 && setOptionValue(true,1,"INGRAPHDATAALIGN",ctx,data,statData,undefined,config.inGraphDataAlign,"inGraphDataAlign",0,-1,{nullValue: true  }) == "off-center" && setOptionValue(true,1,"INGRAPHDATAROTATE",ctx,data,statData,undefined,config.inGraphDataRotate,"inGraphDataRotate",0,-1,{nullValue : true} ) == 0) {
		doughnutRadius = doughnutRadius - setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",0,-1,{nullValue : true} ) - setOptionValue(true,1,"INGRAPHDATAPADDINGRADIUS",ctx,data,statData,undefined,config.inGraphDataPaddingRadius,"inGraphDataPaddingRadius",0,-1,{nullValue: true} ) - 5;
		var posAngle;
		for (var i = 0; i < data.length; i++) {
			if (!(typeof(data[i].value) == 'undefined') && 1*data[i].value>=0) {
				ctx.font = setOptionValue(true,1,"INGRAPHDATAFONTSTYLE",ctx,data,statData,undefined,config.inGraphDataFontStyle,"inGraphDataFontStyle",i,-1,{nullValue : true} ) + ' ' + setOptionValue(true,ctx.chartTextScale,"INGRAPHDATAFONTSIZE",ctx,data,statData,undefined,config.inGraphDataFontSize,"inGraphDataFontSize",i,-1,{nullValue : true} ) + 'px ' + setOptionValue(true,1,"INGRAPHDATAFONTFAMILY",ctx,data,statData,undefined,config.inGraphDataFontFamily,"inGraphDataFontFamily",i,-1,{nullValue : true} );
				if (setOptionValue(true,1,"INGRAPHDATAANGLEPOSITION",ctx,data,statData,undefined,config.inGraphDataAnglePosition,"inGraphDataAnglePosition",i,-1,{nullValue : true} ) == 1) posAngle = realCumulativeAngle + setOptionValue(true,1,"INGRAPHDATAPADDINANGLE",ctx,data,statData,undefined,config.inGraphDataPaddingAngle,"inGraphDataPaddingAngle",i,-1,{nullValue: true  }) * (Math.PI / 180);
				else if (setOptionValue(true,1,"INGRAPHDATAANGLEPOSITION",ctx,data,statData,undefined,config.inGraphDataAnglePosition,"inGraphDataAnglePosition",i,-1,{nullValue : true} ) == 2) posAngle = realCumulativeAngle - statData[i].segmentAngle / 2 + setOptionValue(true,1,"INGRAPHDATAPADDINANGLE",ctx,data,statData,undefined,config.inGraphDataPaddingAngle,"inGraphDataPaddingAngle",i,-1,{nullValue: true  }) * (Math.PI / 180);
				else if (setOptionValue(true,1,"INGRAPHDATAANGLEPOSITION",ctx,data,statData,undefined,config.inGraphDataAnglePosition,"inGraphDataAnglePosition",i,-1,{nullValue : true} ) == 3) posAngle = realCumulativeAngle - statData[i].segmentAngle + setOptionValue(true,1,"INGRAPHDATAPADDINANGLE",ctx,data,statData,undefined,config.inGraphDataPaddingAngle,"inGraphDataPaddingAngle",i,-1,{nullValue: true  }) * (Math.PI / 180);
				realCumulativeAngle -= statData[i].segmentAngle;
				var dispString = tmplbis(setOptionValue(true,1,"INGRAPHDATATMPL",ctx,data,statData,undefined,config.inGraphDataTmpl,"inGraphDataTmpl",i,-1,{nullValue : true} ), statData[i],config);
				var textMeasurement = ctx.measureTextMultiLine(dispString).textWidth;
				var MaxRadiusX = Math.abs((realAvailableWidth - textMeasurement) / Math.cos(posAngle)) - setOptionValue(true,1,"INGRAPHDATAPADDINGRADIUS",ctx,data,statData,undefined,config.inGraphDataPaddingRadius,"inGraphDataPaddingRadius",i,-1,{nullValue: true} ) - 5;
				if (MaxRadiusX < doughnutRadius) doughnutRadius = MaxRadiusX;
			}
		}
	}
	doughnutRadius = doughnutRadius * config.radiusScale;
	return {
		radius : doughnutRadius,
		midPieX : midPieX,
		midPieY : midPieY
	};
};

$(document).foundation();
var rawDataURL = "assets/js/chart.json";

$(".product-card").hover(function() {
  	console.log("hovered")
    $(this).children("div:first").toggleClass('show');
});
$.getJSON(rawDataURL, function (json) {
	var data = prepData(json);
	var ctx = document.getElementById("myChart");
	var context = ctx.getContext('2d');
		context.rect(0, 0, ctx.width, ctx.height);

		// add linear gradient
		var grd = context.createLinearGradient(200, 0, 200,  ctx.height);
		// light blue
		grd.addColorStop(0, 'rgba(0, 0, 0, 1)');   
		// dark blue
			grd.addColorStop(0.5, 'rgba(0, 0, 0, 0.5)');  
		grd.addColorStop(1, 'rgba(244, 244, 244, 0)');

	var lineData = { 
				 
		        labels: data[0].x,

		        datasets: [{
		        	fillColor: gradientColor,
        			gradientColors : ["rgba(244, 244, 244, 0.6) 100%","rgba(244, 244, 244, 0) 0%"],
		        	strokeColor:"rgb(225, 232, 238)",
		        	borderColor: "rgb(225, 232, 238)",
		        	pointRadius : 5,
		        	pointColor: "rgb(225, 232, 238)",
		        	pointStrokeColor: 'rgba(255,255,255,1)',
		        	pointHoverRadius: 8,
		        	pointHoverBackgroundColor: "rgb(225, 232, 238)",
		        	pointHoverBorderColor: "rgba(255,255,255,1)",
		            tension:0,
	            	bezierCurve: false,	
		            data: data[0].y
		        }]
		    };
	lineData.shapesInChart=[];
		for(var i=0;i<lineData.labels.length;i++){
			console.log(lineData.datasets[0].data[1])
			lineData.shapesInChart[i]= {
					position : "INCHART",
					shape: "LINE",
					strokeStyle : "dashSpace",
					strokeColor: grd,
					animate : true,
					x1: i,
					y1: 0,
					x2: i,
					y2: Math.max(lineData.datasets[0].data[i]),
					iter : 'last'
			}
		};

	var option =  {
		canvasBorders : false,
		legend : false,
		scaleShowGridLines:false,
		scaleGridLineStyle:"dashSpace",
		scaleXGridLinesStep:1,
    	scaleYGridLinesStep:0,
    	annotateDisplay:true,
    	scaleGridLineWidth:1,
    	scaleGridLineColor:grd,
    	inGraphDataBorders:false,
    	yAxisLeft:false,
    	yAxisRight:false,
    	bezierCurve:false,
    	drawXScaleLine: [{position:"0",lineWidth:0,lineColor:"rgba(255,255,255,0"}],
    	scaleTickSizeLeft:0,
    	scaleTickSizeBottom:0,
    	showYLabels: 0,
    	scaleYGridLinesStep:0,
    	scaleLineColor:"rgba(244, 244, 244, 0)",
    	annotateBackgroundColor:"rgb(131,140,199)",
    	annotateClassName: "toolTip",
    	annotateLabel: "<%='<p>&euro;'+v3+'</p>'+'<p>Earned for '+v2+'</p>' %>",
    	endDrawScaleFunction: drawShapes
    
    };

var myChart = new Chart(context).Line(lineData,option);
})

var rng = document.getElementById("graphRange");
document.getElementById("graphContainer").scrollLeft = 800;
rng.oninput = function () {
    document.getElementById("graphContainer").scrollLeft = this.value * 16;
}


function prepData(rawData) {
	dataRefined = rawData.numbers
    var x = [];
    var y = [];
    // var text = [];

     dataRefined.forEach(function(datum, i) {
     	
        x.push(datum.month);
        y.push(datum.money);
    });
    return [{
        x: x,
        y: y
    }];
}





var tag_canvas_suffix="_Tag_Canvas";
var count_tag_canvas=0;
var first_tag="not_yet_defined";
var current_tag="not_yet_defined";
var tag_canvas_list=[];
var tag_def_height=400;
var tag_def_width=800;
var tag_animation_only_at_first_display=false;

function setCanvas(tpgraph,data,options,height,width) { 
	var setheight,setwidth;
	if(typeof height=="undefined")setheight=tag_def_height;
	else setheight=height;
	if(typeof width=="undefined")setwidth=tag_def_width;
	else setwidth=width;
	
	var divs = document.getElementsByTagName('div');
	if(first_tag=="not_yet_defined") { first_tag=divs[divs.length-1].id; current_tag=first_tag; }
	if(typeof tag_canvas_list[divs[divs.length-1].id]=="undefined") tag_canvas_list[divs[divs.length-1].id] = [];
	var cnvcnt=tag_canvas_list[divs[divs.length-1].id].length;
	document.write("<canvas id=\""+divs[divs.length-1].id+tag_canvas_suffix+"_"+cnvcnt+"\" height=\""+setheight+"\" width=\""+setwidth+"\"></canvas>");
	tag_canvas_list[divs[divs.length-1].id][tag_canvas_list[divs[divs.length-1].id].length]={ firstDisplay: true, width:setwidth, height: setheight, tpgraph:tpgraph,data:data,options:options, runAnimation:true };
        document.getElementById(divs[divs.length-1].id+tag_canvas_suffix+"_"+cnvcnt).getContext("2d").original_height=setheight;
        document.getElementById(divs[divs.length-1].id+tag_canvas_suffix+"_"+cnvcnt).getContext("2d").original_width=setwidth;
	if(divs[divs.length-1].id==first_tag){
		console.log("Display Canvas: "+divs[divs.length-1].id+tag_canvas_suffix+"_"+cnvcnt);
		tab_disp_canvas(divs[divs.length-1].id+tag_canvas_suffix+"_"+cnvcnt,tpgraph,data,options,true,setwidth,setheight,true);
		if(tag_animation_only_at_first_display==true)tag_canvas_list[divs[divs.length-1].id][tag_canvas_list[divs[divs.length-1].id].length-1]["runAnimation"]=false;
		tag_canvas_list[divs[divs.length-1].id][tag_canvas_list[divs[divs.length-1].id].length-1]["firstDisplay"]=false;	
	}
};


function tab_disp_graph(tab){
	if(typeof tag_canvas_list[tab]!="undefined") {
		for(var i=0;i<tag_canvas_list[tab].length;i++) {
			tab_disp_canvas(tab+tag_canvas_suffix+"_"+i,tag_canvas_list[tab][i]["tpgraph"],tag_canvas_list[tab][i]["data"],tag_canvas_list[tab][i]["options"],tag_canvas_list[tab][i]["runAnimation"],tag_canvas_list[tab][i]["width"],tag_canvas_list[tab][i]["height"],tag_canvas_list[tab][i]["firstDisplay"]);
			if(tag_animation_only_at_first_display==true)tag_canvas_list[tab][i]["runAnimation"]=false;
			tag_canvas_list[tab][i]["firstDisplay"]=false;			
		}
	}
};

function tab_disp_canvas(canvas,tpgraph,data,options,runAnimation,setWidth,setHeight,firstDisp){

	if(!runAnimation){
		bootStrapChartJsResize(document.getElementById(canvas).getContext("2d"),data,options);
		return(false);
	}

	if(!firstDisp) {
//		bootStrapChartJsResize(document.getElementById(canvas).getContext("2d"),data,options);
//		document.getElementById(canvas).getContext("2d").firstPass=9;
//		bootStrapChartJsResize(document.getElementById(canvas).getContext("2d"),data,options);
//		document.getElementById(canvas).getContext("2d").stroke();
//		document.getElementById(canvas).getContext("2d").clearRect(0, 0, document.getElementById(canvas).getContext("2d").canvas.width, document.getElementById(canvas).getContext("2d").canvas.height);
//		document.getElementById(canvas).getContext("2d").stroke();
//		document.getElementById(canvas).getContext("2d").firstPass=9;
//		updateChart(document.getElementById(canvas).getContext("2d"),data,options,true,true);
		document.getElementById(canvas).getContext("2d").firstPass=undefined;
		eval("var chart = new Chart(document.getElementById(canvas).getContext(\"2d\"))."+tpgraph+"(data,options);"); 
	}
	else {
		eval("var chart = new Chart(document.getElementById(canvas).getContext(\"2d\"))."+tpgraph+"(data,options);"); 
	}
};

function setRefreshCanvas() {
$('a[data-toggle=tab]').on('shown.bs.tab', function (e) {
var vl_target=e.target+"";
vl_target=vl_target.split("#").pop();	
current_tag=vl_target;
tab_disp_graph(vl_target);
});
};

function bootStrapChartJsResize(ctx,data,options) {
	ctx.firstPass=9;
	updateChart(ctx,data,options,false,false);
};




var drillDownBackData=[];
var drillDownBackConfig=[];

var posDrillDownBackData=0;

function chartDrillUp(event,ctx,config,data,other)
{
	if(posDrillDownBackData>0) {
		posDrillDownBackData--;
//          	ctx.fistPass=undefined;
//		eval("var newchart=new Chart(document.getElementById(\"canvas_bar\").getContext(\"2d\"))."+ctx.tpchart+"(drillDownBackData[posDrillDownBackData],drillDownBackConfig[posDrillDownBackData]);");
		deleteHighLight(ctx,drillDownBackData[posDrillDownBackData]);
		updateChart(ctx,drillDownBackData[posDrillDownBackData],drillDownBackConfig[posDrillDownBackData],false,false);
	}
}

function chartDrillDown(event,ctx,config,data,other)
{
  if(other != null) {
  	if(data.datasets[other.i].drillDownData != null) {
  		if(data.datasets[other.i].drillDownData[other.j] != null) {
  			var vconfig=config;
	  		if(data.datasets[other.i].drillDownConfig != null)if(data.datasets[other.i].drillDownConfig[other.j] != null)vconfig=data.datasets[other.i].drillDownConfig[other.j];
	          	drillDownBackConfig[posDrillDownBackData]=config;
	          	drillDownBackData[posDrillDownBackData++]=data;
//	          	ctx.fistPass=undefined;
//			eval("var newchart=new Chart(document.getElementById(\"canvas_bar\").getContext(\"2d\"))."+ctx.tpchart+"(data.datasets[other.i].drillDownData[other.j],vconfig);");
			deleteHighLight(ctx,data.datasets[other.i].drillDownData[other.j]);
			updateChart(ctx,data.datasets[other.i].drillDownData[other.j],vconfig,false,false);
		}
	}
  } else if(config.drillOutsideUp){
	if(posDrillDownBackData>0) {
		posDrillDownBackData--;
//          	ctx.fistPass=undefined;
//		eval("var newchart=new Chart(document.getElementById(\"canvas_bar\").getContext(\"2d\"))."+ctx.tpchart+"(drillDownBackData[posDrillDownBackData],drillDownBackConfig[posDrillDownBackData]);");
		deleteHighLight(ctx,drillDownBackData[posDrillDownBackData]);
		updateChart(ctx,drillDownBackData[posDrillDownBackData],drillDownBackConfig[posDrillDownBackData],false,false);
	}
  }
}

//
// Additional formats for ChartNew.js
//
// see https://github.com/FVANCOP/ChartNew.js/wiki/900_010_format.js
//
function fmtChartJSPerso(config, value, fmt) {
	var return_value, spltdt; 
	switch (fmt.split(/[\s,]+/)[0].toUpperCase()) {
		case "FIXEDDECIMAL":
		case "DECIMAL":
			var spltdt = Math.round(fmt.split(/[\s,]+/)[1]);
			var roundVal;
			if (spltdt <= 0) {
				roundVal = -spltdt;
				return_value = +(Math.round(value + "e+" + roundVal) + "e-" + roundVal);
				// Force number of decimals;
				if(fmt.split(/[\s,]+/)[0].toUpperCase()=="FIXEDDECIMAL") return_value=return_value.toFixed(Math.abs(spltdt));
			} else {
				roundVal = spltdt;
				var divval = "1e+" + roundVal;
				return_value = +(Math.round(value / divval)) * divval;
			}
			if (config.decimalSeparator != "." || config.thousandSeparator != "") {
				return_value = value.toString().replace(/\./g, config.decimalSeparator);
				if (config.thousandSeparator != "") {
					var part1 = return_value;
					var part2 = "";
					var posdec = part1.indexOf(config.decimalSeparator);
					if (posdec >= 0) {
						part2 = part1.substring(posdec + 1, part1.length);
						part2 = part2.split('').reverse().join(''); // reverse string
						part1 = part1.substring(0, posdec);
					}
					part1 = part1.toString().replace(/\B(?=(\d{3})+(?!\d))/g, config.thousandSeparator);
					part2 = part2.split('').reverse().join(''); // reverse string
					return_value = part1
					if (part2 != "") return_value = return_value + config.decimalSeparator + part2;
				}
			}
			break;
		case "ABBREVIATENUMBER":
			return_value = value;
			if (typeof(value) == "number") {
				return_value = abbreviateNumber(value);
			}
			break;
		case "DATE":
			spltdt = fmt.replace(/,/g, " ").replace(/:/g, " ").split(/[\s,]+/);
			var options = new Array();
			for (var i = 1; i < spltdt.length; i++) {
				switch (spltdt[i].toUpperCase()) {
					case "WEEKDAY":
					case "YEAR":
					case "MONTH":
					case "DAY":
						options[spltdt[i]] = spltdt[i + 1];
						break;
					default:
						break;
				}
			}
			return_value = value.toLocaleDateString(fmt.split(" ")[1], options);
			break;
		case "FMTDATE":
			spltdt = fmt.split(/[\s,]+/)[1].toUpperCase();
			return_value = spltdt.replaceArray(["DD", "MM", "YYYY", "YY"], [value.getDate(), 1 + value.getMonth(), value.getFullYear(), value.getYear() % 100]);
			break;
		case "TIME":
			return_value = value.toLocaleTimeString();
			break;
		case "FMTTIME":
			spltdt = fmt.split(/[\s,]+/)[1].toUpperCase();
			return_value = spltdt.replaceArray(["HH", "MM", "SS"], [
				value.getHours() < 10 ? '0' + value.getHours() : value.getHours(),
				value.getMinutes() < 10 ? '0' + value.getMinutes() : value.getMinutes(),
				value.getSeconds() < 10 ? '0' + value.getSeconds() : value.getSeconds()
			]);
			break;
		case "FMTDATETIME":
			spltdt = fmt.splitLimit(/[\s,]+/, 2)[1];
			return_value = spltdt.replaceArray(["DD", "MM", "YYYY", "YY", "HH", "mm", "ss"], [
				value.getDate(), 1 + value.getMonth(), value.getFullYear(), value.getYear() % 100,
				value.getHours() < 10 ? '0' + value.getHours() : value.getHours(),
				value.getMinutes() < 10 ? '0' + value.getMinutes() : value.getMinutes(),
				value.getSeconds() < 10 ? '0' + value.getSeconds() : value.getSeconds()
			]);
			break;
		default:
			return_value = value;
			break;
	}
	return (return_value);
}

function abbreviateNumber(num) {
	var suffixes = ["", "k", "m", "b","t"];
	var sign = num > 0 ? 1 : -1;
	if (num < 1000 && num > -1000 ) return num;
	var i = parseInt(Math.floor(Math.log(Math.abs(num)) / Math.log(1000)));
	return ((i % 1 == 0 ) ? (num / Math.pow(1000, i)) : (num / Math.pow(1000, i)).toFixed(1)) + '' + suffixes[i];
};

String.prototype.replaceArray = function(find, replace) {
	var replaceString = this;
	var regex;
	for (var i = 0; i < find.length; i++) {
		regex = new RegExp(find[i], "g");
		replaceString = replaceString.replace(regex, replace[i]);
	}
	return replaceString;
};
/**
 * split a string into an array with limit entries
 * The last entry contains the last part of the string, which can contain the separator)
 * @param separator {string} string separator
 * @param limit {integer} number of entries in the array
 * @return array of separated strings
 */
String.prototype.splitLimit = function(separator, limit) {
	var splitString = this;
	var result = [];
	var pos = splitString.search(separator);
	if (pos < 0) return false;
	result.push(splitString.substring(0, pos));
	result.push(splitString.substring(pos + 1));
	return result;
}

//
// See ../Samples/issue_102.html
//
// Module intially written by Ole Kroger
// Change 1 : Omar Sedki - possibility to specify a percentage 
// Change 2 : Vancoppenolle Franois - generalized for all graph types
//


function gradientColor(area,ctx,data,statData,posi,posj,othervars) {
	// v0 = left xAxis of rectangle or xAxis of center
	// v1 = top yAxis of rectangle or yAxis of center
	// v2 = right xAxis of rectangle or internal radius (=0 for PolarArea, Pie and Radar)
	// v3 = bottom yAxis or rectangle or external radius
	var grd, gradientColors;
	if (area=="SHAPESINCHART_RECT") {
		grd = ctx.createLinearGradient(othervars.xPosLeft, othervars.yPosBottom, othervars.xPosLeft, othervars.yPosTop);
		gradientColors = othervars.gradientColors;
	}else if (area=="SHAPESINCHART_ELLIPSE" || area=="SHAPESINCHART_REGULARSHAPE" || area=="SHAPESINCHART_CIRCLE") {
		grd = ctx.createRadialGradient(othervars.midPosX, othervars.midPosY, 0, othervars.midPosX, othervars.midPosY , othervars.radius);
		gradientColors = othervars.gradientColors;
	}
	else {
		switch(ctx.tpchart) {
			case "Radar" :
				if (area == "COLOR") {
					grd = ctx.createRadialGradient(othervars.midPosX, othervars.midPosY, 0, othervars.midPosX, othervars.midPosY , othervars.ext_radius);
				} else {
					grd = ctx.createRadialGradient(othervars.xPosLeft + (othervars.xPosRight - othervars.xPosLeft) / 2, othervars.yPosBottom + (othervars.yPosTop - othervars.yPosBottom) / 2, 0, othervars.xPosLeft + (othervars.xPosRight - othervars.xPosLeft) / 2, othervars.yPosBottom + (othervars.yPosTop - othervars.yPosBottom) / 2, Math.max((othervars.xPosRight - othervars.xPosLeft) / 2, (othervars.yPosTop - othervars.yPosBottom) / 2));
				}
				gradientColors = data.datasets[posi].gradientColors;
				break;
			case "PolarArea" :
			case "Pie" : 
			case "Doughnut" :
				if (area == "COLOR") {
					grd = ctx.createRadialGradient(statData[0].midPosX, statData[0].midPosY, othervars.scaleAnimation*statData[0].int_radius, statData[0].midPosX, statData[0].midPosY , othervars.scaleAnimation* statData[0].radiusOffset);
				} else {
					grd = ctx.createRadialGradient(othervars.xPosLeft + (othervars.xPosRight - othervars.xPosLeft) / 2, othervars.yPosBottom + (othervars.yPosTop - othervars.yPosBottom) / 2, 0, othervars.xPosLeft + (othervars.xPosRight - othervars.xPosLeft) / 2, othervars.yPosBottom + (othervars.yPosTop - othervars.yPosBottom) / 2, Math.max((othervars.xPosRight - othervars.xPosLeft) / 2, (othervars.yPosTop - othervars.yPosBottom) / 2));
				}
				gradientColors = data[posi].gradientColors;
				break;
			case "Line" :
			case "Bar" :
			case "StackedBar" :
				grd = ctx.createLinearGradient(othervars.xPosLeft, othervars.yPosBottom, othervars.xPosLeft, othervars.yPosTop);
				gradientColors = data.datasets[posi].gradientColors;
				break;
			case "HorizontalBar" :
			case "HorizontalStackedBar" :
				grd = ctx.createLinearGradient(othervars.xPosLeft, othervars.yPosBottom, othervars.xPosRight, othervars.yPosBottom);
				gradientColors = data.datasets[posi].gradientColors;
				break;
			default : 
				break;
		
		}
	}
	var steps = gradientColors.length;
	var currentStepValue = 0;
	var stepValues = [];
	var PERCENT_REGEX = /(\d{1,2}|100)%\s*?$/g
	for (var iter = 0; iter < steps; iter++) {
		var userStepValue = gradientColors[iter].match(PERCENT_REGEX);
		if (!userStepValue) {
			stepValues[iter] = false;
			continue;
		}
		userStepValue = parseFloat(userStepValue) / 100.0;
		stepValues[iter] = userStepValue;
	}
	for (var iter = 0; iter < steps; iter++) {
		if (stepValues[iter] === false) {
			if (iter == 0) {
				stepValues[iter] = 0;
			} else if (iter == steps - 1) {
				stepValues[iter] = 1;
			} else {
				// found next stepValue which isn't false
				var s = iter + 1;
				while (s < steps - 1 && stepValues[s] === false) {
					s++;
				}
				var lastStep = ((iter == 0) ? 0 : stepValues[iter - 1]);
				stepValues[iter] = ((s >= steps - 1) ? 1 : stepValues[s + 1]) - lastStep;
				stepValues[iter] = lastStep + stepValues[iter] / (s - iter + 1);
			}
		}
		GradientcolorsWithoutStep = gradientColors[iter].replace(PERCENT_REGEX, "").trim();
		grd.addColorStop(stepValues[iter], GradientcolorsWithoutStep);
	}
	return grd;
}

// JavaScript Document

function addHatch(data,param) {

	// check conditions;
	
	if(data.datasets.length !=2) return;
	// find xBegin and xEnd values;
	if(typeof data.xBegin == "undefined") data.xBegin=1 * data.labels[0];
	if(typeof data.xEnd == "undefined") data.xEnd=1 * data.labels[data.labels.length - 1];
	if(typeof data.xBegin != "number" || isNaN(data.xBegin))data.xBegin=0;
	if (data.xEnd <= data.xBegin || isNaN(data.xEnd)) data.xEnd = data.xBegin + 100;
	var mouseDetection;
	if (typeof param.mouseDetection != "undefined" ){
		mouseDetection=param.mouseDetection;
	} else if (typeof param.annotateDisplay != "undefined") {
		mouseDetection=param.annotateDisplay;
	} else mouseDetection=false;
	


	nb_hatch_lines= (typeof param.nb_hatch_lines != "undefined" ? param.nb_hatch_lines : 100)
	data.datasets[2] ={
      			data : [],
      			xPos : [],
			origin : [],
      			linkType : 1,
      			mouseDetection : mouseDetection,
      			animation : (typeof param.animation != "undefined" ? param.animation : true),
      			inGraphDataShow: (typeof param.positive_inGraphDataShow != "undefined" ? param.positive_inGraphDataShow : false),
      			annotateDisplay : (typeof param.positive_annotateDisplay != "undefined" ? param.positive_annotateDisplay : false),
      			title : (typeof param.positive_title != "undefined" ? param.positive_title : ""),
			strokeColor : (typeof param.positive_strokeColor != "undefined" ? param.positive_strokeColor : "red"),
			datasetStrokeWidth : (typeof param.positive_datasetStrokeWidth != "undefined" ? param.positive_datasetStrokeWidth : 2),
			datasetStrokeStyle : (typeof param.positive_datasetStrokeStyle != "undefined" ? param.positive_datasetStrokeStyle : "solid"),
			pointColor : (typeof param.positive_pointColor != "undefined" ? param.positive_pointColor : "rgba(0,0,0,0)"),
        		pointStrokeColor : (typeof param.positive_pointStrokeColor != "undefined" ? param.positive_pointStrokeColor : "rgba(0,0,0,0)")    			
	};

	data.datasets[3] ={
      			data : [],
      			xPos : [],
			origin : [],
      			linkType : 1,
      			highLight : false,
      			mouseDetection : mouseDetection,
      			animation : (typeof param.animation != "undefined" ? param.animation : true),
      			inGraphDataShow: (typeof param.negative_inGraphDataShow != "undefined" ? param.negative_inGraphDataShow : false),
      			annotateDisplay : (typeof param.negative_annotateDisplay != "undefined" ? param.negative_annotateDisplay : false),
      			title : (typeof param.negative_title != "undefined" ? param.negative_title : ""),
			strokeColor : (typeof param.negative_strokeColor != "undefined" ? param.negative_strokeColor : "blue"),
			datasetStrokeWidth : (typeof param.negative_datasetStrokeWidth != "undefined" ? param.negative_datasetStrokeWidth : 2),
			datasetStrokeStyle : (typeof param.negative_datasetStrokeStyle != "undefined" ? param.negative_datasetStrokeStyle : "solid"),
			pointColor : (typeof param.negative_pointColor != "undefined" ? param.negative_pointColor : "rgba(0,0,0,0)"),
        		pointStrokeColor : (typeof param.negative_pointStrokeColor != "undefined" ? param.negative_pointStrokeColor : "rgba(0,0,0,0)")    			
	};
	
	var v1,v2,vpos;	        	
	var cntp=0,cntn=0;
	for(var i=0;i<nb_hatch_lines;i++) {
		vpos=data.xBegin+i*(data.xEnd-data.xBegin)/(nb_hatch_lines-1);
		v1=setDataVal(vpos,0,data);		
		v2=setDataVal(vpos,1,data);		
		
		if(v1>v2) {
			data.datasets[2].xPos[cntp]=vpos;
			data.datasets[2].origin[cntp]=v1;		
			data.datasets[2].data[cntp]=v2;
			cntp++;		
		} else {
			data.datasets[3].xPos[cntn]=vpos;
			data.datasets[3].origin[cntn]=v1;		
			data.datasets[3].data[cntn]=v2;		
			cntn++;
		}
	}
	
	
	var tmpdata=data.datasets[0];
	data.datasets[0]=data.datasets[1];
	data.datasets[1]=data.datasets[2];
	data.datasets[2]=data.datasets[3];
	data.datasets[3]=tmpdata;
	tmpdata=data.datasets[0];
	data.datasets[0]=data.datasets[1];
	data.datasets[1]=data.datasets[2];
	data.datasets[2]=data.datasets[3];
	data.datasets[3]=tmpdata;
	
	if(data.datasets[1].xPos.length==0) {
		data.datasets[1]=data.datasets[2];
		data.datasets[2]=data.datasets[3];
		data.datasets.pop();
	}	
	if(data.datasets[0].xPos.length==0) {
		data.datasets[0]=data.datasets[1];
		data.datasets[1]=data.datasets[2];
		if(data.datasets.length==4)data.datasets[2]=data.datasets[3];
		data.datasets.pop();
	}	


	function setDataVal(xpos,i,data) {
		var pt0x, pt1x, pt0y, pt1y,rtval;
		if(xpos<data.xBegin) return null;
		if(xpos>data.xEnd) return null;
		if(Math.abs(xpos-data.xBegin)<0.0001)return data.datasets[i].data[0];

		if(typeof data.datasets[i].xPos=="undefined") {
			if(xpos==data.xBegin)return data.datasets[i].data[0];
			var curpos=(xpos-data.xBegin)/((data.xEnd-data.xBegin)/(data.labels.length-1));
			if(Math.abs(curpos-Math.round(curpos))<0.0001) return data.datasets[i].data[Math.round(curpos)];
			else {
				pt0x=data.xBegin+Math.floor(curpos)*((data.xEnd-data.xBegin)/(data.labels.length-1));
				pt1x=data.xBegin+Math.ceil(curpos)*((data.xEnd-data.xBegin)/(data.labels.length-1));
				pt0y=data.datasets[i].data[Math.floor(curpos)];
				pt1y=data.datasets[i].data[Math.ceil(curpos)];
			}
		} else {
		        var j=data.datasets[i].xPos.length-1;
			while(j>=0 && typeof pt0x=="undefined") {
				if(typeof (1*data.datasets[i].xPos[j])=="number" && typeof (1*data.datasets[i].data[j])=="number" && typeof pt0x == "undefined") {

					if(Math.abs(xpos-1*data.datasets[i].xPos[j])<0.0001) return data.datasets[i].data[j];
					if(xpos>=1*data.datasets[i].xPos[j]) {
						pt0x=1*data.datasets[i].xPos[j];
						pt0y=1*data.datasets[i].data[j];
					}
				}
				j--;
			}
			if(typeof pt0x != "undefined") {
				j++;
				while(j<data.datasets[i].xPos.length && typeof pt1x=="undefined") {
					if(typeof (1*data.datasets[i].xPos[j])=="number" && typeof (1*data.datasets[i].data[j])=="number" && typeof pt1x == "undefined") {
						if(xpos<1*data.datasets[i].xPos[j]) {
							pt1x=1*data.datasets[i].xPos[j];
							pt1y=1*data.datasets[i].data[j];
						}
					}
					j++;
				}
			}						
		}

		if(typeof pt0x != "undefined" && typeof pt1x != "undefined") {
			var a=(pt0y-pt1y)/(pt0x-pt1x);
			var b=pt0y-a*pt0x;
			rtval=a*xpos+b;
		}
		return rtval;
	}	

	

	
};

// JavaScript Document

var drawShape_default= {
	position : "INCHART",
	shape : "CIRCLE",
	radius : 10, 
	ellipseHeight : 20,
	ellipseWidth : 40,
	sideCount : 4,
	lineCount : 3,
	x1:0,
	x2:0,
	x3:0,
	x4:0,
	x5:0,
	x6:0,
	x7:0,
	x8:0,
	x9:0,
	x10:0,
	y1:0,
	y2:0,
	y3:0,
	y4:0,
	y5:0,
	y6:0,
	y7:0,
	y8:0,
	y9:0,
	y10:0,
	strokeStyle: "solid",
	strokeSize:2, 
	strokeColor : "black", 
	fillColor: "blue",
	startAngle : 0, 
	endAngle : 360, 
	limitToChart : true,
	paddingX1: 0,
	paddingY1: 0,
	paddingX2: 0,
	paddingY2: 0,
	paddingX3: 0,
	paddingY3: 0,
	paddingX4: 0,
	paddingY4: 0,
       	paddingX5: 0,
	paddingY5: 0,
	paddingX6: 0,
	paddingY6: 0,
	paddingX7: 0,
	paddingY7: 0,
	paddingX8: 0,
	paddingY8: 0,
	paddingX9: 0,
	paddingY9: 0,
	paddingX10: 0,
	paddingY10: 0,

	when : "always",    // "initFunction", "enddatafunction", "endscalefunction" or "always"
	iter : "all",        // "first", "last", "all" or a number
	animate : false,
	arrowWidth : 15,
	arrowHeight : 20,
	arrowTop : true,
	arrowBottom : false,
	text : "Your Text",
	rotate : 0,
	textAlign : "center",
	textBaseline : "middle",
	imagesrc : "",
	imageAlign : "center",
	imageBaseline : "middle",
	fontColor : "rgba(220,220,220,1)", 
	fontStyle : "normal",
	fontSize : 12,
	fontFamily : "'Arial'",
	textBorders : false,
	textBordersColor : "black",
	textBordersWidth : 1,
	textBordersXSpace : 3,
	textBordersYSpace : 3,
	textBordersStyle : "solid",
	textBackgroundColor : "none"
};

function shapeLoadImages(data) {
	var shape,shapesInChart;


	if(typeof data.shapesInChart == "object") shapesInChart=data.shapesInChart;
	if(typeof data[0]=="object") if (typeof data[0].shapesInChart == "object") shapesInChart=data[0].shapesInChart;
	
	if(typeof shapesInChart == "object") {
		//      preload all images first;
		for(var i=0;i<shapesInChart.length;i++) {
			if(typeof shapesInChart[i].shape == "string")shape=shapesInChart[i].shape.toUpperCase()
			else shape= drawShape_default.shape.toUpperCase();
			if (shape=="IMAGE"){
				if(typeof shapesInChart[i].loadImage == "undefined") {
					shapesInChart[i].loadImage=new Image();
					var imagesrc = drawShapeSetValue(shapesInChart[i].imagesrc,drawShape_default.imagesrc);
					if (imagesrc=="") shapesInChart[i].loadImage.src='data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw==';
					else shapesInChart[i].loadImage.src=imagesrc;
				}
			}

		}	
	}
	function drawShapeSetValue(dataval,defval) {
		if(typeof dataval != "undefined") return dataval;
		else return defval;
	};	

}


function drawShapes(area, ctx, data,statData, posi,posj,othervars){
	var shape,whendrw,iter,realAnimation,shapesInChart;

	if(typeof data.shapesInChart == "object") var shapesInChart=data.shapesInChart;
	if(typeof data[0]=="object") if (typeof data[0].shapesInChart == "object") var shapesInChart=data[0].shapesInChart;

	
	if(typeof shapesInChart == "object") {

		//      preload all images first;
		shapeLoadImages(data);
	
		for(var i=0;i<shapesInChart.length;i++) {

			if(area=="HIGHLIGHT") {
				if(shapesInChart[i].hightLight != true)continue;
			} else {		
				if(typeof othervars.config.dispShapesInChart == "object") {
					if (othervars.config.dispShapesInChart.indexOf(i)<0) continue;
				} else if (typeof othervars.config.dispShapesInChart != "undefined") {
					if (typeof othervars.config.dispShapesInChart == false)continue;
				}

				whendrw=drawShapeSetValue(shapesInChart[i].when,drawShape_default.when).toUpperCase();
				if (whendrw != "ALWAYS" && whendrw != area) { continue;}
				iter=drawShapeSetValue(shapesInChart[i].iter,drawShape_default.iter.toUpperCase());
				if (typeof iter=="number" && iter != othervars.cntiter && othervars.config.animation==true) {continue;}
				if (iter==="first" && othervars.cntiter != 1 && othervars.config.animation==true) {continue;}
//				if (iter==="last" && othervars.cntiter != othervars.config.animationSteps && othervars.config.animation==true) {continue;}
				if (iter==="last" && othervars.animationValue < 1 && othervars.config.animation==true) {continue;}
			}

			if(typeof shapesInChart[i].shape == "function")shape= shapesInChart[i].shape;
			else if(typeof shapesInChart[i].shape != "string")shape= drawShape_default.shape.toUpperCase();
			else shape=shapesInChart[i].shape.toUpperCase();

			if(othervars.config.animation && drawShapeSetValue(shapesInChart[i].animate,drawShape_default.animate)) realAnimation=othervars.animationValue;
			else realAnimation=1;
			ctx.save();
			switch(shape) {
				case "LINE" :
					var vright, vleft, vtop, vbottom, tmp;
					vright= 1*drawShapeSetValue(shapesInChart[i].x2,drawShape_default.x2);
					vleft= 1*drawShapeSetValue(shapesInChart[i].x1,drawShape_default.x1);
					vtop= 1*drawShapeSetValue(shapesInChart[i].y2,drawShape_default.y2);
					vbottom= 1*drawShapeSetValue(shapesInChart[i].y1,drawShape_default.y1);
					if (vright<vleft){
						tmp=vright;vright=vleft;vleft=tmp;
						tmp=vtop;vtop=vbottom;vbottom=tmp;
					}
  
					ctx.beginPath();
					var xypos1=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,vright,vtop,1*drawShapeSetValue(shapesInChart[i].paddingX1,drawShape_default.paddingX1),1*drawShapeSetValue(shapesInChart[i].paddingY1,drawShape_default.paddingY1),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
					var xypos2=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,vleft,vbottom,1*drawShapeSetValue(shapesInChart[i].paddingX2,drawShape_default.paddingX2),1*drawShapeSetValue(shapesInChart[i].paddingY2,drawShape_default.paddingY2),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
					if(Math.abs(xypos1.xpos-xypos2.xpos) < othervars.config.zeroValue) { // vertical line;
						vright=xypos1.xpos;
						vleft=xypos2.xpos;
						vbottom=xypos1.ypos + (1-realAnimation)*(xypos2.ypos-xypos1.ypos)/2;
						vtop=xypos2.ypos - (1-realAnimation)*(xypos2.ypos-xypos1.ypos)/2 ;
					} else { // non vertical line;
						// compute line function;
						var a=(xypos1.ypos-xypos2.ypos)/(xypos1.xpos-xypos2.xpos);
						var b=xypos1.ypos-a*xypos1.xpos;
						vright=xypos2.xpos - (1-realAnimation)*(xypos2.xpos-xypos1.xpos)/2;
						vleft =xypos1.xpos + (1-realAnimation)*(xypos2.xpos-xypos1.xpos)/2;
						vtop=a*vright+b;
						vbottom=a*vleft+b;
					}
					ctx.moveTo(vright, vtop);
					ctx.lineTo(vleft, vbottom);
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*drawShapeSetValue(shapesInChart[i].strokeSize,drawShape_default.strokeSize));
					ctx.strokeStyle = drawShapeSetValue(shapesInChart[i].strokeColor,drawShape_default.strokeColor);
					ctx.setLineDash(lineStyleFn(drawShapeSetValue(shapesInChart[i].strokeStyle,drawShape_default.strokeStyle)));	
					ctx.stroke();
					ctx.setLineDash([]);
					break;
				case "ARROW" :
					var vright, vleft, vtop, vbottom, tmp;
					var arrowtx1,arrowtx2,arrowty1,arrowty2;
					var arrowbx1,arrowbx2,arrowby1,arrowby2;
					vright= 1*drawShapeSetValue(shapesInChart[i].x1,drawShape_default.x1);
					vleft= 1*drawShapeSetValue(shapesInChart[i].x2,drawShape_default.x2);
					vtop= 1*drawShapeSetValue(shapesInChart[i].y1,drawShape_default.y1);
					vbottom= 1*drawShapeSetValue(shapesInChart[i].y2,drawShape_default.y2);

					ctx.beginPath();
					var xypos1=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,vright,vtop,1*drawShapeSetValue(shapesInChart[i].paddingX1,drawShape_default.paddingX1),1*drawShapeSetValue(shapesInChart[i].paddingY1,drawShape_default.paddingY1),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
					var xypos2=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,vleft,vbottom,1*drawShapeSetValue(shapesInChart[i].paddingX2,drawShape_default.paddingX2),1*drawShapeSetValue(shapesInChart[i].paddingY2,drawShape_default.paddingY2),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
					var arrowWidth=realAnimation*1*drawShapeSetValue(shapesInChart[i].arrowWidth,drawShape_default.arrowWidth) ;
					var arrowHeight=realAnimation*1*drawShapeSetValue(shapesInChart[i].arrowHeight,drawShape_default.arrowHeight);

					if(Math.abs(xypos1.xpos-xypos2.xpos) < othervars.config.zeroValue) { // vertical line;
						vright=xypos1.xpos;
						vleft=xypos2.xpos;
						vbottom=xypos1.ypos ;
						vtop=xypos2.ypos - (1-realAnimation)*(xypos2.ypos-xypos1.ypos);
						if(vbottom>vtop)fact=1;else fact=-1;
						arrowby1=vbottom-fact*arrowHeight;
						arrowby2=arrowby1;
						arrowty1=vtop+fact*arrowHeight;
						arrowty2=arrowty1;
						arrowbx1=vright-arrowWidth/2;
						arrowbx2=vright+arrowWidth/2;
						arrowtx1=arrowbx1;
						arrowtx2=arrowbx2;
					} else { // non vertical line;
						// compute line function;
						var a=(xypos1.ypos-xypos2.ypos)/(xypos1.xpos-xypos2.xpos);
						var b=xypos1.ypos-a*xypos1.xpos;
						vright=xypos2.xpos - (1-realAnimation)*(xypos2.xpos-xypos1.xpos);
						vleft =xypos1.xpos ;
						vtop=a*vright+b;
						vbottom=a*vleft+b;
						if(Math.abs(vtop-vbottom) < othervars.config.zeroValue) { // Horizontal Arrow;
							var fact;
							if(vleft<vright)fact=1;else fact=-1;
							arrowby1=vbottom-arrowWidth/2;
							arrowby2=vbottom+arrowWidth/2;
							arrowbx1=vleft+fact*arrowHeight;
							arrowbx2=arrowbx1;
							arrowty1=arrowby1;
							arrowty2=arrowby2;
							arrowtx1=vright-fact*arrowHeight;
							arrowtx2=arrowtx1;
						
						} else {
							var fact;
							if(vleft<vright)fact=1;else fact=-1;
							var crossptx=vleft+fact*arrowHeight*Math.cos(Math.atan(a));
							var crosspty=a*crossptx+b;
							var bprim=crosspty+(1/a)*crossptx;
							arrowbx1=crossptx-(arrowWidth/2)*(Math.cos(Math.atan(-1/a)));
							arrowbx2=crossptx+(arrowWidth/2)*(Math.cos(Math.atan(-1/a)));
							arrowby1=(-1/a)*arrowbx1+bprim;
							arrowby2=(-1/a)*arrowbx2+bprim;
							crossptx=vright-fact*arrowHeight*Math.cos(Math.atan(a));
							crosspty=a*crossptx+b;
							bprim=crosspty+(1/a)*crossptx;
							arrowtx1=crossptx-(arrowWidth/2)*(Math.cos(Math.atan(-1/a)));
							arrowtx2=crossptx+(arrowWidth/2)*(Math.cos(Math.atan(-1/a)));
							arrowty1=(-1/a)*arrowtx1+bprim;
							arrowty2=(-1/a)*arrowtx2+bprim;
							
						}
						var crossptx=vleft+arrowHeight*Math.cos(Math.atan(a));
						var crosspty=a*crossptx+b;
						var bprim=crosspty+(1/a)
						
					}
					ctx.moveTo(vright, vtop);
					ctx.lineTo(vleft, vbottom);
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*drawShapeSetValue(shapesInChart[i].strokeSize,drawShape_default.strokeSize));
					ctx.strokeStyle = drawShapeSetValue(shapesInChart[i].strokeColor,drawShape_default.strokeColor);
					ctx.setLineDash(lineStyleFn(drawShapeSetValue(shapesInChart[i].strokeStyle,drawShape_default.strokeStyle)));	
					ctx.stroke();
					
					ctx.restore();
					ctx.strokeStyle = drawShapeSetValue(shapesInChart[i].strokeColor,drawShape_default.strokeColor);
					ctx.setLineDash(lineStyleFn(drawShapeSetValue(shapesInChart[i].strokeStyle,drawShape_default.strokeStyle)));	
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*drawShapeSetValue(shapesInChart[i].strokeSize,drawShape_default.strokeSize));
					ctx.setLineDash([]);

					if(drawShapeSetValue(shapesInChart[i].arrowTop,drawShape_default.arrowTop)) {
						ctx.moveTo(vright, vtop);
						ctx.lineTo(arrowtx1, arrowty1);
						ctx.lineTo(arrowtx2, arrowty2);
						ctx.lineTo(vright,vtop);
						ctx.stroke();
						ctx.closePath();
						ctx.fillStyle=drawShapeSetValue(shapesInChart[i].strokeColor,drawShape_default.strokeColor);
						ctx.fill();
					}
					if(drawShapeSetValue(shapesInChart[i].arrowBottom,drawShape_default.arrowBottom)) {
						ctx.moveTo(vleft, vbottom);
						ctx.lineTo(arrowbx1, arrowby1);
						ctx.lineTo(arrowbx2, arrowby2);
						ctx.lineTo(vleft,vbottom);
						ctx.stroke();
						ctx.closePath();
						ctx.fillStyle=drawShapeSetValue(shapesInChart[i].strokeColor,drawShape_default.strokeColor);
						ctx.fill();
					}
					ctx.setLineDash([]);
					break;
				case "TEXT" :
					ctx.beginPath();
					var vx, vy, text;
					vx= 1*drawShapeSetValue(shapesInChart[i].x1,drawShape_default.x1);
					vy= 1*drawShapeSetValue(shapesInChart[i].y1,drawShape_default.y1);
					text= drawShapeSetValue(shapesInChart[i].text,drawShape_default.text);
					if(typeof text=="function") {
						text=text(i, null, ctx, othervars.config, vx, vy, othervars.borderX, othervars.borderY, true, data, othervars.animationValue,othervars);
					}
					var xypos1=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,vx,vy,1*drawShapeSetValue(shapesInChart[i].paddingX1,drawShape_default.paddingX1),1*drawShapeSetValue(shapesInChart[i].paddingY1,drawShape_default.paddingY1),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
					ctx.translate(xypos1.xpos, xypos1.ypos);
					var fontSize=realAnimation*drawShapeSetValue(shapesInChart[i].fontSize,drawShape_default.fontSize);
					ctx.font = drawShapeSetValue(shapesInChart[i].fontStyle,drawShape_default.fontStyle) + " " + (Math.ceil(ctx.chartTextScale*fontSize)).toString() + "px " + drawShapeSetValue(shapesInChart[i].fontFamily,drawShape_default.fontFamily);
					ctx.fillStyle = drawShapeSetValue(shapesInChart[i].fontColor,drawShape_default.fontColor);
					ctx.textAlign = drawShapeSetValue(shapesInChart[i].textAlign,drawShape_default.textAlign);
					ctx.textBaseline = drawShapeSetValue(shapesInChart[i].textBaseline,drawShape_default.textBaseline);
					var rotateVal=Math.PI * 1*drawShapeSetValue(shapesInChart[i].rotate,drawShape_default.rotate) / 180;
					ctx.rotate(rotateVal);
					setTextBordersAndBackground(ctx,text,Math.ceil(ctx.chartTextScale*fontSize),0,0,drawShapeSetValue(shapesInChart[i].textBorders,drawShape_default.textBorders),drawShapeSetValue(shapesInChart[i].textBordersColor,drawShape_default.textBordersColor),Math.ceil((realAnimation)*ctx.chartLineScale*drawShapeSetValue(shapesInChart[i].textBordersWidth,drawShape_default.textBordersWidth)),Math.ceil(ctx.chartSpaceScale*drawShapeSetValue(shapesInChart[i].textBordersXSpace,drawShape_default.textBordersXSpace)),Math.ceil(ctx.chartSpaceScale*drawShapeSetValue(shapesInChart[i].textBordersYSpace,drawShape_default.textBordersYSpace)),drawShapeSetValue(shapesInChart[i].textBordersStyle,drawShape_default.textBordersStyle),drawShapeSetValue(shapesInChart[i].textBackgroundColor,drawShape_default.textBackgroundColor),"TEXTINSHAPE");
					if (iter !=="all" || (iter === "all" && othervars.cntiter != othervars.config.animationSteps) || othervars.config.animation==false) {
					       ctx.fillTextMultiLine(text, 0, 0, ctx.textBaseline, Math.ceil(ctx.chartTextScale*fontSize),true,othervars.config.detectMouseOnText,ctx,"SHAPESINCHART_TEXTMOUSE",rotateVal,xypos1.xpos, xypos1.ypos,-1,-1);
					} else ctx.fillTextMultiLine(text, 0, 0, ctx.textBaseline, Math.ceil(ctx.chartTextScale*fontSize),true,false,ctx,"SHAPESINCHART_TEXTMOUSE",rotateVal,xypos1.xpos, xypos1.ypos,-1,-1);
					break;
				case "IMAGE" :
					var imageAlign = drawShapeSetValue(shapesInChart[i].imageAlign,drawShape_default.imageAlign);
					var imageBaseline = drawShapeSetValue(shapesInChart[i].imageBaseline,drawShape_default.imageBaseline);
					var vx, vy, text;
					vx= 1*drawShapeSetValue(shapesInChart[i].x1,drawShape_default.x1);
					vy= 1*drawShapeSetValue(shapesInChart[i].y1,drawShape_default.y1);
					var xypos1=setXYpos(shape,shapesInChart[i],imageAlign,imageBaseline,shapesInChart[i].loadImage,ctx,data,statData,othervars,vx,vy,1*drawShapeSetValue(shapesInChart[i].paddingX1,drawShape_default.paddingX1),1*drawShapeSetValue(shapesInChart[i].paddingY1,drawShape_default.paddingY1),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
					ctx.translate(xypos1.xpos, xypos1.ypos);
					var rotateVal=Math.PI * 1*drawShapeSetValue(shapesInChart[i].rotate,drawShape_default.rotate) / 180;
					ctx.rotate(rotateVal);
					var imageWidth=drawShapeSetValue(shapesInChart[i].imageWidth,shapesInChart[i].loadImage.width);
					var imageHeight=drawShapeSetValue(shapesInChart[i].imageHeight,shapesInChart[i].loadImage.height);
					ctx.drawImage(shapesInChart[i].loadImage, 0, 0,shapesInChart[i].loadImage.width,shapesInChart[i].loadImage.height,0, 0,imageWidth,imageHeight);
					break;
				case "STAR" :
				case "PLUS" :
				case "CROSS" :
					var vxs1,vys1,vxs2,vys2,lineCount,angle,vx,vy,vx2,vy2;
					var angle     = (Math.PI*(1*drawShapeSetValue(shapesInChart[i].rotate,drawShape_default.rotate)-90)/180);
					switch(shape) {
						case "PLUS" :
							lineCount=2;
							break;
						case "CROSS" :
							lineCount=2;
							angle+=Math.PI/4;
							break;
						default: 
							lineCount = 1*drawShapeSetValue(shapesInChart[i].lineCount,drawShape_default.lineCount);
							if (lineCount<2)lineCount=2;
							break;
					}
					var angleplus = Math.PI/lineCount;
					vx= 1*drawShapeSetValue(shapesInChart[i].x1,drawShape_default.x1);
					vy= 1*drawShapeSetValue(shapesInChart[i].y1,drawShape_default.y1);
					var radius    = realAnimation*1*drawShapeSetValue(shapesInChart[i].radius,drawShape_default.radius);
					if (radius < 0) {
						var xypos2=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x2,drawShape_default.x2),1*drawShapeSetValue(shapesInChart[i].y2,drawShape_default.y2),1*drawShapeSetValue(shapesInChart[i].paddingX2,drawShape_default.paddingX2),1*drawShapeSetValue(shapesInChart[i].paddingY2,drawShape_default.paddingY2),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						radius=Math.sqrt(((xypos.xpos-xypos2.xpos)*(xypos.xpos-xypos2.xpos))+((xypos.ypos-xypos2.ypos)*(xypos.ypos-xypos2.ypos)));
					}
					var xypos1=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,vx,vy,1*drawShapeSetValue(shapesInChart[i].paddingX1,drawShape_default.paddingX1),1*drawShapeSetValue(shapesInChart[i].paddingY1,drawShape_default.paddingY1),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
					ctx.beginPath();

					ctx.lineWidth = Math.ceil(ctx.chartLineScale*drawShapeSetValue(shapesInChart[i].strokeSize,drawShape_default.strokeSize));
					ctx.strokeStyle = drawShapeSetValue(shapesInChart[i].strokeColor,drawShape_default.strokeColor);
					ctx.setLineDash(lineStyleFn(drawShapeSetValue(shapesInChart[i].strokeStyle,drawShape_default.strokeStyle)));	
					for(var j=0;j<lineCount;j++) {
						vxs1=xypos1.xpos+radius*Math.cos(angle);
						vys1=xypos1.ypos+radius*Math.sin(angle);
						vxs2=xypos1.xpos-radius*Math.cos(angle);
						vys2=xypos1.ypos-radius*Math.sin(angle);
						angle+=angleplus;
						ctx.moveTo(vxs1,vys1);
						ctx.lineTo(vxs2,vys2);
						ctx.stroke();
					}					
					ctx.setLineDash([]);
					break;
				case "REGULARSHAPE" :
				case "TRIANGLE" :
				case "SQUARE" :
				case "DIAMOND" :
					var vxs,vys,sideCount,angle;
					var angle     = (Math.PI*(1*drawShapeSetValue(shapesInChart[i].rotate,drawShape_default.rotate)-90)/180);
					switch(shape) {
						case "TRIANGLE" :
							sideCount=3;
							break;
						case "SQUARE" :
							sideCount=4;
							angle+=Math.PI/4;
							break;
						case "DIAMOND" :
							sideCount=4;
							break;
						default: 
							sideCount = 1*drawShapeSetValue(shapesInChart[i].sideCount,drawShape_default.sideCount);
							if (sideCount<3)sideCount=3;
							break;
					}
					var angleplus = 2*Math.PI/sideCount;
					vx= 1*drawShapeSetValue(shapesInChart[i].x1,drawShape_default.x1);
					vy= 1*drawShapeSetValue(shapesInChart[i].y1,drawShape_default.y1);
					var xypos1=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,vx,vy,1*drawShapeSetValue(shapesInChart[i].paddingX1,drawShape_default.paddingX1),1*drawShapeSetValue(shapesInChart[i].paddingY1,drawShape_default.paddingY1),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
					var radius    = realAnimation*1*drawShapeSetValue(shapesInChart[i].radius,drawShape_default.radius);
					if (radius < 0) {
						var xypos2=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x2,drawShape_default.x2),1*drawShapeSetValue(shapesInChart[i].y2,drawShape_default.y2),1*drawShapeSetValue(shapesInChart[i].paddingX2,drawShape_default.paddingX2),1*drawShapeSetValue(shapesInChart[i].paddingY2,drawShape_default.paddingY2),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						radius=Math.sqrt(((xypos.xpos-xypos2.xpos)*(xypos.xpos-xypos2.xpos))+((xypos.ypos-xypos2.ypos)*(xypos.ypos-xypos2.ypos)));
					}
					ctx.beginPath();
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*drawShapeSetValue(shapesInChart[i].strokeSize,drawShape_default.strokeSize));
					ctx.strokeStyle = drawShapeSetValue(shapesInChart[i].strokeColor,drawShape_default.strokeColor);
					ctx.setLineDash(lineStyleFn(drawShapeSetValue(shapesInChart[i].strokeStyle,drawShape_default.strokeStyle)));	
					for(var j=0;j<sideCount;j++) {
						vxs=xypos1.xpos+radius*Math.cos(angle);
						vys=xypos1.ypos+radius*Math.sin(angle);
						angle+=angleplus;
						if(j==0) ctx.moveTo(vxs,vys);
						else     ctx.lineTo(vxs,vys);
					}					
					ctx.closePath();
					ctx.fillStyle=setOptionValue(true,1,"SHAPESINCHART_REGULARSHAPE",ctx,data,statData,shapesInChart[i].fillColor,drawShape_default.fillColor,"fillColor",-1,-1,{gradientColors: shapesInChart[i].gradientColors,animationValue : realAnimation, midPosX : xypos1.xpos, midPosY : xypos1.ypos, radius : radius });
					ctx.fill();
					ctx.stroke();
					ctx.setLineDash([]);
					break;					
				case "ELLIPSE" :
					ctx.beginPath();
					var xypos=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x1,drawShape_default.x1),1*drawShapeSetValue(shapesInChart[i].y1,drawShape_default.y1),1*drawShapeSetValue(shapesInChart[i].paddingX1,drawShape_default.paddingX1),1*drawShapeSetValue(shapesInChart[i].paddingY1,drawShape_default.paddingY1),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
					var height=realAnimation*1*drawShapeSetValue(shapesInChart[i].ellipseHeight,drawShape_default.ellipseHeight);
					var width= realAnimation*1*drawShapeSetValue(shapesInChart[i].ellipseWidth,drawShape_default.ellipseWidth);
					ctx.moveTo(xypos.xpos, xypos.ypos - height/2); // A1
					ctx.bezierCurveTo(
    						xypos.xpos + width/2, xypos.ypos - height/2, // C1
    						xypos.xpos + width/2, xypos.ypos + height/2, // C2
    						xypos.xpos, xypos.ypos + height/2); // A2
					ctx.bezierCurveTo(
						xypos.xpos - width/2, xypos.ypos + height/2, // C3
						xypos.xpos - width/2, xypos.ypos - height/2, // C4
						xypos.xpos, xypos.ypos - height/2); // A1
					ctx.closePath();
					ctx.fillStyle=setOptionValue(true,1,"SHAPESINCHART_ELLIPSE",ctx,data,statData,shapesInChart[i].fillColor,drawShape_default.fillColor,"fillColor",-1,-1,{gradientColors: shapesInChart[i].gradientColors,animationValue : realAnimation, midPosX : xypos.xpos, midPosY : xypos.ypos, radius : Math.max(width/2,height/2) });
					ctx.fill();
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*drawShapeSetValue(shapesInChart[i].strokeSize,drawShape_default.strokeSize));
					ctx.strokeStyle = drawShapeSetValue(shapesInChart[i].strokeColor,drawShape_default.strokeColor);
					ctx.setLineDash(lineStyleFn(drawShapeSetValue(shapesInChart[i].strokeStyle,drawShape_default.strokeStyle)));	
					ctx.stroke();
					ctx.setLineDash([]);
					break;
				case "RECTANGLE" :
	
					var vright, vleft, vtop, vbottom, tmp;
					vright= 1*drawShapeSetValue(shapesInChart[i].x1,drawShape_default.x1);
					vleft= 1*drawShapeSetValue(shapesInChart[i].x2,drawShape_default.x2);
					vtop= 1*drawShapeSetValue(shapesInChart[i].y2,drawShape_default.y2);
					vbottom= 1*drawShapeSetValue(shapesInChart[i].y1,drawShape_default.y1);
					ctx.beginPath();

					var xypos1=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,vleft,vtop,1*drawShapeSetValue(shapesInChart[i].paddingX1,drawShape_default.paddingX1),1*drawShapeSetValue(shapesInChart[i].paddingY1,drawShape_default.paddingY1),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
					var xypos2=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,vright,vbottom,1*drawShapeSetValue(shapesInChart[i].paddingX2,drawShape_default.paddingX2),1*drawShapeSetValue(shapesInChart[i].paddingY2,drawShape_default.paddingY2),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));

					if (xypos2.xpos<xypos1.xpos){tmp=xypos2.xpos;xypos2.xpos=xypos1.xpos;xypos1.xpos=tmp;}
					if (xypos2.ypos<xypos1.ypos){tmp=xypos2.ypos;xypos2.ypos=xypos1.ypos;xypos1.ypos=tmp;}

					ctx.moveTo(xypos1.xpos+(1-realAnimation)*((xypos2.xpos-xypos1.xpos)/2), xypos1.ypos+(1-realAnimation)*((xypos2.ypos-xypos1.ypos)/2));
					ctx.lineTo(xypos1.xpos+(1-realAnimation)*((xypos2.xpos-xypos1.xpos)/2), xypos2.ypos-(1-realAnimation)*((xypos2.ypos-xypos1.ypos)/2));
					ctx.lineTo(xypos2.xpos-(1-realAnimation)*((xypos2.xpos-xypos1.xpos)/2), xypos2.ypos-(1-realAnimation)*((xypos2.ypos-xypos1.ypos)/2));
					ctx.lineTo(xypos2.xpos-(1-realAnimation)*((xypos2.xpos-xypos1.xpos)/2), xypos1.ypos+(1-realAnimation)*((xypos2.ypos-xypos1.ypos)/2));
	
					ctx.closePath();
					ctx.fillStyle=setOptionValue(true,1,"SHAPESINCHART_RECT",ctx,data,statData,shapesInChart[i].fillColor,drawShape_default.fillColor,"fillColor",-1,-1,{gradientColors: shapesInChart[i].gradientColors,animationValue : realAnimation, xPosLeft : xypos1.xpos+(1-realAnimation)*((xypos2.xpos-xypos1.xpos)/2), yPosBottom : xypos1.ypos+(1-realAnimation)*((xypos2.ypos-xypos1.ypos)/2), yPosTop :xypos2.ypos-(1-realAnimation)*((xypos2.ypos-xypos1.ypos)/2) });
					ctx.fill();
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*drawShapeSetValue(shapesInChart[i].strokeSize,drawShape_default.strokeSize));
					ctx.strokeStyle = drawShapeSetValue(shapesInChart[i].strokeColor,drawShape_default.strokeColor);
					ctx.setLineDash(lineStyleFn(drawShapeSetValue(shapesInChart[i].strokeStyle,drawShape_default.strokeStyle)));	
					ctx.stroke();
					ctx.setLineDash([]);
					break;
				case "MYSHAPE" :
					var xpos,ypos,xypos1,paddingX,paddingY;
					ctx.beginPath();

					if(typeof shapesInChart[i].shapePoints !== "object") break;
					if(shapesInChart[i].shapePoints.length <3) break;
					
					for(var j=0;j<shapesInChart[i].shapePoints.length;j++) {
						xpos=drawShapeSetValue(shapesInChart[i].shapePoints[j][0],drawShape_default.x1);
						ypos=drawShapeSetValue(shapesInChart[i].shapePoints[j][1],drawShape_default.y1);
						paddingX=drawShapeSetValue(shapesInChart[i].shapePadding[j][0],drawShape_default.paddingX1);
						paddingY=drawShapeSetValue(shapesInChart[i].shapePadding[j][1],drawShape_default.paddingY1);
						xypos1=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,xpos,ypos,1*paddingX,1*paddingY,drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						if(j==0) ctx.moveTo(xypos1.xpos,xypos1.ypos);
						else ctx.lineTo(xypos1.xpos,xypos1.ypos);
					} 					
					ctx.closePath();
					ctx.fillStyle=drawShapeSetValue(shapesInChart[i].fillColor,drawShape_default.fillColor);
					ctx.fill();
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*drawShapeSetValue(shapesInChart[i].strokeSize,drawShape_default.strokeSize));
					ctx.strokeStyle = drawShapeSetValue(shapesInChart[i].strokeColor,drawShape_default.strokeColor);
					ctx.setLineDash(lineStyleFn(drawShapeSetValue(shapesInChart[i].strokeStyle,drawShape_default.strokeStyle)));	
					ctx.stroke();
					ctx.setLineDash([]);
					break;
				case "CIRCLE" :
					ctx.beginPath();
					var xypos=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x1,drawShape_default.x1),1*drawShapeSetValue(shapesInChart[i].y1,drawShape_default.y1),1*drawShapeSetValue(shapesInChart[i].paddingX1,drawShape_default.paddingX1),1*drawShapeSetValue(shapesInChart[i].paddingY1,drawShape_default.paddingY1),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
					var radius    = realAnimation*1*drawShapeSetValue(shapesInChart[i].radius,drawShape_default.radius);
					if (radius < 0) {
						var xypos2=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x2,drawShape_default.x2),1*drawShapeSetValue(shapesInChart[i].y2,drawShape_default.y2),1*drawShapeSetValue(shapesInChart[i].paddingX2,drawShape_default.paddingX2),1*drawShapeSetValue(shapesInChart[i].paddingY2,drawShape_default.paddingY2),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						radius=Math.sqrt(((xypos.xpos-xypos2.xpos)*(xypos.xpos-xypos2.xpos))+((xypos.ypos-xypos2.ypos)*(xypos.ypos-xypos2.ypos)));
					}
					var xypos=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x1,drawShape_default.x1),1*drawShapeSetValue(shapesInChart[i].y1,drawShape_default.y1),1*drawShapeSetValue(shapesInChart[i].paddingX1,drawShape_default.paddingX1),1*drawShapeSetValue(shapesInChart[i].paddingY1,drawShape_default.paddingY1),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
					if (1*drawShapeSetValue(shapesInChart[i].endAngle,drawShape_default.endAngle)-1*drawShapeSetValue(shapesInChart[i].startAngle,drawShape_default.startAngle) !=  360)
						ctx.arc(xypos.xpos,xypos.ypos, 0, (Math.PI/180)*1*drawShapeSetValue(shapesInChart[i].startAngle,drawShape_default.startAngle), (Math.PI/180)*1*drawShapeSetValue(shapesInChart[i].endAngle,drawShape_default.endAngle),false);
					ctx.arc(xypos.xpos,xypos.ypos, realAnimation*1*radius, (Math.PI/180)*1*drawShapeSetValue(shapesInChart[i].startAngle,drawShape_default.startAngle), (Math.PI/180)*1*drawShapeSetValue(shapesInChart[i].endAngle,drawShape_default.endAngle),true);
					ctx.closePath();
					ctx.fillStyle=setOptionValue(true,1,"SHAPESINCHART_CIRCLE",ctx,data,statData,shapesInChart[i].fillColor,drawShape_default.fillColor,"fillColor",-1,-1,{gradientColors: shapesInChart[i].gradientColors,animationValue : realAnimation, midPosX : xypos.xpos, midPosY : xypos.ypos, radius : radius  });
//					ctx.fillStyle=drawShapeSetValue(shapesInChart[i].fillColor,drawShape_default.fillColor);
					ctx.fill();
					ctx.lineWidth = Math.ceil(ctx.chartLineScale*drawShapeSetValue(shapesInChart[i].strokeSize,drawShape_default.strokeSize));
					ctx.strokeStyle = drawShapeSetValue(shapesInChart[i].strokeColor,drawShape_default.strokeColor);
					ctx.setLineDash(lineStyleFn(drawShapeSetValue(shapesInChart[i].strokeStyle,drawShape_default.strokeStyle)));	
					ctx.stroke();
					ctx.setLineDash([]);
					break;
				default : 
					if(typeof shapesInChart[i].shape == "function"){
						othervars.currentShape=i;
						othervars.shapesInChart=shapesInChart[i];
						othervars.xypos1=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x1,drawShape_default.x1),1*drawShapeSetValue(shapesInChart[i].y1,drawShape_default.y1),1*drawShapeSetValue(shapesInChart[i].paddingX1,drawShape_default.paddingX1),1*drawShapeSetValue(shapesInChart[i].paddingY1,drawShape_default.paddingY1),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						othervars.xypos2=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x2,drawShape_default.x2),1*drawShapeSetValue(shapesInChart[i].y2,drawShape_default.y2),1*drawShapeSetValue(shapesInChart[i].paddingX2,drawShape_default.paddingX2),1*drawShapeSetValue(shapesInChart[i].paddingY2,drawShape_default.paddingY2),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						othervars.xypos3=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x3,drawShape_default.x3),1*drawShapeSetValue(shapesInChart[i].y3,drawShape_default.y3),1*drawShapeSetValue(shapesInChart[i].paddingX3,drawShape_default.paddingX3),1*drawShapeSetValue(shapesInChart[i].paddingY3,drawShape_default.paddingY3),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						othervars.xypos4=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x4,drawShape_default.x4),1*drawShapeSetValue(shapesInChart[i].y4,drawShape_default.y4),1*drawShapeSetValue(shapesInChart[i].paddingX4,drawShape_default.paddingX4),1*drawShapeSetValue(shapesInChart[i].paddingY4,drawShape_default.paddingY4),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						othervars.xypos5=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x5,drawShape_default.x5),1*drawShapeSetValue(shapesInChart[i].y5,drawShape_default.y5),1*drawShapeSetValue(shapesInChart[i].paddingX5,drawShape_default.paddingX5),1*drawShapeSetValue(shapesInChart[i].paddingY5,drawShape_default.paddingY5),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						othervars.xypos6=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x6,drawShape_default.x6),1*drawShapeSetValue(shapesInChart[i].y6,drawShape_default.y6),1*drawShapeSetValue(shapesInChart[i].paddingX6,drawShape_default.paddingX6),1*drawShapeSetValue(shapesInChart[i].paddingY6,drawShape_default.paddingY6),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						othervars.xypos7=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x7,drawShape_default.x7),1*drawShapeSetValue(shapesInChart[i].y7,drawShape_default.y7),1*drawShapeSetValue(shapesInChart[i].paddingX7,drawShape_default.paddingX7),1*drawShapeSetValue(shapesInChart[i].paddingY7,drawShape_default.paddingY7),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						othervars.xypos8=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x8,drawShape_default.x8),1*drawShapeSetValue(shapesInChart[i].y8,drawShape_default.y8),1*drawShapeSetValue(shapesInChart[i].paddingX8,drawShape_default.paddingX8),1*drawShapeSetValue(shapesInChart[i].paddingY8,drawShape_default.paddingY8),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						othervars.xypos9=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x9,drawShape_default.x9),1*drawShapeSetValue(shapesInChart[i].y9,drawShape_default.y9),1*drawShapeSetValue(shapesInChart[i].paddingX9,drawShape_default.paddingX9),1*drawShapeSetValue(shapesInChart[i].paddingY9,drawShape_default.paddingY9),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						othervars.xypos10=setXYpos(shape,shapesInChart[i],"","","",ctx,data,statData,othervars,1*drawShapeSetValue(shapesInChart[i].x10,drawShape_default.x10),1*drawShapeSetValue(shapesInChart[i].y10,drawShape_default.y10),1*drawShapeSetValue(shapesInChart[i].paddingX10,drawShape_default.paddingX10),1*drawShapeSetValue(shapesInChart[i].paddingY10,drawShape_default.paddingY10),drawShapeSetValue(shapesInChart[i].limitToChart,drawShape_default.limitToChart));
						shapesInChart[i].shape(area, ctx, data,statData, posi,posj,othervars);
					}
					break;
			}
			ctx.restore();
		}
	}
	
	function setXYpos(shape,shapesInChart,imageAlign,imageBaseline,image,ctx,data,statData,othervars,xposval,yposval,paddingX1,paddingY1,limitToChart) {
		var xpos, ypos, position;
		if(typeof shapesInChart.position != "string")position= drawShape_default.position.toUpperCase();
		else position=shapesInChart.position.toUpperCase();
		switch(position) {
			case "RELATIVE" :
				xpos = paddingX1;
				ypos = paddingY1;
				switch (xposval) {
					case 0:
						break;
					case 1:
						xpos += othervars.borderX;
						break;
					case 2:
						xpos += othervars.midPosX;
						break;
					case -2:
						if (window.devicePixelRatio) xpos += (ctx.canvas.width/2)/window.devicePixelRatio;
						else xpos += ctx.canvas.width / 2;
						break;
					case 3:
						xpos += xpos + 2 * othervars.midPosX - othervars.borderX;
						break;
					case 4:
						if (window.devicePixelRatio) xpos += ctx.canvas.width/window.devicePixelRatio;
						else xpos += ctx.canvas.width;
						break;
					default:
						xpos += othervars.midPosX;
						break;
				}
				switch (yposval) {
					case 0:
						break;
					case 3:
						ypos += othervars.borderY;
						break;
					case 2:
						ypos += othervars.midPosY;
						break;
					case -2:
						if (window.devicePixelRatio) ypos += (ctx.canvas.height/2)/window.devicePixelRatio;
						else ypos += ctx.canvas.height / 2;
						break;
					case 1:
						ypos += ypos + 2 * othervars.midPosY - othervars.borderY;
						break;
					case 4:
						if (window.devicePixelRatio) ypos += ctx.canvas.height/window.devicePixelRatio;
						else ypos += ctx.canvas.height;
						break;
					default:
						ypos += othervars.midPosY;
						break;
				}
				break;
			case "INCHART" :
				switch(ctx.tpdata) {
					case 0 :
						switch(tpdraw(ctx,data.datasets[0])) {
							case "Radar" :
								var angle=((2*Math.PI)/(data.labels.length))*xposval;
								ypos=calculateOffset(othervars.config.logarithmic, yposval, statData[0][0].calculatedScale, statData[0][0].scaleHop,limitToChart);
								xpos=Math.cos(othervars.config.startAngle * Math.PI / 180 - angle) * ypos;
								ypos=Math.sin(othervars.config.startAngle * Math.PI / 180 - angle) * ypos;
								xpos=statData[0][0].midPosX + xpos+paddingX1;
								ypos=statData[0][0].midPosY - ypos+paddingY1;
								break;
							case "Line" :
								ypos= calculateOffset(statData[0][0].logarithmic, yposval, statData[0][0].calculatedScale, statData[0][0].scaleHop,limitToChart) - statData[0][0].zeroY;
								ypos=statData[0][0].yAxisPos - ypos+paddingY1;
								var xposval_wk=xposval;
								if(limitToChart){
									if (xposval_wk<0)xposval_wk=0;
									if (xposval_wk>statData[0][0].nbValueHop)xposval_wk=statData[0][0].nbValueHop;
								}
								xpos=statData[0][0].yAxisPosX + (statData[0][0].valueHop * xposval_wk)+paddingX1;
								break;
							case "Bar" :
							case "StackedBar" :
								ypos = statData[0][0].xAxisPosY - calculateOffset(othervars.config.logarithmic, yposval , statData[0][0].calculatedScale, statData[0][0].scaleHop,limitToChart)+paddingY1;
								var xposval_wk=xposval;
								if(limitToChart){
									if (xposval_wk<-0.5)xposval_wk=-0.5;
									if (xposval_wk>data.labels.length-0.5)xposval_wk=data.labels.length-0.5;
								}
								xpos = statData[0][0].yAxisPosX + statData[0][0].valueHop * (xposval_wk+0.5)+paddingX1;
								break;
							case "HorizontalStackedBar" :
							case "HorizontalBar" :
								xpos = statData[0][0].yAxisPosX + calculateOffset(othervars.config.logarithmic, xposval , statData[0][0].calculatedScale, statData[0][0].valueHop,limitToChart)+paddingX1;
								var xposval_wk=yposval;
								if(limitToChart){
									if (xposval_wk<-0.5)xposval_wk=-0.5;
									if (xposval_wk>data.labels.length-0.5)xposval_wk=data.labels.length-0.5;
								}
								ypos = statData[0][0].xAxisPosY - statData[0][0].scaleHop * (xposval_wk+0.5)+paddingY1;
								break;
		        				default :
								xpos=xposval+paddingX1;
								ypos=yposval+paddingY1;
								break;
						}
						break;
					case 1: 
						switch(ctx.tpchart) {
							case "Pie" :
							case "Doughnut" :
							case "PolarArea" :
								if(xposval < -0.499)xpos=-0.499;
								else if(xposval > data.length-0.501) xpos=data.length-0.501;
								else xpos=xposval;
								var curdata=Math.round(xpos);
								var startAngle=statData[curdata].startAngle;
								var segmentAngle=statData[curdata].segmentAngle;
								var firstAngle=statData[curdata].firstAngle;
								var realStartAngle=statData[curdata].realStartAngle;
								var endAngle=statData[curdata].endAngle;
								var angle=2*Math.PI-(startAngle+(xpos-curdata+0.5)*segmentAngle);
								if(ctx.tpchart=="PolarArea")
									ypos= calculateOffset(othervars.config.logarithmic, yposval, statData[0].calculatedScale, statData[0].scaleHop);
								else {
									ypos=statData[0].int_radius+yposval*(statData[0].ext_radius-statData[0].int_radius);
								}
								if(limitToChart){
									if (ypos<-statData[0].ext_radius)ypos=-statData[0].ext_radius;
									if (ypos>statData[0].ext_radius)ypos=statData[0].ext_radius;
								} 
								xpos=Math.cos(angle) * ypos;
								ypos=Math.sin(angle) * ypos;
								xpos=statData[0].midPosX + xpos+paddingX1;
								ypos=statData[0].midPosY - ypos+paddingY1;
								break;
		        				default :
								xpos=xposval+paddingX1;
								ypos=yposval+paddingY1;
								break;
						}
						break;
        				default :
						xpos=xposval+paddingX1;
						ypos=yposval+paddingY1;
						break;
					}
					break;
			case "ABSOLUTE" :
			default:
				xpos=xposval+paddingX1;
				ypos=yposval+paddingY1;
				break;

		}
		if(shape=="IMAGE") {
			var imageWidth=drawShapeSetValue(shapesInChart.imageWidth,image.width);
			var imageHeight=drawShapeSetValue(shapesInChart.imageHeight,image.height);
			switch (imageAlign) {
				case "left":
					break;
				case "right":
					xpos -= imageWidth;
					break;
				case "center":
					xpos -= (imageWidth / 2);
					break;
				default:
					break;
			}
			switch (imageBaseline) {
				case "top":
					break;
				case "bottom":
					ypos -= imageHeight;
					break;
				case "middle":
					ypos -= (imageHeight / 2);
					break;
				default:
					break;
			}
		}

		
		return {xpos:xpos,ypos:ypos};
	};
	
	function calculateOffset(logarithmic, val, calculatedScale, scaleHop,limitToChart) {
		if (!logarithmic) { // no logarithmic scale
			var outerValue = calculatedScale.steps * calculatedScale.stepValue;
			var adjustedValue = val - calculatedScale.graphMin;
			if(limitToChart) {
				var scalingFactor = CapValue(adjustedValue / outerValue, 1, 0);
				return (scaleHop * calculatedScale.steps) * scalingFactor;
			} else 	return (scaleHop * calculatedScale.steps) * (adjustedValue/outerValue);
		} else { // logarithmic scale
			return CapValue(log10(val) * scaleHop - log10(calculatedScale.graphMin) * scaleHop, undefined, 0);
		}
	};
	function CapValue(valueToCap, maxValue, minValue) {
		if (isNumber(maxValue)) {
			if (valueToCap > maxValue) {
				return maxValue;
			}
		}
		if (isNumber(minValue)) {
			if (valueToCap < minValue) {
				return minValue;
			}
		}
		return valueToCap;
	};

	function drawShapeSetValue(dataval,defval) {
		if(typeof dataval != "undefined") return dataval;
		else return defval;
	};	
	
	function xPos(iteration, data,yAxisPosX,valueHop,nbValueHop) {
		return yAxisPosX + (valueHop * iteration);
	};

};

function addIns_highLight(ctx, config, data, movement, animationCount,statData){
	var special;
	var shapesVar,shapeAddins;
	var i,decalRadius,property;
	var addHighLight=false,totreat;
	var rectHeight, rectWidth, ratio;
	if (ctx.tpdata==0){
		if(typeof data.special=="object")special=data.special;
		if(typeof data.shapesInChart == "object") shapesVar=data.shapesInChart;
		else {
			data.shapesInChart=[];
			shapesVar=data.shapesInChart;
		}
	}
	else {
		if(typeof data[0].special=="object")special=data[0].special;
		if(typeof data[0].shapesInChart == "object") shapesVar=data[0].shapesInChart;
		else {
			data[0].shapesInChart=[];
			shapesVar=data[0].shapesInChart;
		}
	}
	addHighLight=false;	
	if(typeof special=="object") {
		for(i=0;i<special.length;i++) {
			totreat=false;
			if(typeof special[i].addIns_shape== "undefined")shapeAddins="ARROW" ;
			else shapeAddins=special[i].addIns_shape.toUpperCase();
			switch(shapeAddins) {
				case "ELLIPSE" :
					switch(tpdraw(ctx,(typeof data.datasets == "object") ? data.datasets[special[i].posi] : undefined)) {
						case "Line" :
						case "Radar" :
							totreat=true;
							addHighLight=true;
							shapesVar[shapesVar.length]={hightLight : true };
							shapesVar[shapesVar.length-1].shape= special[i].addIns_shape;
							shapesVar[shapesVar.length-1].position= "inchart";
							shapesVar[shapesVar.length-1].x1= special[i].posj;
							shapesVar[shapesVar.length-1].y1= data.datasets[special[i].posi].data[special[i].posj];
							shapesVar[shapesVar.length-1].ellipseHeight=30;
							shapesVar[shapesVar.length-1].ellipseWidth=40;

							break;
						case "Bar" :
						case "StackedBar" :
						case "HorizontalBar" :
						case "HorizontalStackedBar" :
							totreat=true;
							addHighLight=true;
							shapesVar[shapesVar.length]={hightLight : true };
							shapesVar[shapesVar.length-1].shape= special[i].addIns_shape;
							shapesVar[shapesVar.length-1].position= "absolute";
							shapesVar[shapesVar.length-1].x1= (statData[special[i].posi][special[i].posj].xPosRight+statData[special[i].posi][special[i].posj].xPosLeft)/2;
							shapesVar[shapesVar.length-1].y1= (statData[special[i].posi][special[i].posj].yPosTop+statData[special[i].posi][special[i].posj].yPosBottom)/2;
							rectHeight=1.25*Math.abs(statData[special[i].posi][special[i].posj].yPosTop-statData[special[i].posi][special[i].posj].yPosBottom);
							rectWidth=1.25*Math.abs(statData[special[i].posi][special[i].posj].xPosRight-statData[special[i].posi][special[i].posj].xPosLeft);
							ratio=rectWidth/rectHeight;
							shapesVar[shapesVar.length-1].ellipseWidth=Math.sqrt((rectWidth*rectWidth) + (ratio*ratio) * (rectHeight*rectHeight));
							shapesVar[shapesVar.length-1].ellipseHeight=shapesVar[shapesVar.length-1].ellipseWidth/ratio;
							break;
						case "Pie" :
						case "Doughnut" :
						case "PolarArea" :
						default:
							break;
					}				
					shapesVar[shapesVar.length-1].strokeColor= "black";
					shapesVar[shapesVar.length-1].fillColor= "black";    
					break;
				case "ARROW" :
				default:
					totreat=true;
					addHighLight=true;
					shapesVar[shapesVar.length]={hightLight : true };
					shapesVar[shapesVar.length-1].shape= "arrow";
					switch(tpdraw(ctx,(typeof data.datasets == "object") ? data.datasets[special[i].posi] : undefined)) {
						case "Line" :
						case "Radar" :
							shapesVar[shapesVar.length-1].position= "inchart";
							shapesVar[shapesVar.length-1].x1= special[i].posj;
							shapesVar[shapesVar.length-1].y1= data.datasets[special[i].posi].data[special[i].posj];
							shapesVar[shapesVar.length-1].paddingX1= 30;
							shapesVar[shapesVar.length-1].paddingY1= -30;
							shapesVar[shapesVar.length-1].x2= special[i].posj;
							shapesVar[shapesVar.length-1].y2= data.datasets[special[i].posi].data[special[i].posj];
							break;
						case "Bar" :
						case "StackedBar" :
						case "HorizontalBar" :
						case "HorizontalStackedBar" :
							shapesVar[shapesVar.length-1].position= "absolute";
							shapesVar[shapesVar.length-1].x2= statData[special[i].posi][special[i].posj].xPosRight;
							shapesVar[shapesVar.length-1].y2= statData[special[i].posi][special[i].posj].yPosTop;
							shapesVar[shapesVar.length-1].x1= shapesVar[shapesVar.length-1].x2;
							shapesVar[shapesVar.length-1].y1= shapesVar[shapesVar.length-1].y2;
							if(ctx.tpchart=="Bar" || ctx.tpchart=="StackedBar") {
								shapesVar[shapesVar.length-1].x1=shapesVar[shapesVar.length-1].x1+30;
								if(data.datasets[special[i].posi].data[special[i].posj]>=0) {
									shapesVar[shapesVar.length-1].y1= shapesVar[shapesVar.length-1].y1-30;
								} else {
									shapesVar[shapesVar.length-1].y1= shapesVar[shapesVar.length-1].y1+30;
								}
							} else {
								shapesVar[shapesVar.length-1].y1=shapesVar[shapesVar.length-1].y1-30;
								if(data.datasets[special[i].posi].data[special[i].posj]>=0) {
									shapesVar[shapesVar.length-1].x1= shapesVar[shapesVar.length-1].x1+30;
								} else {
									shapesVar[shapesVar.length-1].x1= shapesVar[shapesVar.length-1].x1-30;
								}
							}
							break;
						case "Pie" :
						case "Doughnut" :
							if(typeof config.highLightSet.expandOutRadius=="number")decalRadius=config.highLightSet.expandOutRadius;
							else decalRadius=0;	
							shapesVar[shapesVar.length-1].position= "inchart";
							shapesVar[shapesVar.length-1].limitToChart= false;
							shapesVar[shapesVar.length-1].x1= special[i].posi;
							if(ctx.tpchart=="Pie")	shapesVar[shapesVar.length-1].y1= 1.3+decalRadius;
							else shapesVar[shapesVar.length-1].y1= 1+(100*0.3)/(100-config.percentageInnerCutout);
							
							shapesVar[shapesVar.length-1].x2= special[i].posi;
							shapesVar[shapesVar.length-1].y2= 1+decalRadius;
							break;
						case "PolarArea" :
							shapesVar[shapesVar.length-1].position= "inchart";
							shapesVar[shapesVar.length-1].limitToChart= false;
							shapesVar[shapesVar.length-1].x1= special[i].posi;
							shapesVar[shapesVar.length-1].y1= data[special[i].posi].value+0.3*(statData[0].outerVal-statData[0].calculatedScale.graphMin);;
							shapesVar[shapesVar.length-1].x2= special[i].posi;
							shapesVar[shapesVar.length-1].y2= data[special[i].posi].value;
							break;
					}				
					shapesVar[shapesVar.length-1].strokeColor= "black";
					shapesVar[shapesVar.length-1].fillColor= "black";    
					break;
			};
			// overwrite options;
			if(totreat) {
				for (property in config.highLightSet) {
					if(property.substring(0,7)=="addIns_") {			 
						eval("shapesVar[shapesVar.length-1]."+property.substring(7,50)+"=config.highLightSet[property];");
					}
				}
			}
		}

		
		if(addHighLight) {
			// draw shapes;
			drawShapes("HIGHLIGHT", ctx, data,statData, 0, 0 ,{ config: config});
			// remove shapes;
			for(i=shapesVar.length-1;i>=0;i--) shapesVar.splice(i,1);
		}
	}

};

var moreInChartData_default= {
	position : "INCHART",
	iter : "last",

	link : "Line",
	
	// default values for Line;
	linkStrokeColorLine: "black",
	linkStrokeStyleLine : "solid", 
	linkStrokeSizeLine: 2,
	paddingValXLine : 4,
	paddingValYLine : 0,
	piePaddingY : 0.1,
	paddingX : 0,
	paddingY : 0,


	// default values for Triangle;
	arrowWidth : 2,
	arrowHeight : 0.1,
//     	linkFillColorTriangle : null,
	linkStrokeColorTriangle: "rgba(0,0,0,0)",
	linkStrokeStyleTriangle : "solid", 
	linkStrokeSizeTriangle: 0,
	paddingValXTriangle : 4,
	paddingValYTriangle : -16,
	
	// default for text;
	text : "<Value>",
	fontColor : "black", 
	fontStyle : "normal",
	fontSize : 25,
	fontFamily : "'Arial'",

	// default for Image;
	imageLoad : null,
	imagePos : 1,     // 0 before text, 1 after text;
	imageWidth : 20,   
	imageHeight: 20,   

	spaceBetweenTextAndImage : 5,
//	relativeImagePosition : "smart",
//	rotate : 0,

	// Point position;

	limitToChart : false,
	x1 : null,
	y1 : null,
	x2 : null,
	y2 : null,
	x3 : null,
	y3 : null,
	x4 : null,
	y4 : null,
	x5 : null,
	y5 : null,
	x6 : null,
	y6 : null,
	x7 : null,
	y7 : null,
	x8 : null,
	y8 : null,
	x9 : null,
	y9 : null,
	x10 : null,
	y10 : null,
	paddingX1 : null,
	paddingY1 : null,
	paddingX2 : null,
	paddingY2 : null,
	paddingX3 : null,
	paddingY3 : null,
	paddingX4 : null,
	paddingY4 : null,
	paddingX5 : null,
	paddingY5 : null,
	paddingX6 : null,
	paddingY6 : null,
	paddingX7 : null,
	paddingY7 : null,
	paddingX8 : null,
	paddingY8 : null,
	paddingX9 : null,
	paddingY9 : null,
	paddingX10 : null,
	paddingY10 : null,
	
	// Special values;
	avoidOverwrite : true	
	
	
};

function pushInGraphData(type_chart,data,config,pushInfoDefault) {

	var pushconfig = (pushInfoDefault) ? mergeChartConfig(moreInChartData_default, pushInfoDefault) : moreInChartData_default;
	var resconfig;

	var pushInfo,shapesInChart;
	if(typeof data.datasets == "object") {
		pushInfo=data.datasets;
		if(typeof data.shapesInChart == "undefined") data.shapesInChart=[];
		shapesInChart=data.shapesInChart;
		for (var i=0;i<data.datasets.length;i++){
			for(var j=0;j<data.datasets[i].data.length;j++) {
				if(typeof data.datasets[i].data[j]!="undefined") {
					resconfig = mergeChartConfig(data.datasets[i], pushconfig);
					pushInGraphDataSub(type_chart.upcase(),data.datasets[i],i,j,shapesInChart,data,config,resconfig);
				}
			}
		}
	}
	else {
		pushInfo=data;
		if(typeof data[0].shapesInChart == "undefined") data[0].shapesInChart=[];
		shapesInChart=data[0].shapesInChart;
		for (var i=0;i<data.length;i++){
			if(typeof data[i].value !="undefined") {
				resconfig = mergeChartConfig(data[i], pushconfig);
				pushInGraphDataSub(type_chart.toUpperCase(),data[i],i,-1,shapesInChart,data,config,resconfig);
			}
		}
		data[0].shapesInChart[0].avoidOverwrite=pushconfig.avoidOverwrite;
	}
	

	function mergeOptionConfig(defaults, userDefined) {
		var returnObj = {};
		for (var attrname in defaults) {
			returnObj[attrname] = defaults[attrname];
		}
		for (var attrnameBis in userDefined) {
			returnObj[attrnameBis] = userDefined[attrnameBis];
		}
		return returnObj;
	};


	function pushInGraphDataSub(type_chart,pushInfoI,i,j,shapesInChart,data,config,resconfig) {

        	var addRadius;
		shapesInChart[shapesInChart.length]=mergeOptionConfig(resconfig,pushInfoI);
	
		// push shapesInChart info for the pointer;

		var newShapes=shapesInChart[shapesInChart.length-1];

		if (newShapes.text.indexOf("<Title>") >= 0) newShapes.text=newShapes.text.replace("<Title>",pushInfoI.title);
		if (newShapes.text.indexOf("<Value>") >= 0){
			if(j==-1)newShapes.text=newShapes.text.replace("<Value>",""+pushInfoI.value);
			else newShapes.text=newShapes.text.replace("<Value>",""+pushInfoI.data[j]);
		}
		switch(newShapes.link.toUpperCase()) {
			case  "TRIANGLE" :
				var cumval=0;
				for(var vi=0;vi<data.length;vi++)cumval=cumval+1*data[vi].value;
				var arrowWidth=(cumval/360)*newShapes.arrowWidth;
	
				newShapes.shape = annotateTriangleFunction;
				newShapes.strokeColor=newShapes.linkStrokeColorLine;
				newShapes.strokeStyle=newShapes.linkStrokeStyleLine; 
				newShapes.strokeSize=newShapes.linkStrokeSizeLine;
				switch(type_chart) {
					case "PIE" :
					case "DOUGHNUT" :
						var multRadius;
						var percentageInnerCutout=50;
						if(typeof config.percentageInnerCutout != "undefined")percentageInnerCutout=config.percentageInnerCutout;
						if(type_chart.toUpperCase()=="DOUGHNUT")multRadius=100/(100-percentageInnerCutout);
						else multRadius=1;
                                                addRadius=0;
						if(typeof pushInfoI.expandOutRadius!="undefined")addRadius=1*pushInfoI.expandOutRadius;

						if(newShapes.x1==null)newShapes.x1=  (pushInfoI.value==0 ? i : Math.max(i-0.5,i-(arrowWidth/pushInfoI.value)));
						if(newShapes.y1==null)newShapes.y1= 0.99+addRadius;
						if(newShapes.x2==null)newShapes.x2= i;
						if(newShapes.y2==null)newShapes.y2 =1+newShapes.arrowHeight+addRadius;
						if(newShapes.x3==null)newShapes.x3= (pushInfoI.value==0 ? i : Math.min(i+0.5,i+(arrowWidth/pushInfoI.value)));
						if(newShapes.y3==null)newShapes.y3 = 0.99+addRadius;
						if(newShapes.x4==null)newShapes.x4 = i;
						if(newShapes.y4==null)newShapes.y4 = 1.2+addRadius;
						if(newShapes.fillColor==null)newShapes.fillColor =pushInfoI.color;

						break;
					case "POLARAREA" :
					case "LINE" :
					case "RADAR" :
					case "BAR" :
					case "HORIZONTALBAR" : 
					case "STACKEDBAR" :
					case "HORIZONTALSTACKEDBAR" : 
						// not implemented;
						break;
				};
				break;
			case  "LINE" :	
			default:
				newShapes.shape = annotateLineFunction;
				newShapes.strokeColor=newShapes.linkStrokeColorLine;
				newShapes.strokeStyle=newShapes.linkStrokeStyleLine; 
				newShapes.strokeSize=newShapes.linkStrokeSizeLine;
				switch(type_chart) {
					case "PIE" :
					case "DOUGHNUT" :
						var multRadius;
						var percentageInnerCutout=50;
						if(typeof config.percentageInnerCutout != "undefined")percentageInnerCutout=config.percentageInnerCutout;
						if(type_chart.toUpperCase()=="DOUGHNUT")multRadius=100/(100-percentageInnerCutout);
						else multRadius=1;
                                                addRadius=0;
						if(typeof pushInfoI.expandOutRadius!="undefined")addRadius=1*pushInfoI.expandOutRadius;
						if(newShapes.x1==null)newShapes.x1=i;
						if(newShapes.y1==null)newShapes.y1=1+addRadius;
						if(newShapes.x2==null)newShapes.x2=i;
						if(newShapes.y2==null)newShapes.y2=1+newShapes.piePaddingY*multRadius;
						if(newShapes.x10==null)newShapes.x10=i;
						if(newShapes.y10==null)newShapes.y10=1-multRadius;
						break;
					case "POLARAREA" :
					case "LINE" :
					case "RADAR" :
					case "BAR" :
					case "HORIZONTALBAR" : 
					case "STACKEDBAR" :
					case "HORIZONTALSTACKEDBAR" : 
						// not implemented;
						break;
				};
				break;
			
		}
	
		// push shapesInChart info for the text and Image;
	
	} ;
};


function annotateLineFunction(area, ctx, data, statData, posi,posj,othervars){

	if (typeof ctx.specialInChartData=="undefined")ctx.specialInChartData=[];
	/* compute radius */
	var radius= (Math.sqrt(Math.pow(othervars.xypos2.xpos-othervars.xypos10.xpos,2)+ Math.pow(othervars.xypos2.ypos-othervars.xypos10.ypos,2)));

	var xln, yln;
	var xip, yip;
	var paddingX, paddingY;
	var paddingValX=othervars.shapesInChart.paddingValXLine;
	var paddingValY=othervars.shapesInChart.paddingValYLine;

// line to label;
	
	ctx.beginPath();

	xip=othervars.xypos2.xpos;
	yip=othervars.xypos2.ypos;

		
	if(othervars.xypos10.xpos>othervars.xypos2.xpos) {
		ctx.textAlign="right";
		paddingX=-paddingValX;
		xln=othervars.xypos10.xpos-radius+othervars.shapesInChart.paddingX;
		yln=othervars.xypos2.ypos+othervars.shapesInChart.paddingY;
	} else {
		ctx.textAlign="left";
		paddingX=paddingValX;
		xln=radius + othervars.xypos10.xpos+othervars.shapesInChart.paddingX;
		yln=othervars.xypos2.ypos+othervars.shapesInChart.paddingY;
	}

	if(data[0].shapesInChart[0].avoidOverwrite) {
	
		if (typeof ctx.specialInChartData.prevYln!="undefined") {
			if(Math.abs(ctx.specialInChartData.prevXln-xln)<0.001) {
				if(othervars.xypos10.xpos<othervars.xypos2.xpos) yln=Math.max(yln,ctx.specialInChartData.prevYln+1.5*othervars.shapesInChart.fontSize);
				else yln=Math.min(yln,ctx.specialInChartData.prevYln-1.5*othervars.shapesInChart.fontSize);
			}
		};
		ctx.specialInChartData.prevXln=xln;
		ctx.specialInChartData.prevYln=yln;
	};

	ctx.beginPath();

	ctx.moveTo(othervars.xypos1.xpos, othervars.xypos1.ypos);
	ctx.quadraticCurveTo(xip, yip,xln, yln);
	ctx.lineWidth = othervars.shapesInChart.strokeSize;
	ctx.strokeStyle = othervars.shapesInChart.strokeColor;
	ctx.setLineDash(lineStyleFn(othervars.shapesInChart.strokeStyle));	
	ctx.stroke();

// set text/shape position;
	ctx.beginPath();
	ctx.textBaseline="middle";
	if(othervars.xypos2.ypos<othervars.xypos1.ypos) {
		paddingY=-paddingValY;
	} else {
		paddingY=1*paddingValY;
	}

// draw labels/images;
	drawTextAndImage(area, ctx, data,statData, posi,posj,othervars,xln+paddingX, yln+paddingY);

};


function annotateTriangleFunction(area, ctx, data,statData, posi,posj,othervars){

	if (typeof ctx.specialInChartData=="undefined")ctx.specialInChartData=[];

// triangle to label;
	ctx.beginPath();
	if(othervars.xypos1.xpos==othervars.xypos3.xpos && othervars.xypos1.ypos==othervars.xypos3.ypos) {
		ctx.strokeStyle = othervars.shapesInChart.fillColor;
		ctx.lineWidth = 2;
		ctx.moveTo(othervars.xypos1.xpos, othervars.xypos1.ypos);
		ctx.lineTo(othervars.xypos2.xpos, othervars.xypos2.ypos);
	} else {	
		ctx.moveTo(othervars.xypos1.xpos, othervars.xypos1.ypos);
		ctx.lineWidth = 0;
		ctx.strokeStyle = "rgba(0,0,0,0)";
		ctx.lineTo(othervars.xypos2.xpos, othervars.xypos2.ypos);
		ctx.lineTo(othervars.xypos3.xpos, othervars.xypos3.ypos);
		ctx.closePath();
		ctx.fillStyle=othervars.shapesInChart.fillColor;
		ctx.fill();
	}
	ctx.stroke();



// set Label/image position;
	var paddingX=0;
	var paddingY=0;
	var paddingValX=othervars.shapesInChart.paddingValXTriangle;
	var paddingValY=othervars.shapesInChart.paddingValYTriangle;
	var xln=othervars.xypos4.xpos;
	var yln=othervars.xypos4.ypos;

	ctx.beginPath();
	if(othervars.xypos4.xpos>=othervars.xypos2.xpos) {
		paddingX=paddingValX;
		ctx.textAlign="left";
	} else {
		paddingX=-paddingValX;
		ctx.textAlign="right";
	}
	
	ctx.textBaseline="middle";

	if(data[0].shapesInChart[0].avoidOverwrite) {
	
		if (typeof ctx.specialInChartData.prevYln!="undefined" && ctx.textAlign==ctx.specialInChartData.textAlign) {
				if(othervars.xypos4.xpos>=othervars.xypos2.xpos) { 
					
				
					yln=Math.max(yln,ctx.specialInChartData.prevYln+1.5*othervars.shapesInChart.fontSize);
				} else {
					yln=Math.min(yln,ctx.specialInChartData.prevYln-1.5*othervars.shapesInChart.fontSize);
				}
		}
		ctx.specialInChartData.prevXln=xln;
		ctx.specialInChartData.prevYln=yln;
	};

// draw labels/images;
	ctx.specialInChartData.prevMsr=drawTextAndImage(area, ctx, data,statData, posi,posj,othervars,xln+paddingX, yln+paddingY);
        ctx.specialInChartData.textAlign=ctx.textAlign;
        ctx.specialInChartData.textBaseline=ctx.textBaseline;
        
};

function drawTextAndImage(area, ctx, data,statData, posi,posj,othervars,xpos,ypos) {

	var paddingTextX=0;
	var paddingTextY=0;
	var paddingImageX=0;
	var paddingImageY=0;
	var lgt=0;
	var hgt=0;
	var txtSize=0;
	
	// compute padding values;
	if(othervars.shapesInChart.imageLoad != null && othervars.shapesInChart.text != "") {
		ctx.save();
		var fontSize=othervars.shapesInChart.fontSize;
		ctx.font = othervars.shapesInChart.fontStyle + " " + othervars.shapesInChart.fontSize.toString() + "px " + othervars.shapesInChart.fontFamily;
		ctx.fillStyle = othervars.shapesInChart.fontColor;
		txtSize=ctx.measureTextMultiLine(othervars.shapesInChart.text,othervars.shapesInChart.fontSize);

		if(othervars.shapesInChart.imagePos==1 && ctx.textAlign=="right") {
			paddingTextX=-(othervars.shapesInChart.imageWidth+othervars.shapesInChart.spaceBetweenTextAndImage);
			paddingImageX=-(othervars.shapesInChart.imageWidth);
		} else if(othervars.shapesInChart.imagePos==0 && ctx.textAlign=="left") {
			paddingTextX=othervars.shapesInChart.imageWidth+othervars.shapesInChart.spaceBetweenTextAndImage;
		} else if(othervars.shapesInChart.imagePos==0 && ctx.textAlign=="right") {
			paddingImageX=-(txtSize.textWidth+othervars.shapesInChart.spaceBetweenTextAndImage+othervars.shapesInChart.imageWidth);
		} else if(othervars.shapesInChart.imagePos==1 && ctx.textAlign=="left") {
			paddingImageX=txtSize.textWidth+othervars.shapesInChart.spaceBetweenTextAndImage;
		}
		ctx.restore();
		lgt=othervars.shapesInChart.spaceBetweenTextAndImage;
	};

	// draw text;
	if(othervars.shapesInChart.text!="") {
		ctx.save();
		ctx.translate(xpos+paddingTextX,ypos+paddingTextY);
		var fontSize=othervars.shapesInChart.fontSize;
		ctx.font = othervars.shapesInChart.fontStyle + " " + othervars.shapesInChart.fontSize.toString() + "px " + othervars.shapesInChart.fontFamily;
		ctx.fillStyle = othervars.shapesInChart.fontColor;
		if (othervars.shapesInChart.iter !=="all" || (othervars.shapesInChart.iter === "all" && othervars.cntiter != othervars.config.animationSteps) || othervars.config.animation==false) {
			ctx.fillTextMultiLine(othervars.shapesInChart.text, 0, 0, ctx.textBaseline, Math.ceil(ctx.chartTextScale*fontSize),true,othervars.config.detectMouseOnText,ctx,"SHAPESINCHART_TEXTMOUSE",0,xpos+paddingTextX,ypos+paddingTextY,-1,-1);
		} else ctx.fillTextMultiLine(othervars.shapesInChart.text, 0, 0, ctx.textBaseline, Math.ceil(ctx.chartTextScale*fontSize),true,false,ctx,"SHAPESINCHART_TEXTMOUSE",0,xpos+paddingTextX,ypos+paddingTextY,-1,-1);
		ctx.restore();
		lgt+=txtSize;
		hgt=Math.max(hgt,1.5* othervars.shapesInChart.fontSize);
	}
	// draw image;
	if(othervars.shapesInChart.imageLoad != null) {
		paddingImageY=-(othervars.shapesInChart.imageHeight-((2/3)*txtSize.textHeight/2));

		ctx.save();
//		ctx.translate(xpos+paddingImageX, ypos+paddingImageY -(othervars.shapesInChart.fontSize/2)+imageAfterPaddingY-(othervars.shapesInChart.imageAfterHeight/2));
		ctx.translate(xpos+paddingImageX, ypos+paddingImageY);
		ctx.drawImage(othervars.shapesInChart.imageLoad, 0, 0,othervars.shapesInChart.imageLoad.width,othervars.shapesInChart.imageLoad.height,0, 0,othervars.shapesInChart.imageWidth,othervars.shapesInChart.imageHeight);
		ctx.restore();
		lgt+=othervars.shapesInChart.imageWidth;
		hgt=Math.max(hgt,othervars.shapesInChart.imageWidth.imageHeight);
	}
	
	return {height : hgt,width : lgt};



};





function stats(data, config) {
	data.stats = {};
	if (typeof data.datasets == 'undefined') { // Pie structure;
		PSbasic(data);
	} else { // line structure;
		LSbasic(data);
		Linear_Regression(data);
	}
	replace_stats(data, config);
	return;
};

function isStat(val) {
	if (typeof val == "string") {
		if (val.indexOf("#") >= 0) return true;
	}
	return false;
};

function Linear_Regression(data) {
	// compute Means - source of algorithm : http://fr.wikipedia.org/wiki/R%C3%A9gression_lin%C3%A9aire
	data.stats.linear_regression_count_xPos = 0;
	data.stats.linear_regression_sum_xPos = 0;
	data.stats.linear_regression_sum_data = 0;
	for (var i = 0; i < data.datasets.length; i++) {
		if (!(typeof data.datasets[i].xPos == "undefined")) {
			data.datasets[i].stats.linear_regression_sum_xPos = 0;
			data.datasets[i].stats.linear_regression_sum_data = 0;
			data.datasets[i].stats.linear_regression_count_xPos = 0;
			data.datasets[i].stats.count_data = 0;
			for (var j = 0; j < data.datasets[i].data.length; j++) {
				if (!(typeof data.datasets[i].data[j] == "undefined") && !(typeof data.datasets[i].xPos[j] == "undefined")) {
					data.stats.linear_regression_count_xPos++;
					data.stats.linear_regression_sum_xPos += data.datasets[i].xPos[j];
					data.stats.linear_regression_sum_data += data.datasets[i].data[j];
					data.datasets[i].stats.linear_regression_count_xPos++;
					data.datasets[i].stats.linear_regression_sum_xPos += data.datasets[i].xPos[j];
					data.datasets[i].stats.linear_regression_sum_data += data.datasets[i].data[j];
				}
			}
			if (data.datasets[i].stats.linear_regression_count_xPos > 0) {
				data.datasets[i].stats.linear_regression_mean_xPos = data.datasets[i].stats.linear_regression_sum_xPos / data.datasets[i].stats.linear_regression_count_xPos;
				data.datasets[i].stats.linear_regression_mean_data = data.datasets[i].stats.linear_regression_sum_data / data.datasets[i].stats.linear_regression_count_xPos;
			}
		}
	}
	// mean;
	if (data.stats.linear_regression_count_xPos > 0) {
		data.stats.linear_regression_mean_xPos = data.stats.linear_regression_sum_xPos / data.stats.linear_regression_count_xPos;
		data.stats.linear_regression_mean_data = data.stats.linear_regression_sum_data / data.stats.linear_regression_count_xPos;
	}
	// Covariance - variance;
	data.stats.linear_regression_covariance = 0;
	data.stats.linear_regression_variance = 0;
	for (var i = 0; i < data.datasets.length; i++) {
		if (!(typeof data.datasets[i].xPos == "undefined")) {
			data.datasets[i].stats.linear_regression_covariance = 0;
			data.datasets[i].stats.linear_regression_variance = 0;
			for (var j = 0; j < data.datasets[i].data.length; j++) {
				if (!(typeof data.datasets[i].data[j] == "undefined") && !(typeof data.datasets[i].xPos[j] == "undefined")) {
					data.stats.linear_regression_covariance += (data.datasets[i].xPos[j] - data.stats.linear_regression_mean_xPos) * (data.datasets[i].data[j] - data.stats.linear_regression_mean_data);
					data.stats.linear_regression_variance += (data.datasets[i].xPos[j] - data.stats.linear_regression_mean_xPos) * (data.datasets[i].xPos[j] - data.stats.linear_regression_mean_xPos);
					data.datasets[i].stats.linear_regression_covariance += (data.datasets[i].xPos[j] - data.datasets[i].stats.linear_regression_mean_xPos) * (data.datasets[i].data[j] - data.datasets[i].stats.linear_regression_mean_data);
					data.datasets[i].stats.linear_regression_variance += (data.datasets[i].xPos[j] - data.datasets[i].stats.linear_regression_mean_xPos) * (data.datasets[i].xPos[j] - data.datasets[i].stats.linear_regression_mean_xPos);
				}
			}
			if (data.datasets[i].stats.linear_regression_count_xPos > 0) {
				data.datasets[i].stats.linear_regression_covariance /= data.datasets[i].stats.linear_regression_count_xPos;
				data.datasets[i].stats.linear_regression_variance /= data.datasets[i].stats.linear_regression_count_xPos;
				data.datasets[i].stats.linear_regression_b1 = data.datasets[i].stats.linear_regression_covariance / data.datasets[i].stats.linear_regression_variance;
				data.datasets[i].stats.linear_regression_b0 = data.datasets[i].stats.linear_regression_mean_data - data.datasets[i].stats.linear_regression_b1 * data.datasets[i].stats.linear_regression_mean_xPos;
			}
		}
	}
	// b1 - b0;
	if (data.stats.linear_regression_count_xPos > 0) {
		data.stats.linear_regression_covariance /= data.stats.linear_regression_count_xPos;
		data.stats.linear_regression_variance /= data.stats.linear_regression_count_xPos;
		data.stats.linear_regression_b1 = data.stats.linear_regression_covariance / data.stats.linear_regression_variance;
		data.stats.linear_regression_b0 = data.stats.linear_regression_mean_data - data.stats.linear_regression_b1 * data.stats.linear_regression_mean_xPos;
	}
}

function PSbasic(data) {
	data.stats.sum = 0;
	data.stats.count_all = 0;
	data.stats.count_missing = 0;
	data.stats.count_not_missing = 0;
	data.stats.mean = undefined;
	data.stats.sum_square_diff_mean = 0;
	data.stats.standard_deviation = undefined;
	data.stats.standard_deviation_estimation = undefined;
	data.stats.student_t_test = undefined;
	data.stats.coefficient_variation = undefined;
	data.stats.data_with_stats = false;
	for (var i = 0; i < data["length"]; i++) {
		if (!isStat(data[i].value)) {
			(data.stats.count_all) ++;
		} else data.stats.data_with_stats = true;
		if (typeof data[i].value == "undefined") {
			(data.stats.count_missing) ++;
		} else if (isStat(data[i].value)) {} else {
			(data.stats.count_not_missing) ++;
			(data.stats.sum) += 1 * data[i].value;
		}
	}
	if (data.stats.count_not_missing > 0) {
		data.stats.mean = data.stats.sum / data.stats.count_not_missing;
	}
	// sum of (val-mean)2;
	// sum of (val-mean)3;
	data.stats.sum_square_diff_mean = 0;
	data.stats.sum_pow3_diff_mean = 0;
	data.stats.sum_pow4_diff_mean = 0;
	for (var i = 0; i < data["length"]; i++) {
		if (typeof data[i].value != "undefined" && !isStat(data[i].value)) {
			data.stats.sum_square_diff_mean += Math.pow(data[i].value - data.stats.mean, 2);
			data.stats.sum_pow3_diff_mean += Math.pow(data[i].value - data.stats.mean, 3);
			data.stats.sum_pow4_diff_mean += Math.pow(data[i].value - data.stats.mean, 4);
		}
	}
	// standard deviation;
	if (data.stats.count_not_missing > 0) {
		data.stats.variance = data.stats.sum_square_diff_mean / data.stats.count_not_missing;
		data.stats.standard_deviation = Math.sqrt(data.stats.sum_square_diff_mean / data.stats.count_not_missing);
		data.stats.standard_error_mean = Math.sqrt(data.stats.sum_square_diff_mean) / data.stats.count_not_missing;
	}
	// standard deviation estimation;
	if (data.stats.count_not_missing > 1) {
		data.stats.standard_deviation_estimation = Math.sqrt(data.stats.sum_square_diff_mean / (data.stats.count_not_missing - 1));
		if (data.stats.mean > 0) data.stats.coefficient_variation = 100 * data.stats.standard_deviation_estimation / data.stats.mean;
		if (data.stats.standard_deviation_estimation > 0) data.stats.student_t_test = data.stats.mean / (data.stats.standard_deviation_estimation / Math.sqrt(data.stats.count_not_missing));
//		console.log(data.stats.mean);
//		console.log(data.stats.standard_deviation_estimation);
//		console.log(data.stats.count_not_missing);
	}
	// skewness;
	if (data.stats.count_not_missing > 2) {
		data.stats.skewness = (data.stats.count_not_missing * data.stats.sum_pow3_diff_mean) / (Math.pow(data.stats.standard_deviation_estimation, 3) * (data.stats.count_not_missing - 1) * (data.stats.count_not_missing - 2));
	} else {
		data.stats.skewness = undefined;
	}
	// kutosis;
	if (data.stats.count_not_missing > 3) {
		data.stats.kurtosis = (data.stats.count_not_missing * (data.stats.count_not_missing + 1) * data.stats.sum_pow4_diff_mean) / (Math.pow(data.stats.standard_deviation_estimation, 4) * (data.stats.count_not_missing - 1) * (data.stats.count_not_missing - 2) * (data.stats.count_not_missing - 3)) - 3 * (data.stats.count_not_missing - 1) * (data.stats.count_not_missing - 1) / ((data.stats.count_not_missing - 2) * (data.stats.count_not_missing - 3));
	} else {
		data.stats.kurtosis = undefined;
	}
	// ordering stats;
	var orderStat = new Array();
	cnt = 0;
	for (i = 0; i < data.length; i++) {
		if (typeof data[i].value != "undefined" && !isStat(data[i].value)) {
			orderStat[cnt] = {
				val: 1 * data[i].value,
				one: 1
			};
			cnt++;
		}
	}
	var setStat = new Array();
	setStat = Pstats(orderStat, "one");
	for (i = 0; i < setStat.length; i++) {
		data.stats.minimum = setStat[i].res.minimum;
		data.stats.minimumpi = setStat[i].res.minimumpi;
		data.stats.minimumpj = setStat[i].res.minimumpj;
		data.stats.maximum = setStat[i].res.maximum;
		data.stats.maximumpi = setStat[i].res.maximumpi;
		data.stats.maximumpj = setStat[i].res.maximumpj;
		data.stats.Q0 = setStat[i].res.Q0;
		data.stats.Q1 = setStat[i].res.Q1;
		data.stats.Q5 = setStat[i].res.Q5;
		data.stats.Q10 = setStat[i].res.Q10;
		data.stats.Q25 = setStat[i].res.Q25;
		data.stats.Q50 = setStat[i].res.Q50;
		data.stats.Q75 = setStat[i].res.Q75;
		data.stats.Q90 = setStat[i].res.Q90;
		data.stats.Q95 = setStat[i].res.Q95;
		data.stats.Q99 = setStat[i].res.Q99;
		data.stats.Q100 = setStat[i].res.Q100;
		data.stats.median = setStat[i].res.median;
		data.stats.interquartile_range = data.stats.Q75 - data.stats.Q25;
	}
};

function LSbasic(data) {
	data.stats.sum = 0;
	data.stats.count_all = 0;
	data.stats.count_missing = 0;
	data.stats.count_not_missing = 0;
	data.stats.mean = undefined;
	data.stats.sum_square_diff_mean = 0;
	data.stats.sum_pow3_diff_mean = 0;
	data.stats.sum_pow4_diff_mean = 0;
	data.stats.standard_deviation = undefined;
	data.stats.standard_deviation_estimation = undefined;
	data.stats.student_t_test = undefined;
	data.stats.coefficient_variation = undefined;
	data.stats.data_with_stats = false;
	data.stats.data_minimum = {};
	data.stats.data_maximum = {};
	data.stats.data_minimumpi = {};
	data.stats.data_maximumpi = {};
	data.stats.data_minimumpj = {};
	data.stats.data_maximumpj = {};
	data.stats.data_Q0 = {};
	data.stats.data_Q1 = {};
	data.stats.data_Q5 = {};
	data.stats.data_Q10 = {};
	data.stats.data_Q25 = {};
	data.stats.data_Q50 = {};
	data.stats.data_Q75 = {};
	data.stats.data_Q90 = {};
	data.stats.data_Q95 = {};
	data.stats.data_Q99 = {};
	data.stats.data_Q100 = {};
	data.stats.data_median = {};
	data.stats.data_sum = {};
	data.stats.data_count_all = {};
	data.stats.data_count_missing = {};
	data.stats.data_count_not_missing = {};
	data.stats.data_mean = {};
	data.stats.data_sum_square_diff_mean = {};
	data.stats.data_sum_pow3_diff_mean = {};
	data.stats.data_sum_pow4_diff_mean = {};
	data.stats.data_variance = {};
	data.stats.data_standard_deviation = {};
	data.stats.data_standard_error_mean = {};
	data.stats.data_standard_deviation_estimation = {};
	data.stats.data_student_t_test = {};
	data.stats.data_coefficient_variation = {};
	data.stats.data_skewness = {};
	data.stats.data_kurtosis = {};
	data.stats.data_interquartile_range = {};
	data.stats.max_number_data = 0;
	data.stats.min_number_data = Number.MAX_VALUE;
	for (var i = 0; i < data.datasets["length"]; i++) {
		data.datasets[i].stats = {};
		data.datasets[i].stats.sum = 0;
		data.datasets[i].stats.count_all = 0;
		data.datasets[i].stats.count_missing = 0;
		data.datasets[i].stats.count_not_missing = 0;
		data.datasets[i].stats.mean = undefined;
		data.datasets[i].stats.sum_square_diff_mean = 0;
		data.datasets[i].stats.sum_pow3_diff_mean = 0;
		data.datasets[i].stats.sum_pow4_diff_mean = 0;
		data.datasets[i].stats.standard_deviation = undefined;
		if (data.datasets[i].data["length"] > data.stats.max_number_data) {
			for (var k = data.stats.max_number_data; k < data.datasets[i].data["length"]; k++) {
				data.stats.data_sum[k] = 0;
				data.stats.data_count_all[k] = 0;
				data.stats.data_count_missing[k] = 0;
				data.stats.data_count_not_missing[k] = 0;
				data.stats.data_mean[k] = undefined;
				data.stats.data_sum_square_diff_mean[k] = 0;
				data.stats.data_sum_pow3_diff_mean[k] = 0;
				data.stats.data_sum_pow4_diff_mean[k] = 0;
				data.stats.data_standard_deviation[k] = undefined;
				data.stats.data_standard_deviation_estimation[k] = undefined;
				data.stats.data_student_t_test[k] = undefined;
				data.stats.data_coefficient_variation[k] = undefined;
			}
			data.stats.max_number_data = data.datasets[i].data["length"];
			data.stats.min_number_data = Math.min(data.stats.min_number_data, data.datasets[i].data["length"]);
		}
		for (var j = 0; j < data.datasets[i].data["length"]; j++) {
			if (!isStat(data.datasets[i].data[j])) {
				(data.stats.count_all) ++;
				(data.datasets[i].stats.count_all) ++;
				(data.stats.data_count_all[j]) ++;
			} else {
				data.stats.data_with_stats = true;
			}
			if (typeof data.datasets[i].data[j] == "undefined") {
				(data.stats.count_missing) ++;
				(data.datasets[i].stats.count_missing) ++;
				(data.stats.data_count_missing[j]) ++;
			} else if (isStat(data.datasets[i].data[j])) {} else {
				(data.stats.count_not_missing) ++;
				(data.datasets[i].stats.count_not_missing) ++;
				(data.stats.data_count_not_missing[j]) ++;
				(data.stats.sum) += 1 * data.datasets[i].data[j];
				(data.datasets[i].stats.sum) += 1 * data.datasets[i].data[j];
				(data.stats.data_sum[j]) += 1 * data.datasets[i].data[j];
			}
		}
		if (data.datasets[i].stats.count_not_missing == 0) {
			data.datasets[i].stats.minimum = undefined;
			data.datasets[i].stats.minimumpi = undefined;
			data.datasets[i].stats.minimumpj = undefined;
			data.datasets[i].stats.maximum = undefined;
			data.datasets[i].stats.maximumpi = undefined;
			data.datasets[i].stats.maximumpj = undefined;
			data.datasets[i].stats.sum = undefined;
			data.datasets[i].stats.mean = undefined;
		} else {
			data.datasets[i].stats.mean = data.datasets[i].stats.sum / data.datasets[i].stats.count_not_missing;
		}
	}
	if (data.stats.count_not_missing > 0) {
		data.stats.mean = data.stats.sum / data.stats.count_not_missing;
	}
	for (i = 0; i < data.stats.max_number_data; i++) {
		if (data.stats.data_count_not_missing[i] > 0) {
			data.stats.data_mean[i] = data.stats.data_sum[i] / data.stats.data_count_not_missing[i];
		}
	}
	// sum of (val-mean)2;
	data.stats.sum_square_diff_mean = 0;
	data.stats.sum_pow3_diff_mean = 0;
	data.stats.sum_pow4_diff_mean = 0;
	for (var i = 0; i < data.datasets["length"]; i++) {
		data.datasets[i].stats.sum_square_diff_mean = 0;
		data.datasets[i].stats.sum_pow3_diff_mean = 0;
		data.datasets[i].stats.sum_pow4_diff_mean = 0;
		for (var j = 0; j < data.datasets[i].data["length"]; j++) {
			if (typeof data.datasets[i].data[j] != "undefined" && !isStat(data.datasets[i].data[j].value)) {
				data.stats.sum_square_diff_mean += Math.pow(data.datasets[i].data[j] - data.stats.mean, 2);
				data.stats.sum_pow3_diff_mean += Math.pow(data.datasets[i].data[j] - data.stats.mean, 3);
				data.stats.sum_pow4_diff_mean += Math.pow(data.datasets[i].data[j] - data.stats.mean, 4);
				data.stats.data_sum_square_diff_mean[j] += Math.pow(data.datasets[i].data[j] - data.stats.data_mean[j], 2);
				data.stats.data_sum_pow3_diff_mean[j] += Math.pow(data.datasets[i].data[j] - data.stats.data_mean[j], 3);
				data.stats.data_sum_pow4_diff_mean[j] += Math.pow(data.datasets[i].data[j] - data.stats.data_mean[j], 4);
				data.datasets[i].stats.sum_square_diff_mean += Math.pow(data.datasets[i].data[j] - data.datasets[i].stats.mean, 2);
				data.datasets[i].stats.sum_pow3_diff_mean += Math.pow(data.datasets[i].data[j] - data.datasets[i].stats.mean, 3);
				data.datasets[i].stats.sum_pow4_diff_mean += Math.pow(data.datasets[i].data[j] - data.datasets[i].stats.mean, 4);
			}
		}
	}
	// standard deviation;
	if (data.stats.count_not_missing > 0) {
		data.stats.variance = data.stats.sum_square_diff_mean / data.stats.count_not_missing;
		data.stats.standard_deviation = Math.sqrt(data.stats.sum_square_diff_mean / data.stats.count_not_missing);
		data.stats.standard_error_mean = Math.sqrt(data.stats.sum_square_diff_mean) / data.stats.count_not_missing;
	}
	for (i = 0; i < data.datasets["length"]; i++) {
		if (data.datasets[i].stats.count_not_missing > 0) {
			data.datasets[i].stats.variance = data.datasets[i].stats.sum_square_diff_mean / data.datasets[i].stats.count_not_missing;
			data.datasets[i].stats.standard_deviation = Math.sqrt(data.datasets[i].stats.sum_square_diff_mean / data.datasets[i].stats.count_not_missing);
			data.datasets[i].stats.standard_error_mean = Math.sqrt(data.datasets[i].stats.sum_square_diff_mean) / data.datasets[i].stats.count_not_missing;
		}
	}
	for (j = 0; j < data.stats.max_number_data; j++) {
		if (data.stats.data_count_not_missing[j] > 0) {
			data.stats.data_variance[j] = data.stats.data_sum_square_diff_mean[j] / data.stats.data_count_not_missing[j];
			data.stats.data_standard_deviation[j] = Math.sqrt(data.stats.data_sum_square_diff_mean[j] / data.stats.data_count_not_missing[j]);
			data.stats.data_standard_error_mean[j] = Math.sqrt(data.stats.data_sum_square_diff_mean[j]) / data.stats.data_count_not_missing[j];
		}
	}
	// standard deviation estimation;
	if (data.stats.count_not_missing > 1) {
		data.stats.standard_deviation_estimation = Math.sqrt(data.stats.sum_square_diff_mean / (data.stats.count_not_missing - 1));
		if (data.stats.mean > 0) data.stats.coefficient_variation = 100 * data.stats.standard_deviation_estimation / data.stats.mean;
		if (data.stats.standard_deviation_estimation > 0) data.stats.student_t_test = data.stats.mean / (data.stats.standard_deviation_estimation / Math.sqrt(data.stats.count_not_missing));
	}
	for (i = 0; i < data.datasets["length"]; i++) {
		if (data.datasets[i].stats.count_not_missing > 1) {
			data.datasets[i].stats.standard_deviation_estimation = Math.sqrt(data.datasets[i].stats.sum_square_diff_mean / (data.datasets[i].stats.count_not_missing - 1));
			if (data.datasets[i].stats.mean > 0) data.datasets[i].stats.coefficient_variation = 100 * data.datasets[i].stats.standard_deviation_estimation / data.datasets[i].stats.mean;
			if (data.datasets[i].stats.standard_deviation_estimation > 0) data.datasets[i].stats.student_t_test = data.datasets[i].stats.mean / (data.datasets[i].stats.standard_deviation_estimation / Math.sqrt(data.datasets[i].stats.count_not_missing));
		}
	}
	for (j = 0; j < data.stats.max_number_data; j++) {
		if (data.stats.data_count_not_missing[j] > 1) {
			data.stats.data_standard_deviation_estimation[j] = Math.sqrt(data.stats.data_sum_square_diff_mean[j] / (data.stats.data_count_not_missing[j] - 1));
			if (data.stats.data_mean[j] > 0) data.stats.data_coefficient_variation[j] = 100 * data.stats.data_standard_deviation_estimation[j] / data.stats.data_mean[j];
			if (data.stats.data_standard_deviation_estimation[j] > 0) data.stats.data_student_t_test[j] = data.stats.data_mean[j] / (data.stats.data_standard_deviation_estimation[j] / Math.sqrt(data.stats.data_count_not_missing[j]));
		}
	}
	// skewness;
	if (data.stats.count_not_missing >= 2) {
		data.stats.skewness = (data.stats.count_not_missing * data.stats.sum_pow3_diff_mean) / (Math.pow(data.stats.standard_deviation_estimation, 3) * (data.stats.count_not_missing - 1) * (data.stats.count_not_missing - 2));
	} else {
		data.stats.skewness = undefined;
	}
	// kurtosis;
	if (data.stats.count_not_missing >= 3) {
		data.stats.kurtosis = (data.stats.count_not_missing * (data.stats.count_not_missing + 1) * data.stats.sum_pow4_diff_mean) / (Math.pow(data.stats.standard_deviation_estimation, 4) * (data.stats.count_not_missing - 1) * (data.stats.count_not_missing - 2) * (data.stats.count_not_missing - 3)) - 3 * (data.stats.count_not_missing - 1) * (data.stats.count_not_missing - 1) / ((data.stats.count_not_missing - 2) * (data.stats.count_not_missing - 3));
	} else {
		data.stats.kurtosis = undefined;
	}
	for (i = 0; i < data.datasets["length"]; i++) {
		if (data.datasets[i].stats.count_not_missing >= 2) {
			data.datasets[i].stats.skewness = (data.datasets[i].stats.count_not_missing * data.datasets[i].stats.sum_pow3_diff_mean) / (Math.pow(data.datasets[i].stats.standard_deviation_estimation, 3) * (data.datasets[i].stats.count_not_missing - 1) * (data.datasets[i].stats.count_not_missing - 2));
		} else {
			data.datasets[i].stats.skewness = undefined;
		}
		if (data.datasets[i].stats.count_not_missing >= 3) {
			data.datasets[i].stats.kurtosis = (data.datasets[i].stats.count_not_missing * (data.datasets[i].stats.count_not_missing + 1) * data.datasets[i].stats.sum_pow4_diff_mean) / (Math.pow(data.datasets[i].stats.standard_deviation_estimation, 4) * (data.datasets[i].stats.count_not_missing - 1) * (data.datasets[i].stats.count_not_missing - 2) * (data.datasets[i].stats.count_not_missing - 3)) - 3 * (data.datasets[i].stats.count_not_missing - 1) * (data.datasets[i].stats.count_not_missing - 1) / ((data.datasets[i].stats.count_not_missing - 2) * (data.datasets[i].stats.count_not_missing - 3));
		} else {
			data.datasets[i].stats.kurtosis = undefined;
		}
	}
	for (j = 0; j < data.stats.max_number_data; j++) {
		if (data.stats.data_count_not_missing[j] >= 2) {
			data.stats.data_skewness[j] = (data.stats.data_count_not_missing[j] * data.stats.data_sum_pow3_diff_mean[j]) / (Math.pow(data.stats.data_standard_deviation_estimation[j], 3) * (data.stats.data_count_not_missing[j] - 1) * (data.stats.data_count_not_missing[j] - 2));
		} else {
			data.stats.data_skewness[j] = undefined;
		}
		if (data.stats.data_count_not_missing[j] >= 3) {
			data.stats.data_kurtosis[j] = (data.stats.data_count_not_missing[j] * (data.stats.data_count_not_missing[j] + 1) * data.stats.data_sum_pow4_diff_mean[j]) / (Math.pow(data.stats.data_standard_deviation_estimation[j], 4) * (data.stats.data_count_not_missing[j] - 1) * (data.stats.data_count_not_missing[j] - 2) * (data.stats.data_count_not_missing[j] - 3)) - 3 * (data.stats.data_count_not_missing[j] - 1) * (data.stats.data_count_not_missing[j] - 1) / ((data.stats.data_count_not_missing[j] - 2) * (data.stats.data_count_not_missing[j] - 3));
		} else {
			data.stats.data_kurtosis[j] = undefined;
		}
	}
	// ordering stats;
	var orderStat = new Array();
	cnt = 0;
	for (i = 0; i < data.datasets["length"]; i++) {
		for (j = 0; j < data.datasets[i].data["length"]; j++) {
			if (typeof data.datasets[i].data[j] != "undefined" && !isStat(data.datasets[i].data[j].value)) {
				orderStat[cnt] = {
					val: 1 * data.datasets[i].data[j],
					dataset: i,
					col: j,
					one: 1
				};
				cnt++;
			}
		}
	}
	var setStat = new Array();
	setStat = Pstats(orderStat, "one");
	for (i = 0; i < setStat.length; i++) {
		data.stats.minimum = setStat[i].res.minimum;
		data.stats.minimumpi = setStat[i].res.minimumpi;
		data.stats.minimumpj = setStat[i].res.minimumpj;
		data.stats.maximum = setStat[i].res.maximum;
		data.stats.maximumpi = setStat[i].res.maximumpi;
		data.stats.maximumpj = setStat[i].res.maximumpj;
		data.stats.Q0 = setStat[i].res.Q0;
		data.stats.Q1 = setStat[i].res.Q1;
		data.stats.Q5 = setStat[i].res.Q5;
		data.stats.Q10 = setStat[i].res.Q10;
		data.stats.Q25 = setStat[i].res.Q25;
		data.stats.Q50 = setStat[i].res.Q50;
		data.stats.Q75 = setStat[i].res.Q75;
		data.stats.Q90 = setStat[i].res.Q90;
		data.stats.Q95 = setStat[i].res.Q95;
		data.stats.Q99 = setStat[i].res.Q99;
		data.stats.Q100 = setStat[i].res.Q100;
		data.stats.median = setStat[i].res.median;
		data.stats.interquartile_range = data.stats.Q75 - data.stats.Q25;
	}
	setStat = Pstats(orderStat, "dataset");
	for (i = 0; i < setStat.length; i++) {
		data.datasets[setStat[i].secvalue].stats.minimum = setStat[i].res.minimum;
		data.datasets[setStat[i].secvalue].stats.minimumpi = setStat[i].res.minimumpi;
		data.datasets[setStat[i].secvalue].stats.minimumpj = setStat[i].res.minimumpj;
		data.datasets[setStat[i].secvalue].stats.maximum = setStat[i].res.maximum;
		data.datasets[setStat[i].secvalue].stats.maximumpi = setStat[i].res.maximumpi;
		data.datasets[setStat[i].secvalue].stats.maximumpj = setStat[i].res.maximumpj;
		data.datasets[setStat[i].secvalue].stats.Q0 = setStat[i].res.Q0;
		data.datasets[setStat[i].secvalue].stats.Q1 = setStat[i].res.Q1;
		data.datasets[setStat[i].secvalue].stats.Q5 = setStat[i].res.Q5;
		data.datasets[setStat[i].secvalue].stats.Q10 = setStat[i].res.Q10;
		data.datasets[setStat[i].secvalue].stats.Q25 = setStat[i].res.Q25;
		data.datasets[setStat[i].secvalue].stats.Q50 = setStat[i].res.Q50;
		data.datasets[setStat[i].secvalue].stats.Q75 = setStat[i].res.Q75;
		data.datasets[setStat[i].secvalue].stats.Q90 = setStat[i].res.Q90;
		data.datasets[setStat[i].secvalue].stats.Q95 = setStat[i].res.Q95;
		data.datasets[setStat[i].secvalue].stats.Q99 = setStat[i].res.Q99;
		data.datasets[setStat[i].secvalue].stats.Q100 = setStat[i].res.Q100;
		data.datasets[setStat[i].secvalue].stats.median = setStat[i].res.median;
		data.datasets[setStat[i].secvalue].stats.interquartile_range = data.datasets[setStat[i].secvalue].stats.Q75 - data.datasets[setStat[i].secvalue].stats.Q25;
	}
	setStat = Pstats(orderStat, "col");
	for (i = 0; i < setStat.length; i++) {
		data.stats.data_minimum[setStat[i].secvalue] = setStat[i].res.minimum;
		data.stats.data_minimumpi[setStat[i].secvalue] = setStat[i].res.minimumpi;
		data.stats.data_minimumpj[setStat[i].secvalue] = setStat[i].res.minimumpj;
		data.stats.data_maximum[setStat[i].secvalue] = setStat[i].res.maximum;
		data.stats.data_maximumpi[setStat[i].secvalue] = setStat[i].res.maximumpi;
		data.stats.data_maximumpj[setStat[i].secvalue] = setStat[i].res.maximumpj;
		data.stats.data_Q0[setStat[i].secvalue] = setStat[i].res.Q0;
		data.stats.data_Q1[setStat[i].secvalue] = setStat[i].res.Q1;
		data.stats.data_Q5[setStat[i].secvalue] = setStat[i].res.Q5;
		data.stats.data_Q10[setStat[i].secvalue] = setStat[i].res.Q10;
		data.stats.data_Q25[setStat[i].secvalue] = setStat[i].res.Q25;
		data.stats.data_Q50[setStat[i].secvalue] = setStat[i].res.Q50;
		data.stats.data_Q75[setStat[i].secvalue] = setStat[i].res.Q75;
		data.stats.data_Q90[setStat[i].secvalue] = setStat[i].res.Q90;
		data.stats.data_Q95[setStat[i].secvalue] = setStat[i].res.Q95;
		data.stats.data_Q99[setStat[i].secvalue] = setStat[i].res.Q99;
		data.stats.data_Q100[setStat[i].secvalue] = setStat[i].res.Q100;
		data.stats.data_median[setStat[i].secvalue] = setStat[i].res.median;
		data.stats.data_interquartile_range[setStat[i].secvalue] = data.stats.data_Q75[setStat[i].secvalue] - data.stats.data_Q25[setStat[i].secvalue];
	}
};

function Pstats(orderStat, secVar) {
	var result = new Array();
	orderStat.sort(function(a, b) {
		if (a[secVar] < b[secVar]) return -1
		else if (a[secVar] > b[secVar]) return 1
		if (a.val < b.val) return -1
		else if (a.val > b.val) return 1
		else return 0
	});
	var deb = 0,
		fin = 0;
	for (i = 1; i < orderStat.length; i++) {
		if (orderStat[i][secVar] == orderStat[deb][secVar]) fin++;
		else {
			result[result.length] = {
				secvalue: orderStat[deb][secVar],
				res: P2stats(deb, fin, orderStat)
			};
			fin++;
			deb = fin;
		}
	}
	result[result.length] = {
		secvalue: orderStat[deb][secVar],
		res: P2stats(deb, fin, orderStat)
	};
	return result;
};

function P2stats(deb, fin, orderStat) {
	return {
		minimum: orderStat[deb].val,
		minimumpi : orderStat[deb].dataset,
		minimumpj : orderStat[deb].col,
		maximum: orderStat[fin].val,
		maximumpi : orderStat[fin].dataset,
		maximumpj : orderStat[fin].col,
		Q0: orderStat[deb].val,
		Q1: Quantile(1, deb, fin, orderStat),
		Q5: Quantile(5, deb, fin, orderStat),
		Q10: Quantile(10, deb, fin, orderStat),
		Q25: Quantile(25, deb, fin, orderStat),
		Q50: Quantile(50, deb, fin, orderStat),
		Q75: Quantile(75, deb, fin, orderStat),
		Q90: Quantile(90, deb, fin, orderStat),
		Q95: Quantile(95, deb, fin, orderStat),
		Q99: Quantile(99, deb, fin, orderStat),
		Q100: orderStat[fin].val,
		median: Quantile(50, deb, fin, orderStat)
	}
};

function Quantile(quant, deb, fin, orderStat) {
	var nbobs = fin - deb + 1;
	if (quant <= 50.01) {
		var v1 = Math.ceil((nbobs * quant / 100) - 0.000001) - 1;
		var v2 = Math.ceil(((nbobs + 1) * quant / 100) - 0.000001) - 1;
	} else {
		var v1 = Math.ceil((nbobs * (100 - quant) / 100) - 0.000001) - 1;
		v1 = nbobs - v1 - 1;
		var v2 = Math.ceil(((nbobs + 1) * (100 - quant) / 100) - 0.000001) - 1;
		v2 = nbobs - v2 - 1;
	}
	//  if(deb+v2>fin)v2=fin-deb-1;
	return ((orderStat[deb + v1].val + orderStat[deb + v2].val) / 2);
};

function disp_stats(data) {
	document.write("data.stats.count_all=" + data.stats.count_all + "<BR>");
	document.write("data.stats.count_missing=" + data.stats.count_missing + "<BR>");
	document.write("data.stats.count_not_missing=" + data.stats.count_not_missing + "<BR>");
	document.write("data.stats.minimum=" + data.stats.minimum + "<BR>");
	document.write("data.stats.minimumpi=" + data.stats.minimumpi + "<BR>");
	document.write("data.stats.minimumpj=" + data.stats.minimumpj + "<BR>");
	document.write("data.stats.maximum=" + data.stats.maximum + "<BR>");
	document.write("data.stats.maximumpi=" + data.stats.maximumpi + "<BR>");
	document.write("data.stats.maximumpj=" + data.stats.maximumpj + "<BR>");
	document.write("data.stats.sum=" + data.stats.sum + "<BR>");
	document.write("data.stats.mean=" + data.stats.mean + "<BR>");
	document.write("data.stats.sum_square_diff_mean=" + data.stats.sum_square_diff_mean + "<BR>");
	document.write("data.stats.variance=" + data.stats.variance + "<BR>");
	document.write("data.stats.standard _deviation=" + data.stats.standard_deviation + "<BR>");
	document.write("data.stats.standard_error_mean=" + data.stats.standard_error_mean + "<BR>");
	document.write("data.stats.standard_deviation_estimation=" + data.stats.standard_deviation_estimation + "<BR>");
	document.write("data.stats.coefficient_variation=" + data.stats.coefficient_variation + "<BR>");
	document.write("data.stats.skewness=" + data.stats.skewness + "<BR>");
	document.write("data.stats.kurtosis=" + data.stats.kurtosis + "<BR>");
	document.write("data.stats.student_t_test=" + data.stats.student_t_test + "<BR>");
	document.write("data.stats.Q0" + data.stats.Q0 + "<BR>");
	document.write("data.stats.Q1=" + data.stats.Q1 + "<BR>");
	document.write("data.stats.Q5=" + data.stats.Q5 + "<BR>");
	document.write("data.stats.Q10=" + data.stats.Q10 + "<BR>");
	document.write("data.stats.Q25=" + data.stats.Q25 + "<BR>");
	document.write("data.stats.Q50=" + data.stats.Q50 + "<BR>");
	document.write("data.stats.Q75=" + data.stats.Q75 + "<BR>");
	document.write("data.stats.Q90=" + data.stats.Q90 + "<BR>");
	document.write("data.stats.Q95=" + data.stats.Q95 + "<BR>");
	document.write("data.stats.Q99=" + data.stats.Q99 + "<BR>");
	document.write("data.stats.Q100=" + data.stats.Q100 + "<BR>");
	document.write("data.stats.median=" + data.stats.median + "<BR>");
	document.write("data.stats.interquartile_range=" + data.stats.interquartile_range + "<BR>");
	document.write("<hr>")
	if (typeof data.datasets != 'undefined') {
		for (i = 0; i < data.datasets.length; i++) {
			document.write("<hr>")
			document.write("DATASET: " + i + "<BR>");
			document.write("data.datasets[" + i + "].stats.count_all=" + data.datasets[i].stats.count_all + "<BR>");
			document.write("data.datasets[" + i + "].stats.count_missing=" + data.datasets[i].stats.count_missing + "<BR>");
			document.write("data.datasets[" + i + "].stats.count_not_missing=" + data.datasets[i].stats.count_not_missing + "<BR>");
			document.write("data.datasets[" + i + "].stats.minimum=" + data.datasets[i].stats.minimum + "<BR>");
			document.write("data.datasets[" + i + "].stats.minimumpi=" + data.datasets[i].stats.minimumpi + "<BR>");
			document.write("data.datasets[" + i + "].stats.minimumpj=" + data.datasets[i].stats.minimumpj + "<BR>");
			document.write("data.datasets[" + i + "].stats.maximum=" + data.datasets[i].stats.maximum + "<BR>");
			document.write("data.datasets[" + i + "].stats.maximumpi=" + data.datasets[i].stats.maximumpi + "<BR>");
			document.write("data.datasets[" + i + "].stats.maximumpj=" + data.datasets[i].stats.maximumpj + "<BR>");
			document.write("data.datasets[" + i + "].stats.sum=" + data.datasets[i].stats.sum + "<BR>");
			document.write("data.datasets[" + i + "].stats.mean=" + data.datasets[i].stats.mean + "<BR>");
			document.write("data.datasets[" + i + "].stats.sum_square_diff_mean=" + data.datasets[i].stats.sum_square_diff_mean + "<BR>");
			document.write("data.datasets[" + i + "].stats.variance=" + data.datasets[i].stats.variance + "<BR>");
			document.write("data.datasets[" + i + "].stats.standard_deviation=" + data.datasets[i].stats.standard_deviation + "<BR>");
			document.write("data.datasets[" + i + "].stats.standard_error_mean=" + data.datasets[i].stats.standard_error_mean + "<BR>");
			document.write("data.datasets[" + i + "].stats.standard_deviation_estimation=" + data.datasets[i].stats.standard_deviation_estimation + "<BR>");
			document.write("data.datasets[" + i + "].stats.student_t_test=" + data.datasets[i].stats.student_t_test + "<BR>");
			document.write("data.datasets[" + i + "].stats.coefficient_variation=" + data.datasets[i].stats.coefficient_variation + "<BR>");
			document.write("data.datasets[" + i + "]stats.skewness=" + data.datasets[i].stats.skewness + "<BR>");
			document.write("data.datasets[" + i + "]stats.kurtosis=" + data.datasets[i].stats.kurtosis + "<BR>");
			document.write("data.datasets[" + i + "].stats.Q0=" + data.datasets[i].stats.Q0 + "<BR>");
			document.write("data.datasets[" + i + "].stats.Q1=" + data.datasets[i].stats.Q1 + "<BR>");
			document.write("data.datasets[" + i + "].stats.Q5=" + data.datasets[i].stats.Q5 + "<BR>");
			document.write("data.datasets[" + i + "].stats.Q10=" + data.datasets[i].stats.Q10 + "<BR>");
			document.write("data.datasets[" + i + "].stats.Q25=" + data.datasets[i].stats.Q25 + "<BR>");
			document.write("data.datasets[" + i + "].stats.Q50=" + data.datasets[i].stats.Q50 + "<BR>");
			document.write("data.datasets[" + i + "].stats.Q75=" + data.datasets[i].stats.Q75 + "<BR>");
			document.write("data.datasets[" + i + "].stats.Q90=" + data.datasets[i].stats.Q90 + "<BR>");
			document.write("data.datasets[" + i + "].stats.Q95=" + data.datasets[i].stats.Q95 + "<BR>");
			document.write("data.datasets[" + i + "].stats.Q99=" + data.datasets[i].stats.Q99 + "<BR>");
			document.write("data.datasets[" + i + "].stats.Q100=" + data.datasets[i].stats.Q100 + "<BR>");
			document.write("data.datasets[" + i + "].stats.median=" + data.datasets[i].stats.median + "<BR>");
			document.write("data.datasets[" + i + "].stats.interquartile_range=" + data.datasets[i].stats.interquartile_range + "<BR>");
		}
		document.write("<hr>")
		for (i = 0; i < data.stats.max_number_data; i++) {
			document.write("<hr>")
			document.write("Data: " + i + "<BR>");
			document.write("data.stats.data_count_all[" + i + "]=" + data.stats.data_count_all[i] + "<BR>");
			document.write("data.stats.data_count_missing[" + i + "]=" + data.stats.data_count_missing[i] + "<BR>");
			document.write("data.stats.data_count_not_missing[" + i + "]=" + data.stats.data_count_not_missing[i] + "<BR>");
			document.write("data.stats.data_minimum[" + i + "]=" + data.stats.data_minimum[i] + "<BR>");
			document.write("data.stats.data_minimumpi[" + i + "]=" + data.stats.data_minimumpi[i] + "<BR>");
			document.write("data.stats.data_minimumpj[" + i + "]=" + data.stats.data_minimumpj[i] + "<BR>");
			document.write("data.stats.data_maximum[" + i + "]=" + data.stats.data_maximum[i] + "<BR>");
			document.write("data.stats.data_maximumpi[" + i + "]=" + data.stats.data_maximumpi[i] + "<BR>");
			document.write("data.stats.data_maximumpj[" + i + "]=" + data.stats.data_maximumpj[i] + "<BR>");
			document.write("data.stats.data_sum[" + i + "]=" + data.stats.data_sum[i] + "<BR>");
			document.write("data.stats.data_mean[" + i + "]=" + data.stats.data_mean[i] + "<BR>");
			document.write("data.stats.data_sum_square_diff_mean[" + i + "]=" + data.stats.data_sum_square_diff_mean[i] + "<BR>");
			document.write("data.stats.data_variance[" + i + "]=" + data.stats.data_variance[i] + "<BR>");
			document.write("data.stats.data_standard_deviation[" + i + "]=" + data.stats.data_standard_deviation[i] + "<BR>");
			document.write("data.stats.data_standard_error_mean[" + i + "]=" + data.stats.data_standard_error_mean[i] + "<BR>");
			document.write("data.stats.data_standard_deviation_estimation[" + i + "]=" + data.stats.data_standard_deviation_estimation[i] + "<BR>");
			document.write("data.stats.data_student_t_test[" + i + "]=" + data.stats.data_student_t_test[i] + "<BR>");
			document.write("data.stats.data_coefficient_variation[" + i + "]=" + data.stats.data_coefficient_variation[i] + "<BR>");
			document.write("data.stats.data_skewness[" + i + "]=" + data.stats.data_skewness[i] + "<BR>");
			document.write("data.stats.data_kurtosis[" + i + "]=" + data.stats.data_kurtosis[i] + "<BR>");
			document.write("data.stats.data_Q0[" + i + "]=" + data.stats.data_Q0[i] + "<BR>");
			document.write("data.stats.data_Q1[" + i + "]=" + data.stats.data_Q1[i] + "<BR>");
			document.write("data.stats.data_Q5[" + i + "]=" + data.stats.data_Q5[i] + "<BR>");
			document.write("data.stats.data_Q10[" + i + "]=" + data.stats.data_Q10[i] + "<BR>");
			document.write("data.stats.data_Q25[" + i + "]=" + data.stats.data_Q25[i] + "<BR>");
			document.write("data.stats.data_Q50[" + i + "]=" + data.stats.data_Q50[i] + "<BR>");
			document.write("data.stats.data_Q75[" + i + "]=" + data.stats.data_Q75[i] + "<BR>");
			document.write("data.stats.data_Q90[" + i + "]=" + data.stats.data_Q90[i] + "<BR>");
			document.write("data.stats.data_Q95[" + i + "]=" + data.stats.data_Q95[i] + "<BR>");
			document.write("data.stats.data_Q99[" + i + "]=" + data.stats.data_Q99[i] + "<BR>");
			document.write("data.stats.data_Q100[" + i + "]=" + data.stats.data_Q100[i] + "<BR>");
			document.write("data.stats.data_median[" + i + "]=" + data.stats.data_median[i] + "<BR>");
			document.write("data.stats.data_interquartile_range[" + i + "]=" + data.stats.data_interquartile_range[i] + "<BR>");
		}
	}
};

function replace_stats(data, config) {
	// replace in the data
	var i,j;
	if (data.stats.data_with_stats) {
		if (typeof data.datasets == 'undefined') { // Pie structure;
			for (i = 0; i < data.length; i++) {
				if (isStat(data[i].value)) data[i].value = replace_Stats_In(data[i].value, data, -1, -1);
				// templates ?
				if (isTemplate(data[i].value)) {
					data[i].value = tmplStat(data[i].value, {
						V1: 1
					});
				}
			}
		} else { // line structure;
			for (i = 0; i < data.datasets["length"]; i++) {
				for (j = 0; j < data.datasets[i].data["length"]; j++) {
					if (isStat(data.datasets[i].data[j])) {
						data.datasets[i].data[j] = replace_Stats_In(data.datasets[i].data[j], data, i, j);
					}
					// templates ?
					if (isTemplate(data.datasets[i].data[j])) {
						data.datasets[i].data[j] = tmplStat(data.datasets[i].data[j], {
							V1: 1
						});
					}
				}
			}
		}
	}
	// replace in other part of the data (titles)
	if (typeof data.datasets == 'undefined') { // Pie structure;
		for (i = 0; i < data.length; i++) {
			if (isStat(data[i].title)) data[i].title = replace_Stats_In(data[i].title, data, -1, -1);
			// templates ?
			if (isTemplate(data[i].title)) {
				data[i].title = tmplStat(data[i].title, {
					V1: 1
				});
			}
		}
	} else { // line structure;
		for (var i = 0; i < data.datasets["length"]; i++) {
			if (isStat(data.datasets[i].title)) {
				data.datasets[i].title = replace_Stats_In(data.datasets[i].title, data, i, -1);
			}
			// templates ?
			if (isTemplate(data.datasets[i].title)) {
				data.datasets[i].title = tmplStat(data.datasets[i].title, {
					V1: 1
				});
			}
		}
	}
	// replace in shapesInChart;
	if (typeof data.datasets == 'undefined') { // Pie structure;
		if (typeof data[0].shapesInChart == "object") {
			for(i=0;i<data[0].shapesInChart.length;i++) {
				replace_in_object(data[0].shapesInChart[i], data);
			}
		}
	} else { // Line structure;
		if(typeof data.shapesInChart == "object") {
			for(i=0;i<data.shapesInChart.length;i++) {
				replace_in_object(data.shapesInChart[i], data);
			}
		} 

	}	
	// replace in options;
	replace_in_object(config, data);
};

function replace_in_object(obj, data) {
	for (var attrname in obj) {
		if (typeof obj[attrname] == "object") {
			replace_in_object(obj[attrname], data);
		} else if (isStat(obj[attrname])) {
			obj[attrname] = replace_Stats_In(obj[attrname], data, -1, -1);
			// templates if not a template option....
			if (!(attrname == "annotateLabel" || attrname == "inGraphDataTmpl" || attrname == "scaleLabel")) {
				if (isTemplate(obj[attrname])) {
					obj[attrname] = tmplStat(obj[attrname], {
						V1: 1
					});
				}
			}
		}
	}
};

function tmplStat(str, data) {
	// Figure out if we're getting a template, or if we need to
	// load the template - and be sure to cache the result.
	var fn = !/\W/.test(str) ?
		cachebis[str] = cachebis[str] ||
		tmplbis(document.getElementById(str).innerHTML) :
		// Generate a reusable function that will serve as a template
		// generator (and which will be cached).
		new Function("obj",
			"var p=[],print=function(){p.push.apply(p,arguments);};" +
			// Introduce the data as local variables using with(){}
			"with(obj){p.push('" +
			// Convert the template into pure JavaScript
			str
			.replace(/[\r\t\n]/g, " ")
			.split("<%").join("\t")
			.replace(/((^|%>)[^\t]*)'/g, "$1\r")
			.replace(/\t=(.*?)%>/g, "',$1,'")
			.split("\t").join("');")
			.split("%>").join("p.push('")
			.split("\r").join("\\'") + "');}return p.join('');");
	// Provide some basic currying to the user
	return data ? fn(data) : fn;
};

function isTemplate(strvar) {
	if (typeof strvar == "string") {
		if (strvar.indexOf("<%") >= 0) {
			if (strvar.indexOf(">", strvar.indexOf("%>")) > 0) {
				return true;
			}
		}
	}
	return false;
};

function replace_Stats_In(strval, data, dataset, coldata) {
	var resval = "";
	var start = 0;
	var prevstat = true;
	while (strval.indexOf("#", start) >= 0) {
		// strval.substring(start,)           ;
		if (!prevstat) {
			var statOf = convertStat(strval.substring(start, strval.indexOf("#", start)), data, dataset, coldata);
			if (statOf.found) {
				resval = resval + statOf.resval;
				start = strval.indexOf("#", start) + 1;
				prevstat = true;
			} else {
				resval = resval + "#" + statOf.resval;
				start = strval.indexOf("#", start) + 1;
			}
		} else {
			if (start > 0) resval = resval;
			resval = resval + strval.substring(start, strval.indexOf("#", start));
			start = strval.indexOf("#", start) + 1;
			prevstat = false;
		}
	}
	if (!prevstat) resval = resval + "#";
	resval = resval + strval.substring(start, strval.length);
	return resval;
};

function convertStat(statval, data, dataset, coldata) {
	var resval = statval;
	var found = false;
	if (typeof data.stats[statval.toLowerCase()] != "undefined" && typeof data.stats[statval.toLowerCase()] != "object") {
		resval = data.stats[statval.toLowerCase()];
		found = true;
	} else if (statval.toLowerCase().substring(0, 3) == "ds_") {
		stat = statval.toLowerCase().substring(3);
		if (stat.indexOf("(") > 0) {
			var vdataset = stat.substring(stat.indexOf("(") + 1);
			vdataset = 1 * vdataset.substring(0, vdataset.indexOf(")"));
			var stat = stat.substring(0, stat.indexOf("("));
		} else {
			vdataset = Math.max(1 * dataset, 0);
		}
		if (typeof data.datasets == "object") {
			if (typeof data.datasets[vdataset] == "object") {
				if (typeof data.datasets[vdataset].stats == "object") {
					if (typeof data.datasets[vdataset].stats[stat] == "number") {
						resval = data.datasets[vdataset].stats[stat];
						found = true;
					}
				}
			}
		}
	} else if (statval.toLowerCase().substring(0, 5) == "data_") {
		stat = statval.toLowerCase().substring(5);
		if (stat.indexOf("(") > 0) {
			vdataset = stat.substring(stat.indexOf("(") + 1);
			vdataset = 1 * vdataset.substring(0, vdataset.indexOf(")"));
			stat = stat.substring(0, stat.indexOf("("));
		} else {
			vdataset = Math.max(1 * coldata, 0);
		}
		if (typeof data.datasets == "object") {
			if (typeof data.stats["data_" + stat] == "object") {
				if (typeof data.stats["data_" + stat][vdataset] == "number") {
					resval = data.stats["data_" + stat][vdataset];
					found = true;
				}
			}
		}
	} else if (statval.toLowerCase().substring(0, 9) == "variable_") {
		resval = eval(statval.toLowerCase().substring(9));
		found=true;
	}
	return {
		found: found,
		resval: resval
	};
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5qcyIsIndoYXQtaW5wdXQuanMiLCJmb3VuZGF0aW9uLmNvcmUuanMiLCJmb3VuZGF0aW9uLnV0aWwuYm94LmpzIiwiZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzIiwiZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanMiLCJmb3VuZGF0aW9uLnV0aWwubW90aW9uLmpzIiwiZm91bmRhdGlvbi51dGlsLm5lc3QuanMiLCJmb3VuZGF0aW9uLnV0aWwudGltZXJBbmRJbWFnZUxvYWRlci5qcyIsImZvdW5kYXRpb24udXRpbC50b3VjaC5qcyIsImZvdW5kYXRpb24udXRpbC50cmlnZ2Vycy5qcyIsImZvdW5kYXRpb24uYWJpZGUuanMiLCJmb3VuZGF0aW9uLmFjY29yZGlvbi5qcyIsImZvdW5kYXRpb24uYWNjb3JkaW9uTWVudS5qcyIsImZvdW5kYXRpb24uZHJpbGxkb3duLmpzIiwiZm91bmRhdGlvbi5kcm9wZG93bi5qcyIsImZvdW5kYXRpb24uZHJvcGRvd25NZW51LmpzIiwiZm91bmRhdGlvbi5lcXVhbGl6ZXIuanMiLCJmb3VuZGF0aW9uLmludGVyY2hhbmdlLmpzIiwiZm91bmRhdGlvbi5tYWdlbGxhbi5qcyIsImZvdW5kYXRpb24ub2ZmY2FudmFzLmpzIiwiZm91bmRhdGlvbi5vcmJpdC5qcyIsImZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnUuanMiLCJmb3VuZGF0aW9uLnJlc3BvbnNpdmVUb2dnbGUuanMiLCJmb3VuZGF0aW9uLnJldmVhbC5qcyIsImZvdW5kYXRpb24uc2xpZGVyLmpzIiwiZm91bmRhdGlvbi5zdGlja3kuanMiLCJmb3VuZGF0aW9uLnRhYnMuanMiLCJmb3VuZGF0aW9uLnRvZ2dsZXIuanMiLCJmb3VuZGF0aW9uLnRvb2x0aXAuanMiLCJDaGFydE5ldy5qcyIsImFwcC5qcyIsIkFkZC1pbnMvYm9vdHN0cmFwX0NoYXJ0TmV3LmpzIiwiQWRkLWlucy9kcmlsbERvd24uanMiLCJBZGQtaW5zL2Zvcm1hdC5qcyIsIkFkZC1pbnMvZ3JhZGllbnRDb2xvci5qcyIsIkFkZC1pbnMvaGF0Y2guanMiLCJBZGQtaW5zL3NoYXBlc0luQ2hhcnQuanMiLCJBZGQtaW5zL3NwZWNpYWxJbkNoYXJ0RGF0YS5qcyIsIkFkZC1pbnMvc3RhdHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxL1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDblpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25lQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFwUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbjZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2Mi4xLjRcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAwNSwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE1LTA0LTI4VDE2OjAxWlxuICovXG5cbihmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXG4vLyBDYW4ndCBiZSBpbiBzdHJpY3QgbW9kZSwgc2V2ZXJhbCBsaWJzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXG4vLyB0aGUgc3RhY2sgdmlhIGFyZ3VtZW50cy5jYWxsZXIuY2FsbGVlIGFuZCBGaXJlZm94IGRpZXMgaWZcbi8vIHlvdSB0cnkgdG8gdHJhY2UgdGhyb3VnaCBcInVzZSBzdHJpY3RcIiBjYWxsIGNoYWlucy4gKCMxMzMzNSlcbi8vXG5cbnZhciBhcnIgPSBbXTtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG52YXJcblx0Ly8gVXNlIHRoZSBjb3JyZWN0IGRvY3VtZW50IGFjY29yZGluZ2x5IHdpdGggd2luZG93IGFyZ3VtZW50IChzYW5kYm94KVxuXHRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcblxuXHR2ZXJzaW9uID0gXCIyLjEuNFwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjFcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW1xcZGEtel0pL2dpLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gU3RhcnQgd2l0aCBhbiBlbXB0eSBzZWxlY3RvclxuXHRzZWxlY3RvcjogXCJcIixcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0cmV0dXJuIG51bSAhPSBudWxsID9cblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdICkgOlxuXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0XHRzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXHRcdHJldC5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdC8vIChZb3UgY2FuIHNlZWQgdGhlIGFyZ3VtZW50cyB3aXRoIGFuIGFycmF5IG9mIGFyZ3MsIGJ1dCB0aGlzIGlzXG5cdC8vIG9ubHkgdXNlZCBpbnRlcm5hbGx5Lilcblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2ssIGFyZ3MgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAodGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0pKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzW2pdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQvLyBhZGRpbmcgMSBjb3JyZWN0cyBsb3NzIG9mIHByZWNpc2lvbiBmcm9tIHBhcnNlRmxvYXQgKCMxNTEwMClcblx0XHRyZXR1cm4gIWpRdWVyeS5pc0FycmF5KCBvYmogKSAmJiAob2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKyAxKSA+PSAwO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0Ly8gTm90IHBsYWluIG9iamVjdHM6XG5cdFx0Ly8gLSBBbnkgb2JqZWN0IG9yIHZhbHVlIHdob3NlIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSBpcyBub3QgXCJbb2JqZWN0IE9iamVjdF1cIlxuXHRcdC8vIC0gRE9NIG5vZGVzXG5cdFx0Ly8gLSB3aW5kb3dcblx0XHRpZiAoIGpRdWVyeS50eXBlKCBvYmogKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIG9iai5jb25zdHJ1Y3RvciAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwoIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIGZ1bmN0aW9uIGhhc24ndCByZXR1cm5lZCBhbHJlYWR5LCB3ZSdyZSBjb25maWRlbnQgdGhhdFxuXHRcdC8vIHxvYmp8IGlzIGEgcGxhaW4gb2JqZWN0LCBjcmVhdGVkIGJ5IHt9IG9yIGNvbnN0cnVjdGVkIHdpdGggbmV3IE9iamVjdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMCwgaU9TPDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbChvYmopIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdHZhciBzY3JpcHQsXG5cdFx0XHRpbmRpcmVjdCA9IGV2YWw7XG5cblx0XHRjb2RlID0galF1ZXJ5LnRyaW0oIGNvZGUgKTtcblxuXHRcdGlmICggY29kZSApIHtcblx0XHRcdC8vIElmIHRoZSBjb2RlIGluY2x1ZGVzIGEgdmFsaWQsIHByb2xvZ3VlIHBvc2l0aW9uXG5cdFx0XHQvLyBzdHJpY3QgbW9kZSBwcmFnbWEsIGV4ZWN1dGUgY29kZSBieSBpbmplY3RpbmcgYVxuXHRcdFx0Ly8gc2NyaXB0IHRhZyBpbnRvIHRoZSBkb2N1bWVudC5cblx0XHRcdGlmICggY29kZS5pbmRleE9mKFwidXNlIHN0cmljdFwiKSA9PT0gMSApIHtcblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblx0XHRcdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBPdGhlcndpc2UsIGF2b2lkIHRoZSBET00gbm9kZSBjcmVhdGlvbiwgaW5zZXJ0aW9uXG5cdFx0XHQvLyBhbmQgcmVtb3ZhbCBieSB1c2luZyBhbiBpbmRpcmVjdCBnbG9iYWwgZXZhbFxuXHRcdFx0XHRpbmRpcmVjdCggY29kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdC8vIGFyZ3MgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0dmFyIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoLFxuXHRcdFx0aXNBcnJheSA9IGlzQXJyYXlsaWtlKCBvYmogKTtcblxuXHRcdGlmICggYXJncyApIHtcblx0XHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseSggb2JqWyBpIF0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KCBvYmpbIGkgXSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlsaWtlKCBPYmplY3QoYXJyKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRpc0FycmF5ID0gaXNBcnJheWxpa2UoIGVsZW1zICksXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5ICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBEYXRlLm5vdyxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSk7XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbihpLCBuYW1lKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlsaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDguMiAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9IFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggb2JqLm5vZGVUeXBlID09PSAxICYmIGxlbmd0aCApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4yLjAtcHJlXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDA4LCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTQtMTItMTZcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gV2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc3ludGF4LyNjaGFyYWN0ZXJzXG5cdGNoYXJhY3RlckVuY29kaW5nID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXFxceDAwLVxcXFx4YTBdKStcIixcblxuXHQvLyBMb29zZWx5IG1vZGVsZWQgb24gQ1NTIGlkZW50aWZpZXIgY2hhcmFjdGVyc1xuXHQvLyBBbiB1bnF1b3RlZCB2YWx1ZSBzaG91bGQgYmUgYSBDU1MgaWRlbnRpZmllciBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHQvLyBQcm9wZXIgc3ludGF4OiBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoIFwid1wiLCBcIncjXCIgKSxcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3KlwiICkgKyBcIilcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblx0cmVzY2FwZSA9IC8nfFxcXFwvZyxcblxuXHQvLyBDU1MgZXNjYXBlcyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH07XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG1hdGNoLCBlbGVtLCBtLCBub2RlVHlwZSxcblx0XHQvLyBRU0EgdmFyc1xuXHRcdGksIGdyb3Vwcywgb2xkLCBuaWQsIG5ld0NvbnRleHQsIG5ld1NlbGVjdG9yO1xuXG5cdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblx0bm9kZVR5cGUgPSBjb250ZXh0Lm5vZGVUeXBlO1xuXG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0aWYgKCAhc2VlZCAmJiBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgd2hlbiBwb3NzaWJsZSAoZS5nLiwgbm90IHVuZGVyIERvY3VtZW50RnJhZ21lbnQpXG5cdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIjSURcIilcblx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKTtcblx0XHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKGpRdWVyeSAjNjk2Mylcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFLCBPcGVyYSwgYW5kIFdlYmtpdCByZXR1cm4gaXRlbXNcblx0XHRcdFx0XHRcdC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBDb250ZXh0IGlzIG5vdCBhIGRvY3VtZW50XG5cdFx0XHRcdFx0aWYgKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgJiYgKGVsZW0gPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiYgZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCJUQUdcIilcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiLkNMQVNTXCIpXG5cdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFFTQSBwYXRoXG5cdFx0aWYgKCBzdXBwb3J0LnFzYSAmJiAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXHRcdFx0bmlkID0gb2xkID0gZXhwYW5kbztcblx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0bmV3U2VsZWN0b3IgPSBub2RlVHlwZSAhPT0gMSAmJiBzZWxlY3RvcjtcblxuXHRcdFx0Ly8gcVNBIHdvcmtzIHN0cmFuZ2VseSBvbiBFbGVtZW50LXJvb3RlZCBxdWVyaWVzXG5cdFx0XHQvLyBXZSBjYW4gd29yayBhcm91bmQgdGhpcyBieSBzcGVjaWZ5aW5nIGFuIGV4dHJhIElEIG9uIHRoZSByb290XG5cdFx0XHQvLyBhbmQgd29ya2luZyB1cCBmcm9tIHRoZXJlIChUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhlIHRlY2huaXF1ZSlcblx0XHRcdC8vIElFIDggZG9lc24ndCB3b3JrIG9uIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJiBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXG5cdFx0XHRcdGlmICggKG9sZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKFwiaWRcIikpICkge1xuXHRcdFx0XHRcdG5pZCA9IG9sZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgbmlkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmlkID0gXCJbaWQ9J1wiICsgbmlkICsgXCInXSBcIjtcblxuXHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0Z3JvdXBzW2ldID0gbmlkICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHQ7XG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oXCIsXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoKHFzYUVycm9yKSB7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCAhb2xkICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge0Z1bmN0aW9uKHN0cmluZywgT2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBkaXYgYW5kIGV4cGVjdHMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBkaXYgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGRpdi5wYXJlbnROb2RlICkge1xuXHRcdFx0ZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGRpdiA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdCggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLVxuXHRcdFx0KCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgcGFyZW50LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBJZiBubyBkb2N1bWVudCBhbmQgZG9jdW1lbnRFbGVtZW50IGlzIGF2YWlsYWJsZSwgcmV0dXJuXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gU2V0IG91ciBkb2N1bWVudFxuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdHBhcmVudCA9IGRvYy5kZWZhdWx0VmlldztcblxuXHQvLyBTdXBwb3J0OiBJRT44XG5cdC8vIElmIGlmcmFtZSBkb2N1bWVudCBpcyBhc3NpZ25lZCB0byBcImRvY3VtZW50XCIgdmFyaWFibGUgYW5kIGlmIGlmcmFtZSBoYXMgYmVlbiByZWxvYWRlZCxcblx0Ly8gSUUgd2lsbCB0aHJvdyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBhY2Nlc3NpbmcgXCJkb2N1bWVudFwiIHZhcmlhYmxlLCBzZWUgalF1ZXJ5ICMxMzkzNlxuXHQvLyBJRTYtOCBkbyBub3Qgc3VwcG9ydCB0aGUgZGVmYXVsdFZpZXcgcHJvcGVydHkgc28gcGFyZW50IHdpbGwgYmUgdW5kZWZpbmVkXG5cdGlmICggcGFyZW50ICYmIHBhcmVudCAhPT0gcGFyZW50LnRvcCApIHtcblx0XHQvLyBJRTExIGRvZXMgbm90IGhhdmUgYXR0YWNoRXZlbnQsIHNvIGFsbCBtdXN0IHN1ZmZlclxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblx0XHR9IGVsc2UgaWYgKCBwYXJlbnQuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRwYXJlbnQuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIFN1cHBvcnQgdGVzdHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jICk7XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWRpdi5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvYy5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jLmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcblx0XHRcdFx0cmV0dXJuIG0gJiYgbS5wYXJlbnROb2RlID8gWyBtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdXBwb3J0OiBJRTYvN1xuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRkZWxldGUgRXhwci5maW5kW1wiSURcIl07XG5cblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jLnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxmXScgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuMissIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS43K1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2liaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBkaXYsIFwiZGl2XCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBkaXYsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgZG9lcyBub3QgaW1wbGVtZW50IGluY2x1c2l2ZSBkZXNjZW5kZW50XG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvYyB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvYyB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2MgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2M7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIGRpZmYsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gcGFyZW50WyBleHBhbmRvIF0gfHwgKHBhcmVudFsgZXhwYW5kbyBdID0ge30pO1xuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IG91dGVyQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMV07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsyXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB1c2VDYWNoZSAmJiAoY2FjaGUgPSAoZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSkpWyB0eXBlIF0pICYmIGNhY2hlWzBdID09PSBkaXJydW5zICkge1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gY2FjaGVbMV07XG5cblx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLikgb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxICkgJiYgKytkaWZmICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0KG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pKVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdFwiZGlzYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBkaXIgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gZGlyIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXHRcdFx0XHRcdFx0aWYgKCAob2xkQ2FjaGUgPSBvdXRlckNhY2hlWyBkaXIgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ICE9PSBkb2N1bWVudCAmJiBjb250ZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gS2VlcCBgaWAgYSBzdHJpbmcgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIHNvIGBtYXRjaGVkQ291bnRgIHdpbGwgYmUgXCIwMFwiIGJlbG93XG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBubyBzZWVkIGFuZCBvbmx5IG9uZSBncm91cFxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFRha2UgYSBzaG9ydGN1dCBhbmQgc2V0IHRoZSBjb250ZXh0IGlmIHRoZSByb290IHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0cnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYxICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICgvXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPnwpJC8pO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0pO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSk7XG5cblx0fVxuXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0XHR9XG5cblx0XHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID49IDAgKSAhPT0gbm90O1xuXHR9KTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSA/XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdIDpcblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdFx0fSkpO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSkgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdC8vIE5lZWRlZCBiZWNhdXNlICQoIHNlbGVjdG9yLCBjb250ZXh0ICkgYmVjb21lcyAkKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKVxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQgKTtcblx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFwiIFwiICsgc2VsZWN0b3IgOiBzZWxlY3Rvcjtcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UpICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0pO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclswXSA9PT0gXCI8XCIgJiYgc2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiYgc2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAobWF0Y2hbMV0gfHwgIWNvbnRleHQpICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWzFdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWzFdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWzJdICk7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBCbGFja2JlcnJ5IDQuNlxuXHRcdFx0XHRcdC8vIGdFQklEIHJldHVybnMgbm9kZXMgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAoIzY5NjMpXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWzBdID0gZWxlbTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3RqUXVlcnkgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSB0aGlzWzBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiB0eXBlb2Ygcm9vdGpRdWVyeS5yZWFkeSAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRcdHJvb3RqUXVlcnkucmVhZHkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRkaXI6IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHRcdHZhciBtYXRjaGVkID0gW10sXG5cdFx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaGVkO1xuXHR9LFxuXG5cdHNpYmxpbmc6IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHRcdHZhciBtYXRjaGVkID0gW107XG5cblx0XHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVkO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzW2ldICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCApIDpcblx0XHRcdFx0MDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbaV07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAocG9zID9cblx0XHRcdFx0XHRwb3MuaW5kZXgoY3VyKSA+IC0xIDpcblxuXHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGN1ciwgc2VsZWN0b3JzKSkgKSB7XG5cblx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlKCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWUoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3Rvcilcblx0XHQpO1xuXHR9XG59KTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCh7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZSggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0pO1xudmFyIHJub3R3aGl0ZSA9ICgvXFxTKy9nKTtcblxuXG5cbi8vIFN0cmluZyB0byBPYmplY3Qgb3B0aW9ucyBmb3JtYXQgY2FjaGVcbnZhciBvcHRpb25zQ2FjaGUgPSB7fTtcblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXMgYW5kIHN0b3JlIGluIGNhY2hlXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0gb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0pO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdCggb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gfHwgY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcblx0XHRtZW1vcnksXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXHRcdC8vIEZpcnN0IGNhbGxiYWNrIHRvIGZpcmUgKHVzZWQgaW50ZXJuYWxseSBieSBhZGQgYW5kIGZpcmVXaXRoKVxuXHRcdGZpcmluZ1N0YXJ0LFxuXHRcdC8vIEVuZCBvZiB0aGUgbG9vcCB3aGVuIGZpcmluZ1xuXHRcdGZpcmluZ0xlbmd0aCxcblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSByZW1vdmUgaWYgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4LFxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXHRcdC8vIFN0YWNrIG9mIGZpcmUgY2FsbHMgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRzdGFjayA9ICFvcHRpb25zLm9uY2UgJiYgW10sXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRtZW1vcnkgPSBvcHRpb25zLm1lbW9yeSAmJiBkYXRhO1xuXHRcdFx0ZmlyZWQgPSB0cnVlO1xuXHRcdFx0ZmlyaW5nSW5kZXggPSBmaXJpbmdTdGFydCB8fCAwO1xuXHRcdFx0ZmlyaW5nU3RhcnQgPSAwO1xuXHRcdFx0ZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBsaXN0ICYmIGZpcmluZ0luZGV4IDwgZmlyaW5nTGVuZ3RoOyBmaXJpbmdJbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIGRhdGFbIDAgXSwgZGF0YVsgMSBdICkgPT09IGZhbHNlICYmIG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7IC8vIFRvIHByZXZlbnQgZnVydGhlciBjYWxscyB1c2luZyBhZGRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdGlmICggc3RhY2sgKSB7XG5cdFx0XHRcdFx0aWYgKCBzdGFjay5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCBzdGFjay5zaGlmdCgpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0Ly8gRmlyc3QsIHdlIHNhdmUgdGhlIGN1cnJlbnQgbGVuZ3RoXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0KGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KSggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0Ly8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcblx0XHRcdFx0XHQvLyBjdXJyZW50IGZpcmluZyBiYXRjaD9cblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIFdpdGggbWVtb3J5LCBpZiB3ZSdyZSBub3QgZmlyaW5nIHRoZW5cblx0XHRcdFx0XHQvLyB3ZSBzaG91bGQgY2FsbCByaWdodCBhd2F5XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nU3RhcnQgPSBzdGFydDtcblx0XHRcdFx0XHRcdGZpcmUoIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nTGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nTGVuZ3RoLS07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gPyBqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDogISEoIGxpc3QgJiYgbGlzdC5sZW5ndGggKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0ZmlyaW5nTGVuZ3RoID0gMDtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSGF2ZSB0aGUgbGlzdCBkbyBub3RoaW5nIGFueW1vcmVcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gc3RhY2sgPSBtZW1vcnkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIElzIGl0IGRpc2FibGVkP1xuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gTG9jayB0aGUgbGlzdCBpbiBpdHMgY3VycmVudCBzdGF0ZVxuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN0YWNrID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgKSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSXMgaXQgbG9ja2VkP1xuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFzdGFjaztcblx0XHRcdH0sXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggbGlzdCAmJiAoICFmaXJlZCB8fCBzdGFjayApICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRzdGFjay5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcmUoIGFyZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZWplY3RlZFwiIF0sXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIGkgXSApICYmIGZuc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZFsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdIGZvciBmb3J3YXJkaW5nIGFjdGlvbnMgdG8gbmV3RGVmZXJcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzFdIF0oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IHByb21pc2UgPyBuZXdEZWZlci5wcm9taXNlKCkgOiB0aGlzLCBmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdHByb21pc2UucGlwZSA9IHByb21pc2UudGhlbjtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDMgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWzFdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHByb21pc2UgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzdWJvcmRpbmF0ZSAvKiAsIC4uLiwgc3Vib3JkaW5hdGVOICovICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGxlbmd0aCA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoLFxuXG5cdFx0XHQvLyB0aGUgY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBsZW5ndGggIT09IDEgfHwgKCBzdWJvcmRpbmF0ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggc3Vib3JkaW5hdGUucHJvbWlzZSApICkgPyBsZW5ndGggOiAwLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkLiBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cblx0XHRcdGRlZmVycmVkID0gcmVtYWluaW5nID09PSAxID8gc3Vib3JkaW5hdGUgOiBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpLCBjb250ZXh0cywgdmFsdWVzICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdGNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggdmFsdWVzID09PSBwcm9ncmVzc1ZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHRwcm9ncmVzc1ZhbHVlcywgcHJvZ3Jlc3NDb250ZXh0cywgcmVzb2x2ZUNvbnRleHRzO1xuXG5cdFx0Ly8gQWRkIGxpc3RlbmVycyB0byBEZWZlcnJlZCBzdWJvcmRpbmF0ZXM7IHRyZWF0IG90aGVycyBhcyByZXNvbHZlZFxuXHRcdGlmICggbGVuZ3RoID4gMSApIHtcblx0XHRcdHByb2dyZXNzVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApXG5cdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIHVwZGF0ZUZ1bmMoIGksIHByb2dyZXNzQ29udGV4dHMsIHByb2dyZXNzVmFsdWVzICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQtLXJlbWFpbmluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHdlJ3JlIG5vdCB3YWl0aW5nIG9uIGFueXRoaW5nLCByZXNvbHZlIHRoZSBtYXN0ZXJcblx0XHRpZiAoICFyZW1haW5pbmcgKSB7XG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcblx0fVxufSk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cdC8vIEFkZCB0aGUgY2FsbGJhY2tcblx0alF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKCBmbiApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblxuXHRcdC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xuXHRcdGlmICggalF1ZXJ5LmZuLnRyaWdnZXJIYW5kbGVyICkge1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLnRyaWdnZXJIYW5kbGVyKCBcInJlYWR5XCIgKTtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS5vZmYoIFwicmVhZHlcIiApO1xuXHRcdH1cblx0fVxufSk7XG5cbi8qKlxuICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbmpRdWVyeS5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24oIG9iaiApIHtcblx0aWYgKCAhcmVhZHlMaXN0ICkge1xuXG5cdFx0cmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cblx0XHQvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZCBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyBXZSBvbmNlIHRyaWVkIHRvIHVzZSByZWFkeVN0YXRlIFwiaW50ZXJhY3RpdmVcIiBoZXJlLCBidXQgaXQgY2F1c2VkIGlzc3VlcyBsaWtlIHRoZSBvbmVcblx0XHQvLyBkaXNjb3ZlcmVkIGJ5IENocmlzUyBoZXJlOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjI4MiNjb21tZW50OjE1XG5cdFx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XG5cdFx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0XHRcdHNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG5qUXVlcnkucmVhZHkucHJvbWlzZSgpO1xuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGpRdWVyeS5hY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGpRdWVyeS5hY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5W2ldLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbiggZWxlbXNbaV0sIGtleSwgcmF3ID8gdmFsdWUgOiB2YWx1ZS5jYWxsKCBlbGVtc1tpXSwgaSwgZm4oIGVsZW1zW2ldLCBrZXkgKSApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNoYWluYWJsZSA/XG5cdFx0ZWxlbXMgOlxuXG5cdFx0Ly8gR2V0c1xuXHRcdGJ1bGsgP1xuXHRcdFx0Zm4uY2FsbCggZWxlbXMgKSA6XG5cdFx0XHRsZW4gPyBmbiggZWxlbXNbMF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIG9iamVjdCBjYW4gaGF2ZSBkYXRhXG4gKi9cbmpRdWVyeS5hY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0LyoganNoaW50IC1XMDE4ICovXG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LFxuXHQvLyBPbGQgV2ViS2l0IGRvZXMgbm90IGhhdmUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zL2ZyZWV6ZSBtZXRob2QsXG5cdC8vIHJldHVybiBuZXcgZW1wdHkgb2JqZWN0IGluc3RlYWQgd2l0aCBubyBbW3NldF1dIGFjY2Vzc29yXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcy5jYWNoZSA9IHt9LCAwLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdH0pO1xuXG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuRGF0YS5hY2NlcHRzID0galF1ZXJ5LmFjY2VwdERhdGE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXHRrZXk6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdC8vIEFsd2F5cyByZXR1cm4gdGhlIGtleSBmb3IgYSBmcm96ZW4gb2JqZWN0LlxuXHRcdGlmICggIURhdGEuYWNjZXB0cyggb3duZXIgKSApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBkZXNjcmlwdG9yID0ge30sXG5cdFx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGUga2V5XG5cdFx0XHR1bmxvY2sgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF1bmxvY2sgKSB7XG5cdFx0XHR1bmxvY2sgPSBEYXRhLnVpZCsrO1xuXG5cdFx0XHQvLyBTZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlIHByb3BlcnR5XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkZXNjcmlwdG9yWyB0aGlzLmV4cGFuZG8gXSA9IHsgdmFsdWU6IHVubG9jayB9O1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggb3duZXIsIGRlc2NyaXB0b3IgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0XG5cdFx0XHQvLyBGYWxsYmFjayB0byBhIGxlc3Mgc2VjdXJlIGRlZmluaXRpb25cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRkZXNjcmlwdG9yWyB0aGlzLmV4cGFuZG8gXSA9IHVubG9jaztcblx0XHRcdFx0alF1ZXJ5LmV4dGVuZCggb3duZXIsIGRlc2NyaXB0b3IgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhlIGNhY2hlIG9iamVjdFxuXHRcdGlmICggIXRoaXMuY2FjaGVbIHVubG9jayBdICkge1xuXHRcdFx0dGhpcy5jYWNoZVsgdW5sb2NrIF0gPSB7fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdW5sb2NrO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHQvLyBUaGVyZSBtYXkgYmUgYW4gdW5sb2NrIGFzc2lnbmVkIHRvIHRoaXMgbm9kZSxcblx0XHRcdC8vIGlmIHRoZXJlIGlzIG5vIGVudHJ5IGZvciB0aGlzIFwib3duZXJcIiwgY3JlYXRlIG9uZSBpbmxpbmVcblx0XHRcdC8vIGFuZCBzZXQgdGhlIHVubG9jayBhcyB0aG91Z2ggYW4gb3duZXIgZW50cnkgaGFkIGFsd2F5cyBleGlzdGVkXG5cdFx0XHR1bmxvY2sgPSB0aGlzLmtleSggb3duZXIgKSxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZVsgdW5sb2NrIF07XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBkYXRhIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEZyZXNoIGFzc2lnbm1lbnRzIGJ5IG9iamVjdCBhcmUgc2hhbGxvdyBjb3BpZWRcblx0XHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5leHRlbmQoIHRoaXMuY2FjaGVbIHVubG9jayBdLCBkYXRhICk7XG5cdFx0XHQvLyBPdGhlcndpc2UsIGNvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0Y2FjaGVbIHByb3AgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0Ly8gRWl0aGVyIGEgdmFsaWQgY2FjaGUgaXMgZm91bmQsIG9yIHdpbGwgYmUgY3JlYXRlZC5cblx0XHQvLyBOZXcgY2FjaGVzIHdpbGwgYmUgY3JlYXRlZCBhbmQgdGhlIHVubG9jayByZXR1cm5lZCxcblx0XHQvLyBhbGxvd2luZyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBuZXdseSBjcmVhdGVkXG5cdFx0Ly8gZW1wdHkgZGF0YSBvYmplY3QuIEEgdmFsaWQgb3duZXIgb2JqZWN0IG11c3QgYmUgcHJvdmlkZWQuXG5cdFx0dmFyIGNhY2hlID0gdGhpcy5jYWNoZVsgdGhpcy5rZXkoIG93bmVyICkgXTtcblxuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRjYWNoZSA6IGNhY2hlWyBrZXkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHN0b3JlZDtcblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoKGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSApIHtcblxuXHRcdFx0c3RvcmVkID0gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblxuXHRcdFx0cmV0dXJuIHN0b3JlZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0c3RvcmVkIDogdGhpcy5nZXQoIG93bmVyLCBqUXVlcnkuY2FtZWxDYXNlKGtleSkgKTtcblx0XHR9XG5cblx0XHQvLyBbKl1XaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGNhbWVsLFxuXHRcdFx0dW5sb2NrID0gdGhpcy5rZXkoIG93bmVyICksXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGVbIHVubG9jayBdO1xuXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuY2FjaGVbIHVubG9jayBdID0ge307XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGtleSApICkge1xuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0ga2V5LmNvbmNhdCgga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXHRcdFx0XHQvLyBUcnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxuXHRcdFx0XHRpZiAoIGtleSBpbiBjYWNoZSApIHtcblx0XHRcdFx0XHRuYW1lID0gWyBrZXksIGNhbWVsIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0bmFtZSA9IGNhbWVsO1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lIGluIGNhY2hlID9cblx0XHRcdFx0XHRcdFsgbmFtZSBdIDogKCBuYW1lLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBuYW1lLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIG5hbWVbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHJldHVybiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoXG5cdFx0XHR0aGlzLmNhY2hlWyBvd25lclsgdGhpcy5leHBhbmRvIF0gXSB8fCB7fVxuXHRcdCk7XG5cdH0sXG5cdGRpc2NhcmQ6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHRpZiAoIG93bmVyWyB0aGlzLmV4cGFuZG8gXSApIHtcblx0XHRcdGRlbGV0ZSB0aGlzLmNhY2hlWyBvd25lclsgdGhpcy5leHBhbmRvIF0gXTtcblx0XHR9XG5cdH1cbn07XG52YXIgZGF0YV9wcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFfdXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvKFtBLVpdKS9nO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG5cdFx0XHRcdFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0XHRcdFx0XHQrZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFfdXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhX3VzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFfcHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFfdXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhX3VzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YV9wcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFfcHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTExK1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSg1KSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhX3ByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhX3VzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhLFxuXHRcdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBjYW1lbGl6ZWRcblx0XHRcdFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoIGVsZW0sIGNhbWVsS2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGNhbWVsS2V5LCB1bmRlZmluZWQgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIEZpcnN0LCBhdHRlbXB0IHRvIHN0b3JlIGEgY29weSBvciByZWZlcmVuY2Ugb2YgYW55XG5cdFx0XHRcdC8vIGRhdGEgdGhhdCBtaWdodCd2ZSBiZWVuIHN0b3JlIHdpdGggYSBjYW1lbENhc2VkIGtleS5cblx0XHRcdFx0dmFyIGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCB0aGlzLCBjYW1lbEtleSApO1xuXG5cdFx0XHRcdC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cblx0XHRcdFx0Ly8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cblx0XHRcdFx0Ly8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXG5cdFx0XHRcdGRhdGFfdXNlci5zZXQoIHRoaXMsIGNhbWVsS2V5LCB2YWx1ZSApO1xuXG5cdFx0XHRcdC8vICouLi4gSW4gdGhlIGNhc2Ugb2YgcHJvcGVydGllcyB0aGF0IG1pZ2h0IF9hY3R1YWxseV9cblx0XHRcdFx0Ly8gaGF2ZSBkYXNoZXMsIHdlIG5lZWQgdG8gYWxzbyBzdG9yZSBhIGNvcHkgb2YgdGhhdFxuXHRcdFx0XHQvLyB1bmNoYW5nZWQgcHJvcGVydHkuXG5cdFx0XHRcdGlmICgga2V5LmluZGV4T2YoXCItXCIpICE9PSAtMSAmJiBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0ZGF0YV91c2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhX3VzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cblxualF1ZXJ5LmV4dGVuZCh7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YV9wcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YV9wcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSlcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1swXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59KTtcbnZhciBwbnVtID0gKC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvKS5zb3VyY2U7XG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8ICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHR9O1xuXG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoL14oPzpjaGVja2JveHxyYWRpbykkL2kpO1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogU2FmYXJpPD01LjFcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaTw9NS4xLCBBbmRyb2lkPDQuMlxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0pKCk7XG52YXIgc3RydW5kZWZpbmVkID0gdHlwZW9mIHVuZGVmaW5lZDtcblxuXG5cbnN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudSl8Y2xpY2svLFxuXHRyZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkkLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YV9wcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUpICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gc3RydW5kZWZpbmVkICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoe1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbihcIi5cIilcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHwgc3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUsIGZhbHNlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YV9wcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhX3ByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsyXSAmJiBuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8IHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRlbGV0ZSBlbGVtRGF0YS5oYW5kbGU7XG5cdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBlbGVtLCBcImV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoXCIuXCIpID49IDAgKSB7XG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdChcIi5cIik7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbihcIi5cIik7XG5cdFx0ZXZlbnQubmFtZXNwYWNlX3JlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKGN1ciA9IGV2ZW50UGF0aFtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YV9wcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmIGRhdGFfcHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBqUXVlcnkuYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCFzcGVjaWFsLl9kZWZhdWx0IHx8IHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSkgJiZcblx0XHRcdFx0alF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YV9wcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWzBdID0gZXZlbnQ7XG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoIChoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSkgJiYgIWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQubmFtZXNwYWNlX3JlIHx8IGV2ZW50Lm5hbWVzcGFjZV9yZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9KS5oYW5kbGUgfHwgaGFuZGxlT2JqLmhhbmRsZXIgKVxuXHRcdFx0XHRcdFx0XHQuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKGV2ZW50LnJlc3VsdCA9IHJldCkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgYnViYmxpbmcgaW4gRmlyZWZveCAoIzM4NjEpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJiAoIWV2ZW50LmJ1dHRvbiB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIpICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID49IDAgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0Ly8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcblx0cHJvcHM6IFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdXNlSG9va3M6IHtcblx0XHRwcm9wczogXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXHRcdFx0dmFyIGV2ZW50RG9jLCBkb2MsIGJvZHksXG5cdFx0XHRcdGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbjtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0ZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHRib2R5ID0gZXZlbnREb2MuYm9keTtcblxuXHRcdFx0XHRldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggKyAoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwICk7XG5cdFx0XHRcdGV2ZW50LnBhZ2VZID0gb3JpZ2luYWwuY2xpZW50WSArICggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCwgY29weSxcblx0XHRcdHR5cGUgPSBldmVudC50eXBlLFxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxuXHRcdFx0Zml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuXHRcdGlmICggIWZpeEhvb2sgKSB7XG5cdFx0XHR0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cblx0XHRcdFx0cm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuXHRcdFx0XHR7fTtcblx0XHR9XG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuXHRcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0aSA9IGNvcHkubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ29yZG92YSAyLjUgKFdlYktpdCkgKCMxMzI1NSlcblx0XHQvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3Rcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lPDI4XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQsIGJ1YmJsZSApIHtcblx0XHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmUuXG5cdFx0Ly8gRmFrZSBvcmlnaW5hbEV2ZW50IHRvIGF2b2lkIGRvbm9yJ3Mgc3RvcFByb3BhZ2F0aW9uLCBidXQgaWYgdGhlXG5cdFx0Ly8gc2ltdWxhdGVkIGV2ZW50IHByZXZlbnRzIGRlZmF1bHQgdGhlbiB3ZSBkbyB0aGUgc2FtZSBvbiB0aGUgZG9ub3IuXG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlLFxuXHRcdFx0XHRvcmlnaW5hbEV2ZW50OiB7fVxuXHRcdFx0fVxuXHRcdCk7XG5cdFx0aWYgKCBidWJibGUgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbCggZWxlbSwgZSApO1xuXHRcdH1cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUsIGZhbHNlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQpICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiBlLnByZXZlbnREZWZhdWx0ICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmIGUuc3RvcFByb3BhZ2F0aW9uICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTUrXG5qUXVlcnkuZWFjaCh7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSk7XG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3gsIENocm9tZSwgU2FmYXJpXG4vLyBDcmVhdGUgXCJidWJibGluZ1wiIGZvY3VzIGFuZCBibHVyIGV2ZW50c1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luQnViYmxlcyApIHtcblx0alF1ZXJ5LmVhY2goeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSwgdHJ1ZSApO1xuXHRcdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgLypJTlRFUk5BTCovIG9uZSApIHtcblx0XHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdFx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vbiggdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblx0XHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRcdGZuID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggb25lID09PSAxICkge1xuXHRcdFx0b3JpZ0ZuID0gZm47XG5cdFx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0XHR9KTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID8gaGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDogaGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbMF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59KTtcblxuXG52YXJcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2dpLFxuXHRydGFnTmFtZSA9IC88KFtcXHc6XSspLyxcblx0cmh0bWwgPSAvPHwmIz9cXHcrOy8sXG5cdHJub0lubmVyaHRtbCA9IC88KD86c2NyaXB0fHN0eWxlfGxpbmspL2ksXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlID0gL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nLFxuXG5cdC8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG5cdHdyYXBNYXAgPSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHRcdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0XHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHRcdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0XHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0XHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cblx0fTtcblxuLy8gU3VwcG9ydDogSUU5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gU3VwcG9ydDogMS54IGNvbXBhdGliaWxpdHlcbi8vIE1hbmlwdWxhdGluZyB0YWJsZXMgcmVxdWlyZXMgYSB0Ym9keVxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdGpRdWVyeS5ub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSA/XG5cblx0XHRlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIilbMF0gfHxcblx0XHRcdGVsZW0uYXBwZW5kQ2hpbGQoIGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIikgKSA6XG5cdFx0ZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSAhPT0gbnVsbCkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YV9wcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sIFwiZ2xvYmFsRXZhbFwiLCAhcmVmRWxlbWVudHMgfHwgZGF0YV9wcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YV9wcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YV9wcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhX3ByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhX3VzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhX3VzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YV91c2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblx0dmFyIHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgPyBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cDovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRidWlsZEZyYWdtZW50OiBmdW5jdGlvbiggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiApIHtcblx0XHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRcdG5vZGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdCwgUGhhbnRvbUpTXG5cdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApO1xuXG5cdFx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBlbGVtLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXQsIFBoYW50b21KU1xuXHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdFx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IG5vZGVzWyBpKysgXSkgKSB7XG5cblx0XHRcdC8vICM0MDg3IC0gSWYgb3JpZ2luIGFuZCBkZXN0aW5hdGlvbiBlbGVtZW50cyBhcmUgdGhlIHNhbWUsIGFuZCB0aGlzIGlzXG5cdFx0XHQvLyB0aGF0IGVsZW1lbnQsIGRvIG5vdCBkbyBhbnl0aGluZ1xuXHRcdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApICE9PSAtMSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSB0bXBbIGorKyBdKSApIHtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZnJhZ21lbnQ7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsIGtleSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IGVsZW1zWyBpIF0pICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0a2V5ID0gZWxlbVsgZGF0YV9wcml2LmV4cGFuZG8gXTtcblxuXHRcdFx0XHRpZiAoIGtleSAmJiAoZGF0YSA9IGRhdGFfcHJpdi5jYWNoZVsga2V5IF0pICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGRhdGFfcHJpdi5jYWNoZVsga2V5IF0gKSB7XG5cdFx0XHRcdFx0XHQvLyBEaXNjYXJkIGFueSByZW1haW5pbmcgYHByaXZhdGVgIGRhdGFcblx0XHRcdFx0XHRcdGRlbGV0ZSBkYXRhX3ByaXYuY2FjaGVbIGtleSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gRGlzY2FyZCBhbnkgcmVtYWluaW5nIGB1c2VyYCBkYXRhXG5cdFx0XHRkZWxldGUgZGF0YV91c2VyLmNhY2hlWyBlbGVtWyBkYXRhX3VzZXIuZXhwYW5kbyBdIF07XG5cdFx0fVxuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCBrZWVwRGF0YSAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGVsZW1zID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgdGhpcyApIDogdGhpcyxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoICFrZWVwRGF0YSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0gKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IChlbGVtID0gdGhpc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmcgPSBhcmd1bWVudHNbIDAgXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRhcmcgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cblx0XHRcdGlmICggYXJnICkge1xuXHRcdFx0XHRhcmcucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBGb3JjZSByZW1vdmFsIGlmIHRoZXJlIHdhcyBubyBuZXcgY29udGVudCAoZS5nLiwgZnJvbSBlbXB0eSBhcmd1bWVudHMpXG5cdFx0cmV0dXJuIGFyZyAmJiAoYXJnLmxlbmd0aCB8fCBhcmcubm9kZVR5cGUpID8gdGhpcyA6IHRoaXMucmVtb3ZlKCk7XG5cdH0sXG5cblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdGRvbU1hbmlwOiBmdW5jdGlvbiggYXJncywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHRcdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2V0ID0gdGhpcyxcblx0XHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRcdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gc2V0LmVxKCBpbmRleCApO1xuXHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5kb21NYW5pcCggYXJncywgY2FsbGJhY2sgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggbCApIHtcblx0XHRcdGZyYWdtZW50ID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIGFyZ3MsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgdGhpcyApO1xuXHRcdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGZpcnN0ICkge1xuXHRcdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdFxuXHRcdFx0XHRcdFx0XHQvLyBqUXVlcnkubWVyZ2UgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCB0aGlzWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdFx0IWRhdGFfcHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiYgalF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Ncblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSk7XG5cblxudmFyIGlmcmFtZSxcblx0ZWxlbWRpc3BsYXkgPSB7fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAqL1xuLy8gQ2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gZGVmYXVsdERpc3BsYXlcbmZ1bmN0aW9uIGFjdHVhbERpc3BsYXkoIG5hbWUsIGRvYyApIHtcblx0dmFyIHN0eWxlLFxuXHRcdGVsZW0gPSBqUXVlcnkoIGRvYy5jcmVhdGVFbGVtZW50KCBuYW1lICkgKS5hcHBlbmRUbyggZG9jLmJvZHkgKSxcblxuXHRcdC8vIGdldERlZmF1bHRDb21wdXRlZFN0eWxlIG1pZ2h0IGJlIHJlbGlhYmx5IHVzZWQgb25seSBvbiBhdHRhY2hlZCBlbGVtZW50XG5cdFx0ZGlzcGxheSA9IHdpbmRvdy5nZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSAmJiAoIHN0eWxlID0gd2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlKCBlbGVtWyAwIF0gKSApID9cblxuXHRcdFx0Ly8gVXNlIG9mIHRoaXMgbWV0aG9kIGlzIGEgdGVtcG9yYXJ5IGZpeCAobW9yZSBsaWtlIG9wdGltaXphdGlvbikgdW50aWwgc29tZXRoaW5nIGJldHRlciBjb21lcyBhbG9uZyxcblx0XHRcdC8vIHNpbmNlIGl0IHdhcyByZW1vdmVkIGZyb20gc3BlY2lmaWNhdGlvbiBhbmQgc3VwcG9ydGVkIG9ubHkgaW4gRkZcblx0XHRcdHN0eWxlLmRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtWyAwIF0sIFwiZGlzcGxheVwiICk7XG5cblx0Ly8gV2UgZG9uJ3QgaGF2ZSBhbnkgZGF0YSBzdG9yZWQgb24gdGhlIGVsZW1lbnQsXG5cdC8vIHNvIHVzZSBcImRldGFjaFwiIG1ldGhvZCBhcyBmYXN0IHdheSB0byBnZXQgcmlkIG9mIHRoZSBlbGVtZW50XG5cdGVsZW0uZGV0YWNoKCk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbi8qKlxuICogVHJ5IHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBkaXNwbGF5IHZhbHVlIG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuICovXG5mdW5jdGlvbiBkZWZhdWx0RGlzcGxheSggbm9kZU5hbWUgKSB7XG5cdHZhciBkb2MgPSBkb2N1bWVudCxcblx0XHRkaXNwbGF5ID0gZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF07XG5cblx0aWYgKCAhZGlzcGxheSApIHtcblx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXG5cdFx0Ly8gSWYgdGhlIHNpbXBsZSB3YXkgZmFpbHMsIHJlYWQgZnJvbSBpbnNpZGUgYW4gaWZyYW1lXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiB8fCAhZGlzcGxheSApIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBhbHJlYWR5LWNyZWF0ZWQgaWZyYW1lIGlmIHBvc3NpYmxlXG5cdFx0XHRpZnJhbWUgPSAoaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSkuYXBwZW5kVG8oIGRvYy5kb2N1bWVudEVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gQWx3YXlzIHdyaXRlIGEgbmV3IEhUTUwgc2tlbGV0b24gc28gV2Via2l0IGFuZCBGaXJlZm94IGRvbid0IGNob2tlIG9uIHJldXNlXG5cdFx0XHRkb2MgPSBpZnJhbWVbIDAgXS5jb250ZW50RG9jdW1lbnQ7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0XHRkb2Mud3JpdGUoKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXG5cdFx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXHRcdFx0aWZyYW1lLmRldGFjaCgpO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHRoZSBjb3JyZWN0IGRlZmF1bHQgZGlzcGxheVxuXHRcdGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdID0gZGlzcGxheTtcblx0fVxuXG5cdHJldHVybiBkaXNwbGF5O1xufVxudmFyIHJtYXJnaW4gPSAoL15tYXJnaW4vKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHRpZiAoIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5vcGVuZXIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cdH1cblxuXHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBpT1MgPCA2XG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIGlPUyA8IDYgKGF0IGxlYXN0KSByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIGEgbGFyZ2VyIHNldCBvZiB2YWx1ZXMsIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHNcblx0XHQvLyB0aGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6IGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICh0aGlzLmdldCA9IGhvb2tGbikuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCxcblx0XHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O21hcmdpbi10b3A6MXB4O1wiICtcblx0XHRcInBvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKSB7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcImJveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbi10b3A6MSU7dG9wOjElO1wiICtcblx0XHRcdFwiYm9yZGVyOjFweDtwYWRkaW5nOjFweDt3aWR0aDo0cHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSBkaXZTdHlsZS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdGRvY0VsZW0ucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogbm9kZS5qcyBqc2RvbVxuXHQvLyBEb24ndCBhc3N1bWUgdGhhdCBnZXRDb21wdXRlZFN0eWxlIGlzIGEgcHJvcGVydHkgb2YgdGhlIGdsb2JhbCBvYmplY3Rcblx0aWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBUaGlzIHRlc3QgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGJ1dCB3ZSBzdGlsbCBkbyBtZW1vaXppbmdcblx0XHRcdFx0Ly8gc2luY2Ugd2UgY2FuIHVzZSB0aGUgYm94U2l6aW5nUmVsaWFibGUgcHJlLWNvbXB1dGluZy5cblx0XHRcdFx0Ly8gTm8gbmVlZCB0byBjaGVjayBpZiB0aGUgdGVzdCB3YXMgYWxyZWFkeSBwZXJmb3JtZWQsIHRob3VnaC5cblx0XHRcdFx0Y29tcHV0ZVBpeGVsUG9zaXRpb25BbmRCb3hTaXppbmdSZWxpYWJsZSgpO1xuXHRcdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHRcdH0sXG5cdFx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdFx0fSxcblx0XHRcdHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdFx0Ly8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiAoIzMzMzMpXG5cdFx0XHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXG5cdFx0XHRcdHZhciByZXQsXG5cdFx0XHRcdFx0bWFyZ2luRGl2ID0gZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nXG5cdFx0XHRcdG1hcmdpbkRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdFx0XHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcblx0XHRcdFx0XHRcImJveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcblx0XHRcdFx0bWFyZ2luRGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXCIwXCI7XG5cdFx0XHRcdGRpdi5zdHlsZS53aWR0aCA9IFwiMXB4XCI7XG5cdFx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0XHRcdHJldCA9ICFwYXJzZUZsb2F0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2LCBudWxsICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0XHRkb2NFbGVtLnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0XHRcdFx0ZGl2LnJlbW92ZUNoaWxkKCBtYXJnaW5EaXYgKTtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KSgpO1xuXG5cbi8vIEEgbWV0aG9kIGZvciBxdWlja2x5IHN3YXBwaW5nIGluL291dCBDU1MgcHJvcGVydGllcyB0byBnZXQgY29ycmVjdCBjYWxjdWxhdGlvbnMuXG5qUXVlcnkuc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhclxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRybnVtc3BsaXQgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKC4qKSRcIiwgXCJpXCIgKSxcblx0cnJlbE51bSA9IG5ldyBSZWdFeHAoIFwiXihbKy1dKT0oXCIgKyBwbnVtICsgXCIpXCIsIFwiaVwiICksXG5cblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiT1wiLCBcIk1velwiLCBcIm1zXCIgXTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBzdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLFxuXHRcdG9yaWdOYW1lID0gbmFtZSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3JpZ05hbWU7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cdHZhciBtYXRjaGVzID0gcm51bXNwbGl0LmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAxIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAyIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cdFx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdFx0NCA6XG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QodmFsKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLCBoaWRkZW4sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YV9wcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblx0XHRcdC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcblx0XHRcdC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3Rcblx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuXHRcdFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcblx0XHRcdC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBkZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuXG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4gKSB7XG5cdFx0XHRcdGRhdGFfcHJpdi5zZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBoaWRkZW4gPyBkaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiBtb3N0IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wXG5cdC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoICFzaG93IHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlc1sgaW5kZXggXSB8fCBcIlwiIDogXCJub25lXCI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgKCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggc3R5bGUsIG9yaWdOYW1lICkgKTtcblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHJldCA9IHJyZWxOdW0uZXhlYyggdmFsdWUgKSkgKSB7XG5cdFx0XHRcdHZhbHVlID0gKCByZXRbMV0gKyAxICkgKiByZXRbMl0gKyBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICkgKTtcblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciwgYWRkICdweCcgdG8gdGhlIChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gKSB7XG5cdFx0XHRcdHZhbHVlICs9IFwicHhcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIGVsZW0uc3R5bGUsIG9yaWdOYW1lICkgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgalF1ZXJ5LmlzTnVtZXJpYyggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJiBlbGVtLm9mZnNldFdpZHRoID09PSAwID9cblx0XHRcdFx0XHRqUXVlcnkuc3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgZXh0cmEgP1xuXHRcdFx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KSA6IDBcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufSk7XG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luUmlnaHQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSxcblx0XHRcdFx0Y3VyQ1NTLCBbIGVsZW0sIFwibWFyZ2luUmlnaHRcIiBdICk7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCh7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdChcIiBcIikgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW4oIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgXCJzd2luZ1wiO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJlxuXHRcdFx0XHQoIXR3ZWVuLmVsZW0uc3R5bGUgfHwgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwpICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLnN0eWxlICYmICggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8IGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9XG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBDb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJmeG51bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICksXG5cdHJydW4gPSAvcXVldWVIb29rcyQvLFxuXHRhbmltYXRpb25QcmVmaWx0ZXJzID0gWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cdHR3ZWVuZXJzID0ge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICksXG5cdFx0XHRcdHRhcmdldCA9IHR3ZWVuLmN1cigpLFxuXHRcdFx0XHRwYXJ0cyA9IHJmeG51bS5leGVjKCB2YWx1ZSApLFxuXHRcdFx0XHR1bml0ID0gcGFydHMgJiYgcGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdFx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdFx0XHRzdGFydCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiArdGFyZ2V0ICkgJiZcblx0XHRcdFx0XHRyZnhudW0uZXhlYyggalF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgcHJvcCApICksXG5cdFx0XHRcdHNjYWxlID0gMSxcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDIwO1xuXG5cdFx0XHRpZiAoIHN0YXJ0ICYmIHN0YXJ0WyAzIF0gIT09IHVuaXQgKSB7XG5cdFx0XHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHRcdFx0dW5pdCA9IHVuaXQgfHwgc3RhcnRbIDMgXTtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0XHRcdHBhcnRzID0gcGFydHMgfHwgW107XG5cblx0XHRcdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRcdFx0c3RhcnQgPSArdGFyZ2V0IHx8IDE7XG5cblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqLlxuXHRcdFx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdFx0XHQvLyBBZGp1c3QgYW5kIGFwcGx5XG5cdFx0XHRcdFx0c3RhcnQgPSBzdGFydCAvIHNjYWxlO1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgcHJvcCwgc3RhcnQgKyB1bml0ICk7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm8gb3IgTmFOIGZyb20gdHdlZW4uY3VyKCksXG5cdFx0XHRcdC8vIGJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2hcblx0XHRcdFx0fSB3aGlsZSAoIHNjYWxlICE9PSAoc2NhbGUgPSB0d2Vlbi5jdXIoKSAvIHRhcmdldCkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0d2VlbiBwcm9wZXJ0aWVzXG5cdFx0XHRpZiAoIHBhcnRzICkge1xuXHRcdFx0XHRzdGFydCA9IHR3ZWVuLnN0YXJ0ID0gK3N0YXJ0IHx8ICt0YXJnZXQgfHwgMDtcblx0XHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHRcdC8vIElmIGEgKz0vLT0gdG9rZW4gd2FzIHByb3ZpZGVkLCB3ZSdyZSBkb2luZyBhIHJlbGF0aXZlIGFuaW1hdGlvblxuXHRcdFx0XHR0d2Vlbi5lbmQgPSBwYXJ0c1sgMSBdID9cblx0XHRcdFx0XHRzdGFydCArICggcGFydHNbIDEgXSArIDEgKSAqIHBhcnRzWyAyIF0gOlxuXHRcdFx0XHRcdCtwYXJ0c1sgMiBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH07XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9KTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNCA7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCB0d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICh0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIHR3ZWVuLCBob29rcywgb2xkZmlyZSwgZGlzcGxheSwgY2hlY2tEaXNwbGF5LFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbiggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YV9wcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIEhhbmRsZSBxdWV1ZTogZmFsc2UgcHJvbWlzZXNcblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gSGVpZ2h0L3dpZHRoIG92ZXJmbG93IHBhc3Ncblx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCJoZWlnaHRcIiBpbiBwcm9wcyB8fCBcIndpZHRoXCIgaW4gcHJvcHMgKSApIHtcblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFOS0xMCBkbyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICkgfHwgZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXk7XG5cblx0XHRpZiAoIGNoZWNrRGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBzaG93L2hpZGUgcGFzc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLmV4ZWMoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGRhdGFTaG93IGxlZnQgb3ZlciBmcm9tIGEgc3RvcHBlZCBoaWRlIG9yIHNob3cgYW5kIHdlIGFyZSBnb2luZyB0byBwcm9jZWVkIHdpdGggc2hvdywgd2Ugc2hvdWxkIHByZXRlbmQgdG8gYmUgaGlkZGVuXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXG5cdFx0Ly8gQW55IG5vbi1meCB2YWx1ZSBzdG9wcyB1cyBmcm9tIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXNwbGF5ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhU2hvdyA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHt9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcInJldmVyc2VcIlxuXHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHR9XG5cdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5zaG93KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW0uZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5KCBlbGVtICkuaGlkZSgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGFuaW0uZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0dHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblxuXHRcdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdFx0dHdlZW4uZW5kID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdFx0dHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdC8vIElmIHRoaXMgaXMgYSBub29wIGxpa2UgLmhpZGUoKS5oaWRlKCksIHJlc3RvcmUgYW4gb3ZlcndyaXR0ZW4gZGlzcGxheSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCAoZGlzcGxheSA9PT0gXCJub25lXCIgPyBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheSkgPT09IFwiaW5saW5lXCIgKSB7XG5cdFx0c3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGFuaW1hdGlvblByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9KSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7IHNwZWNpYWxFYXNpbmc6IHt9IH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9KSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IGFuaW1hdGlvblByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9KVxuXHQpO1xuXG5cdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5zcGxpdChcIiBcIik7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdHR3ZWVuZXJzWyBwcm9wIF0gPSB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0dHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRhbmltYXRpb25QcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XG5cdFx0b3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgPyBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbiApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSh7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFfcHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmICh0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlKSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YV9wcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKHtcblx0c2xpZGVEb3duOiBnZW5GeChcInNob3dcIiksXG5cdHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KFwidG9nZ2xlXCIpLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5cbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoICF0aW1lcklkICkge1xuXHRcdHRpbWVySWQgPSBzZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRjbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSk7XG59O1xuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBpT1M8PTUuMSwgQW5kcm9pZDw9NC4yK1xuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8PTIuM1xuXHQvLyBPcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZSBpbmNvcnJlY3RseSBtYXJrZWQgYXMgZGlzYWJsZWRcblx0c2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcblx0c3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59KSgpO1xuXG5cbnZhciBub2RlSG9vaywgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBkb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiBub2RlSG9vayApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID9cblx0XHRcdFx0dW5kZWZpbmVkIDpcblx0XHRcdFx0cmV0O1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsIHByb3BOYW1lLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAobmFtZSA9IGF0dHJOYW1lc1tpKytdKSApIHtcblx0XHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cblx0XHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGdldCBzcGVjaWFsIHRyZWF0bWVudCAoIzEwODcwKVxuXHRcdFx0XHRpZiAoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRcdC8vIFNldCBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHRvIGZhbHNlXG5cdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0alF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBuYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59KTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fSxcblxuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsIG5vdHhtbCxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcblxuXHRcdGlmICggbm90eG1sICkge1xuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyZXQgOlxuXHRcdFx0XHQoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCA/XG5cdFx0XHRcdHJldCA6XG5cdFx0XHRcdGVsZW1bIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmhhc0F0dHJpYnV0ZSggXCJ0YWJpbmRleFwiICkgfHwgcmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHwgZWxlbS5ocmVmID9cblx0XHRcdFx0XHRlbGVtLnRhYkluZGV4IDpcblx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59KTtcblxuXG5cblxudmFyIHJjbGFzcyA9IC9bXFx0XFxyXFxuXFxmXS9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdHByb2NlZWQgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSApICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHByb2NlZWQgKSB7XG5cdFx0XHQvLyBUaGUgZGlzanVuY3Rpb24gaGVyZSBpcyBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIHJlbW92ZUNsYXNzKVxuXHRcdFx0Y2xhc3NlcyA9ICggdmFsdWUgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF07XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBlbGVtLmNsYXNzTmFtZSA/XG5cdFx0XHRcdFx0KCBcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICkgOlxuXHRcdFx0XHRcdFwiIFwiXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoY2xhenogPSBjbGFzc2VzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmNsYXNzTmFtZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0cHJvY2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgdGhpcy5jbGFzc05hbWUgKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGlmICggcHJvY2VlZCApIHtcblx0XHRcdGNsYXNzZXMgPSAoIHZhbHVlIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggZWxlbS5jbGFzc05hbWUgP1xuXHRcdFx0XHRcdCggXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRcIlwiXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoY2xhenogPSBjbGFzc2VzW2orK10pICkge1xuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPj0gMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSB2YWx1ZSA/IGpRdWVyeS50cmltKCBjdXIgKSA6IFwiXCI7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmNsYXNzTmFtZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGksIHRoaXMuY2xhc3NOYW1lLCBzdGF0ZVZhbCksIHN0YXRlVmFsICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHR2YXIgY2xhc3NOYW1lLFxuXHRcdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdKSApIHtcblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gc3RydW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuY2xhc3NOYW1lICkge1xuXHRcdFx0XHRcdC8vIHN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhX3ByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgdGhpcy5jbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0dGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgPyBcIlwiIDogZGF0YV9wcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggdGhpc1tpXS5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpLmluZGV4T2YoIGNsYXNzTmFtZSApID49IDAgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1swXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdHJldC5yZXBsYWNlKHJyZXR1cm4sIFwiXCIpIDpcblx0XHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0XHRyZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTAtMTErXG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdGpRdWVyeS50cmltKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIiB8fCBpbmRleCA8IDAsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIElFNi05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCggc3VwcG9ydC5vcHREaXNhYmxlZCA/ICFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKCBcImRpc2FibGVkXCIgKSA9PT0gbnVsbCApICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCAob3B0aW9uLnNlbGVjdGVkID0galF1ZXJ5LmluQXJyYXkoIG9wdGlvbi52YWx1ZSwgdmFsdWVzICkgPj0gMCkgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaChbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlICkgPj0gMCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxualF1ZXJ5LmVhY2goIChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiKS5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH0sXG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyB0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDogdGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0pO1xuXG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICgvXFw/Lyk7XG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuLy8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcbmpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKyBcIlwiICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCB0bXA7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0dHJ5IHtcblx0XHR0bXAgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0eG1sID0gdG1wLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyaGFzaCA9IC8jLiokLyxcblx0cnRzID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXHRydXJsID0gL14oW1xcdy4rLV0rOikoPzpcXC9cXC8oPzpbXlxcLz8jXSpAfCkoW15cXC8/IzpdKikoPzo6KFxcZCspfCl8KS8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBEb2N1bWVudCBsb2NhdGlvblxuXHRhamF4TG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24uaHJlZixcblxuXHQvLyBTZWdtZW50IGxvY2F0aW9uIGludG8gcGFydHNcblx0YWpheExvY1BhcnRzID0gcnVybC5leGVjKCBhamF4TG9jYXRpb24udG9Mb3dlckNhc2UoKSApIHx8IFtdO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoZGF0YVR5cGUgPSBkYXRhVHlwZXNbaSsrXSkgKSB7XG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbMF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdChzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10pLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiYgIXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoZGVlcCA9IHt9KSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgc1sgXCJ0aHJvd3NcIiBdICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHsgc3RhdGU6IFwicGFyc2VyZXJyb3JcIiwgZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50IH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBhamF4TG9jYXRpb24sXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBhamF4TG9jUGFydHNbIDEgXSApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL3htbC8sXG5cdFx0XHRodG1sOiAvaHRtbC8sXG5cdFx0XHRqc29uOiAvanNvbi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogalF1ZXJ5LnBhcnNlSlNPTixcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXHRcdFx0Ly8gQ3Jvc3MtZG9tYWluIGRldGVjdGlvbiB2YXJzXG5cdFx0XHRwYXJ0cyxcblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiYgKCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdGpRdWVyeS5ldmVudCxcblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXHRcdFx0Ly8gVGhlIGpxWEhSIHN0YXRlXG5cdFx0XHRzdGF0ZSA9IDAsXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlID09PSAyID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0dmFyIGxuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApLmNvbXBsZXRlID0gY29tcGxldGVEZWZlcnJlZC5hZGQ7XG5cdFx0anFYSFIuc3VjY2VzcyA9IGpxWEhSLmRvbmU7XG5cdFx0anFYSFIuZXJyb3IgPSBqcVhIUi5mYWlsO1xuXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggY2hhcmFjdGVyICgjNzUzMTogYW5kIHN0cmluZyBwcm9tb3Rpb24pXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgYWpheExvY2F0aW9uICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgYWpheExvY1BhcnRzWyAxIF0gKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHdlIGhhdmUgYSBwcm90b2NvbDpob3N0OnBvcnQgbWlzbWF0Y2hcblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHBhcnRzID0gcnVybC5leGVjKCBzLnVybC50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRzLmNyb3NzRG9tYWluID0gISEoIHBhcnRzICYmXG5cdFx0XHRcdCggcGFydHNbIDEgXSAhPT0gYWpheExvY1BhcnRzWyAxIF0gfHwgcGFydHNbIDIgXSAhPT0gYWpheExvY1BhcnRzWyAyIF0gfHxcblx0XHRcdFx0XHQoIHBhcnRzWyAzIF0gfHwgKCBwYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyBcIjgwXCIgOiBcIjQ0M1wiICkgKSAhPT1cblx0XHRcdFx0XHRcdCggYWpheExvY1BhcnRzWyAzIF0gfHwgKCBhamF4TG9jUGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHRjYWNoZVVSTCA9IHMudXJsO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9ICggcy51cmwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YSApO1xuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVybCBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHMudXJsID0gcnRzLnRlc3QoIGNhY2hlVVJMICkgP1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhICdfJyBwYXJhbWV0ZXIsIHNldCBpdHMgdmFsdWVcblx0XHRcdFx0XHRjYWNoZVVSTC5yZXBsYWNlKCBydHMsIFwiJDFfPVwiICsgbm9uY2UrKyApIDpcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBhZGQgb25lIHRvIHRoZSBlbmRcblx0XHRcdFx0XHRjYWNoZVVSTCArICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyBub25jZSsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gKyAoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJiAoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IHN0YXRlID09PSAyICkgKSB7XG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Zm9yICggaSBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9ICkge1xuXHRcdFx0anFYSFJbIGkgXSggc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KFwidGltZW91dFwiKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHN0YXRlID0gMTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0XHQvLyBTaW1wbHkgcmV0aHJvdyBvdGhlcndpc2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gQ2FsbGVkIG9uY2Vcblx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdGUgaXMgXCJkb25lXCIgbm93XG5cdFx0XHRzdGF0ZSA9IDI7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJldGFnXCIpO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdG9wXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59KTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkuYWpheCh7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSk7XG5cdH07XG59KTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xuXHRcdHVybDogdXJsLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9KTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9KS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwodGhpcywgaSkgOiBodG1sICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImJvZHlcIiApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0XHR9XG5cdFx0fSkuZW5kKCk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDw9IDEyLjEyXG5cdC8vIE9wZXJhIHJlcG9ydHMgb2Zmc2V0V2lkdGhzIGFuZCBvZmZzZXRIZWlnaHRzIGxlc3MgdGhhbiB6ZXJvIG9uIHNvbWUgZWxlbWVudHNcblx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPD0gMCAmJiBlbGVtLm9mZnNldEhlaWdodCA8PSAwO1xufTtcbmpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuKCBlbGVtICk7XG59O1xuXG5cblxuXG52YXIgcjIwID0gLyUyMC9nLFxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgPyBpIDogXCJcIiApICsgXCJdXCIsIHYsIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0pO1xuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSlcblx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9KVxuXHRcdC5tYXAoZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9KS5nZXQoKTtcblx0fVxufSk7XG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2goIGUgKSB7fVxufTtcblxudmFyIHhocklkID0gMCxcblx0eGhyQ2FsbGJhY2tzID0ge30sXG5cdHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cdFx0Ly8gZmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gT3BlbiByZXF1ZXN0cyBtdXN0IGJlIG1hbnVhbGx5IGFib3J0ZWQgb24gdW5sb2FkICgjNTI4MClcbi8vIFNlZSBodHRwczovL3N1cHBvcnQubWljcm9zb2Z0LmNvbS9rYi8yODU2NzQ2IGZvciBtb3JlIGluZm9cbmlmICggd2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHR3aW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICggdmFyIGtleSBpbiB4aHJDYWxsYmFja3MgKSB7XG5cdFx0XHR4aHJDYWxsYmFja3NbIGtleSBdKCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKSxcblx0XHRcdFx0XHRpZCA9ICsreGhySWQ7XG5cblx0XHRcdFx0eGhyLm9wZW4oIG9wdGlvbnMudHlwZSwgb3B0aW9ucy51cmwsIG9wdGlvbnMuYXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQgKTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHhockNhbGxiYWNrc1sgaWQgXTtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSB4aHIub25sb2FkID0geGhyLm9uZXJyb3IgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBmaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEFjY2Vzc2luZyBiaW5hcnktZGF0YSByZXNwb25zZVRleHQgdGhyb3dzIGFuIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gKCMxMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ID09PSBcInN0cmluZ1wiID8ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0OiB4aHIucmVzcG9uc2VUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHR9IDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0eGhyLm9uZXJyb3IgPSBjYWxsYmFjayhcImVycm9yXCIpO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSB4aHJDYWxsYmFja3NbIGlkIF0gPSBjYWxsYmFjayhcImFib3J0XCIpO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSk7XG5cblxuXG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvKD86amF2YXxlY21hKXNjcmlwdC9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0pO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KFwiPHNjcmlwdD5cIikucHJvcCh7XG5cdFx0XHRcdFx0YXN5bmM6IHRydWUsXG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoe1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0pO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmICEoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikgJiYgcmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIGZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBSZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIHNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSk7XG5cblxuXG5cbi8vIGRhdGE6IHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0dmFyIHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApLFxuXHRcdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsxXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBqUXVlcnkuYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxudmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcblx0XHRyZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZihcIiBcIik7XG5cblx0aWYgKCBvZmYgPj0gMCApIHtcblx0XHRzZWxlY3RvciA9IGpRdWVyeS50cmltKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoe1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIGlmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWRcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9KS5kb25lKGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KFwiPGRpdj5cIikuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0fSkuY29tcGxldGUoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBjYWxsYmFjaywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFsgXCJhamF4U3RhcnRcIiwgXCJhamF4U3RvcFwiLCBcImFqYXhDb21wbGV0ZVwiLCBcImFqYXhFcnJvclwiLCBcImFqYXhTdWNjZXNzXCIsIFwiYWpheFNlbmRcIiBdLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59KTtcblxuXG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9KS5sZW5ndGg7XG59O1xuXG5cblxuXG52YXIgZG9jRWxlbSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbi8qKlxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoXCJhdXRvXCIpID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgY3VyT2Zmc2V0ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgZG9jRWxlbSwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGJveCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH0sXG5cdFx0XHRkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDtcblxuXHRcdGlmICggIWRvYyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuXHRcdGlmICggIWpRdWVyeS5jb250YWlucyggZG9jRWxlbSwgZWxlbSApICkge1xuXHRcdFx0cmV0dXJuIGJveDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBCbGFja0JlcnJ5IDUsIGlPUyAzIChvcmlnaW5hbCBpUGhvbmUpXG5cdFx0Ly8gSWYgd2UgZG9uJ3QgaGF2ZSBnQkNSLCBqdXN0IHVzZSAwLDAgcmF0aGVyIHRoYW4gZXJyb3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0Ym94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR9XG5cdFx0d2luID0gZ2V0V2luZG93KCBkb2MgKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBib3gudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRsZWZ0OiBib3gubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdH07XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50IHx8IGRvY0VsZW07XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50LCBcImh0bWxcIiApICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2NFbGVtO1xuXHRcdH0pO1xuXHR9XG59KTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbmRvdy5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCApO1xuXHR9O1xufSk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaTw3KywgQ2hyb21lPDM3K1xuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MjgwXG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSwgZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHRcdC8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCApO1xuXHRcdH07XG5cdH0pO1xufSk7XG5cblxuLy8gVGhlIG51bWJlciBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXRcbmpRdWVyeS5mbi5zaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbmpRdWVyeS5mbi5hbmRTZWxmID0galF1ZXJ5LmZuLmFkZEJhY2s7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSk7XG59XG5cblxuXG5cbnZhclxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gc3RydW5kZWZpbmVkICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG5cbn0pKTtcbiIsIjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoZmFjdG9yeSgpKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICByb290LndoYXRJbnB1dCA9IGZhY3RvcnkoKTtcbiAgfVxufSAodGhpcywgZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuXG4gIC8qXG4gICAgLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyaWFibGVzXG4gICAgLS0tLS0tLS0tLS0tLS0tXG4gICovXG5cbiAgLy8gYXJyYXkgb2YgYWN0aXZlbHkgcHJlc3NlZCBrZXlzXG4gIHZhciBhY3RpdmVLZXlzID0gW107XG5cbiAgLy8gY2FjaGUgZG9jdW1lbnQuYm9keVxuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cbiAgLy8gYm9vbGVhbjogdHJ1ZSBpZiB0b3VjaCBidWZmZXIgdGltZXIgaXMgcnVubmluZ1xuICB2YXIgYnVmZmVyID0gZmFsc2U7XG5cbiAgLy8gdGhlIGxhc3QgdXNlZCBpbnB1dCB0eXBlXG4gIHZhciBjdXJyZW50SW5wdXQgPSBudWxsO1xuXG4gIC8vIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgdGhhdCB0YWtlIGtleWJvYXJkIGlucHV0XG4gIHZhciBmb3JtSW5wdXRzID0gW1xuICAgICdpbnB1dCcsXG4gICAgJ3NlbGVjdCcsXG4gICAgJ3RleHRhcmVhJ1xuICBdO1xuXG4gIC8vIHVzZXItc2V0IGZsYWcgdG8gYWxsb3cgdHlwaW5nIGluIGZvcm0gZmllbGRzIHRvIGJlIHJlY29yZGVkXG4gIHZhciBmb3JtVHlwaW5nID0gYm9keS5oYXNBdHRyaWJ1dGUoJ2RhdGEtd2hhdGlucHV0LWZvcm10eXBpbmcnKTtcblxuICAvLyBtYXBwaW5nIG9mIGV2ZW50cyB0byBpbnB1dCB0eXBlc1xuICB2YXIgaW5wdXRNYXAgPSB7XG4gICAgJ2tleWRvd24nOiAna2V5Ym9hcmQnLFxuICAgICdtb3VzZWRvd24nOiAnbW91c2UnLFxuICAgICdtb3VzZWVudGVyJzogJ21vdXNlJyxcbiAgICAndG91Y2hzdGFydCc6ICd0b3VjaCcsXG4gICAgJ3BvaW50ZXJkb3duJzogJ3BvaW50ZXInLFxuICAgICdNU1BvaW50ZXJEb3duJzogJ3BvaW50ZXInXG4gIH07XG5cbiAgLy8gYXJyYXkgb2YgYWxsIHVzZWQgaW5wdXQgdHlwZXNcbiAgdmFyIGlucHV0VHlwZXMgPSBbXTtcblxuICAvLyBtYXBwaW5nIG9mIGtleSBjb2RlcyB0byBjb21tb24gbmFtZVxuICB2YXIga2V5TWFwID0ge1xuICAgIDk6ICd0YWInLFxuICAgIDEzOiAnZW50ZXInLFxuICAgIDE2OiAnc2hpZnQnLFxuICAgIDI3OiAnZXNjJyxcbiAgICAzMjogJ3NwYWNlJyxcbiAgICAzNzogJ2xlZnQnLFxuICAgIDM4OiAndXAnLFxuICAgIDM5OiAncmlnaHQnLFxuICAgIDQwOiAnZG93bidcbiAgfTtcblxuICAvLyBtYXAgb2YgSUUgMTAgcG9pbnRlciBldmVudHNcbiAgdmFyIHBvaW50ZXJNYXAgPSB7XG4gICAgMjogJ3RvdWNoJyxcbiAgICAzOiAndG91Y2gnLCAvLyB0cmVhdCBwZW4gbGlrZSB0b3VjaFxuICAgIDQ6ICdtb3VzZSdcbiAgfTtcblxuICAvLyB0b3VjaCBidWZmZXIgdGltZXJcbiAgdmFyIHRpbWVyO1xuXG5cbiAgLypcbiAgICAtLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbnNcbiAgICAtLS0tLS0tLS0tLS0tLS1cbiAgKi9cblxuICBmdW5jdGlvbiBidWZmZXJJbnB1dChldmVudCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICBzZXRJbnB1dChldmVudCk7XG5cbiAgICBidWZmZXIgPSB0cnVlO1xuICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGJ1ZmZlciA9IGZhbHNlO1xuICAgIH0sIDEwMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gaW1tZWRpYXRlSW5wdXQoZXZlbnQpIHtcbiAgICBpZiAoIWJ1ZmZlcikgc2V0SW5wdXQoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW5wdXQoZXZlbnQpIHtcbiAgICB2YXIgZXZlbnRLZXkgPSBrZXkoZXZlbnQpO1xuICAgIHZhciBldmVudFRhcmdldCA9IHRhcmdldChldmVudCk7XG4gICAgdmFyIHZhbHVlID0gaW5wdXRNYXBbZXZlbnQudHlwZV07XG4gICAgaWYgKHZhbHVlID09PSAncG9pbnRlcicpIHZhbHVlID0gcG9pbnRlclR5cGUoZXZlbnQpO1xuXG4gICAgaWYgKGN1cnJlbnRJbnB1dCAhPT0gdmFsdWUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gb25seSBpZiB0aGUgdXNlciBmbGFnIGlzbid0IHNldFxuICAgICAgICAhZm9ybVR5cGluZyAmJlxuXG4gICAgICAgIC8vIG9ubHkgaWYgY3VycmVudElucHV0IGhhcyBhIHZhbHVlXG4gICAgICAgIGN1cnJlbnRJbnB1dCAmJlxuXG4gICAgICAgIC8vIG9ubHkgaWYgdGhlIGlucHV0IGlzIGBrZXlib2FyZGBcbiAgICAgICAgdmFsdWUgPT09ICdrZXlib2FyZCcgJiZcblxuICAgICAgICAvLyBub3QgaWYgdGhlIGtleSBpcyBgVEFCYFxuICAgICAgICBrZXlNYXBbZXZlbnRLZXldICE9PSAndGFiJyAmJlxuXG4gICAgICAgIC8vIG9ubHkgaWYgdGhlIHRhcmdldCBpcyBvbmUgb2YgdGhlIGVsZW1lbnRzIGluIGBmb3JtSW5wdXRzYFxuICAgICAgICBmb3JtSW5wdXRzLmluZGV4T2YoZXZlbnRUYXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgPj0gMFxuICAgICAgKSB7XG4gICAgICAgIC8vIGlnbm9yZSBrZXlib2FyZCB0eXBpbmcgb24gZm9ybSBlbGVtZW50c1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudElucHV0ID0gdmFsdWU7XG4gICAgICAgIGJvZHkuc2V0QXR0cmlidXRlKCdkYXRhLXdoYXRpbnB1dCcsIGN1cnJlbnRJbnB1dCk7XG5cbiAgICAgICAgaWYgKGlucHV0VHlwZXMuaW5kZXhPZihjdXJyZW50SW5wdXQpID09PSAtMSkgaW5wdXRUeXBlcy5wdXNoKGN1cnJlbnRJbnB1dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAna2V5Ym9hcmQnKSBsb2dLZXlzKGV2ZW50S2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleShldmVudCkge1xuICAgIHJldHVybiAoZXZlbnQua2V5Q29kZSkgPyBldmVudC5rZXlDb2RlIDogZXZlbnQud2hpY2g7XG4gIH1cblxuICBmdW5jdGlvbiB0YXJnZXQoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludGVyVHlwZShldmVudCkge1xuICAgIHJldHVybiAodHlwZW9mIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbnVtYmVyJykgPyBwb2ludGVyTWFwW2V2ZW50LnBvaW50ZXJUeXBlXSA6IGV2ZW50LnBvaW50ZXJUeXBlO1xuICB9XG5cbiAgLy8ga2V5Ym9hcmQgbG9nZ2luZ1xuICBmdW5jdGlvbiBsb2dLZXlzKGV2ZW50S2V5KSB7XG4gICAgaWYgKGFjdGl2ZUtleXMuaW5kZXhPZihrZXlNYXBbZXZlbnRLZXldKSA9PT0gLTEgJiYga2V5TWFwW2V2ZW50S2V5XSkgYWN0aXZlS2V5cy5wdXNoKGtleU1hcFtldmVudEtleV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5Mb2dLZXlzKGV2ZW50KSB7XG4gICAgdmFyIGV2ZW50S2V5ID0ga2V5KGV2ZW50KTtcbiAgICB2YXIgYXJyYXlQb3MgPSBhY3RpdmVLZXlzLmluZGV4T2Yoa2V5TWFwW2V2ZW50S2V5XSk7XG5cbiAgICBpZiAoYXJyYXlQb3MgIT09IC0xKSBhY3RpdmVLZXlzLnNwbGljZShhcnJheVBvcywgMSk7XG4gIH1cblxuXG4gIC8qXG4gICAgLS0tLS0tLS0tLS0tLS0tXG4gICAgaW5pdFxuICAgIC0tLS0tLS0tLS0tLS0tLVxuICAqL1xuXG4gIChmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuXG4gICAgLy8gcG9pbnRlci9tb3VzZVxuICAgIHZhciBtb3VzZUV2ZW50ID0gJ21vdXNlZG93bic7XG5cbiAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgbW91c2VFdmVudCA9ICdwb2ludGVyZG93bic7XG4gICAgfSBlbHNlIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcbiAgICAgIG1vdXNlRXZlbnQgPSAnTVNQb2ludGVyRG93bic7XG4gICAgfVxuXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKG1vdXNlRXZlbnQsIGltbWVkaWF0ZUlucHV0KTtcbiAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBpbW1lZGlhdGVJbnB1dCk7XG5cbiAgICAvLyB0b3VjaFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGJ1ZmZlcklucHV0KTtcblxuICAgIC8vIGtleWJvYXJkXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaW1tZWRpYXRlSW5wdXQpO1xuICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1bkxvZ0tleXMpO1xuXG4gIH0pKCk7XG5cblxuICAvKlxuICAgIC0tLS0tLS0tLS0tLS0tLVxuICAgIGFwaVxuICAgIC0tLS0tLS0tLS0tLS0tLVxuICAqL1xuXG4gIHJldHVybiB7XG5cbiAgICAvLyByZXR1cm5zIHN0cmluZzogdGhlIGN1cnJlbnQgaW5wdXQgdHlwZVxuICAgIGFzazogZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50SW5wdXQ7IH0sXG5cbiAgICAvLyByZXR1cm5zIGFycmF5OiBjdXJyZW50bHkgcHJlc3NlZCBrZXlzXG4gICAga2V5czogZnVuY3Rpb24oKSB7IHJldHVybiBhY3RpdmVLZXlzOyB9LFxuXG4gICAgLy8gcmV0dXJucyBhcnJheTogYWxsIHRoZSBkZXRlY3RlZCBpbnB1dCB0eXBlc1xuICAgIHR5cGVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIGlucHV0VHlwZXM7IH0sXG5cbiAgICAvLyBhY2NlcHRzIHN0cmluZzogbWFudWFsbHkgc2V0IHRoZSBpbnB1dCB0eXBlXG4gICAgc2V0OiBzZXRJbnB1dFxuICB9O1xuXG59KSk7XG4iLCIhZnVuY3Rpb24oJCkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEZPVU5EQVRJT05fVkVSU0lPTiA9ICc2LjAuMyc7XG5cbi8vIEdsb2JhbCBGb3VuZGF0aW9uIG9iamVjdFxuLy8gVGhpcyBpcyBhdHRhY2hlZCB0byB0aGUgd2luZG93LCBvciB1c2VkIGFzIGEgbW9kdWxlIGZvciBBTUQvQnJvd3NlcmlmeVxudmFyIEZvdW5kYXRpb24gPSB7XG4gIHZlcnNpb246IEZPVU5EQVRJT05fVkVSU0lPTixcblxuICAvKipcbiAgICogU3RvcmVzIGluaXRpYWxpemVkIHBsdWdpbnMuXG4gICAqL1xuICBfcGx1Z2luczoge30sXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBnZW5lcmF0ZWQgdW5pcXVlIGlkcyBmb3IgcGx1Z2luIGluc3RhbmNlc1xuICAgKi9cbiAgX3V1aWRzOiBbXSxcbiAgLyoqXG4gICAqIFN0b3JlcyBjdXJyZW50bHkgYWN0aXZlIHBsdWdpbnMuXG4gICAqL1xuICBfYWN0aXZlUGx1Z2luczoge30sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGZvciBSVEwgc3VwcG9ydFxuICAgKi9cbiAgcnRsOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiAkKCdodG1sJykuYXR0cignZGlyJykgPT09ICdydGwnO1xuICB9LFxuICAvKipcbiAgICogRGVmaW5lcyBhIEZvdW5kYXRpb24gcGx1Z2luLCBhZGRpbmcgaXQgdG8gdGhlIGBGb3VuZGF0aW9uYCBuYW1lc3BhY2UgYW5kIHRoZSBsaXN0IG9mIHBsdWdpbnMgdG8gaW5pdGlhbGl6ZSB3aGVuIHJlZmxvd2luZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcGx1Z2luLlxuICAgKi9cbiAgcGx1Z2luOiBmdW5jdGlvbihwbHVnaW4sIG5hbWUpIHtcbiAgICAvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIGFkZGluZyB0byBnbG9iYWwgRm91bmRhdGlvbiBvYmplY3RcbiAgICAvLyBFeGFtcGxlczogRm91bmRhdGlvbi5SZXZlYWwsIEZvdW5kYXRpb24uT2ZmQ2FudmFzXG4gICAgdmFyIGNsYXNzTmFtZSA9IChuYW1lIHx8IGZ1bmN0aW9uTmFtZShwbHVnaW4pKTtcbiAgICAvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIHN0b3JpbmcgdGhlIHBsdWdpbiwgYWxzbyB1c2VkIHRvIGNyZWF0ZSB0aGUgaWRlbnRpZnlpbmcgZGF0YSBhdHRyaWJ1dGUgZm9yIHRoZSBwbHVnaW5cbiAgICAvLyBFeGFtcGxlczogZGF0YS1yZXZlYWwsIGRhdGEtb2ZmLWNhbnZhc1xuICAgIHZhciBhdHRyTmFtZSAgPSBoeXBoZW5hdGUoY2xhc3NOYW1lKTtcblxuICAgIC8vIEFkZCB0byB0aGUgRm91bmRhdGlvbiBvYmplY3QgYW5kIHRoZSBwbHVnaW5zIGxpc3QgKGZvciByZWZsb3dpbmcpXG4gICAgdGhpcy5fcGx1Z2luc1thdHRyTmFtZV0gPSB0aGlzW2NsYXNzTmFtZV0gPSBwbHVnaW47XG4gIH0sXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQ3JlYXRlcyBhIHBvaW50ZXIgdG8gYW4gaW5zdGFuY2Ugb2YgYSBQbHVnaW4gd2l0aGluIHRoZSBGb3VuZGF0aW9uLl9hY3RpdmVQbHVnaW5zIG9iamVjdC5cbiAgICogU2V0cyB0aGUgYFtkYXRhLXBsdWdpbk5hbWU9XCJ1bmlxdWVJZEhlcmVcIl1gLCBhbGxvd2luZyBlYXN5IGFjY2VzcyB0byBhbnkgcGx1Z2luJ3MgaW50ZXJuYWwgbWV0aG9kcy5cbiAgICogQWxzbyBmaXJlcyB0aGUgaW5pdGlhbGl6YXRpb24gZXZlbnQgZm9yIGVhY2ggcGx1Z2luLCBjb25zb2xpZGF0aW5nIHJlcGVkaXRpdmUgY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxuICAgKiBAZmlyZXMgUGx1Z2luI2luaXRcbiAgICovXG4gIHJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbihwbHVnaW4pe1xuICAgIHZhciBwbHVnaW5OYW1lID0gZnVuY3Rpb25OYW1lKHBsdWdpbi5jb25zdHJ1Y3RvcikudG9Mb3dlckNhc2UoKTtcblxuICAgIHBsdWdpbi51dWlkID0gdGhpcy5HZXRZb0RpZ2l0cyg2LCBwbHVnaW5OYW1lKTtcbiAgICBwbHVnaW4uJGVsZW1lbnQuYXR0cignZGF0YS0nICsgcGx1Z2luTmFtZSwgcGx1Z2luLnV1aWQpXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBpbml0aWFsaXplZC5cbiAgICAgICAgICAgKiBAZXZlbnQgUGx1Z2luI2luaXRcbiAgICAgICAgICAgKi9cbiAgICAgICAgICAudHJpZ2dlcignaW5pdC56Zi4nICsgcGx1Z2luTmFtZSk7XG5cbiAgICB0aGlzLl9hY3RpdmVQbHVnaW5zW3BsdWdpbi51dWlkXSA9IHBsdWdpbjtcblxuICAgIHJldHVybjtcbiAgfSxcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBSZW1vdmVzIHRoZSBwb2ludGVyIGZvciBhbiBpbnN0YW5jZSBvZiBhIFBsdWdpbiBmcm9tIHRoZSBGb3VuZGF0aW9uLl9hY3RpdmVQbHVnaW5zIG9iai5cbiAgICogQWxzbyBmaXJlcyB0aGUgZGVzdHJveWVkIGV2ZW50IGZvciB0aGUgcGx1Z2luLCBjb25zb2xpZGF0aW5nIHJlcGVkaXRpdmUgY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxuICAgKiBAZmlyZXMgUGx1Z2luI2Rlc3Ryb3llZFxuICAgKi9cbiAgdW5yZWdpc3RlclBsdWdpbjogZnVuY3Rpb24ocGx1Z2luKXtcbiAgICB2YXIgcGx1Z2luTmFtZSA9IGZ1bmN0aW9uTmFtZShwbHVnaW4uY29uc3RydWN0b3IpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBkZWxldGUgdGhpcy5fYWN0aXZlUGx1Z2luc1twbHVnaW4udXVpZF07XG4gICAgcGx1Z2luLiRlbGVtZW50LnJlbW92ZUF0dHIoJ2RhdGEtJyArIHBsdWdpbk5hbWUpXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBiZWVuIGRlc3Ryb3llZC5cbiAgICAgICAgICAgKiBAZXZlbnQgUGx1Z2luI2Rlc3Ryb3llZFxuICAgICAgICAgICAqL1xuICAgICAgICAgIC50cmlnZ2VyKCdkZXN0cm95ZWQuemYuJyArIHBsdWdpbk5hbWUpO1xuXG4gICAgcmV0dXJuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQ2F1c2VzIG9uZSBvciBtb3JlIGFjdGl2ZSBwbHVnaW5zIHRvIHJlLWluaXRpYWxpemUsIHJlc2V0dGluZyBldmVudCBsaXN0ZW5lcnMsIHJlY2FsY3VsYXRpbmcgcG9zaXRpb25zLCBldGMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwbHVnaW5zIC0gb3B0aW9uYWwgc3RyaW5nIG9mIGFuIGluZGl2aWR1YWwgcGx1Z2luIGtleSwgYXR0YWluZWQgYnkgY2FsbGluZyBgJChlbGVtZW50KS5kYXRhKCdwbHVnaW5OYW1lJylgLCBvciBzdHJpbmcgb2YgYSBwbHVnaW4gY2xhc3MgaS5lLiBgJ2Ryb3Bkb3duJ2BcbiAgICogQGRlZmF1bHQgSWYgbm8gYXJndW1lbnQgaXMgcGFzc2VkLCByZWZsb3cgYWxsIGN1cnJlbnRseSBhY3RpdmUgcGx1Z2lucy5cbiAgICovXG4gIF9yZWZsb3c6IGZ1bmN0aW9uKHBsdWdpbnMpe1xuICAgIHZhciBhY3R2UGx1Z2lucyA9IE9iamVjdC5rZXlzKHRoaXMuX2FjdGl2ZVBsdWdpbnMpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZighcGx1Z2lucyl7XG4gICAgICBhY3R2UGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uKHApe1xuICAgICAgICBfdGhpcy5fYWN0aXZlUGx1Z2luc1twXS5faW5pdCgpO1xuICAgICAgfSk7XG5cbiAgICB9ZWxzZSBpZih0eXBlb2YgcGx1Z2lucyA9PT0gJ3N0cmluZycpe1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IHBsdWdpbnMuc3BsaXQoJy0nKVsxXTtcblxuICAgICAgaWYobmFtZXNwYWNlKXtcblxuICAgICAgICB0aGlzLl9hY3RpdmVQbHVnaW5zW3BsdWdpbnNdLl9pbml0KCk7XG5cbiAgICAgIH1lbHNle1xuICAgICAgICBuYW1lc3BhY2UgPSBuZXcgUmVnRXhwKHBsdWdpbnMsICdpJyk7XG5cbiAgICAgICAgYWN0dlBsdWdpbnMuZmlsdGVyKGZ1bmN0aW9uKHApe1xuICAgICAgICAgIHJldHVybiBuYW1lc3BhY2UudGVzdChwKTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbihwKXtcbiAgICAgICAgICBfdGhpcy5fYWN0aXZlUGx1Z2luc1twXS5faW5pdCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSxcblxuICAvKipcbiAgICogcmV0dXJucyBhIHJhbmRvbSBiYXNlLTM2IHVpZCB3aXRoIG5hbWVzcGFjaW5nXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gbnVtYmVyIG9mIHJhbmRvbSBiYXNlLTM2IGRpZ2l0cyBkZXNpcmVkLiBJbmNyZWFzZSBmb3IgbW9yZSByYW5kb20gc3RyaW5ncy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSAtIG5hbWUgb2YgcGx1Z2luIHRvIGJlIGluY29ycG9yYXRlZCBpbiB1aWQsIG9wdGlvbmFsLlxuICAgKiBAZGVmYXVsdCB7U3RyaW5nfSAnJyAtIGlmIG5vIHBsdWdpbiBuYW1lIGlzIHByb3ZpZGVkLCBub3RoaW5nIGlzIGFwcGVuZGVkIHRvIHRoZSB1aWQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gdW5pcXVlIGlkXG4gICAqL1xuICBHZXRZb0RpZ2l0czogZnVuY3Rpb24obGVuZ3RoLCBuYW1lc3BhY2Upe1xuICAgIGxlbmd0aCA9IGxlbmd0aCB8fCA2O1xuICAgIHJldHVybiBNYXRoLnJvdW5kKChNYXRoLnBvdygzNiwgbGVuZ3RoICsgMSkgLSBNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMzYsIGxlbmd0aCkpKS50b1N0cmluZygzNikuc2xpY2UoMSkgKyAobmFtZXNwYWNlID8gJy0nICsgbmFtZXNwYWNlIDogJycpO1xuICB9LFxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBwbHVnaW5zIG9uIGFueSBlbGVtZW50cyB3aXRoaW4gYGVsZW1gIChhbmQgYGVsZW1gIGl0c2VsZikgdGhhdCBhcmVuJ3QgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgdG8gY2hlY2sgaW5zaWRlLiBBbHNvIGNoZWNrcyB0aGUgZWxlbWVudCBpdHNlbGYsIHVubGVzcyBpdCdzIHRoZSBgZG9jdW1lbnRgIG9iamVjdC5cbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBsdWdpbnMgLSBBIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplLiBMZWF2ZSB0aGlzIG91dCB0byBpbml0aWFsaXplIGV2ZXJ5dGhpbmcuXG4gICAqL1xuICByZWZsb3c6IGZ1bmN0aW9uKGVsZW0sIHBsdWdpbnMpIHtcbiAgICAvLyBJZiBwbHVnaW5zIGlzIHVuZGVmaW5lZCwganVzdCBncmFiIGV2ZXJ5dGhpbmdcbiAgICBpZiAodHlwZW9mIHBsdWdpbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwbHVnaW5zID0gT2JqZWN0LmtleXModGhpcy5fcGx1Z2lucyk7XG4gICAgfVxuICAgIC8vIElmIHBsdWdpbnMgaXMgYSBzdHJpbmcsIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBvbmUgaXRlbVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAnc3RyaW5nJykge1xuICAgICAgcGx1Z2lucyA9IFtwbHVnaW5zXTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcGx1Z2luXG4gICAgJC5lYWNoKHBsdWdpbnMsIGZ1bmN0aW9uKGksIG5hbWUpIHtcbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBwbHVnaW5cbiAgICAgIHZhciBwbHVnaW4gPSBfdGhpcy5fcGx1Z2luc1tuYW1lXTtcblxuICAgICAgLy8gTG9jYWxpemUgdGhlIHNlYXJjaCB0byBhbGwgZWxlbWVudHMgaW5zaWRlIGVsZW0sIGFzIHdlbGwgYXMgZWxlbSBpdHNlbGYsIHVubGVzcyBlbGVtID09PSBkb2N1bWVudFxuICAgICAgdmFyICRlbGVtID0gJChlbGVtKS5maW5kKCdbZGF0YS0nK25hbWUrJ10nKS5hZGRCYWNrKCcqJyk7XG5cbiAgICAgIC8vIEZvciBlYWNoIHBsdWdpbiBmb3VuZCwgaW5pdGlhbGl6ZSBpdFxuICAgICAgJGVsZW0uZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRG9uJ3QgZG91YmxlLWRpcCBvbiBwbHVnaW5zXG4gICAgICAgIGlmICgkKHRoaXMpLmF0dHIoJ3pmLXBsdWdpbicpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gaW5pdGlhbGl6ZSBcIituYW1lK1wiIG9uIGFuIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGhhcyBhIEZvdW5kYXRpb24gcGx1Z2luLlwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzKS5kYXRhKCd6Zi1wbHVnaW4nLCBuZXcgcGx1Z2luKCQodGhpcykpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBnZXRGbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgdHJhbnNpdGlvbmVuZDogZnVuY3Rpb24oJGVsZW0pe1xuICAgIHZhciB0cmFuc2l0aW9ucyA9IHtcbiAgICAgICd0cmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICAnTW96VHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAgICdPVHJhbnNpdGlvbic6ICdvdHJhbnNpdGlvbmVuZCdcbiAgICB9O1xuICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgIGVuZDtcblxuICAgIGZvciAodmFyIHQgaW4gdHJhbnNpdGlvbnMpe1xuICAgICAgaWYgKHR5cGVvZiBlbGVtLnN0eWxlW3RdICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgIGVuZCA9IHRyYW5zaXRpb25zW3RdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihlbmQpe1xuICAgICAgcmV0dXJuIGVuZDtcbiAgICB9ZWxzZXtcbiAgICAgIGVuZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgJGVsZW0udHJpZ2dlckhhbmRsZXIoJ3RyYW5zaXRpb25lbmQnLCBbJGVsZW1dKTtcbiAgICAgIH0sIDEpO1xuICAgICAgcmV0dXJuICd0cmFuc2l0aW9uZW5kJztcbiAgICB9XG4gIH1cbn07XG5cblxuRm91bmRhdGlvbi51dGlsID0ge1xuICAvKipcbiAgICogRnVuY3Rpb24gZm9yIGFwcGx5aW5nIGEgZGVib3VuY2UgZWZmZWN0IHRvIGEgZnVuY3Rpb24gY2FsbC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgYXQgZW5kIG9mIHRpbWVvdXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSAtIFRpbWUgaW4gbXMgdG8gZGVsYXkgdGhlIGNhbGwgb2YgYGZ1bmNgLlxuICAgKiBAcmV0dXJucyBmdW5jdGlvblxuICAgKi9cbiAgdGhyb3R0bGU6IGZ1bmN0aW9uIChmdW5jLCBkZWxheSkge1xuICAgIHZhciB0aW1lciA9IG51bGw7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICBpZiAodGltZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbi8vIFRPRE86IGNvbnNpZGVyIG5vdCBtYWtpbmcgdGhpcyBhIGpRdWVyeSBmdW5jdGlvblxuLy8gVE9ETzogbmVlZCB3YXkgdG8gcmVmbG93IHZzLiByZS1pbml0aWFsaXplXG4vKipcbiAqIFRoZSBGb3VuZGF0aW9uIGpRdWVyeSBtZXRob2QuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gbWV0aG9kIC0gQW4gYWN0aW9uIHRvIHBlcmZvcm0gb24gdGhlIGN1cnJlbnQgalF1ZXJ5IG9iamVjdC5cbiAqL1xudmFyIGZvdW5kYXRpb24gPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgbWV0aG9kLFxuICAgICAgJG1ldGEgPSAkKCdtZXRhLmZvdW5kYXRpb24tbXEnKSxcbiAgICAgICRub0pTID0gJCgnLm5vLWpzJyk7XG5cbiAgaWYoISRtZXRhLmxlbmd0aCl7XG4gICAgJCgnPG1ldGEgY2xhc3M9XCJmb3VuZGF0aW9uLW1xXCI+JykuYXBwZW5kVG8oZG9jdW1lbnQuaGVhZCk7XG4gIH1cbiAgaWYoJG5vSlMubGVuZ3RoKXtcbiAgICAkbm9KUy5yZW1vdmVDbGFzcygnbm8tanMnKTtcbiAgfVxuXG4gIGlmKHR5cGUgPT09ICd1bmRlZmluZWQnKXsvL25lZWRzIHRvIGluaXRpYWxpemUgdGhlIEZvdW5kYXRpb24gb2JqZWN0LCBvciBhbiBpbmRpdmlkdWFsIHBsdWdpbi5cbiAgICBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuX2luaXQoKTtcbiAgICBGb3VuZGF0aW9uLnJlZmxvdyh0aGlzKTtcbiAgfWVsc2UgaWYodHlwZSA9PT0gJ3N0cmluZycpey8vYW4gaW5kaXZpZHVhbCBtZXRob2QgdG8gaW52b2tlIG9uIGEgcGx1Z2luIG9yIGdyb3VwIG9mIHBsdWdpbnNcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7Ly9jb2xsZWN0IGFsbCB0aGUgYXJndW1lbnRzLCBpZiBuZWNlc3NhcnlcbiAgICB2YXIgcGx1Z0NsYXNzID0gdGhpcy5kYXRhKCd6ZlBsdWdpbicpOy8vZGV0ZXJtaW5lIHRoZSBjbGFzcyBvZiBwbHVnaW5cblxuICAgIGlmKHBsdWdDbGFzcyAhPT0gdW5kZWZpbmVkICYmIHBsdWdDbGFzc1ttZXRob2RdICE9PSB1bmRlZmluZWQpey8vbWFrZSBzdXJlIGJvdGggdGhlIGNsYXNzIGFuZCBtZXRob2QgZXhpc3RcbiAgICAgIGlmKHRoaXMubGVuZ3RoID09PSAxKXsvL2lmIHRoZXJlJ3Mgb25seSBvbmUsIGNhbGwgaXQgZGlyZWN0bHkuXG4gICAgICAgICAgcGx1Z0NsYXNzW21ldGhvZF0uYXBwbHkocGx1Z0NsYXNzLCBhcmdzKTtcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSwgZWwpey8vb3RoZXJ3aXNlIGxvb3AgdGhyb3VnaCB0aGUgalF1ZXJ5IGNvbGxlY3Rpb24gYW5kIGludm9rZSB0aGUgbWV0aG9kIG9uIGVhY2hcbiAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseSgkKGVsKS5kYXRhKCd6ZlBsdWdpbicpLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfWVsc2V7Ly9lcnJvciBmb3Igbm8gY2xhc3Mgb3Igbm8gbWV0aG9kXG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJXZSdyZSBzb3JyeSwgJ1wiICsgbWV0aG9kICsgXCInIGlzIG5vdCBhbiBhdmFpbGFibGUgbWV0aG9kIGZvciBcIiArIChwbHVnQ2xhc3MgPyBmdW5jdGlvbk5hbWUocGx1Z0NsYXNzKSA6ICd0aGlzIGVsZW1lbnQnKSArICcuJyk7XG4gICAgfVxuICB9ZWxzZXsvL2Vycm9yIGZvciBpbnZhbGlkIGFyZ3VtZW50IHR5cGVcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiV2UncmUgc29ycnksICdcIiArIHR5cGUgKyBcIicgaXMgbm90IGEgdmFsaWQgcGFyYW1ldGVyLiBZb3UgbXVzdCB1c2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBtZXRob2QgeW91IHdpc2ggdG8gaW52b2tlLlwiKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbndpbmRvdy5Gb3VuZGF0aW9uID0gRm91bmRhdGlvbjtcbiQuZm4uZm91bmRhdGlvbiA9IGZvdW5kYXRpb247XG5cbi8vIFBvbHlmaWxsIGZvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbihmdW5jdGlvbigpIHtcbiAgaWYgKCFEYXRlLm5vdyB8fCAhd2luZG93LkRhdGUubm93KVxuICAgIHdpbmRvdy5EYXRlLm5vdyA9IERhdGUubm93ID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuICB2YXIgdmVuZG9ycyA9IFsnd2Via2l0JywgJ21veiddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK2kpIHtcbiAgICAgIHZhciB2cCA9IHZlbmRvcnNbaV07XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZwKydSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9ICh3aW5kb3dbdnArJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvd1t2cCsnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10pO1xuICB9XG4gIGlmICgvaVAoYWR8aG9uZXxvZCkuKk9TIDYvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgfHwgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgbmV4dFRpbWUgPSBNYXRoLm1heChsYXN0VGltZSArIDE2LCBub3cpO1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2sobGFzdFRpbWUgPSBuZXh0VGltZSk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRUaW1lIC0gbm93KTtcbiAgICB9O1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNsZWFyVGltZW91dDtcbiAgfVxuICAvKipcbiAgICogUG9seWZpbGwgZm9yIHBlcmZvcm1hbmNlLm5vdywgcmVxdWlyZWQgYnkgckFGXG4gICAqL1xuICBpZighd2luZG93LnBlcmZvcm1hbmNlIHx8ICF3aW5kb3cucGVyZm9ybWFuY2Uubm93KXtcbiAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7XG4gICAgICBzdGFydDogRGF0ZS5ub3coKSxcbiAgICAgIG5vdzogZnVuY3Rpb24oKXsgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnN0YXJ0OyB9XG4gICAgfTtcbiAgfVxufSkoKTtcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihvVGhpcykge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XG4gICAgICAvLyBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZScpO1xuICAgIH1cblxuICAgIHZhciBhQXJncyAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICAgIGZOT1AgICAgPSBmdW5jdGlvbigpIHt9LFxuICAgICAgICBmQm91bmQgID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1BcbiAgICAgICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICAgICAgIDogb1RoaXMsXG4gICAgICAgICAgICAgICAgIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG5cbiAgICBpZiAodGhpcy5wcm90b3R5cGUpIHtcbiAgICAgIC8vIG5hdGl2ZSBmdW5jdGlvbnMgZG9uJ3QgaGF2ZSBhIHByb3RvdHlwZVxuICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICB9XG4gICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG5cbiAgICByZXR1cm4gZkJvdW5kO1xuICB9O1xufVxuLy8gUG9seWZpbGwgdG8gZ2V0IHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gaW4gSUU5XG5mdW5jdGlvbiBmdW5jdGlvbk5hbWUoZm4pIHtcbiAgaWYgKEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZnVuY05hbWVSZWdleCA9IC9mdW5jdGlvblxccyhbXihdezEsfSlcXCgvO1xuICAgIHZhciByZXN1bHRzID0gKGZ1bmNOYW1lUmVnZXgpLmV4ZWMoKGZuKS50b1N0cmluZygpKTtcbiAgICByZXR1cm4gKHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGggPiAxKSA/IHJlc3VsdHNbMV0udHJpbSgpIDogXCJcIjtcbiAgfVxuICBlbHNlIGlmIChmbi5wcm90b3R5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmbi5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmbi5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxufVxuXG4vLyBDb252ZXJ0IFBhc2NhbENhc2UgdG8ga2ViYWItY2FzZVxuLy8gVGhhbmsgeW91OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84OTU1NTgwXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cblxufShqUXVlcnkpO1xuIiwiIWZ1bmN0aW9uKEZvdW5kYXRpb24sIHdpbmRvdyl7XG4gIC8qKlxuICAgKiBDb21wYXJlcyB0aGUgZGltZW5zaW9ucyBvZiBhbiBlbGVtZW50IHRvIGEgY29udGFpbmVyIGFuZCBkZXRlcm1pbmVzIGNvbGxpc2lvbiBldmVudHMgd2l0aCBjb250YWluZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdGVzdCBmb3IgY29sbGlzaW9ucy5cbiAgICogQHBhcmFtIHtqUXVlcnl9IHBhcmVudCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGFzIGJvdW5kaW5nIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsck9ubHkgLSBzZXQgdG8gdHJ1ZSB0byBjaGVjayBsZWZ0IGFuZCByaWdodCB2YWx1ZXMgb25seS5cbiAgICogQHBhcmFtIHtCb29sZWFufSB0Yk9ubHkgLSBzZXQgdG8gdHJ1ZSB0byBjaGVjayB0b3AgYW5kIGJvdHRvbSB2YWx1ZXMgb25seS5cbiAgICogQGRlZmF1bHQgaWYgbm8gcGFyZW50IG9iamVjdCBwYXNzZWQsIGRldGVjdHMgY29sbGlzaW9ucyB3aXRoIGB3aW5kb3dgLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIGNvbGxpc2lvbiBmcmVlLCBmYWxzZSBpZiBhIGNvbGxpc2lvbiBpbiBhbnkgZGlyZWN0aW9uLlxuICAgKi9cbiAgdmFyIEltTm90VG91Y2hpbmdZb3UgPSBmdW5jdGlvbihlbGVtZW50LCBwYXJlbnQsIGxyT25seSwgdGJPbmx5KXtcbiAgICB2YXIgZWxlRGltcyA9IEdldERpbWVuc2lvbnMoZWxlbWVudCksXG4gICAgICAgIHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodDtcblxuICAgIGlmKHBhcmVudCl7XG4gICAgICB2YXIgcGFyRGltcyA9IEdldERpbWVuc2lvbnMocGFyZW50KTtcblxuICAgICAgYm90dG9tID0gKGVsZURpbXMub2Zmc2V0LnRvcCArIGVsZURpbXMuaGVpZ2h0IDw9IHBhckRpbXMuaGVpZ2h0ICsgcGFyRGltcy5vZmZzZXQudG9wKTtcbiAgICAgIHRvcCAgICA9IChlbGVEaW1zLm9mZnNldC50b3AgPj0gcGFyRGltcy5vZmZzZXQudG9wKTtcbiAgICAgIGxlZnQgICA9IChlbGVEaW1zLm9mZnNldC5sZWZ0ID49IHBhckRpbXMub2Zmc2V0LmxlZnQpO1xuICAgICAgcmlnaHQgID0gKGVsZURpbXMub2Zmc2V0LmxlZnQgKyBlbGVEaW1zLndpZHRoIDw9IHBhckRpbXMud2lkdGgpO1xuICAgIH1lbHNle1xuICAgICAgYm90dG9tID0gKGVsZURpbXMub2Zmc2V0LnRvcCArIGVsZURpbXMuaGVpZ2h0IDw9IGVsZURpbXMud2luZG93RGltcy5oZWlnaHQgKyBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcCk7XG4gICAgICB0b3AgICAgPSAoZWxlRGltcy5vZmZzZXQudG9wID49IGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wKTtcbiAgICAgIGxlZnQgICA9IChlbGVEaW1zLm9mZnNldC5sZWZ0ID49IGVsZURpbXMud2luZG93RGltcy5vZmZzZXQubGVmdCk7XG4gICAgICByaWdodCAgPSAoZWxlRGltcy5vZmZzZXQubGVmdCArIGVsZURpbXMud2lkdGggPD0gZWxlRGltcy53aW5kb3dEaW1zLndpZHRoKTtcbiAgICB9XG4gICAgdmFyIGFsbERpcnMgPSBbYm90dG9tLCB0b3AsIGxlZnQsIHJpZ2h0XTtcblxuICAgIGlmKGxyT25seSl7IHJldHVybiBsZWZ0ID09PSByaWdodCA9PT0gdHJ1ZTsgfVxuICAgIGlmKHRiT25seSl7IHJldHVybiB0b3AgPT09IGJvdHRvbSA9PT0gdHJ1ZTsgfVxuXG4gICAgcmV0dXJuIGFsbERpcnMuaW5kZXhPZihmYWxzZSkgPT09IC0xO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVc2VzIG5hdGl2ZSBtZXRob2RzIHRvIHJldHVybiBhbiBvYmplY3Qgb2YgZGltZW5zaW9uIHZhbHVlcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7alF1ZXJ5IHx8IEhUTUx9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IG9yIERPTSBlbGVtZW50IGZvciB3aGljaCB0byBnZXQgdGhlIGRpbWVuc2lvbnMuIENhbiBiZSBhbnkgZWxlbWVudCBvdGhlciB0aGF0IGRvY3VtZW50IG9yIHdpbmRvdy5cbiAgICogQHJldHVybnMge09iamVjdH0gLSBuZXN0ZWQgb2JqZWN0IG9mIGludGVnZXIgcGl4ZWwgdmFsdWVzXG4gICAqIFRPRE8gLSBpZiBlbGVtZW50IGlzIHdpbmRvdywgcmV0dXJuIG9ubHkgdGhvc2UgdmFsdWVzLlxuICAgKi9cbiAgdmFyIEdldERpbWVuc2lvbnMgPSBmdW5jdGlvbihlbGVtLCB0ZXN0KXtcbiAgICBlbGVtID0gZWxlbS5sZW5ndGggPyBlbGVtWzBdIDogZWxlbTtcblxuICAgIGlmKGVsZW0gPT09IHdpbmRvdyB8fCBlbGVtID09PSBkb2N1bWVudCl7IHRocm93IG5ldyBFcnJvcihcIkknbSBzb3JyeSwgRGF2ZS4gSSdtIGFmcmFpZCBJIGNhbid0IGRvIHRoYXQuXCIpOyB9XG5cbiAgICB2YXIgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHBhclJlY3QgPSBlbGVtLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHdpblJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICB3aW5ZID0gd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICB3aW5YID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luWSxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luWFxuICAgICAgfSxcbiAgICAgIHBhcmVudERpbXM6IHtcbiAgICAgICAgd2lkdGg6IHBhclJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogcGFyUmVjdC5oZWlnaHQsXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgIHRvcDogcGFyUmVjdC50b3AgKyB3aW5ZLFxuICAgICAgICAgIGxlZnQ6IHBhclJlY3QubGVmdCArIHdpblhcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdpbmRvd0RpbXM6IHtcbiAgICAgICAgd2lkdGg6IHdpblJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogd2luUmVjdC5oZWlnaHQsXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgIHRvcDogd2luWSxcbiAgICAgICAgICBsZWZ0OiB3aW5YXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3Qgb2YgdG9wIGFuZCBsZWZ0IGludGVnZXIgcGl4ZWwgdmFsdWVzIGZvciBkeW5hbWljYWxseSByZW5kZXJlZCBlbGVtZW50cyxcbiAgICogc3VjaCBhczogVG9vbHRpcCwgUmV2ZWFsLCBhbmQgRHJvcGRvd25cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCBmb3IgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICogQHBhcmFtIHtqUXVlcnl9IGFuY2hvciAtIGpRdWVyeSBvYmplY3QgZm9yIHRoZSBlbGVtZW50J3MgYW5jaG9yIHBvaW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24gLSBhIHN0cmluZyByZWxhdGluZyB0byB0aGUgZGVzaXJlZCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCwgcmVsYXRpdmUgdG8gaXQncyBhbmNob3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZPZmZzZXQgLSBpbnRlZ2VyIHBpeGVsIHZhbHVlIG9mIGRlc2lyZWQgdmVydGljYWwgc2VwYXJhdGlvbiBiZXR3ZWVuIGFuY2hvciBhbmQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhPZmZzZXQgLSBpbnRlZ2VyIHBpeGVsIHZhbHVlIG9mIGRlc2lyZWQgaG9yaXpvbnRhbCBzZXBhcmF0aW9uIGJldHdlZW4gYW5jaG9yIGFuZCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3ZlcmZsb3cgLSBpZiBhIGNvbGxpc2lvbiBldmVudCBpcyBkZXRlY3RlZCwgc2V0cyB0byB0cnVlIHRvIGRlZmF1bHQgdGhlIGVsZW1lbnQgdG8gZnVsbCB3aWR0aCAtIGFueSBkZXNpcmVkIG9mZnNldC5cbiAgICogVE9ETyBhbHRlci9yZXdyaXRlIHRvIHdvcmsgd2l0aCBgZW1gIHZhbHVlcyBhcyB3ZWxsL2luc3RlYWQgb2YgcGl4ZWxzXG4gICAqL1xuICB2YXIgR2V0T2Zmc2V0cyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGFuY2hvciwgcG9zaXRpb24sIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpe1xuICAgIHZhciAkZWxlRGltcyA9IEdldERpbWVuc2lvbnMoZWxlbWVudCksXG4gICAgLy8gdmFyICRlbGVEaW1zID0gR2V0RGltZW5zaW9ucyhlbGVtZW50KSxcbiAgICAgICAgJGFuY2hvckRpbXMgPSBhbmNob3IgPyBHZXREaW1lbnNpb25zKGFuY2hvcikgOiBudWxsO1xuICAgICAgICAvLyAkYW5jaG9yRGltcyA9IGFuY2hvciA/IEdldERpbWVuc2lvbnMoYW5jaG9yKSA6IG51bGw7XG4gICAgc3dpdGNoKHBvc2l0aW9uKXtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQsXG4gICAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gKCRlbGVEaW1zLmhlaWdodCArIHZPZmZzZXQpXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAoJGVsZURpbXMud2lkdGggKyBoT2Zmc2V0KSxcbiAgICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3BcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAkYW5jaG9yRGltcy53aWR0aCArIGhPZmZzZXQsXG4gICAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIHRvcCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogKCRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgKCRhbmNob3JEaW1zLndpZHRoIC8gMikpIC0gKCRlbGVEaW1zLndpZHRoIC8gMiksXG4gICAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gKCRlbGVEaW1zLmhlaWdodCArIHZPZmZzZXQpXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogaXNPdmVyZmxvdyA/IGhPZmZzZXQgOiAoKCRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgKCRhbmNob3JEaW1zLndpZHRoIC8gMikpIC0gKCRlbGVEaW1zLndpZHRoIC8gMikpLFxuICAgICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCArIHZPZmZzZXRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgbGVmdCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAoJGVsZURpbXMud2lkdGggKyBoT2Zmc2V0KSxcbiAgICAgICAgICB0b3A6ICgkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgKCRhbmNob3JEaW1zLmhlaWdodCAvIDIpKSAtICgkZWxlRGltcy5oZWlnaHQgLyAyKVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciByaWdodCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAkYW5jaG9yRGltcy53aWR0aCArIGhPZmZzZXQgKyAxLFxuICAgICAgICAgIHRvcDogKCRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAoJGFuY2hvckRpbXMuaGVpZ2h0IC8gMikpIC0gKCRlbGVEaW1zLmhlaWdodCAvIDIpXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiAoJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQubGVmdCArICgkZWxlRGltcy53aW5kb3dEaW1zLndpZHRoIC8gMikpIC0gKCRlbGVEaW1zLndpZHRoIC8gMiksXG4gICAgICAgICAgdG9wOiAoJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wICsgKCRlbGVEaW1zLndpbmRvd0RpbXMuaGVpZ2h0IC8gMikpIC0gKCRlbGVEaW1zLmhlaWdodCAvIDIpXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmV2ZWFsJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiAoJGVsZURpbXMud2luZG93RGltcy53aWR0aCAtICRlbGVEaW1zLndpZHRoKSAvIDIsXG4gICAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3AgKyB2T2Zmc2V0XG4gICAgICAgIH07XG4gICAgICBjYXNlICdyZXZlYWwgZnVsbCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQubGVmdCxcbiAgICAgICAgICB0b3A6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcCxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0LFxuICAgICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCArIHZPZmZzZXRcbiAgICAgICAgfTtcbiAgICB9XG4gIH07XG4gIEZvdW5kYXRpb24uQm94ID0ge1xuICAgIEltTm90VG91Y2hpbmdZb3U6IEltTm90VG91Y2hpbmdZb3UsXG4gICAgR2V0RGltZW5zaW9uczogR2V0RGltZW5zaW9ucyxcbiAgICBHZXRPZmZzZXRzOiBHZXRPZmZzZXRzXG4gIH07XG59KHdpbmRvdy5Gb3VuZGF0aW9uLCB3aW5kb3cpO1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBUaGlzIHV0aWwgd2FzIGNyZWF0ZWQgYnkgTWFyaXVzIE9sYmVydHogKlxuICogUGxlYXNlIHRoYW5rIE1hcml1cyBvbiBHaXRIdWIgL293bGJlcnR6ICpcbiAqIG9yIHRoZSB3ZWIgaHR0cDovL3d3dy5tYXJpdXNvbGJlcnR6LmRlLyAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiFmdW5jdGlvbigkLCBGb3VuZGF0aW9uKXtcbiAgJ3VzZSBzdHJpY3QnO1xuICBGb3VuZGF0aW9uLktleWJvYXJkID0ge307XG5cbiAgdmFyIGtleUNvZGVzID0ge1xuICAgIDk6ICdUQUInLFxuICAgIDEzOiAnRU5URVInLFxuICAgIDI3OiAnRVNDQVBFJyxcbiAgICAzMjogJ1NQQUNFJyxcbiAgICAzNzogJ0FSUk9XX0xFRlQnLFxuICAgIDM4OiAnQVJST1dfVVAnLFxuICAgIDM5OiAnQVJST1dfUklHSFQnLFxuICAgIDQwOiAnQVJST1dfRE9XTidcbiAgfTtcblxuICAvLyBjb25zdGFudHMgZm9yIGVhc2llciBjb21wYXJpbmcgQ2FuIGJlIHVzZWQgbGlrZSBGb3VuZGF0aW9uLnBhcnNlS2V5KGV2ZW50KSA9PT0gRm91bmRhdGlvbi5rZXlzLlNQQUNFXG4gIHZhciBrZXlzID0gKGZ1bmN0aW9uKGtjcykge1xuICAgIHZhciBrID0ge307XG4gICAgZm9yICh2YXIga2MgaW4ga2NzKSBrW2tjc1trY11dID0ga2NzW2tjXTtcbiAgICByZXR1cm4gaztcbiAgfSkoa2V5Q29kZXMpO1xuXG4gIEZvdW5kYXRpb24uS2V5Ym9hcmQua2V5cyA9IGtleXM7XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgKGtleWJvYXJkKSBldmVudCBhbmQgcmV0dXJucyBhIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgaXRzIGtleVxuICAgKiBDYW4gYmUgdXNlZCBsaWtlIEZvdW5kYXRpb24ucGFyc2VLZXkoZXZlbnQpID09PSBGb3VuZGF0aW9uLmtleXMuU1BBQ0VcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXG4gICAqIEByZXR1cm4gU3RyaW5nIGtleSAtIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGtleSBwcmVzc2VkXG4gICAqL1xuICB2YXIgcGFyc2VLZXkgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBrZXkgPSBrZXlDb2Rlc1tldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlXSB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LndoaWNoKS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChldmVudC5zaGlmdEtleSkga2V5ID0gJ1NISUZUXycgKyBrZXk7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpIGtleSA9ICdDVFJMXycgKyBrZXk7XG4gICAgaWYgKGV2ZW50LmFsdEtleSkga2V5ID0gJ0FMVF8nICsga2V5O1xuICAgIHJldHVybiBrZXk7XG4gIH07XG4gIEZvdW5kYXRpb24uS2V5Ym9hcmQucGFyc2VLZXkgPSBwYXJzZUtleTtcblxuXG4gIC8vIHBsYWluIGNvbW1hbmRzIHBlciBjb21wb25lbnQgZ28gaGVyZSwgbHRyIGFuZCBydGwgYXJlIG1lcmdlZCBiYXNlZCBvbiBvcmllbnRhdGlvblxuICB2YXIgY29tbWFuZHMgPSB7fTtcblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZ2l2ZW4gKGtleWJvYXJkKSBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIHRoZSBldmVudCBnZW5lcmF0ZWQgYnkgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCAtIEZvdW5kYXRpb24gY29tcG9uZW50LCBlLmcuIFNsaWRlciBvciBSZXZlYWxcbiAgICogQHBhcmFtIHtPYmplY3RzfSBmdW5jdGlvbnMgLSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSB0byBiZSBleGVjdXRlZFxuICAgKi9cbiAgdmFyIGhhbmRsZUtleSA9IGZ1bmN0aW9uKGV2ZW50LCBjb21wb25lbnQsIGZ1bmN0aW9ucykge1xuICAgIHZhciBjb21tYW5kTGlzdCA9IGNvbW1hbmRzW0ZvdW5kYXRpb24uZ2V0Rm5OYW1lKGNvbXBvbmVudCldLFxuICAgICAga2V5Q29kZSA9IHBhcnNlS2V5KGV2ZW50KSxcbiAgICAgIGNtZHMsXG4gICAgICBjb21tYW5kLFxuICAgICAgZm47XG4gICAgaWYgKCFjb21tYW5kTGlzdCkgcmV0dXJuIGNvbnNvbGUud2FybignQ29tcG9uZW50IG5vdCBkZWZpbmVkIScpO1xuXG4gICAgaWYgKHR5cGVvZiBjb21tYW5kTGlzdC5sdHIgPT09ICd1bmRlZmluZWQnKSB7IC8vIHRoaXMgY29tcG9uZW50IGRvZXMgbm90IGRpZmZlcmVudGlhdGUgYmV0d2VlbiBsdHIgYW5kIHJ0bFxuICAgICAgICBjbWRzID0gY29tbWFuZExpc3Q7IC8vIHVzZSBwbGFpbiBsaXN0XG4gICAgfSBlbHNlIHsgLy8gbWVyZ2UgbHRyIGFuZCBydGw6IGlmIGRvY3VtZW50IGlzIHJ0bCwgcnRsIG92ZXJ3cml0ZXMgbHRyIGFuZCB2aWNlIHZlcnNhXG4gICAgICAgIGlmIChGb3VuZGF0aW9uLnJ0bCgpKSBjbWRzID0gJC5leHRlbmQoe30sIGNvbW1hbmRMaXN0Lmx0ciwgY29tbWFuZExpc3QucnRsKTtcblxuICAgICAgICBlbHNlIGNtZHMgPSAkLmV4dGVuZCh7fSwgY29tbWFuZExpc3QucnRsLCBjb21tYW5kTGlzdC5sdHIpO1xuICAgIH1cbiAgICBjb21tYW5kID0gY21kc1trZXlDb2RlXTtcblxuXG4gICAgZm4gPSBmdW5jdGlvbnNbY29tbWFuZF07XG4gICAgaWYgKGZuICYmIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBleGVjdXRlIGZ1bmN0aW9uIHdpdGggY29udGV4dCBvZiB0aGUgY29tcG9uZW50IGlmIGV4aXN0c1xuICAgICAgICBmbi5hcHBseShjb21wb25lbnQpO1xuICAgICAgICBpZiAoZnVuY3Rpb25zLmhhbmRsZWQgfHwgdHlwZW9mIGZ1bmN0aW9ucy5oYW5kbGVkID09PSAnZnVuY3Rpb24nKSB7IC8vIGV4ZWN1dGUgZnVuY3Rpb24gd2hlbiBldmVudCB3YXMgaGFuZGxlZFxuICAgICAgICAgICAgZnVuY3Rpb25zLmhhbmRsZWQuYXBwbHkoY29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmdW5jdGlvbnMudW5oYW5kbGVkIHx8IHR5cGVvZiBmdW5jdGlvbnMudW5oYW5kbGVkID09PSAnZnVuY3Rpb24nKSB7IC8vIGV4ZWN1dGUgZnVuY3Rpb24gd2hlbiBldmVudCB3YXMgbm90IGhhbmRsZWRcbiAgICAgICAgICAgIGZ1bmN0aW9ucy51bmhhbmRsZWQuYXBwbHkoY29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcbiAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkgPSBoYW5kbGVLZXk7XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIHRoZSBnaXZlbiBgJGVsZW1lbnRgXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gc2VhcmNoIHdpdGhpblxuICAgKiBAcmV0dXJuIHtqUXVlcnl9ICRmb2N1c2FibGUgLSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGhpbiBgJGVsZW1lbnRgXG4gICAqL1xuICB2YXIgZmluZEZvY3VzYWJsZSA9IGZ1bmN0aW9uKCRlbGVtZW50KSB7XG4gICAgcmV0dXJuICRlbGVtZW50LmZpbmQoJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCBidXR0b246bm90KFtkaXNhYmxlZF0pLCBpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdLCAqW2NvbnRlbnRlZGl0YWJsZV0nKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoISQodGhpcykuaXMoJzp2aXNpYmxlJykgfHwgJCh0aGlzKS5hdHRyKCd0YWJpbmRleCcpIDwgMCkgeyByZXR1cm4gZmFsc2U7IH0gLy9vbmx5IGhhdmUgdmlzaWJsZSBlbGVtZW50cyBhbmQgdGhvc2UgdGhhdCBoYXZlIGEgdGFiaW5kZXggZ3JlYXRlciBvciBlcXVhbCAwXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfTtcbiAgRm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlID0gZmluZEZvY3VzYWJsZTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29tcG9uZW50IG5hbWUgbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IC0gRm91bmRhdGlvbiBjb21wb25lbnQsIGUuZy4gU2xpZGVyIG9yIFJldmVhbFxuICAgKiBAcmV0dXJuIFN0cmluZyBjb21wb25lbnROYW1lXG4gICAqL1xuXG4gIHZhciByZWdpc3RlciA9IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUsIGNtZHMpIHtcbiAgICBjb21tYW5kc1tjb21wb25lbnROYW1lXSA9IGNtZHM7XG4gIH07XG4gIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIgPSByZWdpc3Rlcjtcbn0oalF1ZXJ5LCB3aW5kb3cuRm91bmRhdGlvbik7XG4iLCIhZnVuY3Rpb24oJCwgRm91bmRhdGlvbikge1xuXG4vLyBEZWZhdWx0IHNldCBvZiBtZWRpYSBxdWVyaWVzXG52YXIgZGVmYXVsdFF1ZXJpZXMgPSB7XG4gICdkZWZhdWx0JyA6ICdvbmx5IHNjcmVlbicsXG4gIGxhbmRzY2FwZSA6ICdvbmx5IHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpJyxcbiAgcG9ydHJhaXQgOiAnb25seSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpJyxcbiAgcmV0aW5hIDogJ29ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCcgK1xuICAgICdvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIvMSksJyArXG4gICAgJ29ubHkgc2NyZWVuIGFuZCAobWluLWRldmljZS1waXhlbC1yYXRpbzogMiksJyArXG4gICAgJ29ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE5MmRwaSksJyArXG4gICAgJ29ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDJkcHB4KSdcbn07XG5cbnZhciBNZWRpYVF1ZXJ5ID0ge1xuICBxdWVyaWVzOiBbXSxcbiAgY3VycmVudDogJycsXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgc2NyZWVuIGlzIGF0IGxlYXN0IGFzIHdpZGUgYXMgYSBicmVha3BvaW50LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBicmVha3BvaW50IG1hdGNoZXMsIGBmYWxzZWAgaWYgaXQncyBzbWFsbGVyLlxuICAgKi9cbiAgYXRMZWFzdDogZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciBxdWVyeSA9IHRoaXMuZ2V0KHNpemUpO1xuXG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpLm1hdGNoZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtZWRpYSBxdWVyeSBvZiBhIGJyZWFrcG9pbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IC0gVGhlIG1lZGlhIHF1ZXJ5IG9mIHRoZSBicmVha3BvaW50LCBvciBgbnVsbGAgaWYgdGhlIGJyZWFrcG9pbnQgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGdldDogZnVuY3Rpb24oc2l6ZSkge1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5xdWVyaWVzKSB7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJpZXNbaV07XG4gICAgICBpZiAoc2l6ZSA9PT0gcXVlcnkubmFtZSkgcmV0dXJuIHF1ZXJ5LnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbWVkaWEgcXVlcnkgaGVscGVyLCBieSBleHRyYWN0aW5nIHRoZSBicmVha3BvaW50IGxpc3QgZnJvbSB0aGUgQ1NTIGFuZCBhY3RpdmF0aW5nIHRoZSBicmVha3BvaW50IHdhdGNoZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZXh0cmFjdGVkU3R5bGVzID0gJCgnLmZvdW5kYXRpb24tbXEnKS5jc3MoJ2ZvbnQtZmFtaWx5Jyk7XG4gICAgdmFyIG5hbWVkUXVlcmllcztcblxuICAgIG5hbWVkUXVlcmllcyA9IHBhcnNlU3R5bGVUb09iamVjdChleHRyYWN0ZWRTdHlsZXMpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG5hbWVkUXVlcmllcykge1xuICAgICAgc2VsZi5xdWVyaWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIHZhbHVlOiAnb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6ICcgKyBuYW1lZFF1ZXJpZXNba2V5XSArICcpJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKTtcblxuICAgIHRoaXMuX3dhdGNoZXIoKTtcblxuICAgIC8vIEV4dGVuZCBkZWZhdWx0IHF1ZXJpZXNcbiAgICAvLyBuYW1lZFF1ZXJpZXMgPSAkLmV4dGVuZChkZWZhdWx0UXVlcmllcywgbmFtZWRRdWVyaWVzKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBicmVha3BvaW50IG5hbWUgYnkgdGVzdGluZyBldmVyeSBicmVha3BvaW50IGFuZCByZXR1cm5pbmcgdGhlIGxhc3Qgb25lIHRvIG1hdGNoICh0aGUgYmlnZ2VzdCBvbmUpLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge1N0cmluZ30gTmFtZSBvZiB0aGUgY3VycmVudCBicmVha3BvaW50LlxuICAgKi9cbiAgX2dldEN1cnJlbnRTaXplOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF0Y2hlZDtcblxuICAgIGZvciAodmFyIGkgaW4gdGhpcy5xdWVyaWVzKSB7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJpZXNbaV07XG5cbiAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYShxdWVyeS52YWx1ZSkubWF0Y2hlcykge1xuICAgICAgICBtYXRjaGVkID0gcXVlcnk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIG1hdGNoZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlZC5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgYnJlYWtwb2ludCB3YXRjaGVyLCB3aGljaCBmaXJlcyBhbiBldmVudCBvbiB0aGUgd2luZG93IHdoZW5ldmVyIHRoZSBicmVha3BvaW50IGNoYW5nZXMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3dhdGNoZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS56Zi5tZWRpYXF1ZXJ5JywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV3U2l6ZSA9IF90aGlzLl9nZXRDdXJyZW50U2l6ZSgpO1xuXG4gICAgICBpZiAobmV3U2l6ZSAhPT0gX3RoaXMuY3VycmVudCkge1xuICAgICAgICAvLyBCcm9hZGNhc3QgdGhlIG1lZGlhIHF1ZXJ5IGNoYW5nZSBvbiB0aGUgd2luZG93XG4gICAgICAgICQod2luZG93KS50cmlnZ2VyKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCBbbmV3U2l6ZSwgX3RoaXMuY3VycmVudF0pO1xuXG4gICAgICAgIC8vIENoYW5nZSB0aGUgY3VycmVudCBtZWRpYSBxdWVyeVxuICAgICAgICBfdGhpcy5jdXJyZW50ID0gbmV3U2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuRm91bmRhdGlvbi5NZWRpYVF1ZXJ5ID0gTWVkaWFRdWVyeTtcblxuLy8gbWF0Y2hNZWRpYSgpIHBvbHlmaWxsIC0gVGVzdCBhIENTUyBtZWRpYSB0eXBlL3F1ZXJ5IGluIEpTLlxuLy8gQXV0aG9ycyAmIGNvcHlyaWdodCAoYykgMjAxMjogU2NvdHQgSmVobCwgUGF1bCBJcmlzaCwgTmljaG9sYXMgWmFrYXMsIERhdmlkIEtuaWdodC4gRHVhbCBNSVQvQlNEIGxpY2Vuc2VcbndpbmRvdy5tYXRjaE1lZGlhIHx8ICh3aW5kb3cubWF0Y2hNZWRpYSA9IGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBtYXRjaE1lZGl1bSBhcGkgc3VjaCBhcyBJRSA5IGFuZCB3ZWJraXRcbiAgdmFyIHN0eWxlTWVkaWEgPSAod2luZG93LnN0eWxlTWVkaWEgfHwgd2luZG93Lm1lZGlhKTtcblxuICAvLyBGb3IgdGhvc2UgdGhhdCBkb24ndCBzdXBwb3J0IG1hdGNoTWVkaXVtXG4gIGlmICghc3R5bGVNZWRpYSkge1xuICAgIHZhciBzdHlsZSAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKSxcbiAgICBzY3JpcHQgICAgICA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXSxcbiAgICBpbmZvICAgICAgICA9IG51bGw7XG5cbiAgICBzdHlsZS50eXBlICA9ICd0ZXh0L2Nzcyc7XG4gICAgc3R5bGUuaWQgICAgPSAnbWF0Y2htZWRpYWpzLXRlc3QnO1xuXG4gICAgc2NyaXB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlLCBzY3JpcHQpO1xuXG4gICAgLy8gJ3N0eWxlLmN1cnJlbnRTdHlsZScgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnd2luZG93LmdldENvbXB1dGVkU3R5bGUnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcbiAgICBpbmZvID0gKCdnZXRDb21wdXRlZFN0eWxlJyBpbiB3aW5kb3cpICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHN0eWxlLCBudWxsKSB8fCBzdHlsZS5jdXJyZW50U3R5bGU7XG5cbiAgICBzdHlsZU1lZGlhID0ge1xuICAgICAgbWF0Y2hNZWRpdW06IGZ1bmN0aW9uKG1lZGlhKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gJ0BtZWRpYSAnICsgbWVkaWEgKyAneyAjbWF0Y2htZWRpYWpzLXRlc3QgeyB3aWR0aDogMXB4OyB9IH0nO1xuXG4gICAgICAgIC8vICdzdHlsZS5zdHlsZVNoZWV0JyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICdzdHlsZS50ZXh0Q29udGVudCcgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuICAgICAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzdCBpZiBtZWRpYSBxdWVyeSBpcyB0cnVlIG9yIGZhbHNlXG4gICAgICAgIHJldHVybiBpbmZvLndpZHRoID09PSAnMXB4JztcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG1lZGlhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoZXM6IHN0eWxlTWVkaWEubWF0Y2hNZWRpdW0obWVkaWEgfHwgJ2FsbCcpLFxuICAgICAgbWVkaWE6IG1lZGlhIHx8ICdhbGwnXG4gICAgfTtcbiAgfTtcbn0oKSk7XG5cbi8vIFRoYW5rIHlvdTogaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmdcbmZ1bmN0aW9uIHBhcnNlU3R5bGVUb09iamVjdChzdHIpIHtcbiAgdmFyIHN0eWxlT2JqZWN0ID0ge307XG5cbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG5cbiAgc3RyID0gc3RyLnRyaW0oKS5zbGljZSgxLCAtMSk7IC8vIGJyb3dzZXJzIHJlLXF1b3RlIHN0cmluZyBzdHlsZSB2YWx1ZXNcblxuICBpZiAoIXN0cikge1xuICAgIHJldHVybiBzdHlsZU9iamVjdDtcbiAgfVxuXG4gIHN0eWxlT2JqZWN0ID0gc3RyLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uKHJldCwgcGFyYW0pIHtcbiAgICB2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuICAgIHZhciBrZXkgPSBwYXJ0c1swXTtcbiAgICB2YXIgdmFsID0gcGFydHNbMV07XG4gICAga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7XG5cbiAgICAvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxuICAgIC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcbiAgICB2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcblxuICAgIGlmICghcmV0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldFtrZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcbiAgICAgIHJldFtrZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gc3R5bGVPYmplY3Q7XG59XG5cbn0oalF1ZXJ5LCBGb3VuZGF0aW9uKVxuIiwiLyoqXG4gKiBNb3Rpb24gbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLm1vdGlvblxuICovXG4hZnVuY3Rpb24oJCwgRm91bmRhdGlvbikge1xuXG52YXIgaW5pdENsYXNzZXMgICA9IFsnbXVpLWVudGVyJywgJ211aS1sZWF2ZSddO1xudmFyIGFjdGl2ZUNsYXNzZXMgPSBbJ211aS1lbnRlci1hY3RpdmUnLCAnbXVpLWxlYXZlLWFjdGl2ZSddO1xuXG5mdW5jdGlvbiBhbmltYXRlKGlzSW4sIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpIHtcbiAgZWxlbWVudCA9ICQoZWxlbWVudCkuZXEoMCk7XG5cbiAgaWYgKCFlbGVtZW50Lmxlbmd0aCkgcmV0dXJuO1xuXG4gIHZhciBpbml0Q2xhc3MgPSBpc0luID8gaW5pdENsYXNzZXNbMF0gOiBpbml0Q2xhc3Nlc1sxXTtcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNJbiA/IGFjdGl2ZUNsYXNzZXNbMF0gOiBhY3RpdmVDbGFzc2VzWzFdO1xuXG4gIC8vIFNldCB1cCB0aGUgYW5pbWF0aW9uXG4gIHJlc2V0KCk7XG4gIGVsZW1lbnQuYWRkQ2xhc3MoYW5pbWF0aW9uKVxuICAgICAgICAgLmNzcygndHJhbnNpdGlvbicsICdub25lJyk7XG4gICAgICAgIC8vICAuYWRkQ2xhc3MoaW5pdENsYXNzKTtcbiAgLy8gaWYoaXNJbikgZWxlbWVudC5zaG93KCk7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICBlbGVtZW50LmFkZENsYXNzKGluaXRDbGFzcyk7XG4gICAgaWYgKGlzSW4pIGVsZW1lbnQuc2hvdygpO1xuICB9KTtcbiAgLy8gU3RhcnQgdGhlIGFuaW1hdGlvblxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgZWxlbWVudFswXS5vZmZzZXRXaWR0aDtcbiAgICBlbGVtZW50LmNzcygndHJhbnNpdGlvbicsICcnKTtcbiAgICBlbGVtZW50LmFkZENsYXNzKGFjdGl2ZUNsYXNzKTtcbiAgfSk7XG4gIC8vIE1vdmUoNTAwLCBlbGVtZW50LCBmdW5jdGlvbigpe1xuICAvLyAgIC8vIGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGg7XG4gIC8vICAgZWxlbWVudC5jc3MoJ3RyYW5zaXRpb24nLCAnJyk7XG4gIC8vICAgZWxlbWVudC5hZGRDbGFzcyhhY3RpdmVDbGFzcyk7XG4gIC8vIH0pO1xuXG4gIC8vIENsZWFuIHVwIHRoZSBhbmltYXRpb24gd2hlbiBpdCBmaW5pc2hlc1xuICBlbGVtZW50Lm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoZWxlbWVudCksIGZpbmlzaCk7Ly8ub25lKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgZmluaXNoKTtcblxuICAvLyBIaWRlcyB0aGUgZWxlbWVudCAoZm9yIG91dCBhbmltYXRpb25zKSwgcmVzZXRzIHRoZSBlbGVtZW50LCBhbmQgcnVucyBhIGNhbGxiYWNrXG4gIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICBpZiAoIWlzSW4pIGVsZW1lbnQuaGlkZSgpO1xuICAgIHJlc2V0KCk7XG4gICAgaWYgKGNiKSBjYi5hcHBseShlbGVtZW50KTtcbiAgfVxuXG4gIC8vIFJlc2V0cyB0cmFuc2l0aW9ucyBhbmQgcmVtb3ZlcyBtb3Rpb24tc3BlY2lmaWMgY2xhc3Nlc1xuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBlbGVtZW50WzBdLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IDA7XG4gICAgZWxlbWVudC5yZW1vdmVDbGFzcyhpbml0Q2xhc3MgKyAnICcgKyBhY3RpdmVDbGFzcyArICcgJyArIGFuaW1hdGlvbik7XG4gIH1cbn1cblxudmFyIE1vdGlvbiA9IHtcbiAgYW5pbWF0ZUluOiBmdW5jdGlvbihlbGVtZW50LCBhbmltYXRpb24sIC8qZHVyYXRpb24sKi8gY2IpIHtcbiAgICBhbmltYXRlKHRydWUsIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpO1xuICB9LFxuXG4gIGFuaW1hdGVPdXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGFuaW1hdGlvbiwgLypkdXJhdGlvbiwqLyBjYikge1xuICAgIGFuaW1hdGUoZmFsc2UsIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpO1xuICB9XG59O1xuXG52YXIgTW92ZSA9IGZ1bmN0aW9uKGR1cmF0aW9uLCBlbGVtLCBmbil7XG4gIHZhciBhbmltLCBwcm9nLCBzdGFydCA9IG51bGw7XG4gIC8vIGNvbnNvbGUubG9nKCdjYWxsZWQnKTtcblxuICBmdW5jdGlvbiBtb3ZlKHRzKXtcbiAgICBpZighc3RhcnQpIHN0YXJ0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIC8vIGNvbnNvbGUubG9nKHN0YXJ0LCB0cyk7XG4gICAgcHJvZyA9IHRzIC0gc3RhcnQ7XG4gICAgZm4uYXBwbHkoZWxlbSk7XG5cbiAgICBpZihwcm9nIDwgZHVyYXRpb24peyBhbmltID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtb3ZlLCBlbGVtKTsgfVxuICAgIGVsc2V7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbSk7XG4gICAgICBlbGVtLnRyaWdnZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBbZWxlbV0pLnRyaWdnZXJIYW5kbGVyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKTtcbiAgICB9XG4gIH1cbiAgYW5pbSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW92ZSk7XG59O1xuXG5Gb3VuZGF0aW9uLk1vdmUgPSBNb3ZlO1xuRm91bmRhdGlvbi5Nb3Rpb24gPSBNb3Rpb247XG5cbn0oalF1ZXJ5LCBGb3VuZGF0aW9uKTtcbiIsIiFmdW5jdGlvbigkLCBGb3VuZGF0aW9uKXtcbiAgJ3VzZSBzdHJpY3QnO1xuICBGb3VuZGF0aW9uLk5lc3QgPSB7XG4gICAgRmVhdGhlcjogZnVuY3Rpb24obWVudSwgdHlwZSl7XG4gICAgICBtZW51LmF0dHIoJ3JvbGUnLCAnbWVudWJhcicpO1xuICAgICAgdHlwZSA9IHR5cGUgfHwgJ3pmJztcbiAgICAgIHZhciBpdGVtcyA9IG1lbnUuZmluZCgnbGknKS5hdHRyKHsncm9sZSc6ICdtZW51aXRlbSd9KSxcbiAgICAgICAgICBzdWJNZW51Q2xhc3MgPSAnaXMtJyArIHR5cGUgKyAnLXN1Ym1lbnUnLFxuICAgICAgICAgIHN1Ykl0ZW1DbGFzcyA9IHN1Yk1lbnVDbGFzcyArICctaXRlbScsXG4gICAgICAgICAgaGFzU3ViQ2xhc3MgPSAnaXMtJyArIHR5cGUgKyAnLXN1Ym1lbnUtcGFyZW50JztcblxuICAgICAgaXRlbXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICB2YXIgJGl0ZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICAgJHN1YiA9ICRpdGVtLmNoaWxkcmVuKCd1bCcpO1xuICAgICAgICBpZigkc3ViLmxlbmd0aCl7XG4gICAgICAgICAgJGl0ZW0uYWRkQ2xhc3MoJ2hhcy1zdWJtZW51ICcgKyBoYXNTdWJDbGFzcyk7XG4gICAgICAgICAgJHN1Yi5hZGRDbGFzcygnc3VibWVudSAnICsgc3ViTWVudUNsYXNzKS5hdHRyKCdkYXRhLXN1Ym1lbnUnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoJGl0ZW0ucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCl7XG4gICAgICAgICAgJGl0ZW0uYWRkQ2xhc3MoJ2lzLXN1Ym1lbnUtaXRlbSAnICsgc3ViSXRlbUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSxcbiAgICBCdXJuOiBmdW5jdGlvbihtZW51LCB0eXBlKXtcbiAgICAgIHZhciBpdGVtcyA9IG1lbnUuZmluZCgnbGknKS5yZW1vdmVBdHRyKCd0YWJpbmRleCcpLFxuICAgICAgICAgIHN1Yk1lbnVDbGFzcyA9ICdpcy0nICsgdHlwZSArICctc3VibWVudScsXG4gICAgICAgICAgc3ViSXRlbUNsYXNzID0gc3ViTWVudUNsYXNzICsgJy1pdGVtJyxcbiAgICAgICAgICBoYXNTdWJDbGFzcyA9ICdpcy0nICsgdHlwZSArICctc3VibWVudS1wYXJlbnQnO1xuXG4gICAgICAvLyBtZW51LmZpbmQoJy5pcy1hY3RpdmUnKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgICBtZW51LmZpbmQoJyonKVxuICAgICAgLy8gbWVudS5maW5kKCcuJyArIHN1Yk1lbnVDbGFzcyArICcsIC4nICsgc3ViSXRlbUNsYXNzICsgJywgLmlzLWFjdGl2ZSwgLmhhcy1zdWJtZW51LCAuaXMtc3VibWVudS1pdGVtLCAuc3VibWVudSwgW2RhdGEtc3VibWVudV0nKVxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhzdWJNZW51Q2xhc3MgKyAnICcgKyBzdWJJdGVtQ2xhc3MgKyAnICcgKyBoYXNTdWJDbGFzcyArICcgaGFzLXN1Ym1lbnUgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUgaXMtYWN0aXZlJylcbiAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51JykuY3NzKCdkaXNwbGF5JywgJycpO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyggICAgICBtZW51LmZpbmQoJy4nICsgc3ViTWVudUNsYXNzICsgJywgLicgKyBzdWJJdGVtQ2xhc3MgKyAnLCAuaGFzLXN1Ym1lbnUsIC5pcy1zdWJtZW51LWl0ZW0sIC5zdWJtZW51LCBbZGF0YS1zdWJtZW51XScpXG4gICAgICAvLyAgICAgICAgICAgLnJlbW92ZUNsYXNzKHN1Yk1lbnVDbGFzcyArICcgJyArIHN1Ykl0ZW1DbGFzcyArICcgaGFzLXN1Ym1lbnUgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUnKVxuICAgICAgLy8gICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLXN1Ym1lbnUnKSk7XG4gICAgICAvLyBpdGVtcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAvLyAgIHZhciAkaXRlbSA9ICQodGhpcyksXG4gICAgICAvLyAgICAgICAkc3ViID0gJGl0ZW0uY2hpbGRyZW4oJ3VsJyk7XG4gICAgICAvLyAgIGlmKCRpdGVtLnBhcmVudCgnW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpe1xuICAgICAgLy8gICAgICRpdGVtLnJlbW92ZUNsYXNzKCdpcy1zdWJtZW51LWl0ZW0gJyArIHN1Ykl0ZW1DbGFzcyk7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vICAgaWYoJHN1Yi5sZW5ndGgpe1xuICAgICAgLy8gICAgICRpdGVtLnJlbW92ZUNsYXNzKCdoYXMtc3VibWVudScpO1xuICAgICAgLy8gICAgICRzdWIucmVtb3ZlQ2xhc3MoJ3N1Ym1lbnUgJyArIHN1Yk1lbnVDbGFzcykucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51Jyk7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH0pO1xuICAgIH1cbiAgfTtcbn0oalF1ZXJ5LCB3aW5kb3cuRm91bmRhdGlvbik7XG4iLCIhZnVuY3Rpb24oJCwgRm91bmRhdGlvbil7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIFRpbWVyID0gZnVuY3Rpb24oZWxlbSwgb3B0aW9ucywgY2Ipe1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiwvL29wdGlvbnMgaXMgYW4gb2JqZWN0IGZvciBlYXNpbHkgYWRkaW5nIGZlYXR1cmVzIGxhdGVyLlxuICAgICAgICBuYW1lU3BhY2UgPSBPYmplY3Qua2V5cyhlbGVtLmRhdGEoKSlbMF0gfHwgJ3RpbWVyJyxcbiAgICAgICAgcmVtYWluID0gLTEsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICB0aW1lcjtcblxuICAgIHRoaXMucmVzdGFydCA9IGZ1bmN0aW9uKCl7XG4gICAgICByZW1haW4gPSAtMTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gaWYoIWVsZW0uZGF0YSgncGF1c2VkJykpeyByZXR1cm4gZmFsc2U7IH0vL21heWJlIGltcGxlbWVudCB0aGlzIHNhbml0eSBjaGVjayBpZiB1c2VkIGZvciBvdGhlciB0aGluZ3MuXG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgcmVtYWluID0gcmVtYWluIDw9IDAgPyBkdXJhdGlvbiA6IHJlbWFpbjtcbiAgICAgIGVsZW0uZGF0YSgncGF1c2VkJywgZmFsc2UpO1xuICAgICAgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKG9wdGlvbnMuaW5maW5pdGUpe1xuICAgICAgICAgIF90aGlzLnJlc3RhcnQoKTsvL3JlcnVuIHRoZSB0aW1lci5cbiAgICAgICAgfVxuICAgICAgICBjYigpO1xuICAgICAgfSwgcmVtYWluKTtcbiAgICAgIGVsZW0udHJpZ2dlcigndGltZXJzdGFydC56Zi4nICsgbmFtZVNwYWNlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAvL2lmKGVsZW0uZGF0YSgncGF1c2VkJykpeyByZXR1cm4gZmFsc2U7IH0vL21heWJlIGltcGxlbWVudCB0aGlzIHNhbml0eSBjaGVjayBpZiB1c2VkIGZvciBvdGhlciB0aGluZ3MuXG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgZWxlbS5kYXRhKCdwYXVzZWQnLCB0cnVlKTtcbiAgICAgIHZhciBlbmQgPSBEYXRlLm5vdygpO1xuICAgICAgcmVtYWluID0gcmVtYWluIC0gKGVuZCAtIHN0YXJ0KTtcbiAgICAgIGVsZW0udHJpZ2dlcigndGltZXJwYXVzZWQuemYuJyArIG5hbWVTcGFjZSk7XG4gICAgfTtcbiAgfTtcbiAgLyoqXG4gICAqIFJ1bnMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGltYWdlcyBhcmUgZnVsbHkgbG9hZGVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VzIC0gSW1hZ2UocykgdG8gY2hlY2sgaWYgbG9hZGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN9IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIGltYWdlIGlzIGZ1bGx5IGxvYWRlZC5cbiAgICovXG4gIHZhciBvbkltYWdlc0xvYWRlZCA9IGZ1bmN0aW9uKGltYWdlcywgY2FsbGJhY2spe1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdW5sb2FkZWQgPSBpbWFnZXMubGVuZ3RoO1xuXG4gICAgaWYgKHVubG9hZGVkID09PSAwKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHZhciBzaW5nbGVJbWFnZUxvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdW5sb2FkZWQtLTtcbiAgICAgIGlmICh1bmxvYWRlZCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpbWFnZXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNvbXBsZXRlKSB7XG4gICAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5uYXR1cmFsV2lkdGggIT09ICd1bmRlZmluZWQnICYmIHRoaXMubmF0dXJhbFdpZHRoID4gMCkge1xuICAgICAgICBzaW5nbGVJbWFnZUxvYWRlZCgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICQodGhpcykub25lKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2luZ2xlSW1hZ2VMb2FkZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgRm91bmRhdGlvbi5UaW1lciA9IFRpbWVyO1xuICBGb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkID0gb25JbWFnZXNMb2FkZWQ7XG59KGpRdWVyeSwgd2luZG93LkZvdW5kYXRpb24pO1xuIiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8qKldvcmsgaW5zcGlyZWQgYnkgbXVsdGlwbGUganF1ZXJ5IHN3aXBlIHBsdWdpbnMqKlxuLy8qKkRvbmUgYnkgWW9oYWkgQXJhcmF0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuKGZ1bmN0aW9uKCQpIHtcblxuICAkLnNwb3RTd2lwZSA9IHtcbiAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgIGVuYWJsZWQ6ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICBtb3ZlVGhyZXNob2xkOiA3NSxcbiAgICB0aW1lVGhyZXNob2xkOiAyMDBcbiAgfTtcblxuICB2YXIgICBzdGFydFBvc1gsXG4gICAgICAgIHN0YXJ0UG9zWSxcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICBlbGFwc2VkVGltZSxcbiAgICAgICAgaXNNb3ZpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRvdWNoRW5kKCkge1xuICAgIC8vICBhbGVydCh0aGlzKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XG4gICAgaXNNb3ZpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICBpZiAoJC5zcG90U3dpcGUucHJldmVudERlZmF1bHQpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgaWYoaXNNb3ZpbmcpIHtcbiAgICAgIHZhciB4ID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgdmFyIHkgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICB2YXIgZHggPSBzdGFydFBvc1ggLSB4O1xuICAgICAgdmFyIGR5ID0gc3RhcnRQb3NZIC0geTtcbiAgICAgIHZhciBkaXI7XG4gICAgICBlbGFwc2VkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lO1xuICAgICAgaWYoTWF0aC5hYnMoZHgpID49ICQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgZWxhcHNlZFRpbWUgPD0gJC5zcG90U3dpcGUudGltZVRocmVzaG9sZCkge1xuICAgICAgICBkaXIgPSBkeCA+IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZihNYXRoLmFicyhkeSkgPj0gJC5zcG90U3dpcGUubW92ZVRocmVzaG9sZCAmJiBlbGFwc2VkVGltZSA8PSAkLnNwb3RTd2lwZS50aW1lVGhyZXNob2xkKSB7XG4gICAgICAgIGRpciA9IGR5ID4gMCA/ICdkb3duJyA6ICd1cCc7XG4gICAgICB9XG4gICAgICBpZihkaXIpIHtcbiAgICAgICAgb25Ub3VjaEVuZC5jYWxsKHRoaXMpO1xuICAgICAgICAkKHRoaXMpLnRyaWdnZXIoJ3N3aXBlJywgZGlyKS50cmlnZ2VyKCdzd2lwZScgKyBkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgc3RhcnRQb3NYID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgc3RhcnRQb3NZID0gZS50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyICYmIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVhcmRvd24oKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcbiAgfVxuXG4gICQuZXZlbnQuc3BlY2lhbC5zd2lwZSA9IHsgc2V0dXA6IGluaXQgfTtcblxuICAkLmVhY2goWydsZWZ0JywgJ3VwJywgJ2Rvd24nLCAncmlnaHQnXSwgZnVuY3Rpb24gKCkge1xuICAgICQuZXZlbnQuc3BlY2lhbFsnc3dpcGUnICsgdGhpc10gPSB7IHNldHVwOiBmdW5jdGlvbigpe1xuICAgICAgJCh0aGlzKS5vbignc3dpcGUnLCAkLm5vb3ApO1xuICAgIH0gfTtcbiAgfSk7XG59KShqUXVlcnkpO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1ldGhvZCBmb3IgYWRkaW5nIHBzdWVkbyBkcmFnIGV2ZW50cyB0byBlbGVtZW50cyAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuIWZ1bmN0aW9uKCQpe1xuICAkLmZuLmFkZFRvdWNoID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSxlbCl7XG4gICAgICAkKGVsKS5iaW5kKCd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsZnVuY3Rpb24oKXtcbiAgICAgICAgLy93ZSBwYXNzIHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QgYmVjYXVzZSB0aGUgalF1ZXJ5IGV2ZW50XG4gICAgICAgIC8vb2JqZWN0IGlzIG5vcm1hbGl6ZWQgdG8gdzNjIHNwZWNzIGFuZCBkb2VzIG5vdCBwcm92aWRlIHRoZSBUb3VjaExpc3RcbiAgICAgICAgaGFuZGxlVG91Y2goZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgaGFuZGxlVG91Y2ggPSBmdW5jdGlvbihldmVudCl7XG4gICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICAgIGZpcnN0ID0gdG91Y2hlc1swXSxcbiAgICAgICAgICBldmVudFR5cGVzID0ge1xuICAgICAgICAgICAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gICAgICAgICAgICB0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgdG91Y2hlbmQ6ICdtb3VzZXVwJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHlwZSA9IGV2ZW50VHlwZXNbZXZlbnQudHlwZV07XG5cbiAgICAgIHZhciBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgICBzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudCh0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsIGZpcnN0LnNjcmVlblgsIGZpcnN0LnNjcmVlblksIGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLypsZWZ0Ki8sIG51bGwpO1xuICAgICAgZmlyc3QudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuICAgIH07XG4gIH07XG59KGpRdWVyeSk7XG5cblxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyoqRnJvbSB0aGUgalF1ZXJ5IE1vYmlsZSBMaWJyYXJ5Kipcbi8vKipuZWVkIHRvIHJlY3JlYXRlIGZ1bmN0aW9uYWxpdHkqKlxuLy8qKmFuZCB0cnkgdG8gaW1wcm92ZSBpZiBwb3NzaWJsZSoqXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuLyogUmVtb3ZpbmcgdGhlIGpRdWVyeSBmdW5jdGlvbiAqKioqXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblxuXHR2YXIgJGRvY3VtZW50ID0gJCggZG9jdW1lbnQgKSxcblx0XHQvLyBzdXBwb3J0VG91Y2ggPSAkLm1vYmlsZS5zdXBwb3J0LnRvdWNoLFxuXHRcdHRvdWNoU3RhcnRFdmVudCA9ICd0b3VjaHN0YXJ0Jy8vc3VwcG9ydFRvdWNoID8gXCJ0b3VjaHN0YXJ0XCIgOiBcIm1vdXNlZG93blwiLFxuXHRcdHRvdWNoU3RvcEV2ZW50ID0gJ3RvdWNoZW5kJy8vc3VwcG9ydFRvdWNoID8gXCJ0b3VjaGVuZFwiIDogXCJtb3VzZXVwXCIsXG5cdFx0dG91Y2hNb3ZlRXZlbnQgPSAndG91Y2htb3ZlJy8vc3VwcG9ydFRvdWNoID8gXCJ0b3VjaG1vdmVcIiA6IFwibW91c2Vtb3ZlXCI7XG5cblx0Ly8gc2V0dXAgbmV3IGV2ZW50IHNob3J0Y3V0c1xuXHQkLmVhY2goICggXCJ0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCBcIiArXG5cdFx0XCJzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodFwiICkuc3BsaXQoIFwiIFwiICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdFx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0cmV0dXJuIGZuID8gdGhpcy5iaW5kKCBuYW1lLCBmbiApIDogdGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblxuXHRcdC8vIGpRdWVyeSA8IDEuOFxuXHRcdGlmICggJC5hdHRyRm4gKSB7XG5cdFx0XHQkLmF0dHJGblsgbmFtZSBdID0gdHJ1ZTtcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIHRyaWdnZXJDdXN0b21FdmVudCggb2JqLCBldmVudFR5cGUsIGV2ZW50LCBidWJibGUgKSB7XG5cdFx0dmFyIG9yaWdpbmFsVHlwZSA9IGV2ZW50LnR5cGU7XG5cdFx0ZXZlbnQudHlwZSA9IGV2ZW50VHlwZTtcblx0XHRpZiAoIGJ1YmJsZSApIHtcblx0XHRcdCQuZXZlbnQudHJpZ2dlciggZXZlbnQsIHVuZGVmaW5lZCwgb2JqICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQuZXZlbnQuZGlzcGF0Y2guY2FsbCggb2JqLCBldmVudCApO1xuXHRcdH1cblx0XHRldmVudC50eXBlID0gb3JpZ2luYWxUeXBlO1xuXHR9XG5cblx0Ly8gYWxzbyBoYW5kbGVzIHRhcGhvbGRcblxuXHQvLyBBbHNvIGhhbmRsZXMgc3dpcGVsZWZ0LCBzd2lwZXJpZ2h0XG5cdCQuZXZlbnQuc3BlY2lhbC5zd2lwZSA9IHtcblxuXHRcdC8vIE1vcmUgdGhhbiB0aGlzIGhvcml6b250YWwgZGlzcGxhY2VtZW50LCBhbmQgd2Ugd2lsbCBzdXBwcmVzcyBzY3JvbGxpbmcuXG5cdFx0c2Nyb2xsU3VwcmVzc2lvblRocmVzaG9sZDogMzAsXG5cblx0XHQvLyBNb3JlIHRpbWUgdGhhbiB0aGlzLCBhbmQgaXQgaXNuJ3QgYSBzd2lwZS5cblx0XHRkdXJhdGlvblRocmVzaG9sZDogMTAwMCxcblxuXHRcdC8vIFN3aXBlIGhvcml6b250YWwgZGlzcGxhY2VtZW50IG11c3QgYmUgbW9yZSB0aGFuIHRoaXMuXG5cdFx0aG9yaXpvbnRhbERpc3RhbmNlVGhyZXNob2xkOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+PSAyID8gMTUgOiAzMCxcblxuXHRcdC8vIFN3aXBlIHZlcnRpY2FsIGRpc3BsYWNlbWVudCBtdXN0IGJlIGxlc3MgdGhhbiB0aGlzLlxuXHRcdHZlcnRpY2FsRGlzdGFuY2VUaHJlc2hvbGQ6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID49IDIgPyAxNSA6IDMwLFxuXG5cdFx0Z2V0TG9jYXRpb246IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdFx0XHR2YXIgd2luUGFnZVggPSB3aW5kb3cucGFnZVhPZmZzZXQsXG5cdFx0XHRcdHdpblBhZ2VZID0gd2luZG93LnBhZ2VZT2Zmc2V0LFxuXHRcdFx0XHR4ID0gZXZlbnQuY2xpZW50WCxcblx0XHRcdFx0eSA9IGV2ZW50LmNsaWVudFk7XG5cblx0XHRcdGlmICggZXZlbnQucGFnZVkgPT09IDAgJiYgTWF0aC5mbG9vciggeSApID4gTWF0aC5mbG9vciggZXZlbnQucGFnZVkgKSB8fFxuXHRcdFx0XHRldmVudC5wYWdlWCA9PT0gMCAmJiBNYXRoLmZsb29yKCB4ICkgPiBNYXRoLmZsb29yKCBldmVudC5wYWdlWCApICkge1xuXG5cdFx0XHRcdC8vIGlPUzQgY2xpZW50WC9jbGllbnRZIGhhdmUgdGhlIHZhbHVlIHRoYXQgc2hvdWxkIGhhdmUgYmVlblxuXHRcdFx0XHQvLyBpbiBwYWdlWC9wYWdlWS4gV2hpbGUgcGFnZVgvcGFnZS8gaGF2ZSB0aGUgdmFsdWUgMFxuXHRcdFx0XHR4ID0geCAtIHdpblBhZ2VYO1xuXHRcdFx0XHR5ID0geSAtIHdpblBhZ2VZO1xuXHRcdFx0fSBlbHNlIGlmICggeSA8ICggZXZlbnQucGFnZVkgLSB3aW5QYWdlWSkgfHwgeCA8ICggZXZlbnQucGFnZVggLSB3aW5QYWdlWCApICkge1xuXG5cdFx0XHRcdC8vIFNvbWUgQW5kcm9pZCBicm93c2VycyBoYXZlIHRvdGFsbHkgYm9ndXMgdmFsdWVzIGZvciBjbGllbnRYL1lcblx0XHRcdFx0Ly8gd2hlbiBzY3JvbGxpbmcvem9vbWluZyBhIHBhZ2UuIERldGVjdGFibGUgc2luY2UgY2xpZW50WC9jbGllbnRZXG5cdFx0XHRcdC8vIHNob3VsZCBuZXZlciBiZSBzbWFsbGVyIHRoYW4gcGFnZVgvcGFnZVkgbWludXMgcGFnZSBzY3JvbGxcblx0XHRcdFx0eCA9IGV2ZW50LnBhZ2VYIC0gd2luUGFnZVg7XG5cdFx0XHRcdHkgPSBldmVudC5wYWdlWSAtIHdpblBhZ2VZO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiB4LFxuXHRcdFx0XHR5OiB5XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRzdGFydDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIGRhdGEgPSBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgP1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1sgMCBdIDogZXZlbnQsXG5cdFx0XHRcdGxvY2F0aW9uID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLmdldExvY2F0aW9uKCBkYXRhICk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dGltZTogKCBuZXcgRGF0ZSgpICkuZ2V0VGltZSgpLFxuXHRcdFx0XHRcdFx0Y29vcmRzOiBbIGxvY2F0aW9uLngsIGxvY2F0aW9uLnkgXSxcblx0XHRcdFx0XHRcdG9yaWdpbjogJCggZXZlbnQudGFyZ2V0IClcblx0XHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRzdG9wOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgZGF0YSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyA/XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWyAwIF0gOiBldmVudCxcblx0XHRcdFx0bG9jYXRpb24gPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZ2V0TG9jYXRpb24oIGRhdGEgKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0aW1lOiAoIG5ldyBEYXRlKCkgKS5nZXRUaW1lKCksXG5cdFx0XHRcdFx0XHRjb29yZHM6IFsgbG9jYXRpb24ueCwgbG9jYXRpb24ueSBdXG5cdFx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0aGFuZGxlU3dpcGU6IGZ1bmN0aW9uKCBzdGFydCwgc3RvcCwgdGhpc09iamVjdCwgb3JpZ1RhcmdldCApIHtcblx0XHRcdGlmICggc3RvcC50aW1lIC0gc3RhcnQudGltZSA8ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5kdXJhdGlvblRocmVzaG9sZCAmJlxuXHRcdFx0XHRNYXRoLmFicyggc3RhcnQuY29vcmRzWyAwIF0gLSBzdG9wLmNvb3Jkc1sgMCBdICkgPiAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuaG9yaXpvbnRhbERpc3RhbmNlVGhyZXNob2xkICYmXG5cdFx0XHRcdE1hdGguYWJzKCBzdGFydC5jb29yZHNbIDEgXSAtIHN0b3AuY29vcmRzWyAxIF0gKSA8ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS52ZXJ0aWNhbERpc3RhbmNlVGhyZXNob2xkICkge1xuXHRcdFx0XHR2YXIgZGlyZWN0aW9uID0gc3RhcnQuY29vcmRzWzBdID4gc3RvcC5jb29yZHNbIDAgXSA/IFwic3dpcGVsZWZ0XCIgOiBcInN3aXBlcmlnaHRcIjtcblxuXHRcdFx0XHR0cmlnZ2VyQ3VzdG9tRXZlbnQoIHRoaXNPYmplY3QsIFwic3dpcGVcIiwgJC5FdmVudCggXCJzd2lwZVwiLCB7IHRhcmdldDogb3JpZ1RhcmdldCwgc3dpcGVzdGFydDogc3RhcnQsIHN3aXBlc3RvcDogc3RvcCB9KSwgdHJ1ZSApO1xuXHRcdFx0XHR0cmlnZ2VyQ3VzdG9tRXZlbnQoIHRoaXNPYmplY3QsIGRpcmVjdGlvbiwkLkV2ZW50KCBkaXJlY3Rpb24sIHsgdGFyZ2V0OiBvcmlnVGFyZ2V0LCBzd2lwZXN0YXJ0OiBzdGFydCwgc3dpcGVzdG9wOiBzdG9wIH0gKSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH0sXG5cblx0XHQvLyBUaGlzIHNlcnZlcyBhcyBhIGZsYWcgdG8gZW5zdXJlIHRoYXQgYXQgbW9zdCBvbmUgc3dpcGUgZXZlbnQgZXZlbnQgaXNcblx0XHQvLyBpbiB3b3JrIGF0IGFueSBnaXZlbiB0aW1lXG5cdFx0ZXZlbnRJblByb2dyZXNzOiBmYWxzZSxcblxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBldmVudHMsXG5cdFx0XHRcdHRoaXNPYmplY3QgPSB0aGlzLFxuXHRcdFx0XHQkdGhpcyA9ICQoIHRoaXNPYmplY3QgKSxcblx0XHRcdFx0Y29udGV4dCA9IHt9O1xuXG5cdFx0XHQvLyBSZXRyaWV2ZSB0aGUgZXZlbnRzIGRhdGEgZm9yIHRoaXMgZWxlbWVudCBhbmQgYWRkIHRoZSBzd2lwZSBjb250ZXh0XG5cdFx0XHRldmVudHMgPSAkLmRhdGEoIHRoaXMsIFwibW9iaWxlLWV2ZW50c1wiICk7XG5cdFx0XHRpZiAoICFldmVudHMgKSB7XG5cdFx0XHRcdGV2ZW50cyA9IHsgbGVuZ3RoOiAwIH07XG5cdFx0XHRcdCQuZGF0YSggdGhpcywgXCJtb2JpbGUtZXZlbnRzXCIsIGV2ZW50cyApO1xuXHRcdFx0fVxuXHRcdFx0ZXZlbnRzLmxlbmd0aCsrO1xuXHRcdFx0ZXZlbnRzLnN3aXBlID0gY29udGV4dDtcblxuXHRcdFx0Y29udGV4dC5zdGFydCA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBCYWlsIGlmIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvbiBhIHN3aXBlIGV2ZW50XG5cdFx0XHRcdGlmICggJC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0JC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyA9IHRydWU7XG5cblx0XHRcdFx0dmFyIHN0b3AsXG5cdFx0XHRcdFx0c3RhcnQgPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuc3RhcnQoIGV2ZW50ICksXG5cdFx0XHRcdFx0b3JpZ1RhcmdldCA9IGV2ZW50LnRhcmdldCxcblx0XHRcdFx0XHRlbWl0dGVkID0gZmFsc2U7XG5cblx0XHRcdFx0Y29udGV4dC5tb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXJ0IHx8IGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHN0b3AgPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuc3RvcCggZXZlbnQgKTtcblx0XHRcdFx0XHRpZiAoICFlbWl0dGVkICkge1xuXHRcdFx0XHRcdFx0ZW1pdHRlZCA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5oYW5kbGVTd2lwZSggc3RhcnQsIHN0b3AsIHRoaXNPYmplY3QsIG9yaWdUYXJnZXQgKTtcblx0XHRcdFx0XHRcdGlmICggZW1pdHRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXNldCB0aGUgY29udGV4dCB0byBtYWtlIHdheSBmb3IgdGhlIG5leHQgc3dpcGUgZXZlbnRcblx0XHRcdFx0XHRcdFx0JC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBwcmV2ZW50IHNjcm9sbGluZ1xuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIHN0YXJ0LmNvb3Jkc1sgMCBdIC0gc3RvcC5jb29yZHNbIDAgXSApID4gJC5ldmVudC5zcGVjaWFsLnN3aXBlLnNjcm9sbFN1cHJlc3Npb25UaHJlc2hvbGQgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRjb250ZXh0LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGVtaXR0ZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHQvLyBSZXNldCB0aGUgY29udGV4dCB0byBtYWtlIHdheSBmb3IgdGhlIG5leHQgc3dpcGUgZXZlbnRcblx0XHRcdFx0XHRcdCQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ldmVudEluUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHRcdFx0XHRcdCRkb2N1bWVudC5vZmYoIHRvdWNoTW92ZUV2ZW50LCBjb250ZXh0Lm1vdmUgKTtcblx0XHRcdFx0XHRcdGNvbnRleHQubW92ZSA9IG51bGw7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0JGRvY3VtZW50Lm9uKCB0b3VjaE1vdmVFdmVudCwgY29udGV4dC5tb3ZlIClcblx0XHRcdFx0XHQub25lKCB0b3VjaFN0b3BFdmVudCwgY29udGV4dC5zdG9wICk7XG5cdFx0XHR9O1xuXHRcdFx0JHRoaXMub24oIHRvdWNoU3RhcnRFdmVudCwgY29udGV4dC5zdGFydCApO1xuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZXZlbnRzLCBjb250ZXh0O1xuXG5cdFx0XHRldmVudHMgPSAkLmRhdGEoIHRoaXMsIFwibW9iaWxlLWV2ZW50c1wiICk7XG5cdFx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdFx0Y29udGV4dCA9IGV2ZW50cy5zd2lwZTtcblx0XHRcdFx0ZGVsZXRlIGV2ZW50cy5zd2lwZTtcblx0XHRcdFx0ZXZlbnRzLmxlbmd0aC0tO1xuXHRcdFx0XHRpZiAoIGV2ZW50cy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0JC5yZW1vdmVEYXRhKCB0aGlzLCBcIm1vYmlsZS1ldmVudHNcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggY29udGV4dCApIHtcblx0XHRcdFx0aWYgKCBjb250ZXh0LnN0YXJ0ICkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5vZmYoIHRvdWNoU3RhcnRFdmVudCwgY29udGV4dC5zdGFydCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY29udGV4dC5tb3ZlICkge1xuXHRcdFx0XHRcdCRkb2N1bWVudC5vZmYoIHRvdWNoTW92ZUV2ZW50LCBjb250ZXh0Lm1vdmUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNvbnRleHQuc3RvcCApIHtcblx0XHRcdFx0XHQkZG9jdW1lbnQub2ZmKCB0b3VjaFN0b3BFdmVudCwgY29udGV4dC5zdG9wICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdCQuZWFjaCh7XG5cdFx0c3dpcGVsZWZ0OiBcInN3aXBlLmxlZnRcIixcblx0XHRzd2lwZXJpZ2h0OiBcInN3aXBlLnJpZ2h0XCJcblx0fSwgZnVuY3Rpb24oIGV2ZW50LCBzb3VyY2VFdmVudCApIHtcblxuXHRcdCQuZXZlbnQuc3BlY2lhbFsgZXZlbnQgXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmJpbmQoIHNvdXJjZUV2ZW50LCAkLm5vb3AgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS51bmJpbmQoIHNvdXJjZUV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG59KSggalF1ZXJ5LCB0aGlzICk7XG4qL1xuIiwiIWZ1bmN0aW9uKEZvdW5kYXRpb24sICQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLW9wZW5dIHdpbGwgcmV2ZWFsIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuICAkKGRvY3VtZW50KS5vbignY2xpY2suemYudHJpZ2dlcicsICdbZGF0YS1vcGVuXScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZCA9ICQodGhpcykuZGF0YSgnb3BlbicpO1xuICAgICQoJyMnICsgaWQpLnRyaWdnZXJIYW5kbGVyKCdvcGVuLnpmLnRyaWdnZXInLCBbJCh0aGlzKV0pO1xuICB9KTtcblxuICAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLWNsb3NlXSB3aWxsIGNsb3NlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuICAvLyBJZiB1c2VkIHdpdGhvdXQgYSB2YWx1ZSBvbiBbZGF0YS1jbG9zZV0sIHRoZSBldmVudCB3aWxsIGJ1YmJsZSwgYWxsb3dpbmcgaXQgdG8gY2xvc2UgYSBwYXJlbnQgY29tcG9uZW50LlxuICAkKGRvY3VtZW50KS5vbignY2xpY2suemYudHJpZ2dlcicsICdbZGF0YS1jbG9zZV0nLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWQgPSAkKHRoaXMpLmRhdGEoJ2Nsb3NlJyk7XG4gICAgaWYgKGlkKSB7XG4gICAgICAkKCcjJyArIGlkKS50cmlnZ2VySGFuZGxlcignY2xvc2UuemYudHJpZ2dlcicsIFskKHRoaXMpXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjbG9zZS56Zi50cmlnZ2VyJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLXRvZ2dsZV0gd2lsbCB0b2dnbGUgYSBwbHVnaW4gdGhhdCBzdXBwb3J0cyBpdCB3aGVuIGNsaWNrZWQuXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLXRvZ2dsZV0nLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWQgPSAkKHRoaXMpLmRhdGEoJ3RvZ2dsZScpO1xuICAgICQoJyMnICsgaWQpLnRyaWdnZXJIYW5kbGVyKCd0b2dnbGUuemYudHJpZ2dlcicsIFskKHRoaXMpXSk7XG4gIH0pO1xuXG4gIC8vIEVsZW1lbnRzIHdpdGggW2RhdGEtY2xvc2FibGVdIHdpbGwgcmVzcG9uZCB0byBjbG9zZS56Zi50cmlnZ2VyIGV2ZW50cy5cbiAgJChkb2N1bWVudCkub24oJ2Nsb3NlLnpmLnRyaWdnZXInLCAnW2RhdGEtY2xvc2FibGVdJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFuaW1hdGlvbiA9ICQodGhpcykuZGF0YSgnY2xvc2FibGUnKSB8fCAnZmFkZS1vdXQnO1xuICAgIGlmKEZvdW5kYXRpb24uTW90aW9uKXtcbiAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQoJCh0aGlzKSwgYW5pbWF0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjbG9zZWQuemYnKTtcbiAgICAgIH0pO1xuICAgIH1lbHNle1xuICAgICAgJCh0aGlzKS5mYWRlT3V0KCkudHJpZ2dlcignY2xvc2VkLnpmJyk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgTXV0YXRpb25PYnNlcnZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZWZpeGVzID0gWydXZWJLaXQnLCAnTW96JywgJ08nLCAnTXMnLCAnJ107XG4gICAgZm9yICh2YXIgaT0wOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwcmVmaXhlc1tpXSArICdNdXRhdGlvbk9ic2VydmVyJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvd1twcmVmaXhlc1tpXSArICdNdXRhdGlvbk9ic2VydmVyJ107XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSgpKTtcblxuXG4gIHZhciBjaGVja0xpc3RlbmVycyA9IGZ1bmN0aW9uKCl7XG4gICAgZXZlbnRzTGlzdGVuZXIoKTtcbiAgICByZXNpemVMaXN0ZW5lcigpO1xuICAgIHNjcm9sbExpc3RlbmVyKCk7XG4gICAgY2xvc2VtZUxpc3RlbmVyKCk7XG4gIH07XG4gIC8qKlxuICAqIEZpcmVzIG9uY2UgYWZ0ZXIgYWxsIG90aGVyIHNjcmlwdHMgaGF2ZSBsb2FkZWRcbiAgKiBAZnVuY3Rpb25cbiAgKiBAcHJpdmF0ZVxuICAqL1xuICAkKHdpbmRvdykubG9hZChmdW5jdGlvbigpe1xuICAgIGNoZWNrTGlzdGVuZXJzKCk7XG4gIH0pO1xuXG4gIC8vKioqKioqKiogb25seSBmaXJlcyB0aGlzIGZ1bmN0aW9uIG9uY2Ugb24gbG9hZCwgaWYgdGhlcmUncyBzb21ldGhpbmcgdG8gd2F0Y2ggKioqKioqKipcbiAgdmFyIGNsb3NlbWVMaXN0ZW5lciA9IGZ1bmN0aW9uKHBsdWdpbk5hbWUpe1xuICAgIHZhciB5ZXRpQm94ZXMgPSAkKCdbZGF0YS15ZXRpLWJveF0nKSxcbiAgICAgICAgcGx1Z05hbWVzID0gWydkcm9wZG93bicsICd0b29sdGlwJywgJ3JldmVhbCddO1xuXG4gICAgaWYocGx1Z2luTmFtZSl7XG4gICAgICBpZih0eXBlb2YgcGx1Z2luTmFtZSA9PT0gJ3N0cmluZycpe1xuICAgICAgICBwbHVnTmFtZXMucHVzaChwbHVnaW5OYW1lKTtcbiAgICAgIH1lbHNlIGlmKHR5cGVvZiBwbHVnaW5OYW1lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGx1Z2luTmFtZVswXSA9PT0gJ3N0cmluZycpe1xuICAgICAgICBwbHVnTmFtZXMuY29uY2F0KHBsdWdpbk5hbWUpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BsdWdpbiBuYW1lcyBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoeWV0aUJveGVzLmxlbmd0aCl7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gcGx1Z05hbWVzLm1hcChmdW5jdGlvbihuYW1lKXtcbiAgICAgICAgcmV0dXJuICdjbG9zZW1lLnpmLicgKyBuYW1lO1xuICAgICAgfSkuam9pbignICcpO1xuXG4gICAgICAkKHdpbmRvdykub2ZmKGxpc3RlbmVycykub24obGlzdGVuZXJzLCBmdW5jdGlvbihlLCBwbHVnaW5JZCl7XG4gICAgICAgIHZhciBwbHVnaW4gPSBlLm5hbWVzcGFjZS5zcGxpdCgnLicpWzBdO1xuICAgICAgICB2YXIgcGx1Z2lucyA9ICQoJ1tkYXRhLScgKyBwbHVnaW4gKyAnXScpLm5vdCgnW2RhdGEteWV0aS1ib3g9XCInICsgcGx1Z2luSWQgKyAnXCJdJyk7XG5cbiAgICAgICAgcGx1Z2lucy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIF90aGlzID0gJCh0aGlzKTtcblxuICAgICAgICAgIF90aGlzLnRyaWdnZXJIYW5kbGVyKCdjbG9zZS56Zi50cmlnZ2VyJywgW190aGlzXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICB2YXIgcmVzaXplTGlzdGVuZXIgPSBmdW5jdGlvbihkZWJvdW5jZSl7XG4gICAgdmFyIHRpbWVyLFxuICAgICAgICAkbm9kZXMgPSAkKCdbZGF0YS1yZXNpemVdJyk7XG4gICAgaWYoJG5vZGVzLmxlbmd0aCl7XG4gICAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUuemYudHJpZ2dlcicpXG4gICAgICAub24oJ3Jlc2l6ZS56Zi50cmlnZ2VyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGltZXIpIHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfVxuXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXG4gICAgICAgICAgaWYoIU11dGF0aW9uT2JzZXJ2ZXIpey8vZmFsbGJhY2sgZm9yIElFIDlcbiAgICAgICAgICAgICRub2Rlcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICQodGhpcykudHJpZ2dlckhhbmRsZXIoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL3RyaWdnZXIgYWxsIGxpc3RlbmluZyBlbGVtZW50cyBhbmQgc2lnbmFsIGEgcmVzaXplIGV2ZW50XG4gICAgICAgICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXCJyZXNpemVcIik7XG4gICAgICAgIH0sIGRlYm91bmNlIHx8IDEwKTsvL2RlZmF1bHQgdGltZSB0byBlbWl0IHJlc2l6ZSBldmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICB2YXIgc2Nyb2xsTGlzdGVuZXIgPSBmdW5jdGlvbihkZWJvdW5jZSl7XG4gICAgdmFyIHRpbWVyLFxuICAgICAgICAkbm9kZXMgPSAkKCdbZGF0YS1zY3JvbGxdJyk7XG4gICAgaWYoJG5vZGVzLmxlbmd0aCl7XG4gICAgICAkKHdpbmRvdykub2ZmKCdzY3JvbGwuemYudHJpZ2dlcicpXG4gICAgICAub24oJ3Njcm9sbC56Zi50cmlnZ2VyJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIGlmKHRpbWVyKXsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfVxuXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXG4gICAgICAgICAgaWYoIU11dGF0aW9uT2JzZXJ2ZXIpey8vZmFsbGJhY2sgZm9yIElFIDlcbiAgICAgICAgICAgICRub2Rlcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICQodGhpcykudHJpZ2dlckhhbmRsZXIoJ3Njcm9sbG1lLnpmLnRyaWdnZXInKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL3RyaWdnZXIgYWxsIGxpc3RlbmluZyBlbGVtZW50cyBhbmQgc2lnbmFsIGEgc2Nyb2xsIGV2ZW50XG4gICAgICAgICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXCJzY3JvbGxcIik7XG4gICAgICAgIH0sIGRlYm91bmNlIHx8IDEwKTsvL2RlZmF1bHQgdGltZSB0byBlbWl0IHNjcm9sbCBldmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvLyBmdW5jdGlvbiBkb21NdXRhdGlvbk9ic2VydmVyKGRlYm91bmNlKSB7XG4gIC8vICAgLy8gISEhIFRoaXMgaXMgY29taW5nIHNvb24gYW5kIG5lZWRzIG1vcmUgd29yazsgbm90IGFjdGl2ZSAgISEhIC8vXG4gIC8vICAgdmFyIHRpbWVyLFxuICAvLyAgIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbXV0YXRlXScpO1xuICAvLyAgIC8vXG4gIC8vICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAvLyAgICAgLy8gdmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAvLyAgICAgLy8gICB2YXIgcHJlZml4ZXMgPSBbJ1dlYktpdCcsICdNb3onLCAnTycsICdNcycsICcnXTtcbiAgLy8gICAgIC8vICAgZm9yICh2YXIgaT0wOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgLy8gICAgIC8vICAgICBpZiAocHJlZml4ZXNbaV0gKyAnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4gIC8vICAgICAvLyAgICAgICByZXR1cm4gd2luZG93W3ByZWZpeGVzW2ldICsgJ011dGF0aW9uT2JzZXJ2ZXInXTtcbiAgLy8gICAgIC8vICAgICB9XG4gIC8vICAgICAvLyAgIH1cbiAgLy8gICAgIC8vICAgcmV0dXJuIGZhbHNlO1xuICAvLyAgICAgLy8gfSgpKTtcbiAgLy9cbiAgLy9cbiAgLy8gICAgIC8vZm9yIHRoZSBib2R5LCB3ZSBuZWVkIHRvIGxpc3RlbiBmb3IgYWxsIGNoYW5nZXMgZWZmZWN0aW5nIHRoZSBzdHlsZSBhbmQgY2xhc3MgYXR0cmlidXRlc1xuICAvLyAgICAgdmFyIGJvZHlPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGJvZHlNdXRhdGlvbik7XG4gIC8vICAgICBib2R5T2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogZmFsc2UsIHN1YnRyZWU6dHJ1ZSwgYXR0cmlidXRlRmlsdGVyOltcInN0eWxlXCIsIFwiY2xhc3NcIl19KTtcbiAgLy9cbiAgLy9cbiAgLy8gICAgIC8vYm9keSBjYWxsYmFja1xuICAvLyAgICAgZnVuY3Rpb24gYm9keU11dGF0aW9uKG11dGF0ZSkge1xuICAvLyAgICAgICAvL3RyaWdnZXIgYWxsIGxpc3RlbmluZyBlbGVtZW50cyBhbmQgc2lnbmFsIGEgbXV0YXRpb24gZXZlbnRcbiAgLy8gICAgICAgaWYgKHRpbWVyKSB7IGNsZWFyVGltZW91dCh0aW1lcik7IH1cbiAgLy9cbiAgLy8gICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAvLyAgICAgICAgIGJvZHlPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIC8vICAgICAgICAgJCgnW2RhdGEtbXV0YXRlXScpLmF0dHIoJ2RhdGEtZXZlbnRzJyxcIm11dGF0ZVwiKTtcbiAgLy8gICAgICAgfSwgZGVib3VuY2UgfHwgMTUwKTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vIH1cbiAgdmFyIGV2ZW50c0xpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoIU11dGF0aW9uT2JzZXJ2ZXIpeyByZXR1cm4gZmFsc2U7IH1cbiAgICB2YXIgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1yZXNpemVdLCBbZGF0YS1zY3JvbGxdLCBbZGF0YS1tdXRhdGVdJyk7XG5cbiAgICAvL2VsZW1lbnQgY2FsbGJhY2tcbiAgICB2YXIgbGlzdGVuaW5nRWxlbWVudHNNdXRhdGlvbiA9IGZ1bmN0aW9uKG11dGF0aW9uUmVjb3Jkc0xpc3QpIHtcbiAgICAgIHZhciAkdGFyZ2V0ID0gJChtdXRhdGlvblJlY29yZHNMaXN0WzBdLnRhcmdldCk7XG4gICAgICAvL3RyaWdnZXIgdGhlIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBlbGVtZW50IGRlcGVuZGluZyBvbiB0eXBlXG4gICAgICBzd2l0Y2ggKCR0YXJnZXQuYXR0cihcImRhdGEtZXZlbnRzXCIpKSB7XG5cbiAgICAgICAgY2FzZSBcInJlc2l6ZVwiIDpcbiAgICAgICAgJHRhcmdldC50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0XSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJzY3JvbGxcIiA6XG4gICAgICAgICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ3Njcm9sbG1lLnpmLnRyaWdnZXInLCBbJHRhcmdldCwgd2luZG93LnBhZ2VZT2Zmc2V0XSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIGNhc2UgXCJtdXRhdGVcIiA6XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdtdXRhdGUnLCAkdGFyZ2V0KTtcbiAgICAgICAgLy8gJHRhcmdldC50cmlnZ2VySGFuZGxlcignbXV0YXRlLnpmLnRyaWdnZXInKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLy9tYWtlIHN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIGFuIGluZmluaXRlIGxvb3AgZnJvbSBzbG9wcHkgY29kZWluZ1xuICAgICAgICAvLyBpZiAoJHRhcmdldC5pbmRleCgnW2RhdGEtbXV0YXRlXScpID09ICQoXCJbZGF0YS1tdXRhdGVdXCIpLmxlbmd0aC0xKSB7XG4gICAgICAgIC8vICAgZG9tTXV0YXRpb25PYnNlcnZlcigpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vbm90aGluZ1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKG5vZGVzLmxlbmd0aCl7XG4gICAgICAvL2ZvciBlYWNoIGVsZW1lbnQgdGhhdCBuZWVkcyB0byBsaXN0ZW4gZm9yIHJlc2l6aW5nLCBzY3JvbGxpbmcsIChvciBjb21pbmcgc29vbiBtdXRhdGlvbikgYWRkIGEgc2luZ2xlIG9ic2VydmVyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBub2Rlcy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtZW50T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uKTtcbiAgICAgICAgZWxlbWVudE9ic2VydmVyLm9ic2VydmUobm9kZXNbaV0sIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiBmYWxzZSwgY2hhcmFjdGVyRGF0YTogZmFsc2UsIHN1YnRyZWU6ZmFsc2UsIGF0dHJpYnV0ZUZpbHRlcjpbXCJkYXRhLWV2ZW50c1wiXX0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gW1BIXVxuICAvLyBGb3VuZGF0aW9uLkNoZWNrV2F0Y2hlcnMgPSBjaGVja1dhdGNoZXJzO1xuICBGb3VuZGF0aW9uLklIZWFyWW91ID0gY2hlY2tMaXN0ZW5lcnM7XG4gIC8vIEZvdW5kYXRpb24uSVNlZVlvdSA9IHNjcm9sbExpc3RlbmVyO1xuICAvLyBGb3VuZGF0aW9uLklGZWVsWW91ID0gY2xvc2VtZUxpc3RlbmVyO1xuXG59KHdpbmRvdy5Gb3VuZGF0aW9uLCB3aW5kb3cualF1ZXJ5KTtcbiIsIiFmdW5jdGlvbihGb3VuZGF0aW9uLCAkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBBYmlkZS5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBBYmlkZSNpbml0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGZ1bmN0aW9uIEFiaWRlKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgID0gJC5leHRlbmQoe30sIEFiaWRlLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgdGhpcy4kd2luZG93ICA9ICQod2luZG93KTtcbiAgICB0aGlzLm5hbWUgICAgID0gJ0FiaWRlJztcbiAgICB0aGlzLmF0dHIgICAgID0gJ2RhdGEtYWJpZGUnO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cbiAgICovXG4gIEFiaWRlLmRlZmF1bHRzID0ge1xuICAgIHZhbGlkYXRlT246ICdmaWVsZENoYW5nZScsIC8vIG9wdGlvbnM6IGZpZWxkQ2hhbmdlLCBtYW51YWwsIHN1Ym1pdFxuICAgIGxhYmVsRXJyb3JDbGFzczogJ2lzLWludmFsaWQtbGFiZWwnLFxuICAgIGlucHV0RXJyb3JDbGFzczogJ2lzLWludmFsaWQtaW5wdXQnLFxuICAgIGZvcm1FcnJvclNlbGVjdG9yOiAnLmZvcm0tZXJyb3InLFxuICAgIGZvcm1FcnJvckNsYXNzOiAnaXMtdmlzaWJsZScsXG4gICAgcGF0dGVybnM6IHtcbiAgICAgIGFscGhhIDogL15bYS16QS1aXSskLyxcbiAgICAgIGFscGhhX251bWVyaWMgOiAvXlthLXpBLVowLTldKyQvLFxuICAgICAgaW50ZWdlciA6IC9eWy0rXT9cXGQrJC8sXG4gICAgICBudW1iZXIgOiAvXlstK10/XFxkKig/OltcXC5cXCxdXFxkKyk/JC8sXG5cbiAgICAgIC8vIGFtZXgsIHZpc2EsIGRpbmVyc1xuICAgICAgY2FyZCA6IC9eKD86NFswLTldezEyfSg/OlswLTldezN9KT98NVsxLTVdWzAtOV17MTR9fDYoPzowMTF8NVswLTldWzAtOV0pWzAtOV17MTJ9fDNbNDddWzAtOV17MTN9fDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfXwoPzoyMTMxfDE4MDB8MzVcXGR7M30pXFxkezExfSkkLyxcbiAgICAgIGN2diA6IC9eKFswLTldKXszLDR9JC8sXG5cbiAgICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3N0YXRlcy1vZi10aGUtdHlwZS1hdHRyaWJ1dGUuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzc1xuICAgICAgZW1haWwgOiAvXlthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSskLyxcblxuICAgICAgdXJsIDogL14oaHR0cHM/fGZ0cHxmaWxlfHNzaCk6XFwvXFwvKCgoKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDopKkApPygoKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKSl8KCgoW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpBLVpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpBLVpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16QS1aXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16QS1aXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuPykoOlxcZCopPykoXFwvKCgoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSsoXFwvKChbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKikqKT8pPyhcXD8oKChbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFtcXHVFMDAwLVxcdUY4RkZdfFxcL3xcXD8pKik/KFxcIygoKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8XFwvfFxcPykqKT8kLyxcbiAgICAgIC8vIGFiYy5kZVxuICAgICAgZG9tYWluIDogL14oW2EtekEtWjAtOV0oW2EtekEtWjAtOVxcLV17MCw2MX1bYS16QS1aMC05XSk/XFwuKStbYS16QS1aXXsyLDh9JC8sXG5cbiAgICAgIGRhdGV0aW1lIDogL14oWzAtMl1bMC05XXszfSlcXC0oWzAtMV1bMC05XSlcXC0oWzAtM11bMC05XSlUKFswLTVdWzAtOV0pXFw6KFswLTVdWzAtOV0pXFw6KFswLTVdWzAtOV0pKFp8KFtcXC1cXCtdKFswLTFdWzAtOV0pXFw6MDApKSQvLFxuICAgICAgLy8gWVlZWS1NTS1ERFxuICAgICAgZGF0ZSA6IC8oPzoxOXwyMClbMC05XXsyfS0oPzooPzowWzEtOV18MVswLTJdKS0oPzowWzEtOV18MVswLTldfDJbMC05XSl8KD86KD8hMDIpKD86MFsxLTldfDFbMC0yXSktKD86MzApKXwoPzooPzowWzEzNTc4XXwxWzAyXSktMzEpKSQvLFxuICAgICAgLy8gSEg6TU06U1NcbiAgICAgIHRpbWUgOiAvXigwWzAtOV18MVswLTldfDJbMC0zXSkoOlswLTVdWzAtOV0pezJ9JC8sXG4gICAgICBkYXRlSVNPIDogL15cXGR7NH1bXFwvXFwtXVxcZHsxLDJ9W1xcL1xcLV1cXGR7MSwyfSQvLFxuICAgICAgLy8gTU0vREQvWVlZWVxuICAgICAgbW9udGhfZGF5X3llYXIgOiAvXigwWzEtOV18MVswMTJdKVstIFxcLy5dKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFwvLl1cXGR7NH0kLyxcbiAgICAgIC8vIEREL01NL1lZWVlcbiAgICAgIGRheV9tb250aF95ZWFyIDogL14oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlbLSBcXC8uXSgwWzEtOV18MVswMTJdKVstIFxcLy5dXFxkezR9JC8sXG5cbiAgICAgIC8vICNGRkYgb3IgI0ZGRkZGRlxuICAgICAgY29sb3IgOiAvXiM/KFthLWZBLUYwLTldezZ9fFthLWZBLUYwLTldezN9KSQvXG4gICAgfSxcbiAgICB2YWxpZGF0b3JzOiB7XG4gICAgICBlcXVhbFRvOiBmdW5jdGlvbiAoZWwsIHJlcXVpcmVkLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIGZyb20gID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwuZ2V0QXR0cmlidXRlKHRoaXMuYWRkX25hbWVzcGFjZSgnZGF0YS1lcXVhbHRvJykpKS52YWx1ZSxcbiAgICAgICAgICAgIHRvICAgID0gZWwudmFsdWUsXG4gICAgICAgICAgICB2YWxpZCA9IChmcm9tID09PSB0byk7XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgQWJpZGUgcGx1Z2luIGFuZCBjYWxscyBmdW5jdGlvbnMgdG8gZ2V0IEFiaWRlIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBYmlkZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBBYmlkZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFiaWRlLnByb3RvdHlwZS5fZXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vZmYoJy5hYmlkZScpXG4gICAgICAub24oJ3Jlc2V0LmZuZHRuLmFiaWRlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLnJlc2V0Rm9ybSgkKHRoaXMpKTtcbiAgICAgIH0pXG4gICAgICAub24oJ3N1Ym1pdC5mbmR0bi5hYmlkZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZWxmLnZhbGlkYXRlRm9ybShzZWxmLiRlbGVtZW50KTtcbiAgICAgIH0pXG4gICAgICAuZmluZCgnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnKVxuICAgICAgICAub2ZmKCcuYWJpZGUnKVxuICAgICAgICAub24oJ2JsdXIuZm5kdG4uYWJpZGUgY2hhbmdlLmZuZHRuLmFiaWRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnZhbGlkYXRlT24gPT09ICdmaWVsZENoYW5nZScpIHtcbiAgICAgICAgICAgIHNlbGYudmFsaWRhdGVJbnB1dCgkKGUudGFyZ2V0KSwgc2VsZi4kZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNlbGYudmFsaWRhdGVGb3JtKHNlbGYuJGVsZW1lbnQpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2tleWRvd24uZm5kdG4uYWJpZGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIGlmIChzZXR0aW5ncy5saXZlX3ZhbGlkYXRlID09PSB0cnVlICYmIGUud2hpY2ggIT0gOSkge1xuICAgICAgICAgIC8vICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZXIpO1xuICAgICAgICAgIC8vICAgc2VsZi50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICAgICBzZWxmLnZhbGlkYXRlKFt0aGlzXSwgZSk7XG4gICAgICAgICAgLy8gICB9LmJpbmQodGhpcyksIHNldHRpbmdzLnRpbWVvdXQpO1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgICAvLyBzZWxmLnZhbGlkYXRlRm9ybShzZWxmLiRlbGVtZW50KTtcbiAgICAgICAgfSk7XG5cbiAgfSxcbiAgLyoqXG4gICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIEFiaWRlIHVwb24gRE9NIGNoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQWJpZGUucHJvdG90eXBlLl9yZWZsb3cgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgYSBmb3JtIGVsZW1lbnQgaGFzIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUgYW5kIGlmIGl0J3MgY2hlY2tlZCBvciBub3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGNoZWNrIGZvciByZXF1aXJlZCBhdHRyaWJ1dGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBvciBlbXB0eVxuICAgKi9cbiAgQWJpZGUucHJvdG90eXBlLnJlcXVpcmVkQ2hlY2sgPSBmdW5jdGlvbigkZWwpIHtcbiAgICBzd2l0Y2ggKCRlbFswXS50eXBlKSB7XG4gICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgaWYgKCRlbC5hdHRyKCdyZXF1aXJlZCcpICYmICEkZWwudmFsKCkpIHtcbiAgICAgICAgICAvLyByZXF1aXJlbWVudCBjaGVjayBkb2VzIG5vdCBwYXNzXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICBpZiAoJGVsLmF0dHIoJ3JlcXVpcmVkJykgJiYgISRlbC5pcygnOmNoZWNrZWQnKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgaWYgKCRlbC5hdHRyKCdyZXF1aXJlZCcpICYmICEkZWwuaXMoJzpjaGVja2VkJykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoJGVsLmF0dHIoJ3JlcXVpcmVkJykgJiYgKCEkZWwudmFsKCkgfHwgISRlbC52YWwoKS5sZW5ndGggfHwgJGVsLmlzKCc6ZW1wdHknKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgYSBmb3JtIGVsZW1lbnQgaGFzIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUgYW5kIGlmIGl0J3MgY2hlY2tlZCBvciBub3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGNoZWNrIGZvciByZXF1aXJlZCBhdHRyaWJ1dGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBvciBlbXB0eVxuICAgKi9cbiAgQWJpZGUucHJvdG90eXBlLmZpbmRMYWJlbCA9IGZ1bmN0aW9uKCRlbCkge1xuICAgIGlmICgkZWwubmV4dCgnbGFiZWwnKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAkZWwubmV4dCgnbGFiZWwnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gJGVsLmNsb3Nlc3QoJ2xhYmVsJyk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQWRkcyB0aGUgQ1NTIGVycm9yIGNsYXNzIGFzIHNwZWNpZmllZCBieSB0aGUgQWJpZGUgc2V0dGluZ3MgdG8gdGhlIGxhYmVsLCBpbnB1dCwgYW5kIHRoZSBmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIGNsYXNzIHRvXG4gICAqL1xuICBBYmlkZS5wcm90b3R5cGUuYWRkRXJyb3JDbGFzc2VzID0gZnVuY3Rpb24oJGVsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAkbGFiZWwgPSBzZWxmLmZpbmRMYWJlbCgkZWwpLFxuICAgICAgICAkZm9ybUVycm9yID0gJGVsLm5leHQoc2VsZi5vcHRpb25zLmZvcm1FcnJvclNlbGVjdG9yKSB8fCAkZWwuZmluZChzZWxmLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpO1xuXG4gICAgLy8gbGFiZWxcbiAgICBpZiAoJGxhYmVsKSB7XG4gICAgICAkbGFiZWwuYWRkQ2xhc3Moc2VsZi5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XG4gICAgfVxuICAgIC8vIGZvcm0gZXJyb3JcbiAgICBpZiAoJGZvcm1FcnJvcikge1xuICAgICAgJGZvcm1FcnJvci5hZGRDbGFzcyhzZWxmLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpO1xuICAgIH1cbiAgICAvLyBpbnB1dFxuICAgICRlbC5hZGRDbGFzcyhzZWxmLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZXMgQ1NTIGVycm9yIGNsYXNzIGFzIHNwZWNpZmllZCBieSB0aGUgQWJpZGUgc2V0dGluZ3MgZnJvbSB0aGUgbGFiZWwsIGlucHV0LCBhbmQgdGhlIGZvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbVxuICAgKi9cbiAgQWJpZGUucHJvdG90eXBlLnJlbW92ZUVycm9yQ2xhc3NlcyA9IGZ1bmN0aW9uKCRlbCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgJGxhYmVsID0gc2VsZi5maW5kTGFiZWwoJGVsKSxcbiAgICAgICAgJGZvcm1FcnJvciA9ICRlbC5uZXh0KHNlbGYub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3RvcikgfHwgJGVsLmZpbmQoc2VsZi5vcHRpb25zLmZvcm1FcnJvclNlbGVjdG9yKTtcbiAgICAvLyBsYWJlbFxuICAgIGlmICgkbGFiZWwgJiYgJGxhYmVsLmhhc0NsYXNzKHNlbGYub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpKSB7XG4gICAgICAkbGFiZWwucmVtb3ZlQ2xhc3Moc2VsZi5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XG4gICAgfVxuICAgIC8vIGZvcm0gZXJyb3JcbiAgICBpZiAoJGZvcm1FcnJvciAmJiAkZm9ybUVycm9yLmhhc0NsYXNzKHNlbGYub3B0aW9ucy5mb3JtRXJyb3JDbGFzcykpIHtcbiAgICAgICRmb3JtRXJyb3IucmVtb3ZlQ2xhc3Moc2VsZi5vcHRpb25zLmZvcm1FcnJvckNsYXNzKTtcbiAgICB9XG4gICAgLy8gaW5wdXRcbiAgICBpZiAoJGVsLmhhc0NsYXNzKHNlbGYub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpKSB7XG4gICAgICAkZWwucmVtb3ZlQ2xhc3Moc2VsZi5vcHRpb25zLmlucHV0RXJyb3JDbGFzcyk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogR29lcyB0aHJvdWdoIGEgZm9ybSB0byBmaW5kIGlucHV0cyBhbmQgcHJvY2VlZHMgdG8gdmFsaWRhdGUgdGhlbSBpbiB3YXlzIHNwZWNpZmljIHRvIHRoZWlyIHR5cGVcbiAgICogQGZpcmVzIEFiaWRlI2ludmFsaWRcbiAgICogQGZpcmVzIEFiaWRlI3ZhbGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byB2YWxpZGF0ZSwgc2hvdWxkIGJlIGFuIEhUTUwgaW5wdXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGZvcm0gLSBqUXVlcnkgb2JqZWN0IG9mIHRoZSBlbnRpcmUgZm9ybSB0byBmaW5kIHRoZSB2YXJpb3VzIGlucHV0IGVsZW1lbnRzXG4gICAqL1xuICBBYmlkZS5wcm90b3R5cGUudmFsaWRhdGVJbnB1dCA9IGZ1bmN0aW9uKCRlbCwgJGZvcm0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHRleHRJbnB1dCA9ICRmb3JtLmZpbmQoJ2lucHV0W3R5cGU9XCJ0ZXh0XCJdJyksXG4gICAgICAgIGNoZWNrSW5wdXQgPSAkZm9ybS5maW5kKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKSxcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIHJhZGlvR3JvdXBOYW1lO1xuXG4gICAgaWYgKCRlbFswXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIGlmICghc2VsZi5yZXF1aXJlZENoZWNrKCRlbCkgfHwgIXNlbGYudmFsaWRhdGVUZXh0KCRlbCkpIHtcbiAgICAgICAgc2VsZi5hZGRFcnJvckNsYXNzZXMoJGVsKTtcbiAgICAgICAgJGVsLnRyaWdnZXIoJ2ludmFsaWQuZm5kdG4uYWJpZGUnLCAkZWxbMF0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYucmVtb3ZlRXJyb3JDbGFzc2VzKCRlbCk7XG4gICAgICAgICRlbC50cmlnZ2VyKCd2YWxpZC5mbmR0bi5hYmlkZScsICRlbFswXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCRlbFswXS50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICByYWRpb0dyb3VwTmFtZSA9ICRlbC5hdHRyKCduYW1lJyk7XG4gICAgICBsYWJlbCA9ICRlbC5zaWJsaW5ncygnbGFiZWwnKTtcblxuICAgICAgaWYgKHNlbGYudmFsaWRhdGVSYWRpbyhyYWRpb0dyb3VwTmFtZSkpIHtcbiAgICAgICAgJChsYWJlbCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoJCh0aGlzKS5oYXNDbGFzcyhzZWxmLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKSkge1xuICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcyhzZWxmLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAkZWwudHJpZ2dlcigndmFsaWQuZm5kdG4uYWJpZGUnLCAkZWxbMF0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICQobGFiZWwpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhzZWxmLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKTtcbiAgICAgICAgfSk7XG4gICAgICAgICRlbC50cmlnZ2VyKCdpbnZhbGlkLmZuZHRuLmFiaWRlJywgJGVsWzBdKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCRlbFswXS50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICBpZiAoIXNlbGYucmVxdWlyZWRDaGVjaygkZWwpKSB7XG4gICAgICAgIHNlbGYuYWRkRXJyb3JDbGFzc2VzKCRlbCk7XG4gICAgICAgICRlbC50cmlnZ2VyKCdpbnZhbGlkLmZuZHRuLmFiaWRlJywgJGVsWzBdKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmLnJlbW92ZUVycm9yQ2xhc3NlcygkZWwpO1xuICAgICAgICAkZWwudHJpZ2dlcigndmFsaWQuZm5kdG4uYWJpZGUnLCAkZWxbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICghc2VsZi5yZXF1aXJlZENoZWNrKCRlbCkgfHwgIXNlbGYudmFsaWRhdGVUZXh0KCRlbCkpIHtcbiAgICAgICAgc2VsZi5hZGRFcnJvckNsYXNzZXMoJGVsKTtcbiAgICAgICAgJGVsLnRyaWdnZXIoJ2ludmFsaWQuZm5kdG4uYWJpZGUnLCAkZWxbMF0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYucmVtb3ZlRXJyb3JDbGFzc2VzKCRlbCk7XG4gICAgICAgICRlbC50cmlnZ2VyKCd2YWxpZC5mbmR0bi5hYmlkZScsICRlbFswXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogR29lcyB0aHJvdWdoIGEgZm9ybSBhbmQgaWYgdGhlcmUgYXJlIGFueSBpbnZhbGlkIGlucHV0cywgaXQgd2lsbCBkaXNwbGF5IHRoZSBmb3JtIGVycm9yIGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHZhbGlkYXRlLCBzaG91bGQgYmUgYSBmb3JtIEhUTUwgZWxlbWVudFxuICAgKi9cbiAgQWJpZGUucHJvdG90eXBlLnZhbGlkYXRlRm9ybSA9IGZ1bmN0aW9uKCRmb3JtKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBpbnB1dHMgPSAkZm9ybS5maW5kKCdpbnB1dCcpLFxuICAgICAgICBpbnB1dENvdW50ID0gJGZvcm0uZmluZCgnaW5wdXQnKS5sZW5ndGgsXG4gICAgICAgIGNvdW50ZXIgPSAwO1xuXG4gICAgd2hpbGUgKGNvdW50ZXIgPCBpbnB1dENvdW50KSB7XG4gICAgICBzZWxmLnZhbGlkYXRlSW5wdXQoJChpbnB1dHNbY291bnRlcl0pLCAkZm9ybSk7XG4gICAgICBjb3VudGVyKys7XG4gICAgfVxuXG4gICAgLy8gd2hhdCBhcmUgYWxsIHRoZSB0aGluZ3MgdGhhdCBjYW4gZ28gd3Jvbmcgd2l0aCBhIGZvcm0/XG4gICAgaWYgKCRmb3JtLmZpbmQoJy5mb3JtLWVycm9yLmlzLXZpc2libGUnKS5sZW5ndGggfHwgJGZvcm0uZmluZCgnLmlzLWludmFsaWQtbGFiZWwnKS5sZW5ndGgpIHtcbiAgICAgICRmb3JtLmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICRmb3JtLmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIGEgbm90IGEgdGV4dCBpbnB1dCBpcyB2YWxpZCBiYXNlZCBvbiB0aGUgcGF0dGVybnMgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHZhbGlkYXRlLCBzaG91bGQgYmUgYSB0ZXh0IGlucHV0IEhUTUwgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCB2YWx1ZSBtYXRjaGVzIHRoZSBwYXR0ZXJuIHNwZWNpZmllZFxuICAgKi9cbiAgQWJpZGUucHJvdG90eXBlLnZhbGlkYXRlVGV4dCA9IGZ1bmN0aW9uKCRlbCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdmFsaWQgPSBmYWxzZSxcbiAgICAgICAgcGF0dGVybkxpYiA9IHRoaXMub3B0aW9ucy5wYXR0ZXJucyxcbiAgICAgICAgaW5wdXRUZXh0ID0gJCgkZWwpLnZhbCgpLFxuICAgICAgICAvLyBtYXliZSBoYXZlIGEgZGlmZmVyZW50IHdheSBvZiBwYXJzaW5nIHRoaXMgYmMgcGVvcGxlIG1pZ2h0IHVzZSB0eXBlXG4gICAgICAgIHBhdHRlcm4gPSAkKCRlbCkuYXR0cigncGF0dGVybicpO1xuXG4gICAgLy8gaWYgdGhlcmUncyBubyB2YWx1ZSwgdGhlbiByZXR1cm4gdHJ1ZVxuICAgIC8vIHNpbmNlIHJlcXVpcmVkIGNoZWNrIGhhcyBhbHJlYWR5IGJlZW4gZG9uZVxuICAgIGlmIChpbnB1dFRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoaW5wdXRUZXh0Lm1hdGNoKHBhdHRlcm5MaWJbcGF0dGVybl0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3IgYSBub3QgYSByYWRpbyBpbnB1dCBpcyB2YWxpZCBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBpdCBpcyByZXF1aXJlZCBhbmQgc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwIC0gQSBzdHJpbmcgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWUgb2YgYSByYWRpbyBidXR0b24gZ3JvdXBcbiAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdCBsZWFzdCBvbmUgcmFkaW8gaW5wdXQgaGFzIGJlZW4gc2VsZWN0ZWQgKGlmIGl0J3MgcmVxdWlyZWQpXG4gICAqL1xuICBBYmlkZS5wcm90b3R5cGUudmFsaWRhdGVSYWRpbyA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBsYWJlbHMgPSAkKCc6cmFkaW9bbmFtZT1cIicgKyBncm91cCArICdcIl0nKS5zaWJsaW5ncygnbGFiZWwnKSxcbiAgICAgICAgY291bnRlciA9IDA7XG4gICAgLy8gZ28gdGhyb3VnaCBlYWNoIHJhZGlvIGJ1dHRvblxuICAgICQoJzpyYWRpb1tuYW1lPVwiJyArIGdyb3VwICsgJ1wiXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAvLyBwdXQgdGhlbSB0aHJvdWdoIHRoZSByZXF1aXJlZCBjaGVja3BvaW50XG4gICAgICBpZiAoIXNlbGYucmVxdWlyZWRDaGVjaygkKHRoaXMpKSkge1xuICAgICAgICAvLyBpZiBhdCBsZWFzdCBvbmUgZG9lc24ndCBwYXNzLCBhZGQgYSB0YWxseSB0byB0aGUgY291bnRlclxuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9XG4gICAgICAvLyBpZiBhdCBsZWFzdCBvbmUgaXMgY2hlY2tlZFxuICAgICAgLy8gcmVzZXQgdGhlIGNvdW50ZXJcbiAgICAgIGlmICgkKHRoaXMpLmlzKCc6Y2hlY2tlZCcpKSB7XG4gICAgICAgIGNvdW50ZXIgPSAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGNvdW50ZXIgPiAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICBBYmlkZS5wcm90b3R5cGUubWF0Y2hWYWxpZGF0aW9uID0gZnVuY3Rpb24odmFsLCB2YWxpZGF0aW9uKSB7XG5cbiAgfTtcbiAgLyoqXG4gICAqIFJlc2V0cyBmb3JtIGlucHV0cyBhbmQgc3R5bGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAkZm9ybSAtIEEgalF1ZXJ5IG9iamVjdCB0aGF0IHNob3VsZCBiZSBhbiBIVE1MIGZvcm0gZWxlbWVudFxuICAgKi9cbiAgQWJpZGUucHJvdG90eXBlLnJlc2V0Rm9ybSA9IGZ1bmN0aW9uKCRmb3JtKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpbnZhbGlkQXR0ciA9ICdkYXRhLWludmFsaWQnO1xuICAgIC8vIHJlbW92ZSBkYXRhIGF0dHJpYnV0ZXNcbiAgICAkKCdbJyArIHNlbGYuaW52YWxpZEF0dHIgKyAnXScsICRmb3JtKS5yZW1vdmVBdHRyKGludmFsaWRBdHRyKTtcbiAgICAvLyByZW1vdmUgc3R5bGVzXG4gICAgJCgnLicgKyBzZWxmLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzLCAkZm9ybSkubm90KCdzbWFsbCcpLnJlbW92ZUNsYXNzKHNlbGYub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpO1xuICAgICQoJy4nICsgc2VsZi5vcHRpb25zLmlucHV0RXJyb3JDbGFzcywgJGZvcm0pLm5vdCgnc21hbGwnKS5yZW1vdmVDbGFzcyhzZWxmLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKTtcbiAgICAkKCcuZm9ybS1lcnJvci5pcy12aXNpYmxlJykucmVtb3ZlQ2xhc3MoJ2lzLXZpc2libGUnKTtcbiAgICAkZm9ybS5maW5kKCdbZGF0YS1hYmlkZS1lcnJvcl0nKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICQoJzppbnB1dCcsICRmb3JtKS5ub3QoJzpidXR0b24sIDpzdWJtaXQsIDpyZXNldCwgOmhpZGRlbiwgW2RhdGEtYWJpZGUtaWdub3JlXScpLnZhbCgnJykucmVtb3ZlQXR0cihpbnZhbGlkQXR0cik7XG4gIH07XG4gIEFiaWRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgICAvL1RPRE8gdGhpcy4uLlxuICB9O1xuXG4gIEZvdW5kYXRpb24ucGx1Z2luKEFiaWRlLCAnQWJpZGUnKTtcblxuICAvLyBFeHBvcnRzIGZvciBBTUQvQnJvd3NlcmlmeVxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJylcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFiaWRlO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICBkZWZpbmUoWydmb3VuZGF0aW9uJ10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFiaWRlO1xuICAgIH0pO1xuXG59KEZvdW5kYXRpb24sIGpRdWVyeSk7XG4iLCIvKipcbiAqIEFjY29yZGlvbiBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uYWNjb3JkaW9uXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICovXG4hZnVuY3Rpb24oJCwgRm91bmRhdGlvbikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gYWNjb3JkaW9uLlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIEFjY29yZGlvbiNpbml0XG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gQWNjb3JkaW9uKGVsZW1lbnQsIG9wdGlvbnMpe1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBY2NvcmRpb24uZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2luaXQoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gICAgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignQWNjb3JkaW9uJywge1xuICAgICAgJ0VOVEVSJzogJ3RvZ2dsZScsXG4gICAgICAnU1BBQ0UnOiAndG9nZ2xlJyxcbiAgICAgICdBUlJPV19ET1dOJzogJ25leHQnLFxuICAgICAgJ0FSUk9XX1VQJzogJ3ByZXZpb3VzJ1xuICAgIH0pO1xuICB9XG5cbiAgQWNjb3JkaW9uLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIEFtb3VudCBvZiB0aW1lIHRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgYW4gYWNjb3JkaW9uIHBhbmUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDI1MFxuICAgICAqL1xuICAgIHNsaWRlU3BlZWQ6IDI1MCxcbiAgICAvKipcbiAgICAgKiBBbGxvdyB0aGUgYWNjb3JkaW9uIHRvIGhhdmUgbXVsdGlwbGUgb3BlbiBwYW5lcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9cbiAgICBtdWx0aUV4cGFuZDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBjbG9zZSBhbGwgcGFuZXMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovXG4gICAgYWxsb3dBbGxDbG9zZWQ6IGZhbHNlXG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBhY2NvcmRpb24gYnkgYW5pbWF0aW5nIHRoZSBwcmVzZXQgYWN0aXZlIHBhbmUocykuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBY2NvcmRpb24ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKCdyb2xlJywgJ3RhYmxpc3QnKTtcbiAgICB0aGlzLiR0YWJzID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbignbGknKTtcbiAgICB0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24oaWR4LCBlbCl7XG5cbiAgICAgIHZhciAkZWwgPSAkKGVsKSxcbiAgICAgICAgICAkY29udGVudCA9ICRlbC5maW5kKCdbZGF0YS10YWItY29udGVudF0nKSxcbiAgICAgICAgICBpZCA9ICRjb250ZW50WzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ2FjY29yZGlvbicpLFxuICAgICAgICAgIGxpbmtJZCA9IGVsLmlkIHx8IGlkICsgJy1sYWJlbCc7XG5cbiAgICAgICRlbC5maW5kKCdhOmZpcnN0JykuYXR0cih7XG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogaWQsXG4gICAgICAgICdyb2xlJzogJ3RhYicsXG4gICAgICAgICdpZCc6IGxpbmtJZCxcbiAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcbiAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICAkY29udGVudC5hdHRyKHsncm9sZSc6ICd0YWJwYW5lbCcsICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWQsICdhcmlhLWhpZGRlbic6IHRydWUsICdpZCc6IGlkfSk7XG4gICAgfSk7XG4gICAgdmFyICRpbml0QWN0aXZlID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuICAgIGlmKCRpbml0QWN0aXZlLmxlbmd0aCl7XG4gICAgICB0aGlzLmRvd24oJGluaXRBY3RpdmUsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudHMoKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSBhY2NvcmRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBY2NvcmRpb24ucHJvdG90eXBlLl9ldmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy4kdGFicy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpO1xuICAgICAgdmFyICR0YWJDb250ZW50ID0gJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuICAgICAgaWYgKCR0YWJDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAkZWxlbS5jaGlsZHJlbignYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uIGtleWRvd24uemYuYWNjb3JkaW9uJylcbiAgICAgICAgICAgICAgIC5vbignY2xpY2suemYuYWNjb3JkaW9uJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIC8vICQodGhpcykuY2hpbGRyZW4oJ2EnKS5vbignY2xpY2suemYuYWNjb3JkaW9uJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoJGVsZW0uaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKSB7XG4gICAgICAgICAgICBpZihfdGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkIHx8ICRlbGVtLnNpYmxpbmdzKCkuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKXtcbiAgICAgICAgICAgICAgX3RoaXMudXAoJHRhYkNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmRvd24oJHRhYkNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkub24oJ2tleWRvd24uemYuYWNjb3JkaW9uJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgX3RoaXMsIHtcbiAgICAgICAgICAgIHRvZ2dsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkdGFiQ29udGVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICRlbGVtLm5leHQoKS5maW5kKCdhJykuZm9jdXMoKS50cmlnZ2VyKCdjbGljay56Zi5hY2NvcmRpb24nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICRlbGVtLnByZXYoKS5maW5kKCdhJykuZm9jdXMoKS50cmlnZ2VyKCdjbGljay56Zi5hY2NvcmRpb24nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHNlbGVjdGVkIGNvbnRlbnQgcGFuZSdzIG9wZW4vY2xvc2Ugc3RhdGUuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0galF1ZXJ5IG9iamVjdCBvZiB0aGUgcGFuZSB0byB0b2dnbGUuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgQWNjb3JkaW9uLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbigkdGFyZ2V0KXtcbiAgICBpZigkdGFyZ2V0LnBhcmVudCgpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSl7XG4gICAgICBpZih0aGlzLm9wdGlvbnMuYWxsb3dBbGxDbG9zZWQgfHwgJHRhcmdldC5wYXJlbnQoKS5zaWJsaW5ncygpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSl7XG4gICAgICAgIHRoaXMudXAoJHRhcmdldCk7XG4gICAgICB9ZWxzZXsgcmV0dXJuOyB9XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLmRvd24oJHRhcmdldCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogT3BlbnMgdGhlIGFjY29yZGlvbiB0YWIgZGVmaW5lZCBieSBgJHRhcmdldGAuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gQWNjb3JkaW9uIHBhbmUgdG8gb3Blbi5cbiAgICogQHBhcmFtIHtCb29sZWFufSBmaXJzdFRpbWUgLSBmbGFnIHRvIGRldGVybWluZSBpZiByZWZsb3cgc2hvdWxkIGhhcHBlbi5cbiAgICogQGZpcmVzIEFjY29yZGlvbiNkb3duXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgQWNjb3JkaW9uLnByb3RvdHlwZS5kb3duID0gZnVuY3Rpb24oJHRhcmdldCwgZmlyc3RUaW1lKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZighdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kICYmICFmaXJzdFRpbWUpe1xuICAgICAgdmFyICRjdXJyZW50QWN0aXZlID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuICAgICAgaWYoJGN1cnJlbnRBY3RpdmUubGVuZ3RoKXtcbiAgICAgICAgdGhpcy51cCgkY3VycmVudEFjdGl2ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgJHRhcmdldFxuICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpXG4gICAgICAucGFyZW50KCdbZGF0YS10YWItY29udGVudF0nKVxuICAgICAgLmFkZEJhY2soKVxuICAgICAgLnBhcmVudCgpLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcblxuICAgIEZvdW5kYXRpb24uTW92ZShfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsICR0YXJnZXQsIGZ1bmN0aW9uKCl7XG4gICAgICAkdGFyZ2V0LnNsaWRlRG93bihfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQpO1xuICAgIH0pO1xuXG4gICAgaWYoIWZpcnN0VGltZSl7XG4gICAgICBGb3VuZGF0aW9uLl9yZWZsb3codGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLWFjY29yZGlvbicpKTtcbiAgICB9XG4gICAgJCgnIycgKyAkdGFyZ2V0LmF0dHIoJ2FyaWEtbGFiZWxsZWRieScpKS5hdHRyKHtcbiAgICAgICdhcmlhLWV4cGFuZGVkJzogdHJ1ZSxcbiAgICAgICdhcmlhLXNlbGVjdGVkJzogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHRhYiBpcyBkb25lIG9wZW5pbmcuXG4gICAgICogQGV2ZW50IEFjY29yZGlvbiNkb3duXG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdkb3duLnpmLmFjY29yZGlvbicsIFskdGFyZ2V0XSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgdGFiIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiB0YWIgdG8gY2xvc2UuXG4gICAqIEBmaXJlcyBBY2NvcmRpb24jdXBcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBBY2NvcmRpb24ucHJvdG90eXBlLnVwID0gZnVuY3Rpb24oJHRhcmdldCkge1xuICAgIHZhciAkYXVudHMgPSAkdGFyZ2V0LnBhcmVudCgpLnNpYmxpbmdzKCksXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICB2YXIgY2FuQ2xvc2UgPSB0aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQgPyAkYXVudHMuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpIDogJHRhcmdldC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtYWN0aXZlJyk7XG5cbiAgICBpZighdGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkICYmICFjYW5DbG9zZSl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCAkdGFyZ2V0LCBmdW5jdGlvbigpe1xuICAgICAgJHRhcmdldC5zbGlkZVVwKF90aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCk7XG4gICAgfSk7XG5cbiAgICAkdGFyZ2V0LmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSlcbiAgICAgICAgICAgLnBhcmVudCgpLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTtcblxuICAgICQoJyMnICsgJHRhcmdldC5hdHRyKCdhcmlhLWxhYmVsbGVkYnknKSkuYXR0cih7XG4gICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXG4gICAgICdhcmlhLXNlbGVjdGVkJzogZmFsc2VcbiAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdGFiIGlzIGRvbmUgY29sbGFwc2luZyB1cC5cbiAgICAgKiBAZXZlbnQgQWNjb3JkaW9uI3VwXG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd1cC56Zi5hY2NvcmRpb24nLCBbJHRhcmdldF0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBhbiBhY2NvcmRpb24uXG4gICAqIEBmaXJlcyBBY2NvcmRpb24jZGVzdHJveWVkXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgQWNjb3JkaW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS10YWItY29udGVudF0nKS5zbGlkZVVwKDApLmNzcygnZGlzcGxheScsICcnKTtcbiAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ2EnKS5vZmYoJy56Zi5hY2NvcmRpb24nKTtcblxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfTtcblxuICBGb3VuZGF0aW9uLnBsdWdpbihBY2NvcmRpb24sICdBY2NvcmRpb24nKTtcbn0oalF1ZXJ5LCB3aW5kb3cuRm91bmRhdGlvbik7XG4iLCIvKipcbiAqIEFjY29yZGlvbk1lbnUgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmFjY29yZGlvbk1lbnVcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcbiAqL1xuIWZ1bmN0aW9uKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIGFjY29yZGlvbiBtZW51LlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjaW5pdFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbiBtZW51LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBmdW5jdGlvbiBBY2NvcmRpb25NZW51KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQWNjb3JkaW9uTWVudS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCwgJ2FjY29yZGlvbicpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdBY2NvcmRpb25NZW51Jywge1xuICAgICAgJ0VOVEVSJzogJ3RvZ2dsZScsXG4gICAgICAnU1BBQ0UnOiAndG9nZ2xlJyxcbiAgICAgICdBUlJPV19SSUdIVCc6ICdvcGVuJyxcbiAgICAgICdBUlJPV19VUCc6ICd1cCcsXG4gICAgICAnQVJST1dfRE9XTic6ICdkb3duJyxcbiAgICAgICdBUlJPV19MRUZUJzogJ2Nsb3NlJyxcbiAgICAgICdFU0NBUEUnOiAnY2xvc2VBbGwnLFxuICAgICAgJ1RBQic6ICdkb3duJyxcbiAgICAgICdTSElGVF9UQUInOiAndXAnXG4gICAgfSk7XG4gIH1cblxuICBBY2NvcmRpb25NZW51LmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIEFtb3VudCBvZiB0aW1lIHRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgYSBzdWJtZW51IGluIG1zLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAyNTBcbiAgICAgKi9cbiAgICBzbGlkZVNwZWVkOiAyNTAsXG4gICAgLyoqXG4gICAgICogQWxsb3cgdGhlIG1lbnUgdG8gaGF2ZSBtdWx0aXBsZSBvcGVuIHBhbmVzLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSB0cnVlXG4gICAgICovXG4gICAgbXVsdGlPcGVuOiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBhY2NvcmRpb24gbWVudSBieSBoaWRpbmcgYWxsIG5lc3RlZCBtZW51cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFjY29yZGlvbk1lbnUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zdWJtZW51XScpLm5vdCgnLmlzLWFjdGl2ZScpLnNsaWRlVXAoMCk7Ly8uZmluZCgnYScpLmNzcygncGFkZGluZy1sZWZ0JywgJzFyZW0nKTtcbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgJ3JvbGUnOiAndGFibGlzdCcsXG4gICAgICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiB0aGlzLm9wdGlvbnMubXVsdGlPcGVuXG4gICAgfSk7XG5cbiAgICB0aGlzLiRtZW51TGlua3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5oYXMtc3VibWVudScpO1xuICAgIHRoaXMuJG1lbnVMaW5rcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgbGlua0lkID0gdGhpcy5pZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdhY2MtbWVudS1saW5rJyksXG4gICAgICAgICAgJGVsZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICRzdWIgPSAkZWxlbS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKSxcbiAgICAgICAgICBzdWJJZCA9ICRzdWJbMF0uaWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAnYWNjLW1lbnUnKSxcbiAgICAgICAgICBpc0FjdGl2ZSA9ICRzdWIuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgICAgJGVsZW0uYXR0cih7XG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogc3ViSWQsXG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogaXNBY3RpdmUsXG4gICAgICAgICdhcmlhLXNlbGVjdGVkJzogZmFsc2UsXG4gICAgICAgICdyb2xlJzogJ3RhYicsXG4gICAgICAgICdpZCc6IGxpbmtJZFxuICAgICAgfSk7XG4gICAgICAkc3ViLmF0dHIoe1xuICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogbGlua0lkLFxuICAgICAgICAnYXJpYS1oaWRkZW4nOiAhaXNBY3RpdmUsXG4gICAgICAgICdyb2xlJzogJ3RhYnBhbmVsJyxcbiAgICAgICAgJ2lkJzogc3ViSWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBpbml0UGFuZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY3RpdmUnKTtcbiAgICBpZihpbml0UGFuZXMubGVuZ3RoKXtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpbml0UGFuZXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICBfdGhpcy5kb3duKCQodGhpcykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50cygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIG1lbnUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBY2NvcmRpb25NZW51LnByb3RvdHlwZS5fZXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnbGknKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyICRzdWJtZW51ID0gJCh0aGlzKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKTtcblxuICAgICAgaWYgKCRzdWJtZW51Lmxlbmd0aCkge1xuICAgICAgICAkKHRoaXMpLmNoaWxkcmVuKCdhJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb25tZW51Jykub24oJ2NsaWNrLnpmLmFjY29yZGlvbm1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMudG9nZ2xlKCRzdWJtZW51KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkub24oJ2tleWRvd24uemYuYWNjb3JkaW9ubWVudScsIGZ1bmN0aW9uKGUpe1xuICAgICAgdmFyICRlbGVtZW50ID0gJCh0aGlzKSxcbiAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJyksXG4gICAgICAgICAgJHByZXZFbGVtZW50LFxuICAgICAgICAgICRuZXh0RWxlbWVudCxcbiAgICAgICAgICAkdGFyZ2V0ID0gJGVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyk7XG5cbiAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgaWYgKCQodGhpcykuaXMoJGVsZW1lbnQpKSB7XG4gICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWF4KDAsIGktMSkpO1xuICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1pbihpKzEsICRlbGVtZW50cy5sZW5ndGgtMSkpO1xuXG4gICAgICAgICAgaWYgKCQodGhpcykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpIHsgLy8gaGFzIG9wZW4gc3ViIG1lbnVcbiAgICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50LmZpbmQoJ2xpOmZpcnN0LWNoaWxkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkKHRoaXMpLmlzKCc6Zmlyc3QtY2hpbGQnKSkgeyAvLyBpcyBmaXJzdCBlbGVtZW50IG9mIHN1YiBtZW51XG4gICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICgkcHJldkVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpIHsgLy8gaWYgcHJldmlvdXMgZWxlbWVudCBoYXMgb3BlbiBzdWIgbWVudVxuICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJHByZXZFbGVtZW50LmZpbmQoJ2xpOmxhc3QtY2hpbGQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCQodGhpcykuaXMoJzpsYXN0LWNoaWxkJykpIHsgLy8gaXMgbGFzdCBlbGVtZW50IG9mIHN1YiBtZW51XG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkubmV4dCgnbGknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgX3RoaXMsIHtcbiAgICAgICAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICAgICAgX3RoaXMuZG93bigkdGFyZ2V0KTtcbiAgICAgICAgICAgICR0YXJnZXQuZmluZCgnbGknKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCR0YXJnZXQubGVuZ3RoICYmICEkdGFyZ2V0LmlzKCc6aGlkZGVuJykpIHsgLy8gY2xvc2UgYWN0aXZlIHN1YiBvZiB0aGlzIGl0ZW1cbiAgICAgICAgICAgIF90aGlzLnVwKCR0YXJnZXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCkgeyAvLyBjbG9zZSBjdXJyZW50bHkgb3BlbiBzdWJcbiAgICAgICAgICAgIF90aGlzLnVwKCRlbGVtZW50LnBhcmVudCgnW2RhdGEtc3VibWVudV0nKSk7XG4gICAgICAgICAgICAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkcHJldkVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJG5leHRFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCRlbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCkge1xuICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCRlbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5oaWRlQWxsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTsvLy5hdHRyKCd0YWJpbmRleCcsIDApO1xuICB9O1xuICAvKipcbiAgICogQ2xvc2VzIGFsbCBwYW5lcyBvZiB0aGUgbWVudS5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBBY2NvcmRpb25NZW51LnByb3RvdHlwZS5oaWRlQWxsID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykuc2xpZGVVcCh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCk7XG4gIH07XG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBvcGVuL2Nsb3NlIHN0YXRlIG9mIGEgc3VibWVudS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gdGhlIHN1Ym1lbnUgdG8gdG9nZ2xlXG4gICAqL1xuICBBY2NvcmRpb25NZW51LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbigkdGFyZ2V0KXtcbiAgICBpZiAoISR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgdGhpcy51cCgkdGFyZ2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmRvd24oJHRhcmdldCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogT3BlbnMgdGhlIHN1Yi1tZW51IGRlZmluZWQgYnkgYCR0YXJnZXRgLlxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFN1Yi1tZW51IHRvIG9wZW4uXG4gICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I2Rvd25cbiAgICovXG4gIEFjY29yZGlvbk1lbnUucHJvdG90eXBlLmRvd24gPSBmdW5jdGlvbigkdGFyZ2V0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBjb25zb2xlLmxvZygkdGFyZ2V0KTtcbiAgICBpZighdGhpcy5vcHRpb25zLm11bHRpT3Blbil7XG4gICAgICB0aGlzLnVwKHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjdGl2ZScpLm5vdCgkdGFyZ2V0LnBhcmVudHNVbnRpbCh0aGlzLiRlbGVtZW50KSkpO1xuICAgIH1cblxuICAgICR0YXJnZXQuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLmF0dHIoeydhcmlhLWhpZGRlbic6IGZhbHNlfSlcbiAgICAgIC5wYXJlbnQoJy5oYXMtc3VibWVudScpLmF0dHIoeydhcmlhLWV4cGFuZGVkJzogdHJ1ZSwgJ2FyaWEtc2VsZWN0ZWQnOiB0cnVlfSk7XG5cbiAgICAgIEZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgJHRhcmdldCwgZnVuY3Rpb24oKXtcbiAgICAgICAgJHRhcmdldC5zbGlkZURvd24oX3RoaXMub3B0aW9ucy5zbGlkZVNwZWVkKTtcbiAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgZG9uZSBjb2xsYXBzaW5nIHVwLlxuICAgICAqIEBldmVudCBBY2NvcmRpb25NZW51I2Rvd25cbiAgICAgKi9cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Rvd24uemYuYWNjb3JkaW9uTWVudScsIFskdGFyZ2V0XSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgc3ViLW1lbnUgZGVmaW5lZCBieSBgJHRhcmdldGAuIEFsbCBzdWItbWVudXMgaW5zaWRlIHRoZSB0YXJnZXQgd2lsbCBiZSBjbG9zZWQgYXMgd2VsbC5cbiAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBTdWItbWVudSB0byBjbG9zZS5cbiAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjdXBcbiAgICovXG4gIEFjY29yZGlvbk1lbnUucHJvdG90eXBlLnVwID0gZnVuY3Rpb24oJHRhcmdldCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCAkdGFyZ2V0LCBmdW5jdGlvbigpe1xuICAgICAgJHRhcmdldC5zbGlkZVVwKF90aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCk7XG4gICAgfSk7XG4gICAgJHRhcmdldC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpXG4gICAgICAgICAgIC5maW5kKCdbZGF0YS1zdWJtZW51XScpLnNsaWRlVXAoMCkuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKS5lbmQoKVxuICAgICAgICAgICAucGFyZW50KCcuaGFzLXN1Ym1lbnUnKVxuICAgICAgICAgICAuYXR0cih7J2FyaWEtZXhwYW5kZWQnOiBmYWxzZSwgJ2FyaWEtc2VsZWN0ZWQnOiBmYWxzZX0pO1xuICAgIC8vICR0YXJnZXQuc2xpZGVVcCh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24oKSB7XG4gICAgLy8gICAkdGFyZ2V0LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykuc2xpZGVVcCgwKS5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgIC8vIH0pLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSkucGFyZW50KCcuaGFzLXN1Ym1lbnUnKS5hdHRyKHsnYXJpYS1leHBhbmRlZCc6IGZhbHNlLCAnYXJpYS1zZWxlY3RlZCc6IGZhbHNlfSk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBtZW51IGlzIGRvbmUgY29sbGFwc2luZyB1cC5cbiAgICAgKiBAZXZlbnQgQWNjb3JkaW9uTWVudSN1cFxuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigndXAuemYuYWNjb3JkaW9uTWVudScsIFskdGFyZ2V0XSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGFjY29yZGlvbiBtZW51LlxuICAgKiBAZmlyZXMgQWNjb3JkaW9uTWVudSNkZXN0cm95ZWRcbiAgICovXG4gIEFjY29yZGlvbk1lbnUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc3VibWVudV0nKS5zbGlkZURvd24oMCkuY3NzKCdkaXNwbGF5JywgJycpO1xuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uTWVudScpO1xuXG4gICAgRm91bmRhdGlvbi5OZXN0LkJ1cm4odGhpcy4kZWxlbWVudCwgJ2FjY29yZGlvbicpO1xuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfTtcblxuICBGb3VuZGF0aW9uLnBsdWdpbihBY2NvcmRpb25NZW51LCAnQWNjb3JkaW9uTWVudScpO1xufShqUXVlcnksIHdpbmRvdy5Gb3VuZGF0aW9uKTtcbiIsIi8qKlxuICogRHJpbGxkb3duIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5kcmlsbGRvd25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcbiAqL1xuIWZ1bmN0aW9uKCQsIEZvdW5kYXRpb24pe1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcmlsbGRvd24gbWVudS5cbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGZ1bmN0aW9uIERyaWxsZG93bihlbGVtZW50LCBvcHRpb25zKXtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRHJpbGxkb3duLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICBGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ0RyaWxsZG93bicsIHtcbiAgICAgICdFTlRFUic6ICdvcGVuJyxcbiAgICAgICdTUEFDRSc6ICdvcGVuJyxcbiAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcbiAgICAgICdBUlJPV19VUCc6ICd1cCcsXG4gICAgICAnQVJST1dfRE9XTic6ICdkb3duJyxcbiAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJyxcbiAgICAgICdFU0NBUEUnOiAnY2xvc2UnLFxuICAgICAgJ1RBQic6ICdkb3duJyxcbiAgICAgICdTSElGVF9UQUInOiAndXAnXG4gICAgfSk7XG4gIH1cbiAgRHJpbGxkb3duLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIE1hcmt1cCB1c2VkIGZvciBKUyBnZW5lcmF0ZWQgYmFjayBidXR0b24uIFByZXBlbmRlZCB0byBzdWJtZW51IGxpc3RzIGFuZCBkZWxldGVkIG9uIGBkZXN0cm95YCBtZXRob2QuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICc8bGk+PGE+QmFjazwvYT48L2xpPidcbiAgICAgKi9cbiAgICBiYWNrQnV0dG9uOiAnPGxpIGNsYXNzPVwianMtZHJpbGxkb3duLWJhY2tcIiB0YWJpbmRleD1cIjBcIj48YT5CYWNrPC9hPjwvbGk+JyxcbiAgICAvKipcbiAgICAgKiBNYXJrdXAgdXNlZCB0byB3cmFwIGRyaWxsZG93biBtZW51LiBVc2UgYSBjbGFzcyBuYW1lIGZvciBpbmRlcGVuZGVudCBzdHlsaW5nLCBvciB0aGUgSlMgYXBwbGllZCBjbGFzczogYGlzLWRyaWxsZG93bmAuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICc8ZGl2PjwvZGl2PidcbiAgICAgKi9cbiAgICB3cmFwcGVyOiAnPGRpdj48L2Rpdj4nLFxuICAgIC8qKlxuICAgICAqIEFsbG93IHRoZSBtZW51IHRvIHJldHVybiB0byByb290IGxpc3Qgb24gYm9keSBjbGljay5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9cbiAgICBjbG9zZU9uQ2xpY2s6IGZhbHNlLFxuICAgIC8vIGhvbGRPcGVuOiBmYWxzZVxuICB9O1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGRyaWxsZG93biBieSBjcmVhdGluZyBqUXVlcnkgY29sbGVjdGlvbnMgb2YgZWxlbWVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyaWxsZG93bi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuJHN1Ym1lbnVBbmNob3JzID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaS5oYXMtc3VibWVudScpO1xuICAgIHRoaXMuJHN1Ym1lbnVzID0gdGhpcy4kc3VibWVudUFuY2hvcnMuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykuYWRkQ2xhc3MoJ2lzLWRyaWxsZG93bi1zdWInKS8qLndyYXAoJCh0aGlzLm9wdGlvbnMud3JhcHBlcikuYWRkQ2xhc3MoJ2lzLWRyaWxsZG93bi1zdWInKSkqLztcbiAgICAvLyB0aGlzLiRyb290RWxlbXMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpLyouYWRkQ2xhc3MoJ2ZpcnN0LXN1YicpKi87XG4gICAgdGhpcy4kbWVudUl0ZW1zID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaScpLm5vdCgnLmpzLWRyaWxsZG93bi1iYWNrJykuYXR0cigncm9sZScsICdtZW51aXRlbScpO1xuICAgIC8vIHRoaXMuJHN1Ym1lbnVzO1xuXG5cbiAgICB0aGlzLl9wcmVwYXJlTWVudSgpO1xuICAgIC8vIHRoaXMuX2dldE1heERpbXMoKTtcbiAgICB0aGlzLl9rZXlib2FyZEV2ZW50cygpO1xuICB9O1xuICAvKipcbiAgICogcHJlcGFyZXMgZHJpbGxkb3duIG1lbnUgYnkgc2V0dGluZyBhdHRyaWJ1dGVzIHRvIGxpbmtzIGFuZCBlbGVtZW50c1xuICAgKiBzZXRzIGEgbWluIGhlaWdodCB0byBwcmV2ZW50IGNvbnRlbnQganVtcGluZ1xuICAgKiB3cmFwcyB0aGUgZWxlbWVudCBpZiBub3QgYWxyZWFkeSB3cmFwcGVkXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgRHJpbGxkb3duLnByb3RvdHlwZS5fcHJlcGFyZU1lbnUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gaWYoIXRoaXMub3B0aW9ucy5ob2xkT3Blbil7XG4gICAgLy8gICB0aGlzLl9tZW51TGlua0V2ZW50cygpO1xuICAgIC8vIH1cbiAgICB0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgJHN1YiA9ICQodGhpcyk7XG4gICAgICAkc3ViLmZpbmQoJ2EnKVswXS5yZW1vdmVBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICRzdWIuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJylcbiAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgICAgICAgJ3RhYmluZGV4JzogMCxcbiAgICAgICAgICAgICdyb2xlJzogJ21lbnUnXG4gICAgICAgICAgfSk7XG4gICAgICBfdGhpcy5fZXZlbnRzKCRzdWIpO1xuICAgIH0pO1xuICAgIHRoaXMuJHN1Ym1lbnVzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIHZhciAkbWVudSA9ICQodGhpcyksXG4gICAgICAgICAgJGJhY2sgPSAkbWVudS5maW5kKCcuanMtZHJpbGxkb3duLWJhY2snKTtcbiAgICAgIGlmKCEkYmFjay5sZW5ndGgpe1xuICAgICAgICAkbWVudS5wcmVwZW5kKF90aGlzLm9wdGlvbnMuYmFja0J1dHRvbik7XG4gICAgICAgIF90aGlzLl9iYWNrKCRtZW51KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZighdGhpcy4kZWxlbWVudC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtZHJpbGxkb3duJykpe1xuICAgICAgdGhpcy4kd3JhcHBlciA9ICQodGhpcy5vcHRpb25zLndyYXBwZXIpLmFkZENsYXNzKCdpcy1kcmlsbGRvd24nKS5jc3ModGhpcy5fZ2V0TWF4RGltcygpKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQud3JhcCh0aGlzLiR3cmFwcGVyKTtcbiAgICB9XG5cbiAgfTtcbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gZWxlbWVudHMgaW4gdGhlIG1lbnUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBtZW51IGl0ZW0gdG8gYWRkIGhhbmRsZXJzIHRvLlxuICAgKi9cbiAgRHJpbGxkb3duLnByb3RvdHlwZS5fZXZlbnRzID0gZnVuY3Rpb24oJGVsZW0pe1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAkZWxlbS5vZmYoJ2NsaWNrLnpmLmRyaWxsZG93bicpXG4gICAgLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbihlKXtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmKGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBfdGhpcy5fc2hvdygkZWxlbSk7XG5cbiAgICAgIGlmKF90aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKXtcbiAgICAgICAgdmFyICRib2R5ID0gJCgnYm9keScpLm5vdChfdGhpcy4kd3JhcHBlcik7XG4gICAgICAgICRib2R5Lm9mZignLnpmLmRyaWxsZG93bicpLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgX3RoaXMuX2hpZGVBbGwoKTtcbiAgICAgICAgICAkYm9keS5vZmYoJy56Zi5kcmlsbGRvd24nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBBZGRzIGtleWRvd24gZXZlbnQgbGlzdGVuZXIgdG8gYGxpYCdzIGluIHRoZSBtZW51LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJpbGxkb3duLnByb3RvdHlwZS5fa2V5Ym9hcmRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuJG1lbnVJdGVtcy5hZGQodGhpcy4kZWxlbWVudC5maW5kKCcuanMtZHJpbGxkb3duLWJhY2snKSkub24oJ2tleWRvd24uemYuZHJpbGxkb3duJywgZnVuY3Rpb24oZSl7XG4gICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMpLFxuICAgICAgICAgICRlbGVtZW50cyA9ICRlbGVtZW50LnBhcmVudCgndWwnKS5jaGlsZHJlbignbGknKSxcbiAgICAgICAgICAkcHJldkVsZW1lbnQsXG4gICAgICAgICAgJG5leHRFbGVtZW50O1xuXG4gICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIGlmICgkKHRoaXMpLmlzKCRlbGVtZW50KSkge1xuICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1heCgwLCBpLTEpKTtcbiAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5taW4oaSsxLCAkZWxlbWVudHMubGVuZ3RoLTEpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgX3RoaXMsIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCRlbGVtZW50LmlzKF90aGlzLiRzdWJtZW51QW5jaG9ycykpIHtcbiAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtZW50KTtcbiAgICAgICAgICAgICRlbGVtZW50Lm9uKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCgkZWxlbWVudCksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICRlbGVtZW50LmZpbmQoJ3VsIGxpJykuZmlsdGVyKF90aGlzLiRtZW51SXRlbXMpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgndWwnKSk7XG4gICAgICAgICAgJGVsZW1lbnQucGFyZW50KCd1bCcpLm9uKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCgkZWxlbWVudCksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpLmZvY3VzKCk7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRwcmV2RWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9LFxuICAgICAgICBkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkbmV4dEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLl9iYWNrKCk7XG4gICAgICAgICAgLy9fdGhpcy4kbWVudUl0ZW1zLmZpcnN0KCkuZm9jdXMoKTsgLy8gZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxuICAgICAgICB9LFxuICAgICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoISRlbGVtZW50LmlzKF90aGlzLiRtZW51SXRlbXMpKSB7IC8vIG5vdCBtZW51IGl0ZW0gbWVhbnMgYmFjayBidXR0b25cbiAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgndWwnKSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7JGVsZW1lbnQucGFyZW50KCd1bCcpLnBhcmVudCgnbGknKS5mb2N1cygpO30sIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJGVsZW1lbnQuaXMoX3RoaXMuJHN1Ym1lbnVBbmNob3JzKSkge1xuICAgICAgICAgICAgX3RoaXMuX3Nob3coJGVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpeyRlbGVtZW50LmZpbmQoJ3VsIGxpJykuZmlsdGVyKF90aGlzLiRtZW51SXRlbXMpLmZpcnN0KCkuZm9jdXMoKTt9LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTsgLy8gZW5kIGtleWJvYXJkQWNjZXNzXG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlcyBhbGwgb3BlbiBlbGVtZW50cywgYW5kIHJldHVybnMgdG8gcm9vdCBtZW51LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIERyaWxsZG93biNjbG9zZWRcbiAgICovXG4gIERyaWxsZG93bi5wcm90b3R5cGUuX2hpZGVBbGwgPSBmdW5jdGlvbigpe1xuICAgIHZhciAkZWxlbSA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWRyaWxsZG93bi1zdWIuaXMtYWN0aXZlJykuYWRkQ2xhc3MoJ2lzLWNsb3NpbmcnKTtcbiAgICAkZWxlbS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKCRlbGVtKSwgZnVuY3Rpb24oZSl7XG4gICAgICAkZWxlbS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWNsb3NpbmcnKTtcbiAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgZnVsbHkgY2xvc2VkLlxuICAgICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI2Nsb3NlZFxuICAgICAgICAgKi9cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlZC56Zi5kcmlsbGRvd24nKTtcbiAgfTtcbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgbGlzdGVuZXIgZm9yIGVhY2ggYGJhY2tgIGJ1dHRvbiwgYW5kIGNsb3NlcyBvcGVuIG1lbnVzLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIERyaWxsZG93biNiYWNrXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IHN1Yi1tZW51IHRvIGFkZCBgYmFja2AgZXZlbnQuXG4gICAqL1xuICBEcmlsbGRvd24ucHJvdG90eXBlLl9iYWNrID0gZnVuY3Rpb24oJGVsZW0pe1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgJGVsZW0ub2ZmKCdjbGljay56Zi5kcmlsbGRvd24nKTtcbiAgICAkZWxlbS5jaGlsZHJlbignLmpzLWRyaWxsZG93bi1iYWNrJylcbiAgICAgIC5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdtb3VzZXVwIG9uIGJhY2snKTtcbiAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW0pO1xuICAgICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVyIHRvIG1lbnUgaXRlbXMgdy9vIHN1Ym1lbnVzIHRvIGNsb3NlIG9wZW4gbWVudXMgb24gY2xpY2suXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJpbGxkb3duLnByb3RvdHlwZS5fbWVudUxpbmtFdmVudHMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy4kbWVudUl0ZW1zLm5vdCgnLmhhcy1zdWJtZW51JylcbiAgICAgICAgLm9mZignY2xpY2suemYuZHJpbGxkb3duJylcbiAgICAgICAgLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAvLyBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIF90aGlzLl9oaWRlQWxsKCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIE9wZW5zIGEgc3VibWVudS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBEcmlsbGRvd24jb3BlblxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBlbGVtZW50IHdpdGggYSBzdWJtZW51IHRvIG9wZW4uXG4gICAqL1xuICBEcmlsbGRvd24ucHJvdG90eXBlLl9zaG93ID0gZnVuY3Rpb24oJGVsZW0pe1xuICAgICRlbGVtLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb3Blbi56Zi5kcmlsbGRvd24nLCBbJGVsZW1dKTtcbiAgfTtcbiAgLyoqXG4gICAqIEhpZGVzIGEgc3VibWVudVxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIERyaWxsZG93biNoaWRlXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IHN1Yi1tZW51IHRvIGhpZGUuXG4gICAqL1xuICBEcmlsbGRvd24ucHJvdG90eXBlLl9oaWRlID0gZnVuY3Rpb24oJGVsZW0pe1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgJGVsZW0uYWRkQ2xhc3MoJ2lzLWNsb3NpbmcnKVxuICAgICAgICAgLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoJGVsZW0pLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAkZWxlbS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWNsb3NpbmcnKTtcbiAgICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHN1Ym1lbnUgaXMgaGFzIGNsb3NlZC5cbiAgICAgKiBAZXZlbnQgRHJpbGxkb3duI2hpZGVcbiAgICAgKi9cbiAgICAkZWxlbS50cmlnZ2VyKCdoaWRlLnpmLmRyaWxsZG93bicsIFskZWxlbV0pO1xuXG4gIH07XG4gIC8qKlxuICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBuZXN0ZWQgbWVudXMgdG8gY2FsY3VsYXRlIHRoZSBtaW4taGVpZ2h0LCBhbmQgbWF4LXdpZHRoIGZvciB0aGUgbWVudS5cbiAgICogUHJldmVudHMgY29udGVudCBqdW1waW5nLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyaWxsZG93bi5wcm90b3R5cGUuX2dldE1heERpbXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBtYXggPSAwLCByZXN1bHQgPSB7fTtcbiAgICB0aGlzLiRzdWJtZW51cy5hZGQodGhpcy4kZWxlbWVudCkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyIG51bU9mRWxlbXMgPSAkKHRoaXMpLmNoaWxkcmVuKCdsaScpLmxlbmd0aDtcbiAgICAgIG1heCA9IG51bU9mRWxlbXMgPiBtYXggPyBudW1PZkVsZW1zIDogbWF4O1xuICAgIH0pO1xuXG4gICAgcmVzdWx0LmhlaWdodCA9IG1heCAqIHRoaXMuJG1lbnVJdGVtc1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKyAncHgnO1xuICAgIHJlc3VsdC53aWR0aCA9IHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKyAncHgnO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBEcmlsbGRvd24gTWVudVxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIERyaWxsZG93bi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5faGlkZUFsbCgpO1xuICAgIEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsICdkcmlsbGRvd24nKTtcbiAgICB0aGlzLiRlbGVtZW50LnVud3JhcCgpXG4gICAgICAgICAgICAgICAgIC5maW5kKCcuanMtZHJpbGxkb3duLWJhY2snKS5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAuZW5kKCkuZmluZCgnLmlzLWFjdGl2ZSwgLmlzLWNsb3NpbmcsIC5pcy1kcmlsbGRvd24tc3ViJykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1jbG9zaW5nIGlzLWRyaWxsZG93bi1zdWInKVxuICAgICAgICAgICAgICAgICAuZW5kKCkuZmluZCgnW2RhdGEtc3VibWVudV0nKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiB0YWJpbmRleCByb2xlJylcbiAgICAgICAgICAgICAgICAgLm9mZignLnpmLmRyaWxsZG93bicpLmVuZCgpLm9mZignemYuZHJpbGxkb3duJyk7XG5cbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH07XG4gIEZvdW5kYXRpb24ucGx1Z2luKERyaWxsZG93biwgJ0RyaWxsZG93bicpO1xufShqUXVlcnksIHdpbmRvdy5Gb3VuZGF0aW9uKTtcbiIsIi8qKlxuICogRHJvcGRvd24gbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmRyb3Bkb3duXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmJveFxuICovXG4hZnVuY3Rpb24oJCwgRm91bmRhdGlvbil7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcm9wZG93bi5cbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGZ1bmN0aW9uIERyb3Bkb3duKGVsZW1lbnQsIG9wdGlvbnMpe1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBEcm9wZG93bi5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgIHRoaXMuX2luaXQoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gICAgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignRHJvcGRvd24nLCB7XG4gICAgICAnRU5URVInOiAnb3BlbicsXG4gICAgICAnU1BBQ0UnOiAnb3BlbicsXG4gICAgICAnRVNDQVBFJzogJ2Nsb3NlJyxcbiAgICAgICdUQUInOiAndGFiX2ZvcndhcmQnLFxuICAgICAgJ1NISUZUX1RBQic6ICd0YWJfYmFja3dhcmQnXG4gICAgfSk7XG4gIH1cblxuICBEcm9wZG93bi5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSBvcGVuaW5nIGEgc3VibWVudSBvbiBob3ZlciBldmVudC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMjUwXG4gICAgICovXG4gICAgaG92ZXJEZWxheTogMjUwLFxuICAgIC8qKlxuICAgICAqIEFsbG93IHN1Ym1lbnVzIHRvIG9wZW4gb24gaG92ZXIgZXZlbnRzXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovXG4gICAgaG92ZXI6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBwaXhlbHMgYmV0d2VlbiB0aGUgZHJvcGRvd24gcGFuZSBhbmQgdGhlIHRyaWdnZXJpbmcgZWxlbWVudCBvbiBvcGVuLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxXG4gICAgICovXG4gICAgdk9mZnNldDogMSxcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gdGhlIGRyb3Bkb3duIHBhbmUgYW5kIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQgb24gb3Blbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMVxuICAgICAqL1xuICAgIGhPZmZzZXQ6IDEsXG4gICAgLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byBhZGp1c3Qgb3BlbiBwb3NpdGlvbi4gSlMgd2lsbCB0ZXN0IGFuZCBmaWxsIHRoaXMgaW4uXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICd0b3AnXG4gICAgICovXG4gICAgcG9zaXRpb25DbGFzczogJycsXG4gICAgLyoqXG4gICAgICogQWxsb3cgdGhlIHBsdWdpbiB0byB0cmFwIGZvY3VzIHRvIHRoZSBkcm9wZG93biBwYW5lIG9uIG9wZW4uXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovXG4gICAgdHJhcEZvY3VzOiBmYWxzZVxuICB9O1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiBieSBzZXR0aW5nL2NoZWNraW5nIG9wdGlvbnMgYW5kIGF0dHJpYnV0ZXMsIGFkZGluZyBoZWxwZXIgdmFyaWFibGVzLCBhbmQgc2F2aW5nIHRoZSBhbmNob3IuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJvcGRvd24ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgJGlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpO1xuXG4gICAgdGhpcy4kYW5jaG9yID0gJCgnW2RhdGEtdG9nZ2xlPVwiJyArICRpZCArICdcIl0nKSB8fCAkKCdbZGF0YS1vcGVuPVwiJyArICRpZCArICdcIl0nKTtcbiAgICB0aGlzLiRhbmNob3IuYXR0cih7XG4gICAgICAnYXJpYS1jb250cm9scyc6ICRpZCxcbiAgICAgICdkYXRhLWlzLWZvY3VzJzogZmFsc2UsXG4gICAgICAnZGF0YS15ZXRpLWJveCc6ICRpZCxcbiAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcbiAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2VcbiAgICAgIC8vICdkYXRhLXJlc2l6ZSc6ICRpZFxuICAgIH0pO1xuXG4gICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MgPSB0aGlzLmdldFBvc2l0aW9uQ2xhc3MoKTtcbiAgICB0aGlzLmNvdW50ZXIgPSA0O1xuICAgIHRoaXMudXNlZFBvc2l0aW9ucyA9IFtdO1xuICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZScsXG4gICAgICAnZGF0YS15ZXRpLWJveCc6ICRpZCxcbiAgICAgICdkYXRhLXJlc2l6ZSc6ICRpZCxcbiAgICAgICdhcmlhLWxhYmVsbGVkYnknOiB0aGlzLiRhbmNob3JbMF0uaWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAnZGQtYW5jaG9yJylcbiAgICB9KTtcbiAgICB0aGlzLl9ldmVudHMoKTtcbiAgfTtcbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgY3VycmVudCBvcmllbnRhdGlvbiBvZiBkcm9wZG93biBwYW5lLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge1N0cmluZ30gcG9zaXRpb24gLSBzdHJpbmcgdmFsdWUgb2YgYSBwb3NpdGlvbiBjbGFzcy5cbiAgICovXG4gIERyb3Bkb3duLnByb3RvdHlwZS5nZXRQb3NpdGlvbkNsYXNzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvKHRvcHxsZWZ0fHJpZ2h0KS9nKTtcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA/IHBvc2l0aW9uWzBdIDogJyc7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9O1xuICAvKipcbiAgICogQWRqdXN0cyB0aGUgZHJvcGRvd24gcGFuZXMgb3JpZW50YXRpb24gYnkgYWRkaW5nL3JlbW92aW5nIHBvc2l0aW9uaW5nIGNsYXNzZXMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24gLSBwb3NpdGlvbiBjbGFzcyB0byByZW1vdmUuXG4gICAqL1xuICBEcm9wZG93bi5wcm90b3R5cGUuX3JlcG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbil7XG4gICAgdGhpcy51c2VkUG9zaXRpb25zLnB1c2gocG9zaXRpb24gPyBwb3NpdGlvbiA6ICdib3R0b20nKTtcbiAgICAvL2RlZmF1bHQsIHRyeSBzd2l0Y2hpbmcgdG8gb3Bwb3NpdGUgc2lkZVxuICAgIGlmKCFwb3NpdGlvbiAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3RvcCcpIDwgMCkpe1xuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygndG9wJyk7XG4gICAgfWVsc2UgaWYocG9zaXRpb24gPT09ICd0b3AnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignYm90dG9tJykgPCAwKSl7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHBvc2l0aW9uKTtcbiAgICB9ZWxzZSBpZihwb3NpdGlvbiA9PT0gJ2xlZnQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKSA8IDApKXtcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pXG4gICAgICAgICAgLmFkZENsYXNzKCdyaWdodCcpO1xuICAgIH1lbHNlIGlmKHBvc2l0aW9uID09PSAncmlnaHQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkpe1xuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbilcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2xlZnQnKTtcbiAgICB9XG5cbiAgICAvL2lmIGRlZmF1bHQgY2hhbmdlIGRpZG4ndCB3b3JrLCB0cnkgYm90dG9tIG9yIGxlZnQgZmlyc3RcbiAgICBlbHNlIGlmKCFwb3NpdGlvbiAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3RvcCcpID4gLTEpICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkpe1xuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnbGVmdCcpO1xuICAgIH1lbHNlIGlmKHBvc2l0aW9uID09PSAndG9wJyAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpID4gLTEpICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkpe1xuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbilcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2xlZnQnKTtcbiAgICB9ZWxzZSBpZihwb3NpdGlvbiA9PT0gJ2xlZnQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKSA+IC0xKSAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpIDwgMCkpe1xuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XG4gICAgfWVsc2UgaWYocG9zaXRpb24gPT09ICdyaWdodCcgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0JykgPiAtMSkgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKSA8IDApKXtcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xuICAgIH1cbiAgICAvL2lmIG5vdGhpbmcgY2xlYXJlZCwgc2V0IHRvIGJvdHRvbVxuICAgIGVsc2V7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHBvc2l0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5jbGFzc0NoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuY291bnRlci0tO1xuICB9O1xuICAvKipcbiAgICogU2V0cyB0aGUgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIHRoZSBkcm9wZG93biBwYW5lLCBjaGVja3MgZm9yIGNvbGxpc2lvbnMuXG4gICAqIFJlY3Vyc2l2ZWx5IGNhbGxzIGl0c2VsZiBpZiBhIGNvbGxpc2lvbiBpcyBkZXRlY3RlZCwgd2l0aCBhIG5ldyBwb3NpdGlvbiBjbGFzcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEcm9wZG93bi5wcm90b3R5cGUuX3NldFBvc2l0aW9uID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLiRhbmNob3IuYXR0cignYXJpYS1leHBhbmRlZCcpID09PSAnZmFsc2UnKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbkNsYXNzKCksXG4gICAgICAgICRlbGVEaW1zID0gRm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLiRlbGVtZW50KSxcbiAgICAgICAgJGFuY2hvckRpbXMgPSBGb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGFuY2hvciksXG4gICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgZGlyZWN0aW9uID0gKHBvc2l0aW9uID09PSAnbGVmdCcgPyAnbGVmdCcgOiAoKHBvc2l0aW9uID09PSAncmlnaHQnKSA/ICdsZWZ0JyA6ICd0b3AnKSksXG4gICAgICAgIHBhcmFtID0gKGRpcmVjdGlvbiA9PT0gJ3RvcCcpID8gJ2hlaWdodCcgOiAnd2lkdGgnLFxuICAgICAgICBvZmZzZXQgPSAocGFyYW0gPT09ICdoZWlnaHQnKSA/IHRoaXMub3B0aW9ucy52T2Zmc2V0IDogdGhpcy5vcHRpb25zLmhPZmZzZXQ7XG5cbiAgICBpZigoJGVsZURpbXMud2lkdGggPj0gJGVsZURpbXMud2luZG93RGltcy53aWR0aCkgfHwgKCF0aGlzLmNvdW50ZXIgJiYgIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy4kZWxlbWVudCkpKXtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCwgdGhpcy4kYW5jaG9yLCAnY2VudGVyIGJvdHRvbScsIHRoaXMub3B0aW9ucy52T2Zmc2V0LCB0aGlzLm9wdGlvbnMuaE9mZnNldCwgdHJ1ZSkpLmNzcyh7XG4gICAgICAgICd3aWR0aCc6ICRlbGVEaW1zLndpbmRvd0RpbXMud2lkdGggLSAodGhpcy5vcHRpb25zLmhPZmZzZXQgKiAyKSxcbiAgICAgICAgJ2hlaWdodCc6ICdhdXRvJyxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jbGFzc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuJGVsZW1lbnQub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCwgdGhpcy4kYW5jaG9yLCBwb3NpdGlvbiwgdGhpcy5vcHRpb25zLnZPZmZzZXQsIHRoaXMub3B0aW9ucy5oT2Zmc2V0KSk7XG5cbiAgICB3aGlsZSghRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLiRlbGVtZW50KSAmJiB0aGlzLmNvdW50ZXIpe1xuICAgICAgdGhpcy5fcmVwb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBlbGVtZW50IHV0aWxpemluZyB0aGUgdHJpZ2dlcnMgdXRpbGl0eSBsaWJyYXJ5LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyb3Bkb3duLnByb3RvdHlwZS5fZXZlbnRzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuJGVsZW1lbnQub24oe1xuICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmNsb3NlLmJpbmQodGhpcyksXG4gICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxuICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9zZXRQb3NpdGlvbi5iaW5kKHRoaXMpXG4gICAgfSk7XG5cbiAgICBpZih0aGlzLm9wdGlvbnMuaG92ZXIpe1xuICAgICAgdGhpcy4kYW5jaG9yLm9mZignbW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJylcbiAgICAgICAgICAub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd24nLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2hvdmVyJyk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgICAgICBfdGhpcy50aW1lT3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBfdGhpcy5vcGVuKCk7XG4gICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XG4gICAgICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYuZHJvcGRvd24nLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgX3RoaXMudGltZU91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgX3RoaXMuJGFuY2hvci5kYXRhKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XG4gICAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuJGFuY2hvci5hZGQodGhpcy4kZWxlbWVudCkub24oJ2tleWRvd24uemYuZHJvcGRvd24nLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgIHZhciB2aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMgPSBGb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUoX3RoaXMuJGVsZW1lbnQpO1xuXG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCBfdGhpcywge1xuICAgICAgICB0YWJfZm9yd2FyZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuZmluZCgnOmZvY3VzJykuaXModmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzLmVxKC0xKSkpIHsgLy8gbGVmdCBtb2RhbCBkb3dud2FyZHMsIHNldHRpbmcgZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMpIHsgLy8gaWYgZm9jdXMgc2hhbGwgYmUgdHJhcHBlZFxuICAgICAgICAgICAgICB2aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMuZXEoMCkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gaWYgZm9jdXMgaXMgbm90IHRyYXBwZWQsIGNsb3NlIGRyb3Bkb3duIG9uIGZvY3VzIG91dFxuICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0YWJfYmFja3dhcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLiRlbGVtZW50LmZpbmQoJzpmb2N1cycpLmlzKHZpc2libGVGb2N1c2FibGVFbGVtZW50cy5lcSgwKSkgfHwgdGhpcy4kZWxlbWVudC5pcygnOmZvY3VzJykpIHsgLy8gbGVmdCBtb2RhbCB1cHdhcmRzLCBzZXR0aW5nIGZvY3VzIHRvIGxhc3QgZWxlbWVudFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMpIHsgLy8gaWYgZm9jdXMgc2hhbGwgYmUgdHJhcHBlZFxuICAgICAgICAgICAgICB2aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMuZXEoLTEpLmZvY3VzKCk7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGlmIGZvY3VzIGlzIG5vdCB0cmFwcGVkLCBjbG9zZSBkcm9wZG93biBvbiBmb2N1cyBvdXRcbiAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMub3BlbigpO1xuICAgICAgICAgIF90aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgLTEpLmZvY3VzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIF90aGlzLiRhbmNob3IuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgZHJvcGRvd24gcGFuZSwgYW5kIGZpcmVzIGEgYnViYmxpbmcgZXZlbnQgdG8gY2xvc2Ugb3RoZXIgZHJvcGRvd25zLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIERyb3Bkb3duI2Nsb3NlbWVcbiAgICogQGZpcmVzIERyb3Bkb3duI3Nob3dcbiAgICovXG4gIERyb3Bkb3duLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24oKXtcbiAgICAvLyB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHRvIGNsb3NlIG90aGVyIG9wZW4gZHJvcGRvd25zXG4gICAgICogQGV2ZW50IERyb3Bkb3duI2Nsb3NlbWVcbiAgICAgKi9cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYuZHJvcGRvd24nLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykpO1xuICAgIHRoaXMuJGFuY2hvci5hZGRDbGFzcygnaG92ZXInKVxuICAgICAgICAuYXR0cih7J2FyaWEtZXhwYW5kZWQnOiB0cnVlfSk7XG4gICAgLy8gdGhpcy4kZWxlbWVudC8qLnNob3coKSovO1xuICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XG4gICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnaXMtb3BlbicpXG4gICAgICAgIC5hdHRyKHsnYXJpYS1oaWRkZW4nOiBmYWxzZX0pO1xuXG5cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIG9uY2UgdGhlIGRyb3Bkb3duIGlzIHZpc2libGUuXG4gICAgICogQGV2ZW50IERyb3Bkb3duI3Nob3dcbiAgICAgKi9cbiAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzaG93LnpmLmRyb3Bkb3duJywgW3RoaXMuJGVsZW1lbnRdKTtcbiAgICAvL3doeSBkb2VzIHRoaXMgbm90IHdvcmsgY29ycmVjdGx5IGZvciB0aGlzIHBsdWdpbj9cbiAgICAvLyBGb3VuZGF0aW9uLnJlZmxvdyh0aGlzLiRlbGVtZW50LCAnZHJvcGRvd24nKTtcbiAgICAvLyBGb3VuZGF0aW9uLl9yZWZsb3codGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLWRyb3Bkb3duJykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG9wZW4gZHJvcGRvd24gcGFuZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBEcm9wZG93biNoaWRlXG4gICAqL1xuICBEcm9wZG93bi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuICAgIGlmKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuJylcbiAgICAgICAgLmF0dHIoeydhcmlhLWhpZGRlbic6IHRydWV9KTtcblxuICAgIHRoaXMuJGFuY2hvci5yZW1vdmVDbGFzcygnaG92ZXInKVxuICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcblxuICAgIGlmKHRoaXMuY2xhc3NDaGFuZ2VkKXtcbiAgICAgIHZhciBjdXJQb3NpdGlvbkNsYXNzID0gdGhpcy5nZXRQb3NpdGlvbkNsYXNzKCk7XG4gICAgICBpZihjdXJQb3NpdGlvbkNsYXNzKXtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhjdXJQb3NpdGlvbkNsYXNzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MpXG4gICAgICAgICAgLyouaGlkZSgpKi8uY3NzKHtoZWlnaHQ6ICcnLCB3aWR0aDogJyd9KTtcbiAgICAgIHRoaXMuY2xhc3NDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmNvdW50ZXIgPSA0O1xuICAgICAgdGhpcy51c2VkUG9zaXRpb25zLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi5kcm9wZG93bicsIFt0aGlzLiRlbGVtZW50XSk7XG4gICAgLy8gRm91bmRhdGlvbi5yZWZsb3codGhpcy4kZWxlbWVudCwgJ2Ryb3Bkb3duJyk7XG4gIH07XG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBkcm9wZG93biBwYW5lJ3MgdmlzaWJpbGl0eS5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpe1xuICAgICAgaWYodGhpcy4kYW5jaG9yLmRhdGEoJ2hvdmVyJykpIHJldHVybjtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBkcm9wZG93bi5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBEcm9wZG93bi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyJykuaGlkZSgpO1xuICAgIHRoaXMuJGFuY2hvci5vZmYoJy56Zi5kcm9wZG93bicpO1xuXG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9O1xuXG4gIEZvdW5kYXRpb24ucGx1Z2luKERyb3Bkb3duLCAnRHJvcGRvd24nKTtcbn0oalF1ZXJ5LCB3aW5kb3cuRm91bmRhdGlvbik7XG4iLCIvKipcbiAqIERyb3Bkb3duTWVudSBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJvcGRvd24tbWVudVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5ib3hcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubmVzdFxuICovXG4hZnVuY3Rpb24oRm91bmRhdGlvbiwgJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgRHJvcGRvd25NZW51LlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIERyb3Bkb3duTWVudSNpbml0XG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93biBtZW51LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBmdW5jdGlvbiBEcm9wZG93bk1lbnUoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBEcm9wZG93bk1lbnUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgIEZvdW5kYXRpb24uTmVzdC5GZWF0aGVyKHRoaXMuJGVsZW1lbnQsICdkcm9wZG93bicpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdEcm9wZG93bk1lbnUnLCB7XG4gICAgICAnRU5URVInOiAnb3BlbicsXG4gICAgICAnU1BBQ0UnOiAnb3BlbicsXG4gICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXG4gICAgICAnQVJST1dfVVAnOiAndXAnLFxuICAgICAgJ0FSUk9XX0RPV04nOiAnZG93bicsXG4gICAgICAnQVJST1dfTEVGVCc6ICdwcmV2aW91cycsXG4gICAgICAnRVNDQVBFJzogJ2Nsb3NlJ1xuICAgIH0pO1xuXG4gICAgLy8gLyoqXG4gICAgLy8gICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBiZWVuIHN1Y2Nlc3NmdWx5IGluaXRpYWxpemVkLlxuICAgIC8vICAqIEBldmVudCBEcm9wZG93bk1lbnUjaW5pdFxuICAgIC8vICAqL1xuICAgIC8vIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaW5pdC56Zi5kcm9wZG93bicpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICAgKi9cbiAgRHJvcGRvd25NZW51LmRlZmF1bHRzID0ge1xuICAgIC8vIHRvZ2dsZU9uOiAnYm90aCcsXG4gICAgLyoqXG4gICAgICogQWxsb3cgYSBzdWJtZW51IHRvIG9wZW4vcmVtYWluIG9wZW4gb24gcGFyZW50IGNsaWNrIGV2ZW50LiBBbGxvd3MgY3Vyc29yIHRvIG1vdmUgYXdheSBmcm9tIG1lbnUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9cbiAgICBjbGlja09wZW46IHRydWUsXG4gICAgLyoqXG4gICAgICogQWxsb3cgY2xpY2tzIG9uIHRoZSBib2R5IHRvIGNsb3NlIGFueSBvcGVuIHN1Ym1lbnVzLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgICAqL1xuICAgIGNsb3NlT25DbGljazogZmFsc2UsXG4gICAgLyoqXG4gICAgICogRGlzYWxsb3dzIGhvdmVyIGV2ZW50cyBmcm9tIG9wZW5pbmcgc3VibWVudXNcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9cbiAgICBkaXNhYmxlSG92ZXI6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFsbG93IGEgc3VibWVudSB0byBhdXRvbWF0aWNhbGx5IGNsb3NlIG9uIGEgbW91c2VsZWF2ZSBldmVudC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL1xuICAgIGF1dG9jbG9zZTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSBvcGVuaW5nIGEgc3VibWVudSBvbiBob3ZlciBldmVudC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMTUwXG4gICAgICovXG4gICAgaG92ZXJEZWxheTogMTUwLFxuICAgIC8qKlxuICAgICAqIEFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IGNsb3NpbmcgYSBzdWJtZW51IG9uIGEgbW91c2VsZWF2ZSBldmVudC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgNTAwXG4gICAgICovXG4gICAgY2xvc2luZ1RpbWU6IDUwMCxcbiAgICAvLyB3cmFwT25LZXlzOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIG9mIHRoZSBtZW51IHJlbGF0aXZlIHRvIHdoYXQgZGlyZWN0aW9uIHRoZSBzdWJtZW51cyBzaG91bGQgb3Blbi4gSGFuZGxlZCBieSBKUy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ2xlZnQnXG4gICAgICovXG4gICAgYWxpZ25tZW50OiAnbGVmdCcsXG4gICAgLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byB2ZXJ0aWNhbCBvcmllbnRlZCBtZW51cywgRm91bmRhdGlvbiBkZWZhdWx0IGlzIGB2ZXJ0aWNhbGAuIFVwZGF0ZSB0aGlzIGlmIHVzaW5nIHlvdXIgb3duIGNsYXNzLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAndmVydGljYWwnXG4gICAgICovXG4gICAgdmVydGljYWxDbGFzczogJ3ZlcnRpY2FsJyxcbiAgICAvKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIHJpZ2h0LXNpZGUgb3JpZW50ZWQgbWVudXMsIEZvdW5kYXRpb24gZGVmYXVsdCBpcyBgYWxpZ24tcmlnaHRgLiBVcGRhdGUgdGhpcyBpZiB1c2luZyB5b3VyIG93biBjbGFzcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ2FsaWduLXJpZ2h0J1xuICAgICAqL1xuICAgIHJpZ2h0Q2xhc3M6ICdhbGlnbi1yaWdodCdcbiAgfTtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4sIGFuZCBjYWxscyBfcHJlcGFyZU1lbnVcbiAgICogQHByaXZhdGVcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBEcm9wZG93bk1lbnUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbENsYXNzKSl7XG4gICAgICB0aGlzLnZlcnRpY2FsID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gdGhpcy52ZXJ0aWNhbCA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLnZlcnRpY2FsQ2xhc3MpO1xuICAgIHRoaXMuX3ByZXBhcmVNZW51KCk7XG4gICAgLy8gdGhpcy5fYWRkVG9wTGV2ZWxLZXlIYW5kbGVyKCk7XG4gIH07XG4gIC8qKlxuICAgKiBQcmVwYXJlcyB0aGUgbWVudSBieSBjaGVja2luZyBhbGlnbm1lbnQgYW5kIG9yaWVudGF0aW9uLCBzZXR0aW5nIGF0dHJpYnV0ZXMgZm9yIGVsZW1lbnRzLCBhbmQgY3JlYXRpbmcgalF1ZXJ5IGNvbGxlY3Rpb25zIG9mIGVsZW1lbnRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIERyb3Bkb3duTWVudS5wcm90b3R5cGUuX3ByZXBhcmVNZW51ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuJHRhYnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCdsaS5oYXMtc3VibWVudScpO1xuICAgIHRoaXMuJHRhYnMuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykuYWRkQ2xhc3MoJ2ZpcnN0LXN1YicpO1xuICAgIHRoaXMuJHN1Ym1lbnVzID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaS5oYXMtc3VibWVudScpO1xuICAgIHRoaXMuJG1lbnVJdGVtcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnbGknKS5hdHRyKHsncm9sZSc6ICdtZW51aXRlbScsICd0YWJpbmRleCc6IDB9KTtcbiAgICB0aGlzLiRtZW51SXRlbXMuY2hpbGRyZW4oJ2EnKS5hdHRyKCd0YWJpbmRleCcsIC0xKTtcbiAgICBpZih0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5yaWdodENsYXNzKSl7XG4gICAgICB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID0gJ3JpZ2h0JztcbiAgICAgIHRoaXMuJHN1Ym1lbnVzLmFkZENsYXNzKCdpcy1sZWZ0LWFycm93IG9wZW5zLWxlZnQnKTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuJHN1Ym1lbnVzLmFkZENsYXNzKCdpcy1yaWdodC1hcnJvdyBvcGVucy1yaWdodCcpO1xuICAgIH1cbiAgICBpZighdGhpcy52ZXJ0aWNhbCl7XG4gICAgICB0aGlzLiR0YWJzLnJlbW92ZUNsYXNzKCdpcy1yaWdodC1hcnJvdyBpcy1sZWZ0LWFycm93IG9wZW5zLWxlZnQgb3BlbnMtcmlnaHQnKS5hZGRDbGFzcygnaXMtZG93bi1hcnJvdycpO1xuICAgIH1cblxuICAgIHRoaXMuJHRhYnMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyICR0YWIgPSAkKHRoaXMpO1xuICAgICAgJHRhYi5hdHRyKHtcbiAgICAgICAgJ3JvbGUnOiAnbWVudWl0ZW0nLFxuICAgICAgICAndGFiaW5kZXgnOiAwLFxuICAgICAgICAnYXJpYS1sYWJlbCc6ICR0YWIuY2hpbGRyZW4oJ2E6Zmlyc3QtY2hpbGQnKS50ZXh0KCkvKi5tYXRjaCgvXFx3L2lnKS5qb2luKCcnKSovXG4gICAgICB9KS5jaGlsZHJlbignYScpLmF0dHIoJ3RhYmluZGV4JywgLTEpOy8vbWF5YmUgYWRkIGEgbW9yZSBzcGVjaWZpYyByZWdleCB0byBtYXRjaCBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgam9pbiB0aGVtIGFwcHJvcHJpYXRlbHlcbiAgICAgIGlmKCR0YWIuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykpe1xuICAgICAgICAkdGFiLmF0dHIoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgdGhpcy4kc3VibWVudXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyICRzdWIgPSAkKHRoaXMpO1xuXG4gICAgICAvLyBpZihfdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ3JpZ2h0Jyl7XG4gICAgICAvLyAgICRzdWIuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykuYWRkQ2xhc3MoJ2lzLXJpZ2h0LWFycm93Jyk7XG4gICAgICAvLyB9XG5cbiAgICAgICRzdWIuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJylcbiAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgICAgICAgJ3RhYmluZGV4JzogLTEsXG4gICAgICAgICAgICAncm9sZSc6ICdtZW51J1xuICAgICAgICAgIH0pLmFkZENsYXNzKCd2ZXJ0aWNhbCcpO1xuICAgICAgX3RoaXMuX2V2ZW50cygkc3ViKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gZWxlbWVudHMgd2l0aGluIHRoZSBtZW51XG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBlbGVtZW50IHRvIGF0dGFjaCBsaXN0ZW5lcnMgdG9vLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIERyb3Bkb3duTWVudS5wcm90b3R5cGUuX2V2ZW50cyA9IGZ1bmN0aW9uKCRlbGVtKXtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBpc1RvdWNoID0gd2luZG93Lm9udG91Y2hzdGFydCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgaWYodGhpcy5vcHRpb25zLmNsaWNrT3BlbiB8fCBpc1RvdWNoKXtcbiAgICAgICRlbGVtLm9mZignY2xpY2suemYuZHJvcGRvd25tZW51JylcbiAgICAgICAgICAub24oJ2NsaWNrLnpmLmRyb3Bkb3dubWVudScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgaWYoISQodGhpcykuaGFzQ2xhc3MoJ2lzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykpeyByZXR1cm47IH1cbiAgICAgICAgICAgIHZhciBoYXNDbGlja2VkID0gJGVsZW0uZGF0YSgnaXNDbGljaycpO1xuICAgICAgICAgICAgaWYoaXNUb3VjaCAmJiBoYXNDbGlja2VkKSByZXR1cm47XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICBpZihoYXNDbGlja2VkKXtcbiAgICAgICAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW0pO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIF90aGlzLl9oaWRlT3RoZXJzKCRlbGVtKTtcbiAgICAgICAgICAgICAgX3RoaXMuX3Nob3coJGVsZW0pO1xuICAgICAgICAgICAgICAkZWxlbS5kYXRhKCdpc0NsaWNrJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIC5wYXJlbnRzVW50aWwoJ1tkYXRhLWRyb3Bkb3duLW1lbnVdJywgJy5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpXG4gICAgICAgICAgICAgICAgICAuZGF0YSgnaXNDbGljaycsIHRydWUpO1xuICAgICAgICAgICAgICBpZihfdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayl7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2FkZEJvZHlIYW5kbGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZighdGhpcy5vcHRpb25zLmRpc2FibGVIb3Zlcil7XG4gICAgICAvL2FkZCBhYmlsaXR5IGZvciBhbGwgbWVudSBpdGVtcyB0byBjbG9zZSBhbiBvcGVuIG1lbnUgb24gdGhlIHNhbWUgbGV2ZWwvL1xuICAgICAgdGhpcy4kbWVudUl0ZW1zLm9uKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3dubWVudScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgJGVsID0gJCh0aGlzKTtcbiAgICAgICAgaWYoISRlbC5oYXNDbGFzcygnaXMtYWN0aXZlJykpe1xuICAgICAgICAgIF90aGlzLl9oaWRlT3RoZXJzKCRlbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy9lbGVtZW50cyB3aXRoIHN1Ym1lbnVzXG4gICAgICAkZWxlbS5vZmYoJ21vdXNlZW50ZXIuemYuZHJvcGRvd25tZW51JylcbiAgICAgICAgLm9uKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3dubWVudScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgIGNsZWFyVGltZW91dCgkZWxlbS5jbG9zZVRpbWVyKTtcbiAgICAgICAgICBpZighJGVsZW0uaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKXtcbiAgICAgICAgICAgICRlbGVtLm9wZW5UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvLyBfdGhpcy5faGlkZU90aGVycygkZWxlbSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Nob3coJGVsZW0pO1xuICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTtcbiAgICAgICAgICB9XG4gICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgaWYoISRlbGVtLmRhdGEoJ2lzQ2xpY2snKSAmJiBfdGhpcy5vcHRpb25zLmF1dG9jbG9zZSl7XG4gICAgICAgIGNsZWFyVGltZW91dCgkZWxlbS5vcGVuVGltZXIpO1xuICAgICAgICAgICRlbGVtLmNsb3NlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7XG4gICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5jbG9zaW5nVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuJG1lbnVJdGVtcy5vbigna2V5ZG93bi56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbihlKXtcbiAgICAgIHZhciAkZWxlbWVudCA9ICQodGhpcyksXG4gICAgICAgICAgJHRhYnMgPSBfdGhpcy4kZWxlbWVudC5jaGlsZHJlbignbGknKSxcbiAgICAgICAgICBpc1RhYiA9ICRlbGVtZW50LmlzKCR0YWJzKSxcbiAgICAgICAgICAkZWxlbWVudHMgPSBpc1RhYiA/ICR0YWJzIDogJGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLmFkZCgkZWxlbWVudC5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJykpLFxuICAgICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgICAkbmV4dEVsZW1lbnQ7XG5cbiAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgaWYgKCQodGhpcykuaXMoJGVsZW1lbnQpKSB7XG4gICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnRzLmVxKGktMSk7XG4gICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKGkrMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBuZXh0U2libGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoISRlbGVtZW50LmlzKCc6bGFzdC1jaGlsZCcpKSAkbmV4dEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH0sIHByZXZTaWJsaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRwcmV2RWxlbWVudC5mb2N1cygpO1xuICAgICAgfSwgb3BlblN1YiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoJGVsZW1lbnQuaGFzKCd1bCcpLmxlbmd0aCkge1xuICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtZW50KTtcbiAgICAgICAgICAkZWxlbWVudC5maW5kKCdsaScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSwgY2xvc2VTdWIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9pZiAoJGVsZW1lbnQuaXMoJzpmaXJzdC1jaGlsZCcpKSB7XG4gICAgICAgICAgJGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpKTtcbiAgICAgICAgLy99XG4gICAgICB9O1xuICAgICAgdmFyIGZ1bmN0aW9ucyA9IHtcbiAgICAgICAgb3Blbjogb3BlblN1YixcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLl9oaWRlQWxsKCk7XG4gICAgICAgICAgX3RoaXMuJG1lbnVJdGVtcy5maXJzdCgpLmZvY3VzKCk7IC8vIGZvY3VzIHRvIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChpc1RhYikge1xuICAgICAgICBpZiAoX3RoaXMudmVydGljYWwpIHsgLy8gdmVydGljYWwgbWVudVxuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnKSB7IC8vIGxlZnQgYWxpZ25lZFxuICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XG4gICAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICB1cDogcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIG5leHQ6IG9wZW5TdWIsXG4gICAgICAgICAgICAgIHByZXZpb3VzOiBjbG9zZVN1YixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIHJpZ2h0IGFsaWduZWRcbiAgICAgICAgICAgICQuZXh0ZW5kKGZ1bmN0aW9ucywge1xuICAgICAgICAgICAgICBkb3duOiBuZXh0U2libGluZyxcbiAgICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICBuZXh0OiBjbG9zZVN1YixcbiAgICAgICAgICAgICAgcHJldmlvdXM6IG9wZW5TdWIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIGhvcml6b250YWwgbWVudVxuICAgICAgICAgICQuZXh0ZW5kKGZ1bmN0aW9ucywge1xuICAgICAgICAgICAgbmV4dDogbmV4dFNpYmxpbmcsXG4gICAgICAgICAgICBwcmV2aW91czogcHJldlNpYmxpbmcsXG4gICAgICAgICAgICBkb3duOiBvcGVuU3ViLFxuICAgICAgICAgICAgdXA6IGNsb3NlU3ViLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyAvLyBub3QgdGFicyAtPiBvbmUgc3ViXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnKSB7IC8vIGxlZnQgYWxpZ25lZFxuICAgICAgICAgICQuZXh0ZW5kKGZ1bmN0aW9ucywge1xuICAgICAgICAgICAgbmV4dDogb3BlblN1YixcbiAgICAgICAgICAgIHByZXZpb3VzOiBjbG9zZVN1YixcbiAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7IC8vIHJpZ2h0IGFsaWduZWRcbiAgICAgICAgICAkLmV4dGVuZChmdW5jdGlvbnMsIHtcbiAgICAgICAgICAgIG5leHQ6IGNsb3NlU3ViLFxuICAgICAgICAgICAgcHJldmlvdXM6IG9wZW5TdWIsXG4gICAgICAgICAgICBkb3duOiBuZXh0U2libGluZyxcbiAgICAgICAgICAgIHVwOiBwcmV2U2libGluZ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCBfdGhpcywgZnVuY3Rpb25zKTtcbiAgICB9KTtcbiAgICAgLy8gZW5kIGtleWJvYXJkQWNjZXNzXG4gIH07XG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBjdXJyZW50IGRyb3Bkb3duIHBhbmUuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IGVsZW1lbnQgd2l0aCBhIHN1Ym1lbnUgdG8gdG9nZ2xlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyb3Bkb3duTWVudS5wcm90b3R5cGUuX3RvZ2dsZSA9IGZ1bmN0aW9uKCRlbGVtKXtcbiAgICBpZigkZWxlbS5oYXNDbGFzcygnaXMtYWN0aXZlJykpe1xuICAgICAgdGhpcy5faGlkZSgkZWxlbSk7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLl9zaG93KCRlbGVtKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGJvZHkgdG8gY2xvc2UgYW55IGRyb3Bkb3ducyBvbiBhIGNsaWNrLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyb3Bkb3duTWVudS5wcm90b3R5cGUuX2FkZEJvZHlIYW5kbGVyID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgJGJvZHkgPSAkKCdib2R5JyksXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAkYm9keS5ub3QoX3RoaXMuJGVsZW1lbnQpLm9uKCdjbGljay56Zi5kcm9wZG93bm1lbnUgdGFwLnpmLmRyb3Bkb3dubWVudSB0b3VjaGVuZC56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbihlKXtcbiAgICAgIF90aGlzLl9oaWRlQWxsKCk7XG4gICAgICAkYm9keS5vZmYoJ2NsaWNrLnpmLmRyb3Bkb3dubWVudSB0YXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudScpO1xuICAgIH0pO1xuICB9O1xuLy9zaG93ICYgaGlkZSBzdHVmZiBAcHJpdmF0ZVxuICAvKipcbiAgICogT3BlbnMgYSBkcm9wZG93biBwYW5lLCBhbmQgY2hlY2tzIGZvciBjb2xsaXNpb25zIGZpcnN0LlxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSBjdXJyZW50IGVsZW1lbnQgd2l0aCBhIHN1Ym1lbnUgdG8gc2hvd1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzIERyb3Bkb3duTWVudSNzaG93XG4gICAqL1xuICBEcm9wZG93bk1lbnUucHJvdG90eXBlLl9zaG93ID0gZnVuY3Rpb24oJGVsZW0pe1xuICAgIHRoaXMuX2hpZGVPdGhlcnMoJGVsZW0pO1xuICAgICRlbGVtLmZvY3VzKCk7XG4gICAgLy8gY29uc29sZS5sb2coJ3Nob3dpbmcgc29tZSBzdHVmZicsICRlbGVtLmZpbmQoJ2xpOmZpcnN0LWNoaWxkJykpO1xuICAgIHZhciAkc3ViID0gJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOmZpcnN0LW9mLXR5cGUnKTtcbiAgICAkZWxlbS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgJHN1Yi5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuYWRkQ2xhc3MoJ2pzLWRyb3Bkb3duLWFjdGl2ZScpXG4gICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcblxuXG4gICAgLy9icmVhayB0aGlzIGludG8gb3duIGZ1bmN0aW9uXG4gICAgdmFyIGNsZWFyID0gRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSgkc3ViLCBudWxsLCB0cnVlKTtcbiAgICBpZighY2xlYXIpe1xuICAgICAgaWYodGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnKXtcbiAgICAgICAgJGVsZW0ucmVtb3ZlQ2xhc3MoJ29wZW5zLWxlZnQnKS5hZGRDbGFzcygnb3BlbnMtcmlnaHQnKTtcbiAgICAgIH1lbHNle1xuICAgICAgICAkZWxlbS5yZW1vdmVDbGFzcygnb3BlbnMtcmlnaHQnKS5hZGRDbGFzcygnb3BlbnMtbGVmdCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgLy8gc3RpbGwgbm90IGNsZWFyLCBzbWFsbCBzY3JlZW4sIGFkZCBpbm5lciBjbGFzc1xuICAgICAgY2xlYXIgPSBGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KCRzdWIsIG51bGwsIHRydWUpO1xuICAgICAgaWYgKCFjbGVhcikge1xuICAgICAgICAkZWxlbS5yZW1vdmVDbGFzcygnb3BlbnMtbGVmdCBvcGVucy1yaWdodCcpLmFkZENsYXNzKCdvcGVucy1pbm5lcicpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAkc3ViLmNzcygndmlzaWJpbGl0eScsICcnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBuZXcgZHJvcGRvd24gcGFuZSBpcyB2aXNpYmxlLlxuICAgICAqIEBldmVudCBEcm9wZG93bk1lbnUjc2hvd1xuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2hvdy56Zi5kcm9wZG93bm1lbnUnLCBbJGVsZW1dKTtcbiAgfTtcbiAgLyoqXG4gICAqIEhpZGVzIGEgc2luZ2xlLCBjdXJyZW50bHkgb3BlbiBkcm9wZG93biBwYW5lLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gZWxlbWVudCB3aXRoIGEgc3VibWVudSB0byBoaWRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEcm9wZG93bk1lbnUucHJvdG90eXBlLl9oaWRlID0gZnVuY3Rpb24oJGVsZW0pe1xuICAgIHRoaXMuX2hpZGVTb21lKCRlbGVtKTtcbiAgfTtcbiAgLyoqXG4gICAqIEhpZGVzIGN1cnJlbnRseSBvcGVuIGRyb3Bkb3duIHBhbmVzIGZyb20gYSBqUXVlcnkgY29sbGVjdGlvbiBwYXNzZWQgYnkgb3RoZXIgZnVuY3Rpb25zLlxuICAgKiBSZXNldHMgdGhlIHBvc2l0aW9uIGNsYXNzZXMgaWYgdGhlIGVsZW1lbnQgd2FzIG11dGF0ZWQgZHVlIHRvIGEgY29sbGlzaW9uLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtcyAtIGVsZW1lbnQocykgd2l0aCBhIHN1Ym1lbnUgdG8gaGlkZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgRHJvcGRvd25NZW51I2hpZGVcbiAgICovXG4gIERyb3Bkb3duTWVudS5wcm90b3R5cGUuX2hpZGVTb21lID0gZnVuY3Rpb24oJGVsZW1zKXtcbiAgICBpZigkZWxlbXMubGVuZ3RoKXtcbiAgICAgIC8vIGlmKCRlbGVtcy5oYXNDbGFzcygnZmlyc3Qtc3ViJykpe1xuICAgICAgLy8gICBjb25zb2xlLmxvZygndHJ1ZScpO1xuICAgICAgLy8gICAkZWxlbXMuYmx1cigpO1xuICAgICAgLy8gfVxuICAgICAgJGVsZW1zLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgb3BlbnMtaW5uZXInKS5kYXRhKCdpc0NsaWNrJywgZmFsc2UpXG5cbiAgICAgICAgICAgIC5maW5kKCcuaXMtYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmRhdGEoJ2lzQ2xpY2snLCBmYWxzZSkuZW5kKClcblxuICAgICAgICAgICAgLmZpbmQoJy5qcy1kcm9wZG93bi1hY3RpdmUnKS5yZW1vdmVDbGFzcygnanMtZHJvcGRvd24tYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICAgICRlbGVtcy5wYXJlbnQoJy5oYXMtc3VibWVudScpLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTtcbiAgICAgIGlmKHRoaXMuY2hhbmdlZCl7XG4gICAgICAgIC8vcmVtb3ZlIHBvc2l0aW9uIGNsYXNzXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09ICdsZWZ0Jyl7XG4gICAgICAgICAgJGVsZW1zLmZpbmQoJy5vcGVucy1sZWZ0JykucmVtb3ZlQ2xhc3MoJ29wZW5zLWxlZnQnKS5hZGRDbGFzcygnb3BlbnMtcmlnaHQnKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgJGVsZW1zLmZpbmQoJy5vcGVucy1yaWdodCcpLnJlbW92ZUNsYXNzKCdvcGVucy1yaWdodCcpLmFkZENsYXNzKCdvcGVucy1sZWZ0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgb3BlbiBtZW51cyBhcmUgY2xvc2VkLlxuICAgICAgICogQGV2ZW50IERyb3Bkb3duTWVudSNoaWRlXG4gICAgICAgKi9cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi5kcm9wZG93bm1lbnUnKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBIaWRlcyBhIHN1Ym1lbnUncyBzaWJsaW5ncy5cbiAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgcmVtYWluIG9wZW4uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJvcGRvd25NZW51LnByb3RvdHlwZS5faGlkZU90aGVycyA9IGZ1bmN0aW9uKCRlbGVtKXtcbiAgICB0aGlzLl9oaWRlU29tZSgkZWxlbS5zaWJsaW5ncygnLmhhcy1zdWJtZW51LmlzLWFjdGl2ZScpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEhpZGVzIGV2ZXJ5dGhpbmcuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgRHJvcGRvd25NZW51LnByb3RvdHlwZS5faGlkZUFsbCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5faGlkZVNvbWUodGhpcy4kZWxlbWVudCk7XG4gIH07XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIERyb3Bkb3duTWVudS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2hpZGVBbGwoKTtcbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5yZW1vdmVEYXRhKCd6Zi1wbHVnaW4nKVxuICAgICAgICAuZmluZCgnbGknKVxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2pzLWRyb3Bkb3duLW5vaG92ZXIgaXMtcmlnaHQtYXJyb3cgaXMtbGVmdC1hcnJvdyBvcGVucy1sZWZ0IG9wZW5zLWlubmVyIG9wZW5zLXJpZ2h0JylcbiAgICAgICAgLmFkZCgnYScpLm9mZignLnpmLmRyb3Bkb3dubWVudScpXG4gICAgICAgIC5lbmQoKS5maW5kKCd1bCcpLnJlbW92ZUNsYXNzKCdmaXJzdC1zdWInKTtcbiAgICBGb3VuZGF0aW9uLk5lc3QuQnVybih0aGlzLiRlbGVtZW50LCAnZHJvcGRvd24nKTtcbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH07XG5cbiAgRm91bmRhdGlvbi5wbHVnaW4oRHJvcGRvd25NZW51LCAnRHJvcGRvd25NZW51Jyk7XG5cbiAgdmFyIGNoZWNrQ2xhc3MgPSBmdW5jdGlvbigkZWxlbSl7XG4gICAgcmV0dXJuICRlbGVtLmhhc0NsYXNzKCdpcy1hY3RpdmUnKTtcbiAgfTtcblxufShGb3VuZGF0aW9uLCBqUXVlcnkpO1xuIiwiIWZ1bmN0aW9uKEZvdW5kYXRpb24sICQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEVxdWFsaXplci5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBFcXVhbGl6ZXIjaW5pdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBmdW5jdGlvbiBFcXVhbGl6ZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyAgPSAkLmV4dGVuZCh7fSwgRXF1YWxpemVyLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgdGhpcy4kd2luZG93ICA9ICQod2luZG93KTtcbiAgICB0aGlzLm5hbWUgICAgID0gJ2VxdWFsaXplcic7XG4gICAgdGhpcy5hdHRyICAgICA9ICdkYXRhLWVxdWFsaXplcic7XG5cbiAgICB0aGlzLl9pbml0KCk7XG4gICAgdGhpcy5fZXZlbnRzKCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICAgKi9cbiAgRXF1YWxpemVyLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBoZWlnaHQgZXF1YWxpemF0aW9uIHdoZW4gc3RhY2tlZCBvbiBzbWFsbGVyIHNjcmVlbnMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9cbiAgICBlcXVhbGl6ZU9uU3RhY2s6IHRydWUsXG4gICAgLyoqXG4gICAgICogQW1vdW50IG9mIHRpbWUsIGluIG1zLCB0byBkZWJvdW5jZSB0aGUgc2l6ZSBjaGVja2luZy9lcXVhbGl6YXRpb24uIExvd2VyIHRpbWVzIG1lYW4gc21vb3RoZXIgdHJhbnNpdGlvbnMvbGVzcyBwZXJmb3JtYW5jZSBvbiBtb2JpbGUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDUwXG4gICAgICovXG4gICAgdGhyb3R0bGVJbnRlcnZhbDogNTBcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIEVxdWFsaXplciBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgZXF1YWxpemVyIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBFcXVhbGl6ZXIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmVmbG93KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgRXF1YWxpemVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRXF1YWxpemVyLnByb3RvdHlwZS5fZXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy4kd2luZG93XG4gICAgICAub2ZmKCcuZXF1YWxpemVyJylcbiAgICAgIC5vbigncmVzaXplLmZuZHRuLmVxdWFsaXplcicsIEZvdW5kYXRpb24udXRpbC50aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX3JlZmxvdygpO1xuICAgICAgfSwgc2VsZi5vcHRpb25zLnRocm90dGxlSW50ZXJ2YWwpKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBub29wIHZlcnNpb24gZm9yIHRoZSBwbHVnaW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEVxdWFsaXplci5wcm90b3R5cGUuX2tpbGxzd2l0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm47XG4gIH07XG4gIC8qKlxuICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBFcXVhbGl6ZXIgdXBvbiBET00gY2hhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBFcXVhbGl6ZXIucHJvdG90eXBlLl9yZWZsb3cgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAkKCdbJyArIHRoaXMuYXR0ciArICddJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciAkZXFQYXJlbnQgICAgICAgPSAkKHRoaXMpLFxuICAgICAgICAgIGFkanVzdGVkSGVpZ2h0cyA9IFtdLFxuICAgICAgICAgICRpbWFnZXMgPSAkZXFQYXJlbnQuZmluZCgnaW1nJyk7XG5cbiAgICAgIGlmICgkaW1hZ2VzLmxlbmd0aCkge1xuICAgICAgICBGb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKCRpbWFnZXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGFkanVzdGVkSGVpZ2h0cyA9IHNlbGYuZ2V0SGVpZ2h0cygkZXFQYXJlbnQpO1xuICAgICAgICAgIHNlbGYuYXBwbHlIZWlnaHQoJGVxUGFyZW50LCBhZGp1c3RlZEhlaWdodHMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhZGp1c3RlZEhlaWdodHMgPSBzZWxmLmdldEhlaWdodHMoJGVxUGFyZW50KTtcbiAgICAgICAgc2VsZi5hcHBseUhlaWdodCgkZXFQYXJlbnQsIGFkanVzdGVkSGVpZ2h0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgb3V0ZXIgaGVpZ2h0cyBvZiBjaGlsZHJlbiBjb250YWluZWQgd2l0aGluIGFuIEVxdWFsaXplciBwYXJlbnQgYW5kIHJldHVybnMgdGhlbSBpbiBhbiBhcnJheVxuICAgKiBAcGFyYW0ge09iamVjdH0gJGVxUGFyZW50IEEgalF1ZXJ5IGluc3RhbmNlIG9mIGFuIEVxdWFsaXplciBjb250YWluZXJcbiAgICogQHJldHVybnMge0FycmF5fSBoZWlnaHRzIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXJcbiAgICovXG4gIEVxdWFsaXplci5wcm90b3R5cGUuZ2V0SGVpZ2h0cyA9IGZ1bmN0aW9uKCRlcVBhcmVudCkge1xuICAgIHZhciBlcUdyb3VwTmFtZSA9ICRlcVBhcmVudC5kYXRhKCdlcXVhbGl6ZXInKSxcbiAgICAgICAgZXFHcm91cCAgICAgPSBlcUdyb3VwTmFtZSA/ICRlcVBhcmVudC5maW5kKCdbJyArIHRoaXMuYXR0ciArICctd2F0Y2g9XCInICsgZXFHcm91cE5hbWUgKyAnXCJdOnZpc2libGUnKSA6ICRlcVBhcmVudC5maW5kKCdbJyArIHRoaXMuYXR0ciArICctd2F0Y2hdOnZpc2libGUnKSxcbiAgICAgICAgaGVpZ2h0cztcblxuICAgIGVxR3JvdXAuaGVpZ2h0KCdpbmhlcml0Jyk7XG4gICAgaGVpZ2h0cyA9IGVxR3JvdXAubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuICQodGhpcykub3V0ZXJIZWlnaHQoZmFsc2UpO30pLmdldCgpO1xuICAgIGNvbnNvbGUubG9nKGhlaWdodHMpO1xuICAgIHJldHVybiBoZWlnaHRzO1xuICB9O1xuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgQ1NTIGhlaWdodCBwcm9wZXJ0eSBvZiBlYWNoIGNoaWxkIGluIGFuIEVxdWFsaXplciBwYXJlbnQgdG8gbWF0Y2ggdGhlIHRhbGxlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9ICRlcVBhcmVudCAtIEEgalF1ZXJ5IGluc3RhbmNlIG9mIGFuIEVxdWFsaXplciBjb250YWluZXJcbiAgICogQHBhcmFtIHthcnJheX0gaGVpZ2h0cyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXJcbiAgICogQGZpcmVzIEVxdWFsaXplciNwcmVFcXVhbGl6ZWRcbiAgICogQGZpcmVzIEVxdWFsaXplciNwb3N0RXF1YWxpemVkXG4gICAqL1xuICBFcXVhbGl6ZXIucHJvdG90eXBlLmFwcGx5SGVpZ2h0ID0gZnVuY3Rpb24oJGVxUGFyZW50LCBoZWlnaHRzKSB7XG4gICAgdmFyIGVxR3JvdXBOYW1lID0gJGVxUGFyZW50LmRhdGEoJ2VxdWFsaXplcicpLFxuICAgICAgICBlcUdyb3VwICAgICA9IGVxR3JvdXBOYW1lID8gJGVxUGFyZW50LmZpbmQoJ1snK3RoaXMuYXR0cisnLXdhdGNoPVwiJytlcUdyb3VwTmFtZSsnXCJdOnZpc2libGUnKSA6ICRlcVBhcmVudC5maW5kKCdbJyt0aGlzLmF0dHIrJy13YXRjaF06dmlzaWJsZScpLFxuICAgICAgICBtYXggICAgICAgICA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGhlaWdodHMpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgYmVmb3JlIHRoZSBoZWlnaHRzIGFyZSBhcHBsaWVkXG4gICAgICogQGV2ZW50IEVxdWFsaXplciNwcmVFcXVhbGl6ZWRcbiAgICAgKi9cbiAgICAkZXFQYXJlbnQudHJpZ2dlcigncHJlRXF1YWxpemVkLnpmLkVxdWFsaXplcicpO1xuXG4gICAgLy8gZm9yIG5vdywgYXBwbHkgdGhlIG1heCBoZWlnaHQgZm91bmQgaW4gdGhlIGFycmF5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcUdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAkKGVxR3JvdXBbaV0pLmNzcygnaGVpZ2h0JywgbWF4KTtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2cobWF4KTtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBoZWlnaHRzIGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgICogQGV2ZW50IEVxdWFsaXplciNwb3N0RXF1YWxpemVkXG4gICAgICovXG4gICAgJGVxUGFyZW50LnRyaWdnZXIoJ3Bvc3RFcXVhbGl6ZWQuemYuRXF1YWxpemVyJyk7XG4gIH07XG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBFcXVhbGl6ZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgRXF1YWxpemVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgICAvL1RPRE8gdGhpcy5cbiAgfTtcblxuICBGb3VuZGF0aW9uLnBsdWdpbihFcXVhbGl6ZXIsICdFcXVhbGl6ZXInKTtcblxuICAvLyBFeHBvcnRzIGZvciBBTUQvQnJvd3NlcmlmeVxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJylcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEVxdWFsaXplcjtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicpXG4gICAgZGVmaW5lKFsnZm91bmRhdGlvbiddLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBFcXVhbGl6ZXI7XG4gICAgfSk7XG5cbn0oRm91bmRhdGlvbiwgalF1ZXJ5KTtcbiIsIi8qKlxuICogSW50ZXJjaGFuZ2UgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmludGVyY2hhbmdlXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudGltZXJBbmRJbWFnZUxvYWRlclxuICovXG4hZnVuY3Rpb24oRm91bmRhdGlvbiwgJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgSW50ZXJjaGFuZ2UuXG4gICAqIEBjbGFzc1xuICAgKiBAZmlyZXMgSW50ZXJjaGFuZ2UjaW5pdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcmNoYW5nZShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIEludGVyY2hhbmdlLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICB0aGlzLnJ1bGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50UGF0aCA9ICcnO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cbiAgICovXG4gIEludGVyY2hhbmdlLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIFJ1bGVzIHRvIGJlIGFwcGxpZWQgdG8gSW50ZXJjaGFuZ2UgZWxlbWVudHMuIFNldCB3aXRoIHRoZSBgZGF0YS1pbnRlcmNoYW5nZWAgYXJyYXkgbm90YXRpb24uXG4gICAgICogQG9wdGlvblxuICAgICAqL1xuICAgIHJ1bGVzOiBudWxsXG4gIH07XG5cbiAgSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTID0ge1xuICAgICdsYW5kc2NhcGUnOiAnc2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSknLFxuICAgICdwb3J0cmFpdCc6ICdzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpJyxcbiAgICAncmV0aW5hJzogJ29ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIvMSksIG9ubHkgc2NyZWVuIGFuZCAobWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE5MmRwaSksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDJkcHB4KSdcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIEludGVyY2hhbmdlIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBpbnRlcmNoYW5nZSBmdW5jdGlvbmluZyBvbiBsb2FkLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEludGVyY2hhbmdlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2FkZEJyZWFrcG9pbnRzKCk7XG4gICAgdGhpcy5fZ2VuZXJhdGVSdWxlcygpO1xuICAgIHRoaXMuX3JlZmxvdygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIEludGVyY2hhbmdlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEludGVyY2hhbmdlLnByb3RvdHlwZS5fZXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuZm5kdG4uaW50ZXJjaGFuZ2UnLCBGb3VuZGF0aW9uLnV0aWwudGhyb3R0bGUodGhpcy5fcmVmbG93LmJpbmQodGhpcyksIDUwKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIEludGVyY2hhbmdlIHVwb24gRE9NIGNoYW5nZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEludGVyY2hhbmdlLnByb3RvdHlwZS5fcmVmbG93ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdGNoO1xuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcnVsZSwgYnV0IG9ubHkgc2F2ZSB0aGUgbGFzdCBtYXRjaFxuICAgIGZvciAodmFyIGkgaW4gdGhpcy5ydWxlcykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzW2ldO1xuXG4gICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEocnVsZS5xdWVyeSkubWF0Y2hlcykge1xuICAgICAgICBtYXRjaCA9IHJ1bGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB0aGlzLnJlcGxhY2UobWF0Y2gucGF0aCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBGb3VuZGF0aW9uIGJyZWFrcG9pbnRzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIEludGVyY2hhbmdlLlNQRUNJQUxfUVVFUklFUyBvYmplY3QuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSW50ZXJjaGFuZ2UucHJvdG90eXBlLl9hZGRCcmVha3BvaW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgaW4gRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LnF1ZXJpZXMpIHtcbiAgICAgIHZhciBxdWVyeSA9IEZvdW5kYXRpb24uTWVkaWFRdWVyeS5xdWVyaWVzW2ldO1xuICAgICAgSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTW3F1ZXJ5Lm5hbWVdID0gcXVlcnkudmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIEludGVyY2hhbmdlIGVsZW1lbnQgZm9yIHRoZSBwcm92aWRlZCBtZWRpYSBxdWVyeSArIGNvbnRlbnQgcGFpcmluZ3NcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0aGF0IGlzIGFuIEludGVyY2hhbmdlIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtBcnJheX0gc2NlbmFyaW9zIC0gQXJyYXkgb2Ygb2JqZWN0cyB0aGF0IGhhdmUgJ21xJyBhbmQgJ3BhdGgnIGtleXMgd2l0aCBjb3JyZXNwb25kaW5nIGtleXNcbiAgICovXG4gIEludGVyY2hhbmdlLnByb3RvdHlwZS5fZ2VuZXJhdGVSdWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBydWxlc0xpc3QgPSBbXTtcbiAgICB2YXIgcnVsZXM7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJ1bGVzKSB7XG4gICAgICBydWxlcyA9IHRoaXMub3B0aW9ucy5ydWxlcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBydWxlcyA9IHRoaXMuJGVsZW1lbnQuZGF0YSgnaW50ZXJjaGFuZ2UnKS5tYXRjaCgvXFxbLio/XFxdL2cpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gcnVsZXMpIHtcbiAgICAgIHZhciBydWxlID0gcnVsZXNbaV0uc2xpY2UoMSwgLTEpLnNwbGl0KCcsICcpO1xuICAgICAgdmFyIHBhdGggPSBydWxlLnNsaWNlKDAsIC0xKS5qb2luKCcnKTtcbiAgICAgIHZhciBxdWVyeSA9IHJ1bGVbcnVsZS5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKEludGVyY2hhbmdlLlNQRUNJQUxfUVVFUklFU1txdWVyeV0pIHtcbiAgICAgICAgcXVlcnkgPSBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnldO1xuICAgICAgfVxuXG4gICAgICBydWxlc0xpc3QucHVzaCh7XG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzTGlzdDtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBgc3JjYCBwcm9wZXJ0eSBvZiBhbiBpbWFnZSwgb3IgY2hhbmdlIHRoZSBIVE1MIG9mIGEgY29udGFpbmVyLCB0byB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIFBhdGggdG8gdGhlIGltYWdlIG9yIEhUTUwgcGFydGlhbC5cbiAgICogQGZpcmVzIEludGVyY2hhbmdlI3JlcGxhY2VkXG4gICAqL1xuICBJbnRlcmNoYW5nZS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aCA9PT0gcGF0aCkgcmV0dXJuO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIFJlcGxhY2luZyBpbWFnZXNcbiAgICBpZiAodGhpcy4kZWxlbWVudFswXS5ub2RlTmFtZSA9PT0gJ0lNRycpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignc3JjJywgcGF0aCkubG9hZChmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcigncmVwbGFjZWQuemYuaW50ZXJjaGFuZ2UnKTtcbiAgICAgICAgX3RoaXMuY3VycmVudFBhdGggPSBwYXRoO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFJlcGxhY2luZyBiYWNrZ3JvdW5kIGltYWdlc1xuICAgIGVsc2UgaWYgKHBhdGgubWF0Y2goL1xcLihnaWZ8anBnfGpwZWd8dGlmZnxwbmcpKFs/I10uKik/L2kpKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmNzcyh7ICdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybCgnK3BhdGgrJyknIH0pO1xuICAgIH1cbiAgICAvLyBSZXBsYWNpbmcgSFRNTFxuICAgIGVsc2Uge1xuICAgICAgJC5nZXQocGF0aCwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQuaHRtbChyZXNwb25zZSk7XG4gICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3JlcGxhY2VkLnpmLmludGVyY2hhbmdlJyk7XG4gICAgICAgIF90aGlzLmN1cnJlbnRQYXRoID0gcGF0aDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGludGVyY2hhbmdlLlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIEludGVyY2hhbmdlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgICAvL1RPRE8gdGhpcy5cbiAgfTtcbiAgRm91bmRhdGlvbi5wbHVnaW4oSW50ZXJjaGFuZ2UsICdJbnRlcmNoYW5nZScpO1xuXG4gIC8vIEV4cG9ydHMgZm9yIEFNRC9Ccm93c2VyaWZ5XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKVxuICAgIG1vZHVsZS5leHBvcnRzID0gSW50ZXJjaGFuZ2U7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nKVxuICAgIGRlZmluZShbJ2ZvdW5kYXRpb24nXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSW50ZXJjaGFuZ2U7XG4gICAgfSk7XG5cbn0oRm91bmRhdGlvbiwgalF1ZXJ5KTtcbiIsIi8qKlxuICogTWFnZWxsYW4gbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLm1hZ2VsbGFuXG4gKi9cbiFmdW5jdGlvbihGb3VuZGF0aW9uLCAkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBNYWdlbGxhbi5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBNYWdlbGxhbiNpbml0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGZ1bmN0aW9uIE1hZ2VsbGFuKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgID0gJC5leHRlbmQoe30sIE1hZ2VsbGFuLmRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2luaXQoKTtcblxuICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXG4gICAqL1xuICBNYWdlbGxhbi5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgdGltZSwgaW4gbXMsIHRoZSBhbmltYXRlZCBzY3JvbGxpbmcgc2hvdWxkIHRha2UgYmV0d2VlbiBsb2NhdGlvbnMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDUwMFxuICAgICAqL1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gICAgLyoqXG4gICAgICogQW5pbWF0aW9uIHN0eWxlIHRvIHVzZSB3aGVuIHNjcm9sbGluZyBiZXR3ZWVuIGxvY2F0aW9ucy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ2Vhc2UtaW4tb3V0J1xuICAgICAqL1xuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyB0byB1c2UgYXMgYSBtYXJrZXIgZm9yIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDUwXG4gICAgICovXG4gICAgdGhyZXNob2xkOiA1MCxcbiAgICAvKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBhY3RpdmUgbG9jYXRpb25zIGxpbmsgb24gdGhlIG1hZ2VsbGFuIGNvbnRhaW5lci5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ2FjdGl2ZSdcbiAgICAgKi9cbiAgICBhY3RpdmVDbGFzczogJ2FjdGl2ZScsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRoZSBzY3JpcHQgdG8gbWFuaXB1bGF0ZSB0aGUgdXJsIG9mIHRoZSBjdXJyZW50IHBhZ2UsIGFuZCBpZiBzdXBwb3J0ZWQsIGFsdGVyIHRoZSBoaXN0b3J5LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSB0cnVlXG4gICAgICovXG4gICAgZGVlcExpbmtpbmc6IGZhbHNlXG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBNYWdlbGxhbiBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgZXF1YWxpemVyIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYWdlbGxhbi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ21hZ2VsbGFuJyksXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICB0aGlzLiR0YXJnZXRzID0gJCgnW2RhdGEtbWFnZWxsYW4tdGFyZ2V0XScpO1xuICAgIHRoaXMuJGxpbmtzID0gdGhpcy4kZWxlbWVudC5maW5kKCdhJyk7XG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICdkYXRhLXJlc2l6ZSc6IGlkLFxuICAgICAgJ2RhdGEtc2Nyb2xsJzogaWQsXG4gICAgICAnaWQnOiBpZFxuICAgIH0pO1xuICAgIHRoaXMuJGFjdGl2ZSA9ICQoKTtcbiAgICB0aGlzLnNjcm9sbFBvcyA9IHBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCwgMTApO1xuXG4gICAgdGhpcy5fZXZlbnRzKCk7XG4gIH07XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGFuIGFycmF5IG9mIHBpeGVsIHZhbHVlcyB0aGF0IGFyZSB0aGUgZGVtYXJjYXRpb24gbGluZXMgYmV0d2VlbiBsb2NhdGlvbnMgb24gdGhlIHBhZ2UuXG4gICAqIENhbiBiZSBpbnZva2VkIGlmIG5ldyBlbGVtZW50cyBhcmUgYWRkZWQgb3IgdGhlIHNpemUgb2YgYSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIE1hZ2VsbGFuLnByb3RvdHlwZS5jYWxjUG9pbnRzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBib2R5ID0gZG9jdW1lbnQuYm9keSxcbiAgICAgICAgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy53aW5IZWlnaHQgPSBNYXRoLnJvdW5kKE1hdGgubWF4KHdpbmRvdy5pbm5lckhlaWdodCwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQpKTtcbiAgICB0aGlzLmRvY0hlaWdodCA9IE1hdGgucm91bmQoTWF0aC5tYXgoYm9keS5zY3JvbGxIZWlnaHQsIGJvZHkub2Zmc2V0SGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwub2Zmc2V0SGVpZ2h0KSk7XG5cbiAgICB0aGlzLiR0YXJnZXRzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIHZhciAkdGFyID0gJCh0aGlzKSxcbiAgICAgICAgICBwdCA9IE1hdGgucm91bmQoJHRhci5vZmZzZXQoKS50b3AgLSBfdGhpcy5vcHRpb25zLnRocmVzaG9sZCk7XG4gICAgICAkdGFyLnRhcmdldFBvaW50ID0gcHQ7XG4gICAgICBfdGhpcy5wb2ludHMucHVzaChwdCk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIE1hZ2VsbGFuLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFnZWxsYW4ucHJvdG90eXBlLl9ldmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAkYm9keSA9ICQoJ2h0bWwsIGJvZHknKSxcbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICBkdXJhdGlvbjogX3RoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6ICAgX3RoaXMub3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgfTtcblxuICAgICQod2luZG93KS5vbmUoJ2xvYWQnLCBmdW5jdGlvbigpe1xuICAgICAgX3RoaXMuY2FsY1BvaW50cygpO1xuICAgICAgX3RoaXMuX3VwZGF0ZUFjdGl2ZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IHRoaXMucmVmbG93LmJpbmQodGhpcyksXG4gICAgICAnc2Nyb2xsbWUuemYudHJpZ2dlcic6IHRoaXMuX3VwZGF0ZUFjdGl2ZS5iaW5kKHRoaXMpXG4gICAgfSkub24oJ2NsaWNrLnpmLm1hZ2VsbGFuJywgJ2FbaHJlZl49XCIjXCJdJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBhcnJpdmFsICAgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpLFxuICAgICAgICAgICAgc2Nyb2xsUG9zID0gJChhcnJpdmFsKS5vZmZzZXQoKS50b3AgLSBfdGhpcy5vcHRpb25zLnRocmVzaG9sZCAvIDI7XG5cbiAgICAgICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGlzIGRpc2FibGVkIGZvciB0aGlzIHBsdWdpbiBjdXJyZW50bHlcbiAgICAgICAgLy8gRm91bmRhdGlvbi5Nb3ZlKF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sICRib2R5LCBmdW5jdGlvbigpe1xuICAgICAgICAgICRib2R5LnN0b3AodHJ1ZSkuYW5pbWF0ZSh7XG4gICAgICAgICAgICBzY3JvbGxUb3A6IHNjcm9sbFBvc1xuICAgICAgICAgIH0sIG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgIC8vIH0pO1xuICB9O1xuICAvKipcbiAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgTWFnZWxsYW4gdXBvbiBET00gY2hhbmdlXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgTWFnZWxsYW4ucHJvdG90eXBlLnJlZmxvdyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5jYWxjUG9pbnRzKCk7XG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlKCk7XG4gIH07XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB2aXNpYmlsaXR5IG9mIGFuIGFjdGl2ZSBsb2NhdGlvbiBsaW5rLCBhbmQgdXBkYXRlcyB0aGUgdXJsIGhhc2ggZm9yIHRoZSBwYWdlLCBpZiBkZWVwTGlua2luZyBlbmFibGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIE1hZ2VsbGFuI3VwZGF0ZVxuICAgKi9cbiAgTWFnZWxsYW4ucHJvdG90eXBlLl91cGRhdGVBY3RpdmUgPSBmdW5jdGlvbigvKmV2dCwgZWxlbSwgc2Nyb2xsUG9zKi8pe1xuICAgIHZhciB3aW5Qb3MgPSAvKnNjcm9sbFBvcyB8fCovIHBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCwgMTApLFxuICAgICAgICBjdXJJZHg7XG5cbiAgICBpZih3aW5Qb3MgKyB0aGlzLndpbkhlaWdodCA9PT0gdGhpcy5kb2NIZWlnaHQpeyBjdXJJZHggPSB0aGlzLnBvaW50cy5sZW5ndGggLSAxOyB9XG4gICAgZWxzZSBpZih3aW5Qb3MgPCB0aGlzLnBvaW50c1swXSl7IGN1cklkeCA9IDA7IH1cbiAgICBlbHNle1xuICAgICAgdmFyIGlzRG93biA9IHRoaXMuc2Nyb2xsUG9zIDwgd2luUG9zLFxuICAgICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBjdXJWaXNpYmxlID0gdGhpcy5wb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHAsIGkpe1xuICAgICAgICAgICAgcmV0dXJuIGlzRG93biA/IHAgPD0gd2luUG9zIDogcCAtIF90aGlzLm9wdGlvbnMudGhyZXNob2xkIDw9IHdpblBvczsvLyYmIHdpblBvcyA+PSBfdGhpcy5wb2ludHNbaSAtMV0gLSBfdGhpcy5vcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgICB9KTtcbiAgICAgIGN1cklkeCA9IGN1clZpc2libGUubGVuZ3RoID8gY3VyVmlzaWJsZS5sZW5ndGggLSAxIDogMDtcbiAgICB9XG5cbiAgICB0aGlzLiRhY3RpdmUucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcbiAgICB0aGlzLiRhY3RpdmUgPSB0aGlzLiRsaW5rcy5lcShjdXJJZHgpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG5cbiAgICBpZih0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpe1xuICAgICAgdmFyIGhhc2ggPSB0aGlzLiRhY3RpdmVbMF0uZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICBpZih3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpe1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgaGFzaCk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2Nyb2xsUG9zID0gd2luUG9zO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gbWFnZWxsYW4gaXMgZmluaXNoZWQgdXBkYXRpbmcgdG8gdGhlIG5ldyBhY3RpdmUgZWxlbWVudC5cbiAgICAgKiBAZXZlbnQgTWFnZWxsYW4jdXBkYXRlXG4gICAgICovXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd1cGRhdGUuemYubWFnZWxsYW4nLCBbdGhpcy4kYWN0aXZlXSk7XG4gIH07XG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBNYWdlbGxhbiBhbmQgcmVzZXRzIHRoZSB1cmwgb2YgdGhlIHdpbmRvdy5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBNYWdlbGxhbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyIC56Zi5tYWdlbGxhbicpXG4gICAgICAgIC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblxuICAgIHZhciBoYXNoID0gdGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXG4gICAgd2luZG93LmxvY2F0aW9uLmhhc2gucmVwbGFjZShoYXNoLCAnJyk7XG5cbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH07XG4gIEZvdW5kYXRpb24ucGx1Z2luKE1hZ2VsbGFuLCAnTWFnZWxsYW4nKTtcblxuICAvLyBFeHBvcnRzIGZvciBBTUQvQnJvd3NlcmlmeVxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJylcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1hZ2VsbGFuO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICBkZWZpbmUoWydmb3VuZGF0aW9uJ10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hZ2VsbGFuO1xuICAgIH0pO1xuXG59KEZvdW5kYXRpb24sIGpRdWVyeSk7XG4iLCIvKipcbiAqIE9mZkNhbnZhcyBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ub2ZmY2FudmFzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICovXG4hZnVuY3Rpb24oJCwgRm91bmRhdGlvbikge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBvZmYtY2FudmFzIHdyYXBwZXIuXG4gKiBAY2xhc3NcbiAqIEBmaXJlcyBPZmZDYW52YXMjaW5pdFxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGluaXRpYWxpemUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gKi9cbmZ1bmN0aW9uIE9mZkNhbnZhcyhlbGVtZW50LCBvcHRpb25zKSB7XG4gIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgT2ZmQ2FudmFzLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gIHRoaXMuJGxhc3RUcmlnZ2VyID0gJCgpO1xuXG4gIHRoaXMuX2luaXQoKTtcbiAgdGhpcy5fZXZlbnRzKCk7XG5cbiAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzKTtcbn1cblxuT2ZmQ2FudmFzLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogQWxsb3cgdGhlIHVzZXIgdG8gY2xpY2sgb3V0c2lkZSBvZiB0aGUgbWVudSB0byBjbG9zZSBpdC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBjbG9zZU9uQ2xpY2s6IHRydWUsXG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSBpbiBtcyB0aGUgb3BlbiBhbmQgY2xvc2UgdHJhbnNpdGlvbiByZXF1aXJlcy4gSWYgbm9uZSBzZWxlY3RlZCwgcHVsbHMgZnJvbSBib2R5IHN0eWxlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDUwMFxuICAgKi9cbiAgdHJhbnNpdGlvblRpbWU6IDAsXG4gIC8qKlxuICAgKiBEaXJlY3Rpb24gdGhlIG9mZmNhbnZhcyBvcGVucyBmcm9tLiBEZXRlcm1pbmVzIGNsYXNzIGFwcGxpZWQgdG8gYm9keS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBsZWZ0XG4gICAqL1xuICBwb3NpdGlvbjogJ2xlZnQnLFxuICAvKipcbiAgICogRm9yY2UgdGhlIHBhZ2UgdG8gc2Nyb2xsIHRvIHRvcCBvbiBvcGVuLlxuICAgKi9cbiAgZm9yY2VUb3A6IHRydWUsXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgb2ZmY2FudmFzIHRvIGJlIHN0aWNreSB3aGlsZSBvcGVuLiBEb2VzIG5vdGhpbmcgaWYgU2FzcyBvcHRpb24gYCRtYWluY29udGVudC1wcmV2ZW50LXNjcm9sbCA9PT0gdHJ1ZWAuXG4gICAqIFBlcmZvcm1hbmNlIGluIFNhZmFyaSBPU1gvaU9TIGlzIG5vdCBncmVhdC5cbiAgICovXG4gIC8vIGlzU3RpY2t5OiBmYWxzZSxcbiAgLyoqXG4gICAqIEFsbG93IHRoZSBvZmZjYW52YXMgdG8gcmVtYWluIG9wZW4gZm9yIGNlcnRhaW4gYnJlYWtwb2ludHMuIENhbiBiZSB1c2VkIHdpdGggYGlzU3RpY2t5YC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgaXNSZXZlYWxlZDogZmFsc2UsXG4gIC8qKlxuICAgKiBCcmVha3BvaW50IGF0IHdoaWNoIHRvIHJldmVhbC4gSlMgd2lsbCB1c2UgYSBSZWdFeHAgdG8gdGFyZ2V0IHN0YW5kYXJkIGNsYXNzZXMsIGlmIGNoYW5naW5nIGNsYXNzbmFtZXMsIHBhc3MgeW91ciBjbGFzcyBAYHJldmVhbENsYXNzYC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSByZXZlYWwtZm9yLWxhcmdlXG4gICAqL1xuICByZXZlYWxPbjogbnVsbCxcbiAgLyoqXG4gICAqIEZvcmNlIGZvY3VzIHRvIHRoZSBvZmZjYW52YXMgb24gb3Blbi4gSWYgdHJ1ZSwgd2lsbCBmb2N1cyB0aGUgb3BlbmluZyB0cmlnZ2VyIG9uIGNsb3NlLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGF1dG9Gb2N1czogdHJ1ZSxcbiAgLyoqXG4gICAqIENsYXNzIHVzZWQgdG8gZm9yY2UgYW4gb2ZmY2FudmFzIHRvIHJlbWFpbiBvcGVuLiBGb3VuZGF0aW9uIGRlZmF1bHRzIGZvciB0aGlzIGFyZSBgcmV2ZWFsLWZvci1sYXJnZWAgJiBgcmV2ZWFsLWZvci1tZWRpdW1gLlxuICAgKiBAb3B0aW9uXG4gICAqIFRPRE8gaW1wcm92ZSB0aGUgcmVnZXggdGVzdGluZyBmb3IgdGhpcy5cbiAgICogQGV4YW1wbGUgcmV2ZWFsLWZvci1sYXJnZVxuICAgKi9cbiAgcmV2ZWFsQ2xhc3M6ICdyZXZlYWwtZm9yLSdcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIG9mZi1jYW52YXMgd3JhcHBlciBieSBhZGRpbmcgdGhlIGV4aXQgb3ZlcmxheSAoaWYgbmVlZGVkKS5cbiAqIEBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuT2ZmQ2FudmFzLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJyk7XG5cbiAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgLy8gRmluZCB0cmlnZ2VycyB0aGF0IGFmZmVjdCB0aGlzIGVsZW1lbnQgYW5kIGFkZCBhcmlhLWV4cGFuZGVkIHRvIHRoZW1cbiAgJChkb2N1bWVudClcbiAgICAuZmluZCgnW2RhdGEtb3Blbj1cIicraWQrJ1wiXSwgW2RhdGEtY2xvc2U9XCInK2lkKydcIl0sIFtkYXRhLXRvZ2dsZT1cIicraWQrJ1wiXScpXG4gICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKVxuICAgIC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgaWQpO1xuXG4gIC8vIEFkZCBhIGNsb3NlIHRyaWdnZXIgb3ZlciB0aGUgYm9keSBpZiBuZWNlc3NhcnlcbiAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spe1xuICAgIGlmKCQoJy5qcy1vZmYtY2FudmFzLWV4aXQnKS5sZW5ndGgpe1xuICAgICAgdGhpcy4kZXhpdGVyID0gJCgnLmpzLW9mZi1jYW52YXMtZXhpdCcpO1xuICAgIH1lbHNle1xuICAgICAgdmFyIGV4aXRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZXhpdGVyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnanMtb2ZmLWNhbnZhcy1leGl0Jyk7XG4gICAgICAkKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykuYXBwZW5kKGV4aXRlcik7XG5cbiAgICAgIHRoaXMuJGV4aXRlciA9ICQoZXhpdGVyKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9wdGlvbnMuaXNSZXZlYWxlZCA9IHRoaXMub3B0aW9ucy5pc1JldmVhbGVkIHx8IG5ldyBSZWdFeHAodGhpcy5vcHRpb25zLnJldmVhbENsYXNzLCAnZycpLnRlc3QodGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUpO1xuXG4gIGlmKHRoaXMub3B0aW9ucy5pc1JldmVhbGVkKXtcbiAgICB0aGlzLm9wdGlvbnMucmV2ZWFsT24gPSB0aGlzLm9wdGlvbnMucmV2ZWFsT24gfHwgdGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goLyhyZXZlYWwtZm9yLW1lZGl1bXxyZXZlYWwtZm9yLWxhcmdlKS9nKVswXS5zcGxpdCgnLScpWzJdO1xuICAgIHRoaXMuX3NldE1RQ2hlY2tlcigpO1xuICB9XG4gIGlmKCF0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUpe1xuICAgIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSA9IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoJCgnW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXScpWzBdKS50cmFuc2l0aW9uRHVyYXRpb24pICogMTAwMDtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGhhbmRsZXJzIHRvIHRoZSBvZmYtY2FudmFzIHdyYXBwZXIgYW5kIHRoZSBleGl0IG92ZXJsYXkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbk9mZkNhbnZhcy5wcm90b3R5cGUuX2V2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLiRlbGVtZW50Lm9uKHtcbiAgICAnb3Blbi56Zi50cmlnZ2VyJzogdGhpcy5vcGVuLmJpbmQodGhpcyksXG4gICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmNsb3NlLmJpbmQodGhpcyksXG4gICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcbiAgICAna2V5ZG93bi56Zi5vZmZjYW52YXMnOiB0aGlzLl9oYW5kbGVLZXlib2FyZC5iaW5kKHRoaXMpXG4gIH0pO1xuXG4gIGlmICh0aGlzLiRleGl0ZXIubGVuZ3RoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLiRleGl0ZXIub24oeydjbGljay56Zi5vZmZjYW52YXMnOiB0aGlzLmNsb3NlLmJpbmQodGhpcyl9KTtcbiAgfVxufTtcbi8qKlxuICogQXBwbGllcyBldmVudCBsaXN0ZW5lciBmb3IgZWxlbWVudHMgdGhhdCB3aWxsIHJldmVhbCBhdCBjZXJ0YWluIGJyZWFrcG9pbnRzLlxuICogQHByaXZhdGVcbiAqL1xuT2ZmQ2FudmFzLnByb3RvdHlwZS5fc2V0TVFDaGVja2VyID0gZnVuY3Rpb24oKXtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uKCl7XG4gICAgaWYoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QoX3RoaXMub3B0aW9ucy5yZXZlYWxPbikpe1xuICAgICAgX3RoaXMucmV2ZWFsKHRydWUpO1xuICAgIH1lbHNle1xuICAgICAgX3RoaXMucmV2ZWFsKGZhbHNlKTtcbiAgICB9XG4gIH0pLm9uZSgnbG9hZC56Zi5vZmZjYW52YXMnLCBmdW5jdGlvbigpe1xuICAgIGlmKEZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KF90aGlzLm9wdGlvbnMucmV2ZWFsT24pKXtcbiAgICAgIF90aGlzLnJldmVhbCh0cnVlKTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogSGFuZGxlcyB0aGUgcmV2ZWFsaW5nL2hpZGluZyB0aGUgb2ZmLWNhbnZhcyBhdCBicmVha3BvaW50cywgbm90IHRoZSBzYW1lIGFzIG9wZW4uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmV2ZWFsZWQgLSB0cnVlIGlmIGVsZW1lbnQgc2hvdWxkIGJlIHJldmVhbGVkLlxuICogQGZ1bmN0aW9uXG4gKi9cbk9mZkNhbnZhcy5wcm90b3R5cGUucmV2ZWFsID0gZnVuY3Rpb24oaXNSZXZlYWxlZCl7XG4gIHZhciAkY2xvc2VyID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1jbG9zZV0nKTtcbiAgaWYoaXNSZXZlYWxlZCl7XG4gICAgLy8gaWYoIXRoaXMub3B0aW9ucy5mb3JjZVRvcCl7XG4gICAgLy8gICB2YXIgc2Nyb2xsUG9zID0gcGFyc2VJbnQod2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICAvLyAgIHRoaXMuJGVsZW1lbnRbMF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCcgKyBzY3JvbGxQb3MgKyAncHgpJztcbiAgICAvLyB9XG4gICAgLy8gaWYodGhpcy5vcHRpb25zLmlzU3RpY2t5KXsgdGhpcy5fc3RpY2soKTsgfVxuICAgIGlmKCRjbG9zZXIubGVuZ3RoKXsgJGNsb3Nlci5oaWRlKCk7IH1cbiAgfWVsc2V7XG4gICAgLy8gaWYodGhpcy5vcHRpb25zLmlzU3RpY2t5IHx8ICF0aGlzLm9wdGlvbnMuZm9yY2VUb3Ape1xuICAgIC8vICAgdGhpcy4kZWxlbWVudFswXS5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICAvLyAgICQod2luZG93KS5vZmYoJ3Njcm9sbC56Zi5vZmZjYW52YXMnKTtcbiAgICAvLyB9XG4gICAgaWYoJGNsb3Nlci5sZW5ndGgpe1xuICAgICAgJGNsb3Nlci5zaG93KCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSBvZmYtY2FudmFzIG1lbnUuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IG9iamVjdCBwYXNzZWQgZnJvbSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7alF1ZXJ5fSB0cmlnZ2VyIC0gZWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGUgb2ZmLWNhbnZhcyB0byBvcGVuLlxuICogQGZpcmVzIE9mZkNhbnZhcyNvcGVuZWRcbiAqL1xuT2ZmQ2FudmFzLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24oZXZlbnQsIHRyaWdnZXIpIHtcbiAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSl7IHJldHVybjsgfVxuICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgJGJvZHkgPSAkKGRvY3VtZW50LmJvZHkpO1xuICAkKCdib2R5Jykuc2Nyb2xsVG9wKDApO1xuICAvLyB3aW5kb3cucGFnZVlPZmZzZXQgPSAwO1xuXG4gIC8vIGlmKCF0aGlzLm9wdGlvbnMuZm9yY2VUb3Ape1xuICAvLyAgIHZhciBzY3JvbGxQb3MgPSBwYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQpO1xuICAvLyAgIHRoaXMuJGVsZW1lbnRbMF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCcgKyBzY3JvbGxQb3MgKyAncHgpJztcbiAgLy8gICBpZih0aGlzLiRleGl0ZXIubGVuZ3RoKXtcbiAgLy8gICAgIHRoaXMuJGV4aXRlclswXS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsJyArIHNjcm9sbFBvcyArICdweCknO1xuICAvLyAgIH1cbiAgLy8gfVxuICAvKipcbiAgICogRmlyZXMgd2hlbiB0aGUgb2ZmLWNhbnZhcyBtZW51IG9wZW5zLlxuICAgKiBAZXZlbnQgT2ZmQ2FudmFzI29wZW5lZFxuICAgKi9cbiAgRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSwgdGhpcy4kZWxlbWVudCwgZnVuY3Rpb24oKXtcbiAgICAkKCdbZGF0YS1vZmYtY2FudmFzLXdyYXBwZXJdJykuYWRkQ2xhc3MoJ2lzLW9mZi1jYW52YXMtb3BlbiBpcy1vcGVuLScrIF90aGlzLm9wdGlvbnMucG9zaXRpb24pO1xuXG4gICAgX3RoaXMuJGVsZW1lbnRcbiAgICAgIC5hZGRDbGFzcygnaXMtb3BlbicpXG4gICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKVxuICAgICAgLnRyaWdnZXIoJ29wZW5lZC56Zi5vZmZjYW52YXMnKTtcblxuICAgIC8vIGlmKF90aGlzLm9wdGlvbnMuaXNTdGlja3kpe1xuICAgIC8vICAgX3RoaXMuX3N0aWNrKCk7XG4gICAgLy8gfVxuICB9KTtcbiAgaWYodHJpZ2dlcil7XG4gICAgdGhpcy4kbGFzdFRyaWdnZXIgPSB0cmlnZ2VyLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuICB9XG4gIGlmKHRoaXMub3B0aW9ucy5hdXRvRm9jdXMpe1xuICAgIHRoaXMuJGVsZW1lbnQub25lKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgZnVuY3Rpb24oKXtcbiAgICAgIF90aGlzLiRlbGVtZW50LmZpbmQoJ2EsIGJ1dHRvbicpLmVxKDApLmZvY3VzKCk7XG4gICAgfSk7XG4gIH1cbn07XG4vKipcbiAqIEFsbG93cyB0aGUgb2ZmY2FudmFzIHRvIGFwcGVhciBzdGlja3kgdXRpbGl6aW5nIHRyYW5zbGF0ZSBwcm9wZXJ0aWVzLlxuICogQHByaXZhdGVcbiAqL1xuLy8gT2ZmQ2FudmFzLnByb3RvdHlwZS5fc3RpY2sgPSBmdW5jdGlvbigpe1xuLy8gICB2YXIgZWxTdHlsZSA9IHRoaXMuJGVsZW1lbnRbMF0uc3R5bGU7XG4vL1xuLy8gICBpZih0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKXtcbi8vICAgICB2YXIgZXhpdFN0eWxlID0gdGhpcy4kZXhpdGVyWzBdLnN0eWxlO1xuLy8gICB9XG4vL1xuLy8gICAkKHdpbmRvdykub24oJ3Njcm9sbC56Zi5vZmZjYW52YXMnLCBmdW5jdGlvbihlKXtcbi8vICAgICBjb25zb2xlLmxvZyhlKTtcbi8vICAgICB2YXIgcGFnZVkgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4vLyAgICAgZWxTdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsJyArIHBhZ2VZICsgJ3B4KSc7XG4vLyAgICAgaWYoZXhpdFN0eWxlICE9PSB1bmRlZmluZWQpeyBleGl0U3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCcgKyBwYWdlWSArICdweCknOyB9XG4vLyAgIH0pO1xuLy8gICAvLyB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3N0dWNrLnpmLm9mZmNhbnZhcycpO1xuLy8gfTtcbi8qKlxuICogQ2xvc2VzIHRoZSBvZmYtY2FudmFzIG1lbnUuXG4gKiBAZnVuY3Rpb25cbiAqIEBmaXJlcyBPZmZDYW52YXMjY2xvc2VkXG4gKi9cbk9mZkNhbnZhcy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYoIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSl7IHJldHVybjsgfVxuXG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgIEZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUsIHRoaXMuJGVsZW1lbnQsIGZ1bmN0aW9uKCl7XG4gICAgJCgnW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXScpLnJlbW92ZUNsYXNzKCdpcy1vZmYtY2FudmFzLW9wZW4gaXMtb3Blbi0nK190aGlzLm9wdGlvbnMucG9zaXRpb24pO1xuXG4gICAgX3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4nKTtcbiAgICAvLyBGb3VuZGF0aW9uLl9yZWZsb3coKTtcbiAgfSk7XG4gIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgb2ZmLWNhbnZhcyBtZW51IG9wZW5zLlxuICAgICAqIEBldmVudCBPZmZDYW52YXMjY2xvc2VkXG4gICAgICovXG4gICAgICAudHJpZ2dlcignY2xvc2VkLnpmLm9mZmNhbnZhcycpO1xuICAvLyBpZihfdGhpcy5vcHRpb25zLmlzU3RpY2t5IHx8ICFfdGhpcy5vcHRpb25zLmZvcmNlVG9wKXtcbiAgLy8gICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gIC8vICAgICBfdGhpcy4kZWxlbWVudFswXS5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgLy8gICAgICQod2luZG93KS5vZmYoJ3Njcm9sbC56Zi5vZmZjYW52YXMnKTtcbiAgLy8gICB9LCB0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUpO1xuICAvLyB9XG5cbiAgdGhpcy4kbGFzdFRyaWdnZXIuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xufTtcblxuLyoqXG4gKiBUb2dnbGVzIHRoZSBvZmYtY2FudmFzIG1lbnUgb3BlbiBvciBjbG9zZWQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IG9iamVjdCBwYXNzZWQgZnJvbSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7alF1ZXJ5fSB0cmlnZ2VyIC0gZWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGUgb2ZmLWNhbnZhcyB0byBvcGVuLlxuICovXG5PZmZDYW52YXMucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKGV2ZW50LCB0cmlnZ2VyKSB7XG4gIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpIHtcbiAgICB0aGlzLmNsb3NlKGV2ZW50LCB0cmlnZ2VyKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLm9wZW4oZXZlbnQsIHRyaWdnZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMga2V5Ym9hcmQgaW5wdXQgd2hlbiBkZXRlY3RlZC4gV2hlbiB0aGUgZXNjYXBlIGtleSBpcyBwcmVzc2VkLCB0aGUgb2ZmLWNhbnZhcyBtZW51IGNsb3NlcywgYW5kIGZvY3VzIGlzIHJlc3RvcmVkIHRvIHRoZSBlbGVtZW50IHRoYXQgb3BlbmVkIHRoZSBtZW51LlxuICogQGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5PZmZDYW52YXMucHJvdG90eXBlLl9oYW5kbGVLZXlib2FyZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGlmIChldmVudC53aGljaCAhPT0gMjcpIHJldHVybjtcblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgdGhpcy5jbG9zZSgpO1xuICB0aGlzLiRsYXN0VHJpZ2dlci5mb2N1cygpO1xufTtcbi8qKlxuICogRGVzdHJveXMgdGhlIG9mZmNhbnZhcyBwbHVnaW4uXG4gKiBAZnVuY3Rpb25cbiAqL1xuT2ZmQ2FudmFzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgLy9UT0RPIG1ha2UgdGhpcy4uLlxufTtcblxuRm91bmRhdGlvbi5wbHVnaW4oT2ZmQ2FudmFzLCAnT2ZmQ2FudmFzJyk7XG5cbn0oalF1ZXJ5LCBGb3VuZGF0aW9uKTtcbiIsIi8qKlxuICogT3JiaXQgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLm9yYml0XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50aW1lckFuZEltYWdlTG9hZGVyXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRvdWNoXG4gKi9cbiFmdW5jdGlvbigkLCBGb3VuZGF0aW9uKXtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBvcmJpdCBjYXJvdXNlbC5cbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGZ1bmN0aW9uIE9yYml0KGVsZW1lbnQsIG9wdGlvbnMpe1xuICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBPcmJpdC5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdPcmJpdCcsIHtcbiAgICAgICAgJ2x0cic6IHtcbiAgICAgICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnXG4gICAgICAgIH0sXG4gICAgICAgICdydGwnOiB7XG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAnbmV4dCcsXG4gICAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ3ByZXZpb3VzJ1xuICAgICAgICB9XG4gICAgfSk7XG4gIH1cbiAgT3JiaXQuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIEpTIHRvIGxvYWRCdWxsZXRzLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSB0cnVlXG4gICAgICovXG4gICAgYnVsbGV0czogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgSlMgdG8gYXBwbHkgZXZlbnQgbGlzdGVuZXJzIHRvIG5hdiBidXR0b25zXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9cbiAgICBuYXZCdXR0b25zOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ3NsaWRlLWluLXJpZ2h0J1xuICAgICAqL1xuICAgIGFuaW1JbkZyb21SaWdodDogJ3NsaWRlLWluLXJpZ2h0JyxcbiAgICAvKipcbiAgICAgKiBtb3Rpb24tdWkgYW5pbWF0aW9uIGNsYXNzIHRvIGFwcGx5XG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdzbGlkZS1vdXQtcmlnaHQnXG4gICAgICovXG4gICAgYW5pbU91dFRvUmlnaHQ6ICdzbGlkZS1vdXQtcmlnaHQnLFxuICAgIC8qKlxuICAgICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ3NsaWRlLWluLWxlZnQnXG4gICAgICpcbiAgICAgKi9cbiAgICBhbmltSW5Gcm9tTGVmdDogJ3NsaWRlLWluLWxlZnQnLFxuICAgIC8qKlxuICAgICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ3NsaWRlLW91dC1sZWZ0J1xuICAgICAqL1xuICAgIGFuaW1PdXRUb0xlZnQ6ICdzbGlkZS1vdXQtbGVmdCcsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIE9yYml0IHRvIGF1dG9tYXRpY2FsbHkgYW5pbWF0ZSBvbiBwYWdlIGxvYWQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9cbiAgICBhdXRvUGxheTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgdGltZSwgaW4gbXMsIGJldHdlZW4gc2xpZGUgdHJhbnNpdGlvbnNcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgNTAwMFxuICAgICAqL1xuICAgIHRpbWVyRGVsYXk6IDUwMDAsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIE9yYml0IHRvIGluZmluaXRlbHkgbG9vcCB0aHJvdWdoIHRoZSBzbGlkZXNcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL1xuICAgIGluZmluaXRlV3JhcDogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIE9yYml0IHNsaWRlcyB0byBiaW5kIHRvIHN3aXBlIGV2ZW50cyBmb3IgbW9iaWxlLCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHV0aWwgbGlicmFyeVxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSB0cnVlXG4gICAgICovXG4gICAgc3dpcGU6IHRydWUsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRoZSB0aW1pbmcgZnVuY3Rpb24gdG8gcGF1c2UgYW5pbWF0aW9uIG9uIGhvdmVyLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSB0cnVlXG4gICAgICovXG4gICAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEFsbG93cyBPcmJpdCB0byBiaW5kIGtleWJvYXJkIGV2ZW50cyB0byB0aGUgc2xpZGVyLCB0byBhbmltYXRlIGZyYW1lcyB3aXRoIGFycm93IGtleXNcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL1xuICAgIGFjY2Vzc2libGU6IHRydWUsXG4gICAgLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgY29udGFpbmVyIG9mIE9yYml0XG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdvcmJpdC1jb250YWluZXInXG4gICAgICovXG4gICAgY29udGFpbmVyQ2xhc3M6ICdvcmJpdC1jb250YWluZXInLFxuICAgIC8qKlxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gaW5kaXZpZHVhbCBzbGlkZXMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdvcmJpdC1zbGlkZSdcbiAgICAgKi9cbiAgICBzbGlkZUNsYXNzOiAnb3JiaXQtc2xpZGUnLFxuICAgIC8qKlxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGJ1bGxldCBjb250YWluZXIuIFlvdSdyZSB3ZWxjb21lLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnb3JiaXQtYnVsbGV0cydcbiAgICAgKi9cbiAgICBib3hPZkJ1bGxldHM6ICdvcmJpdC1idWxsZXRzJyxcbiAgICAvKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBgbmV4dGAgbmF2aWdhdGlvbiBidXR0b24uXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdvcmJpdC1uZXh0J1xuICAgICAqL1xuICAgIG5leHRDbGFzczogJ29yYml0LW5leHQnLFxuICAgIC8qKlxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGBwcmV2aW91c2AgbmF2aWdhdGlvbiBidXR0b24uXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdvcmJpdC1wcmV2aW91cydcbiAgICAgKi9cbiAgICBwcmV2Q2xhc3M6ICdvcmJpdC1wcmV2aW91cydcbiAgfTtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4gYnkgY3JlYXRpbmcgalF1ZXJ5IGNvbGxlY3Rpb25zLCBzZXR0aW5nIGF0dHJpYnV0ZXMsIGFuZCBzdGFydGluZyB0aGUgYW5pbWF0aW9uLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE9yYml0LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy4kd3JhcHBlciA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpO1xuICAgIHRoaXMuJHNsaWRlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcyk7XG4gICAgdmFyICRpbWFnZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2ltZycpLFxuICAgICAgICBpbml0QWN0aXZlID0gdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpO1xuXG4gICAgaWYoIWluaXRBY3RpdmUubGVuZ3RoKXtcbiAgICAgIHRoaXMuJHNsaWRlcy5lcSgwKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYoJGltYWdlcy5sZW5ndGgpe1xuICAgICAgRm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZCgkaW1hZ2VzLCB0aGlzLl9wcmVwYXJlRm9yT3JiaXQuYmluZCh0aGlzKSk7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLl9wcmVwYXJlRm9yT3JiaXQoKTsvL2hlaGVcbiAgICB9XG5cbiAgICBpZih0aGlzLm9wdGlvbnMuYnVsbGV0cyl7XG4gICAgICB0aGlzLl9sb2FkQnVsbGV0cygpO1xuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgaWYodGhpcy5vcHRpb25zLmF1dG9QbGF5KXtcbiAgICAgIHRoaXMuZ2VvU3luYygpO1xuICAgIH1cbiAgICBpZih0aGlzLm9wdGlvbnMuYWNjZXNzaWJsZSl7IC8vIGFsbG93IHdyYXBwZXIgdG8gYmUgZm9jdXNhYmxlIHRvIGVuYWJsZSBhcnJvdyBuYXZpZ2F0aW9uXG4gICAgICB0aGlzLiR3cmFwcGVyLmF0dHIoJ3RhYmluZGV4JywgMCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIGJ1bGxldHMsIGlmIHRoZXkgYXJlIGJlaW5nIHVzZWQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgT3JiaXQucHJvdG90eXBlLl9sb2FkQnVsbGV0cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy4kYnVsbGV0cyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMuYm94T2ZCdWxsZXRzKS5maW5kKCdidXR0b24nKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgYSBgdGltZXJgIG9iamVjdCBvbiB0aGUgb3JiaXQsIGFuZCBzdGFydHMgdGhlIGNvdW50ZXIgZm9yIHRoZSBuZXh0IHNsaWRlLlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIE9yYml0LnByb3RvdHlwZS5nZW9TeW5jID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMudGltZXIgPSBuZXcgRm91bmRhdGlvbi5UaW1lcihcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgIHtkdXJhdGlvbjogdGhpcy5vcHRpb25zLnRpbWVyRGVsYXksXG4gICAgICAgICAgICAgICAgICAgICAgIGluZmluaXRlOiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIHRoaXMudGltZXIuc3RhcnQoKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgd3JhcHBlciBhbmQgc2xpZGUgaGVpZ2h0cyBmb3IgdGhlIG9yYml0LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE9yYml0LnByb3RvdHlwZS5fcHJlcGFyZUZvck9yYml0ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX3NldFdyYXBwZXJIZWlnaHQoZnVuY3Rpb24obWF4KXtcbiAgICAgIF90aGlzLl9zZXRTbGlkZUhlaWdodChtYXgpO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQ2FsdWxhdGVzIHRoZSBoZWlnaHQgb2YgZWFjaCBzbGlkZSBpbiB0aGUgY29sbGVjdGlvbiwgYW5kIHVzZXMgdGhlIHRhbGxlc3Qgb25lIGZvciB0aGUgd3JhcHBlciBoZWlnaHQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSB3aGVuIGNvbXBsZXRlLlxuICAgKi9cbiAgT3JiaXQucHJvdG90eXBlLl9zZXRXcmFwcGVySGVpZ2h0ID0gZnVuY3Rpb24oY2Ipey8vcmV3cml0ZSB0aGlzIHRvIGBmb3JgIGxvb3BcbiAgICB2YXIgbWF4ID0gMCwgdGVtcCwgY291bnRlciA9IDA7XG5cbiAgICB0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdGVtcCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgJCh0aGlzKS5hdHRyKCdkYXRhLXNsaWRlJywgY291bnRlcik7XG5cbiAgICAgIGlmKGNvdW50ZXIpey8vaWYgbm90IHRoZSBmaXJzdCBzbGlkZSwgc2V0IGNzcyBwb3NpdGlvbiBhbmQgZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgICAkKHRoaXMpLmNzcyh7J3Bvc2l0aW9uJzogJ3JlbGF0aXZlJywgJ2Rpc3BsYXknOiAnbm9uZSd9KTtcbiAgICAgIH1cbiAgICAgIG1heCA9IHRlbXAgPiBtYXggPyB0ZW1wIDogbWF4O1xuICAgICAgY291bnRlcisrO1xuICAgIH0pO1xuXG4gICAgaWYoY291bnRlciA9PT0gdGhpcy4kc2xpZGVzLmxlbmd0aCl7XG4gICAgICB0aGlzLiR3cmFwcGVyLmNzcyh7J2hlaWdodCc6IG1heH0pOy8vb25seSBjaGFuZ2UgdGhlIHdyYXBwZXIgaGVpZ2h0IHByb3BlcnR5IG9uY2UuXG4gICAgICBjYihtYXgpOy8vZmlyZSBjYWxsYmFjayB3aXRoIG1heCBoZWlnaHQgZGltZW5zaW9uLlxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heC1oZWlnaHQgb2YgZWFjaCBzbGlkZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBPcmJpdC5wcm90b3R5cGUuX3NldFNsaWRlSGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KXtcbiAgICB0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgJCh0aGlzKS5jc3MoJ21heC1oZWlnaHQnLCBoZWlnaHQpO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gYmFzaWNhbGx5IGV2ZXJ5dGhpbmcgd2l0aGluIHRoZSBlbGVtZW50LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE9yYml0LnByb3RvdHlwZS5fZXZlbnRzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyoqTm93IHVzaW5nIGN1c3RvbSBldmVudCAtIHRoYW5rcyB0bzoqKlxuICAgIC8vKiogICAgICBZb2hhaSBBcmFyYXQgb2YgVG9yb250byAgICAgICoqXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBpZih0aGlzLm9wdGlvbnMuc3dpcGUpe1xuICAgICAgdGhpcy4kc2xpZGVzLm9mZignc3dpcGVsZWZ0LnpmLm9yYml0IHN3aXBlcmlnaHQuemYub3JiaXQnKVxuICAgICAgLm9uKCdzd2lwZWxlZnQuemYub3JiaXQnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZSh0cnVlKTtcbiAgICAgIH0pLm9uKCdzd2lwZXJpZ2h0LnpmLm9yYml0JywgZnVuY3Rpb24oZSl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBpZih0aGlzLm9wdGlvbnMuYXV0b1BsYXkpe1xuICAgICAgdGhpcy4kc2xpZGVzLm9uKCdjbGljay56Zi5vcmJpdCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgIF90aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicsIF90aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpID8gZmFsc2UgOiB0cnVlKTtcbiAgICAgICAgX3RoaXMudGltZXJbX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJykgPyAncGF1c2UnIDogJ3N0YXJ0J10oKTtcbiAgICAgIH0pO1xuICAgICAgaWYodGhpcy5vcHRpb25zLnBhdXNlT25Ib3Zlcil7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ21vdXNlZW50ZXIuemYub3JiaXQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgIF90aGlzLnRpbWVyLnBhdXNlKCk7XG4gICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLm9yYml0JywgZnVuY3Rpb24oKXtcbiAgICAgICAgICBpZighX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJykpe1xuICAgICAgICAgICAgX3RoaXMudGltZXIuc3RhcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMub3B0aW9ucy5uYXZCdXR0b25zKXtcbiAgICAgIHZhciAkY29udHJvbHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLm5leHRDbGFzcyArICcsIC4nICsgdGhpcy5vcHRpb25zLnByZXZDbGFzcyk7XG4gICAgICAkY29udHJvbHMuYXR0cigndGFiaW5kZXgnLCAwKVxuICAgICAgICAvL2Fsc28gbmVlZCB0byBoYW5kbGUgZW50ZXIvcmV0dXJuIGFuZCBzcGFjZWJhciBrZXkgcHJlc3Nlc1xuICAgICAgICAgICAgICAgLm9uKCdjbGljay56Zi5vcmJpdCB0b3VjaGVuZC56Zi5vcmJpdCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKCQodGhpcykuaGFzQ2xhc3MoX3RoaXMub3B0aW9ucy5uZXh0Q2xhc3MpKTtcbiAgICAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmKHRoaXMub3B0aW9ucy5idWxsZXRzKXtcbiAgICAgIHRoaXMuJGJ1bGxldHMub24oJ2NsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0JywgZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoL2lzLWFjdGl2ZS9nLnRlc3QodGhpcy5jbGFzc05hbWUpKXsgcmV0dXJuIGZhbHNlOyB9Ly9pZiB0aGlzIGlzIGFjdGl2ZSwga2ljayBvdXQgb2YgZnVuY3Rpb24uXG4gICAgICAgIHZhciBpZHggPSAkKHRoaXMpLmRhdGEoJ3NsaWRlJyksXG4gICAgICAgICAgICBsdHIgPSBpZHggPiBfdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpLmRhdGEoJ3NsaWRlJyksXG4gICAgICAgICAgICAkc2xpZGUgPSBfdGhpcy4kc2xpZGVzLmVxKGlkeCk7XG5cbiAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUobHRyLCAkc2xpZGUsIGlkeCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLiR3cmFwcGVyLmFkZCh0aGlzLiRidWxsZXRzKS5vbigna2V5ZG93bi56Zi5vcmJpdCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgX3RoaXMsIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZShmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uKCkgeyAvLyBpZiBidWxsZXQgaXMgZm9jdXNlZCwgbWFrZSBzdXJlIGZvY3VzIG1vdmVzXG4gICAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKF90aGlzLiRidWxsZXRzKSkge1xuICAgICAgICAgICAgX3RoaXMuJGJ1bGxldHMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgY3VycmVudCBzbGlkZSB0byBhIG5ldyBvbmUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzTFRSIC0gZmxhZyBpZiB0aGUgc2xpZGUgc2hvdWxkIG1vdmUgbGVmdCB0byByaWdodC5cbiAgICogQHBhcmFtIHtqUXVlcnl9IGNob3NlblNsaWRlIC0gdGhlIGpRdWVyeSBlbGVtZW50IG9mIHRoZSBzbGlkZSB0byBzaG93IG5leHQsIGlmIG9uZSBpcyBzZWxlY3RlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIHRoZSBpbmRleCBvZiB0aGUgbmV3IHNsaWRlIGluIGl0cyBjb2xsZWN0aW9uLCBpZiBvbmUgY2hvc2VuLlxuICAgKiBAZmlyZXMgT3JiaXQjc2xpZGVjaGFuZ2VcbiAgICovXG4gIE9yYml0LnByb3RvdHlwZS5jaGFuZ2VTbGlkZSA9IGZ1bmN0aW9uKGlzTFRSLCBjaG9zZW5TbGlkZSwgaWR4KXtcbiAgICB2YXIgJGN1clNsaWRlID0gdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpLmVxKDApO1xuXG5cbiAgICBpZigvbXVpL2cudGVzdCgkY3VyU2xpZGVbMF0uY2xhc3NOYW1lKSl7IHJldHVybiBmYWxzZTsgfS8vaWYgdGhlIHNsaWRlIGlzIGN1cnJlbnRseSBhbmltYXRpbmcsIGtpY2sgb3V0IG9mIHRoZSBmdW5jdGlvblxuXG4gICAgdmFyICRmaXJzdFNsaWRlID0gdGhpcy4kc2xpZGVzLmZpcnN0KCksXG4gICAgICAgICRsYXN0U2xpZGUgPSB0aGlzLiRzbGlkZXMubGFzdCgpLFxuICAgICAgICBkaXJJbiA9IGlzTFRSID8gJ1JpZ2h0JyA6ICdMZWZ0JyxcbiAgICAgICAgZGlyT3V0ID0gaXNMVFIgPyAnTGVmdCcgOiAnUmlnaHQnLFxuICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgICRuZXdTbGlkZTtcblxuICAgIGlmKCFjaG9zZW5TbGlkZSl7Ly9tb3N0IG9mIHRoZSB0aW1lLCB0aGlzIHdpbGwgYmUgYXV0byBwbGF5ZWQgb3IgY2xpY2tlZCBmcm9tIHRoZSBuYXZCdXR0b25zLlxuICAgICAgJG5ld1NsaWRlID0gaXNMVFIgPyAvL2lmIHdyYXBwaW5nIGVuYWJsZWQsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGBuZXh0YCBvciBgcHJldmAgc2libGluZywgaWYgbm90LCBzZWxlY3QgdGhlIGZpcnN0IG9yIGxhc3Qgc2xpZGUgdG8gZmlsbCBpbi4gaWYgd3JhcHBpbmcgbm90IGVuYWJsZWQsIGF0dGVtcHQgdG8gc2VsZWN0IGBuZXh0YCBvciBgcHJldmAsIGlmIHRoZXJlJ3Mgbm90aGluZyB0aGVyZSwgdGhlIGZ1bmN0aW9uIHdpbGwga2ljayBvdXQgb24gbmV4dCBzdGVwLiBDUkFaWSBORVNURUQgVEVSTkFSSUVTISEhISFcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5pbmZpbml0ZVdyYXAgPyAkY3VyU2xpZGUubmV4dCgnLicgKyB0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykubGVuZ3RoID8gJGN1clNsaWRlLm5leHQoJy4nICsgdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpIDogJGZpcnN0U2xpZGUgOiAkY3VyU2xpZGUubmV4dCgnLicgKyB0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpLy9waWNrIG5leHQgc2xpZGUgaWYgbW92aW5nIGxlZnQgdG8gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgOlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5vcHRpb25zLmluZmluaXRlV3JhcCA/ICRjdXJTbGlkZS5wcmV2KCcuJyArIHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKS5sZW5ndGggPyAkY3VyU2xpZGUucHJldignLicgKyB0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykgOiAkbGFzdFNsaWRlIDogJGN1clNsaWRlLnByZXYoJy4nICsgdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpKTsvL3BpY2sgcHJldiBzbGlkZSBpZiBtb3ZpbmcgcmlnaHQgdG8gbGVmdFxuICAgIH1lbHNle1xuICAgICAgJG5ld1NsaWRlID0gY2hvc2VuU2xpZGU7XG4gICAgfVxuICAgIGlmKCRuZXdTbGlkZS5sZW5ndGgpe1xuICAgICAgaWYodGhpcy5vcHRpb25zLmJ1bGxldHMpe1xuICAgICAgICBpZHggPSBpZHggfHwgdGhpcy4kc2xpZGVzLmluZGV4KCRuZXdTbGlkZSk7Ly9ncmFiIGluZGV4IHRvIHVwZGF0ZSBidWxsZXRzXG4gICAgICAgIHRoaXMuX3VwZGF0ZUJ1bGxldHMoaWR4KTtcbiAgICAgIH1cbiAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbihcbiAgICAgICAgJG5ld1NsaWRlLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5jc3Moeydwb3NpdGlvbic6ICdhYnNvbHV0ZScsICd0b3AnOiAwfSksXG4gICAgICAgIHRoaXMub3B0aW9uc1snYW5pbUluRnJvbScgKyBkaXJJbl0sXG4gICAgICAgIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgJG5ld1NsaWRlLmNzcyh7J3Bvc2l0aW9uJzogJ3JlbGF0aXZlJywgJ2Rpc3BsYXknOiAnYmxvY2snfSlcbiAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgICAgICB9KTtcblxuICAgICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dChcbiAgICAgICAgJGN1clNsaWRlLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKSxcbiAgICAgICAgdGhpcy5vcHRpb25zWydhbmltT3V0VG8nICsgZGlyT3V0XSxcbiAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAkY3VyU2xpZGUucmVtb3ZlQXR0cignYXJpYS1saXZlJyk7XG4gICAgICAgICAgaWYoX3RoaXMub3B0aW9ucy5hdXRvUGxheSl7XG4gICAgICAgICAgICBfdGhpcy50aW1lci5yZXN0YXJ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vZG8gc3R1ZmY/XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVHJpZ2dlcnMgd2hlbiB0aGUgc2xpZGUgaGFzIGZpbmlzaGVkIGFuaW1hdGluZyBpbi5cbiAgICAgICAgICAgKiBAZXZlbnQgT3JiaXQjc2xpZGVjaGFuZ2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzbGlkZWNoYW5nZS56Zi5vcmJpdCcsIFskbmV3U2xpZGVdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBidWxsZXRzLCBpZiBkaXNwbGF5ZWQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHNsaWRlLlxuICAgKi9cbiAgT3JiaXQucHJvdG90eXBlLl91cGRhdGVCdWxsZXRzID0gZnVuY3Rpb24oaWR4KXtcbiAgICB2YXIgJG9sZEJ1bGxldCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMuYm94T2ZCdWxsZXRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKCcuaXMtYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmJsdXIoKSxcbiAgICAgICAgc3BhbiA9ICRvbGRCdWxsZXQuZmluZCgnc3BhbjpsYXN0JykuZGV0YWNoKCksXG4gICAgICAgICRuZXdCdWxsZXQgPSB0aGlzLiRidWxsZXRzLmVxKGlkeCkuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLmFwcGVuZChzcGFuKTtcbiAgfTtcbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjYXJvdXNlbCBhbmQgaGlkZXMgdGhlIGVsZW1lbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgT3JiaXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICAgIGRlbGV0ZSB0aGlzLnRpbWVyO1xuICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYub3JiaXQnKS5maW5kKCcqJykub2ZmKCcuemYub3JiaXQnKS5lbmQoKS5oaWRlKCk7XG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9O1xuXG4gIEZvdW5kYXRpb24ucGx1Z2luKE9yYml0LCAnT3JiaXQnKTtcblxufShqUXVlcnksIHdpbmRvdy5Gb3VuZGF0aW9uKTtcbiIsIi8qKlxuICogUmVzcG9uc2l2ZU1lbnUgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnJlc3BvbnNpdmVNZW51XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYWNjb3JkaW9uTWVudVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5kcmlsbGRvd25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuZHJvcGRvd24tbWVudVxuICovXG4hZnVuY3Rpb24oRm91bmRhdGlvbiwgJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVGhlIHBsdWdpbiBtYXRjaGVzIHRoZSBwbHVnaW4gY2xhc3NlcyB3aXRoIHRoZXNlIHBsdWdpbiBpbnN0YW5jZXMuXG4gIHZhciBNZW51UGx1Z2lucyA9IHtcbiAgICBkcm9wZG93bjoge1xuICAgICAgY3NzQ2xhc3M6ICdkcm9wZG93bicsXG4gICAgICBwbHVnaW46IEZvdW5kYXRpb24uX3BsdWdpbnNbJ2Ryb3Bkb3duLW1lbnUnXSB8fCBudWxsXG4gICAgfSxcbiAgICBkcmlsbGRvd246IHtcbiAgICAgIGNzc0NsYXNzOiAnZHJpbGxkb3duJyxcbiAgICAgIHBsdWdpbjogRm91bmRhdGlvbi5fcGx1Z2luc1snZHJpbGxkb3duJ10gfHwgbnVsbFxuICAgIH0sXG4gICAgYWNjb3JkaW9uOiB7XG4gICAgICBjc3NDbGFzczogJ2FjY29yZGlvbi1tZW51JyxcbiAgICAgIHBsdWdpbjogRm91bmRhdGlvbi5fcGx1Z2luc1snYWNjb3JkaW9uLW1lbnUnXSB8fCBudWxsXG4gICAgfVxuICB9O1xuXG4gIC8vIFtQSF0gTWVkaWEgcXVlcmllc1xuICB2YXIgcGhNZWRpYSA9IHtcbiAgICBzbWFsbDogJyhtaW4td2lkdGg6IDBweCknLFxuICAgIG1lZGl1bTogJyhtaW4td2lkdGg6IDY0MHB4KSdcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHJlc3BvbnNpdmUgbWVudS5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBSZXNwb25zaXZlTWVudSNpbml0XG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93biBtZW51LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBmdW5jdGlvbiBSZXNwb25zaXZlTWVudShlbGVtZW50KSB7XG4gICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgdGhpcy5ydWxlcyA9IHRoaXMuJGVsZW1lbnQuZGF0YSgncmVzcG9uc2l2ZS1tZW51Jyk7XG4gICAgdGhpcy5jdXJyZW50TXEgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFBsdWdpbiA9IG51bGw7XG5cbiAgICB0aGlzLl9pbml0KCk7XG4gICAgdGhpcy5fZXZlbnRzKCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG5cbiAgUmVzcG9uc2l2ZU1lbnUuZGVmYXVsdHMgPSB7fTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIE1lbnUgYnkgcGFyc2luZyB0aGUgY2xhc3NlcyBmcm9tIHRoZSAnZGF0YS1SZXNwb25zaXZlTWVudScgYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJlc3BvbnNpdmVNZW51LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBydWxlc1RyZWUgPSB7fTtcblxuICAgIC8vIFBhcnNlIHJ1bGVzIGZyb20gXCJjbGFzc2VzXCIgaW4gZGF0YSBhdHRyaWJ1dGVcbiAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzLnNwbGl0KCcgJyk7XG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggZXZlcnkgcnVsZSBmb3VuZFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBydWxlID0gcnVsZXNbaV0uc3BsaXQoJy0nKTtcbiAgICAgIHZhciBydWxlU2l6ZSA9IHJ1bGUubGVuZ3RoID4gMSA/IHJ1bGVbMF0gOiAnc21hbGwnO1xuICAgICAgdmFyIHJ1bGVQbHVnaW4gPSBydWxlLmxlbmd0aCA+IDEgPyBydWxlWzFdIDogcnVsZVswXTtcblxuICAgICAgaWYgKE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dICE9PSBudWxsKSB7XG4gICAgICAgIHJ1bGVzVHJlZVtydWxlU2l6ZV0gPSBNZW51UGx1Z2luc1tydWxlUGx1Z2luXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzID0gcnVsZXNUcmVlO1xuXG4gICAgaWYgKCEkLmlzRW1wdHlPYmplY3QocnVsZXNUcmVlKSkge1xuICAgICAgdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgdGhlIE1lbnUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmVzcG9uc2l2ZU1lbnUucHJvdG90eXBlLl9ldmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCBmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xuICAgIH0pO1xuICAgIC8vICQod2luZG93KS5vbigncmVzaXplLnpmLlJlc3BvbnNpdmVNZW51JywgZnVuY3Rpb24oKSB7XG4gICAgLy8gICBfdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcbiAgICAvLyB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBjdXJyZW50IHNjcmVlbiB3aWR0aCBhZ2FpbnN0IGF2YWlsYWJsZSBtZWRpYSBxdWVyaWVzLiBJZiB0aGUgbWVkaWEgcXVlcnkgaGFzIGNoYW5nZWQsIGFuZCB0aGUgcGx1Z2luIG5lZWRlZCBoYXMgY2hhbmdlZCwgdGhlIHBsdWdpbnMgd2lsbCBzd2FwIG91dC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSZXNwb25zaXZlTWVudS5wcm90b3R5cGUuX2NoZWNrTWVkaWFRdWVyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdGNoZWRNcSwgX3RoaXMgPSB0aGlzO1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHJ1bGUgYW5kIGZpbmQgdGhlIGxhc3QgbWF0Y2hpbmcgcnVsZVxuICAgICQuZWFjaCh0aGlzLnJ1bGVzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdChrZXkpKSB7XG4gICAgICAgIG1hdGNoZWRNcSA9IGtleTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE5vIG1hdGNoPyBObyBkaWNlXG4gICAgaWYgKCFtYXRjaGVkTXEpIHJldHVybjtcblxuICAgIC8vIFBsdWdpbiBhbHJlYWR5IGluaXRpYWxpemVkPyBXZSBnb29kXG4gICAgaWYgKHRoaXMuY3VycmVudFBsdWdpbiBpbnN0YW5jZW9mIHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5wbHVnaW4pIHJldHVybjtcblxuICAgIC8vIFJlbW92ZSBleGlzdGluZyBwbHVnaW4tc3BlY2lmaWMgQ1NTIGNsYXNzZXNcbiAgICAkLmVhY2goTWVudVBsdWdpbnMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIF90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHZhbHVlLmNzc0NsYXNzKTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCB0aGUgQ1NTIGNsYXNzIGZvciB0aGUgbmV3IHBsdWdpblxuICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5ydWxlc1ttYXRjaGVkTXFdLmNzc0NsYXNzKTtcblxuICAgIC8vIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgbmV3IHBsdWdpblxuICAgIGlmICh0aGlzLmN1cnJlbnRQbHVnaW4pIHRoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCk7XG4gICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbmV3IHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5wbHVnaW4odGhpcy4kZWxlbWVudCwge30pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgcGx1Z2luIG9uIHRoaXMgZWxlbWVudCwgYXMgd2VsbCBhcyB0aGUgd2luZG93IHJlc2l6ZSBoYW5kbGVyIHRoYXQgc3dpdGNoZXMgdGhlIHBsdWdpbnMgb3V0LlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIFJlc3BvbnNpdmVNZW51LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTtcbiAgICAkKHdpbmRvdykub2ZmKCcuemYuUmVzcG9uc2l2ZU1lbnUnKTtcbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH07XG4gIEZvdW5kYXRpb24ucGx1Z2luKFJlc3BvbnNpdmVNZW51LCAnUmVzcG9uc2l2ZU1lbnUnKTtcblxufShGb3VuZGF0aW9uLCBqUXVlcnkpO1xuIiwiLyoqXG4gKiBSZXNwb25zaXZlVG9nZ2xlIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5yZXNwb25zaXZlVG9nZ2xlXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqL1xuIWZ1bmN0aW9uKCQsIEZvdW5kYXRpb24pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgVGFiIEJhci5cbiAqIEBjbGFzc1xuICogQGZpcmVzIFJlc3BvbnNpdmVUb2dnbGUjaW5pdFxuICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGF0dGFjaCB0YWIgYmFyIGZ1bmN0aW9uYWxpdHkgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gKi9cbmZ1bmN0aW9uIFJlc3BvbnNpdmVUb2dnbGUoZWxlbWVudCwgb3B0aW9ucykge1xuICB0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFJlc3BvbnNpdmVUb2dnbGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICB0aGlzLl9pbml0KCk7XG4gIHRoaXMuX2V2ZW50cygpO1xuXG4gIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG59XG5cblJlc3BvbnNpdmVUb2dnbGUuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBUaGUgYnJlYWtwb2ludCBhZnRlciB3aGljaCB0aGUgbWVudSBpcyBhbHdheXMgc2hvd24sIGFuZCB0aGUgdGFiIGJhciBpcyBoaWRkZW4uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ21lZGl1bSdcbiAgICovXG4gIGhpZGVGb3I6ICdtZWRpdW0nXG59O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSB0YWIgYmFyIGJ5IGZpbmRpbmcgdGhlIHRhcmdldCBlbGVtZW50LCB0b2dnbGluZyBlbGVtZW50LCBhbmQgcnVubmluZyB1cGRhdGUoKS5cbiAqIEBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuUmVzcG9uc2l2ZVRvZ2dsZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRhcmdldElEID0gdGhpcy4kZWxlbWVudC5kYXRhKCdyZXNwb25zaXZlLXRvZ2dsZScpO1xuICBpZiAoIXRhcmdldElEKSB7XG4gICAgY29uc29sZS5lcnJvcignWW91ciB0YWIgYmFyIG5lZWRzIGFuIElEIG9mIGEgTWVudSBhcyB0aGUgdmFsdWUgb2YgZGF0YS10YWItYmFyLicpO1xuICB9XG5cbiAgdGhpcy4kdGFyZ2V0TWVudSA9ICQoJyMnK3RhcmdldElEKTtcbiAgdGhpcy4kdG9nZ2xlciA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtdG9nZ2xlXScpO1xuXG4gIHRoaXMuX3VwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBBZGRzIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyBmb3IgdGhlIHRhYiBiYXIgdG8gd29yay5cbiAqIEBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuUmVzcG9uc2l2ZVRvZ2dsZS5wcm90b3R5cGUuX2V2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpO1xuXG4gIHRoaXMuJHRvZ2dsZXIub24oJ2NsaWNrLnpmLnJlc3BvbnNpdmVUb2dnbGUnLCB0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyB0aGUgY3VycmVudCBtZWRpYSBxdWVyeSB0byBkZXRlcm1pbmUgaWYgdGhlIHRhYiBiYXIgc2hvdWxkIGJlIHZpc2libGUgb3IgaGlkZGVuLlxuICogQGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5SZXNwb25zaXZlVG9nZ2xlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIE1vYmlsZVxuICBpZiAoIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5oaWRlRm9yKSkge1xuICAgIHRoaXMuJGVsZW1lbnQuc2hvdygpO1xuICAgIHRoaXMuJHRhcmdldE1lbnUuaGlkZSgpO1xuICB9XG5cbiAgLy8gRGVza3RvcFxuICBlbHNlIHtcbiAgICB0aGlzLiRlbGVtZW50LmhpZGUoKTtcbiAgICB0aGlzLiR0YXJnZXRNZW51LnNob3coKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUb2dnbGVzIHRoZSBlbGVtZW50IGF0dGFjaGVkIHRvIHRoZSB0YWIgYmFyLiBUaGUgdG9nZ2xlIG9ubHkgaGFwcGVucyBpZiB0aGUgc2NyZWVuIGlzIHNtYWxsIGVub3VnaCB0byBhbGxvdyBpdC5cbiAqIEBmdW5jdGlvblxuICogQGZpcmVzIFJlc3BvbnNpdmVUb2dnbGUjdG9nZ2xlZFxuICovXG5SZXNwb25zaXZlVG9nZ2xlLnByb3RvdHlwZS50b2dnbGVNZW51ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLmhpZGVGb3IpKSB7XG4gICAgdGhpcy4kdGFyZ2V0TWVudS50b2dnbGUoMCk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBlbGVtZW50IGF0dGFjaGVkIHRvIHRoZSB0YWIgYmFyIHRvZ2dsZXMuXG4gICAgICogQGV2ZW50IFJlc3BvbnNpdmVUb2dnbGUjdG9nZ2xlZFxuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigndG9nZ2xlZC56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7XG4gIH1cbn07XG5SZXNwb25zaXZlVG9nZ2xlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgLy9UT0RPIHRoaXMuLi5cbn07XG5Gb3VuZGF0aW9uLnBsdWdpbihSZXNwb25zaXZlVG9nZ2xlLCAnUmVzcG9uc2l2ZVRvZ2dsZScpO1xuXG59KGpRdWVyeSwgRm91bmRhdGlvbik7XG4iLCIvKipcbiAqIFJldmVhbCBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ucmV2ZWFsXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmJveFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvbiBpZiB1c2luZyBhbmltYXRpb25zXG4gKi9cbiFmdW5jdGlvbihGb3VuZGF0aW9uLCAkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXZlYWwuXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGZvciB0aGUgbW9kYWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uYWwgcGFyYW1ldGVycy5cbiAgICovXG5cbiAgZnVuY3Rpb24gUmV2ZWFsKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgUmV2ZWFsLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdSZXZlYWwnLCB7XG4gICAgICAnRU5URVInOiAnb3BlbicsXG4gICAgICAnU1BBQ0UnOiAnb3BlbicsXG4gICAgICAnRVNDQVBFJzogJ2Nsb3NlJyxcbiAgICAgICdUQUInOiAndGFiX2ZvcndhcmQnLFxuICAgICAgJ1NISUZUX1RBQic6ICd0YWJfYmFja3dhcmQnXG4gICAgfSk7XG4gIH1cblxuICBSZXZlYWwuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogTW90aW9uLVVJIGNsYXNzIHRvIHVzZSBmb3IgYW5pbWF0ZWQgZWxlbWVudHMuIElmIG5vbmUgdXNlZCwgZGVmYXVsdHMgdG8gc2ltcGxlIHNob3cvaGlkZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ3NsaWRlLWluLWxlZnQnXG4gICAgICovXG4gICAgYW5pbWF0aW9uSW46ICcnLFxuICAgIC8qKlxuICAgICAqIE1vdGlvbi1VSSBjbGFzcyB0byB1c2UgZm9yIGFuaW1hdGVkIGVsZW1lbnRzLiBJZiBub25lIHVzZWQsIGRlZmF1bHRzIHRvIHNpbXBsZSBzaG93L2hpZGUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdzbGlkZS1vdXQtcmlnaHQnXG4gICAgICovXG4gICAgYW5pbWF0aW9uT3V0OiAnJyxcbiAgICAvKipcbiAgICAgKiBUaW1lLCBpbiBtcywgdG8gZGVsYXkgdGhlIG9wZW5pbmcgb2YgYSBtb2RhbCBhZnRlciBhIGNsaWNrIGlmIG5vIGFuaW1hdGlvbiB1c2VkLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxMFxuICAgICAqL1xuICAgIHNob3dEZWxheTogMCxcbiAgICAvKipcbiAgICAgKiBUaW1lLCBpbiBtcywgdG8gZGVsYXkgdGhlIGNsb3Npbmcgb2YgYSBtb2RhbCBhZnRlciBhIGNsaWNrIGlmIG5vIGFuaW1hdGlvbiB1c2VkLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxMFxuICAgICAqL1xuICAgIGhpZGVEZWxheTogMCxcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgYSBjbGljayBvbiB0aGUgYm9keS9vdmVybGF5IHRvIGNsb3NlIHRoZSBtb2RhbC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL1xuICAgIGNsb3NlT25DbGljazogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGNsb3NlIGlmIHRoZSB1c2VyIHByZXNzZXMgdGhlIGBFU0NBUEVgIGtleS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL1xuICAgIGNsb3NlT25Fc2M6IHRydWUsXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgYWxsb3dzIG11bHRpcGxlIG1vZGFscyB0byBiZSBkaXNwbGF5ZWQgYXQgb25jZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9cbiAgICBtdWx0aXBsZU9wZW5lZDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIG1vZGFsIHNob3VsZCBwdXNoIGRvd24gZnJvbSB0aGUgdG9wIG9mIHRoZSBzY3JlZW4uXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDEwMFxuICAgICAqL1xuICAgIHZPZmZzZXQ6IDEwMCxcbiAgICAvKipcbiAgICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggaW4gZnJvbSB0aGUgc2lkZSBvZiB0aGUgc2NyZWVuLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAwXG4gICAgICovXG4gICAgaE9mZnNldDogMCxcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGJlIGZ1bGxzY3JlZW4sIGNvbXBsZXRlbHkgYmxvY2tpbmcgb3V0IHRoZSByZXN0IG9mIHRoZSB2aWV3LiBKUyBjaGVja3MgZm9yIHRoaXMgYXMgd2VsbC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9cbiAgICBmdWxsU2NyZWVuOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQZXJjZW50YWdlIG9mIHNjcmVlbiBoZWlnaHQgdGhlIG1vZGFsIHNob3VsZCBwdXNoIHVwIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgdmlldy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMTBcbiAgICAgKi9cbiAgICBidG1PZmZzZXRQY3Q6IDEwLFxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gZ2VuZXJhdGUgYW4gb3ZlcmxheSBkaXYsIHdoaWNoIHdpbGwgY292ZXIgdGhlIHZpZXcgd2hlbiBtb2RhbCBvcGVucy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL1xuICAgIG92ZXJsYXk6IHRydWUsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRoZSBtb2RhbCB0byByZW1vdmUgYW5kIHJlaW5qZWN0IG1hcmt1cCBvbiBjbG9zZS4gU2hvdWxkIGJlIHRydWUgaWYgdXNpbmcgdmlkZW8gZWxlbWVudHMgdy9vIHVzaW5nIHByb3ZpZGVyJ3MgYXBpLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgICAqL1xuICAgIHJlc2V0T25DbG9zZTogZmFsc2VcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZGFsIGJ5IGFkZGluZyB0aGUgb3ZlcmxheSBhbmQgY2xvc2UgYnV0dG9ucywgKGlmIHNlbGVjdGVkKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJldmVhbC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuaWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJyk7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy4kYW5jaG9yID0gJCgnW2RhdGEtb3Blbj1cIicgKyB0aGlzLmlkICsgJ1wiXScpLmxlbmd0aCA/ICQoJ1tkYXRhLW9wZW49XCInICsgdGhpcy5pZCArICdcIl0nKSA6ICQoJ1tkYXRhLXRvZ2dsZT1cIicgKyB0aGlzLmlkICsgJ1wiXScpO1xuXG4gICAgaWYodGhpcy4kYW5jaG9yLmxlbmd0aCl7XG4gICAgICB2YXIgYW5jaG9ySWQgPSB0aGlzLiRhbmNob3JbMF0uaWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAncmV2ZWFsJyk7XG5cbiAgICAgIHRoaXMuJGFuY2hvci5hdHRyKHtcbiAgICAgICAgJ2FyaWEtY29udHJvbHMnOiB0aGlzLmlkLFxuICAgICAgICAnaWQnOiBhbmNob3JJZCxcbiAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLFxuICAgICAgICAndGFiaW5kZXgnOiAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7J2FyaWEtbGFiZWxsZWRieSc6IGFuY2hvcklkfSk7XG4gICAgfVxuXG4gICAgLy8gdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4gPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmdWxsJyk7XG4gICAgaWYodGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4gfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZnVsbCcpKXtcbiAgICAgIHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuID0gdHJ1ZTtcbiAgICAgIHRoaXMub3B0aW9ucy5vdmVybGF5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmKHRoaXMub3B0aW9ucy5vdmVybGF5KXtcbiAgICAgIHRoaXMuJG92ZXJsYXkgPSB0aGlzLl9tYWtlT3ZlcmxheSh0aGlzLmlkKTtcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgICAncm9sZSc6ICdkaWFsb2cnLFxuICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgICAnZGF0YS15ZXRpLWJveCc6IHRoaXMuaWQsXG4gICAgICAgICdkYXRhLXJlc2l6ZSc6IHRoaXMuaWRcbiAgICB9KTtcblxuICAgIHRoaXMuX2V2ZW50cygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkgZGl2IHRvIGRpc3BsYXkgYmVoaW5kIHRoZSBtb2RhbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJldmVhbC5wcm90b3R5cGUuX21ha2VPdmVybGF5ID0gZnVuY3Rpb24oaWQpe1xuICAgIHZhciAkb3ZlcmxheSA9ICQoJzxkaXY+PC9kaXY+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdyZXZlYWwtb3ZlcmxheScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKHsndGFiaW5kZXgnOiAtMSwgJ2FyaWEtaGlkZGVuJzogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbygnYm9keScpO1xuICAgIGlmKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spe1xuICAgICAgJG92ZXJsYXkuYXR0cih7XG4gICAgICAgICdkYXRhLWNsb3NlJzogaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gJG92ZXJsYXk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBtb2RhbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJldmVhbC5wcm90b3R5cGUuX2V2ZW50cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuJGVsZW1lbnQub24oe1xuICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmNsb3NlLmJpbmQodGhpcyksXG4gICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxuICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiBmdW5jdGlvbigpe1xuICAgICAgICBpZihfdGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSl7XG4gICAgICAgICAgX3RoaXMuX3NldFBvc2l0aW9uKGZ1bmN0aW9uKCl7fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmKHRoaXMuJGFuY2hvci5sZW5ndGgpe1xuICAgICAgdGhpcy4kYW5jaG9yLm9uKCdrZXlkb3duLnpmLnJldmVhbCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBpZihlLndoaWNoID09PSAxMyB8fCBlLndoaWNoID09PSAzMil7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgX3RoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cblxuICAgIGlmKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgdGhpcy5vcHRpb25zLm92ZXJsYXkpe1xuICAgICAgdGhpcy4kb3ZlcmxheS5vZmYoJy56Zi5yZXZlYWwnKS5vbignY2xpY2suemYucmV2ZWFsJywgdGhpcy5jbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW9kYWwgYmVmb3JlIG9wZW5pbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiBwb3NpdGlvbmluZyBpcyBjb21wbGV0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJldmVhbC5wcm90b3R5cGUuX3NldFBvc2l0aW9uID0gZnVuY3Rpb24oY2Ipe1xuICAgIHZhciBlbGVEaW1zID0gRm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLiRlbGVtZW50KTtcbiAgICB2YXIgZWxlUG9zID0gdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4gPyAncmV2ZWFsIGZ1bGwnIDogKGVsZURpbXMuaGVpZ2h0ID49ICgwLjUgKiBlbGVEaW1zLndpbmRvd0RpbXMuaGVpZ2h0KSkgPyAncmV2ZWFsJyA6ICdjZW50ZXInO1xuXG4gICAgaWYoZWxlUG9zID09PSAncmV2ZWFsIGZ1bGwnKXtcbiAgICAgIGNvbnNvbGUubG9nKCdmdWxsJyk7XG4gICAgICAvL3NldCB0byBmdWxsIGhlaWdodC93aWR0aFxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAgIC5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLiRlbGVtZW50LCBudWxsLCBlbGVQb3MsIHRoaXMub3B0aW9ucy52T2Zmc2V0KSlcbiAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICdoZWlnaHQnOiBlbGVEaW1zLndpbmRvd0RpbXMuaGVpZ2h0LFxuICAgICAgICAgICAgJ3dpZHRoJzogZWxlRGltcy53aW5kb3dEaW1zLndpZHRoXG4gICAgICAgICAgfSk7XG4gICAgfWVsc2UgaWYoIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KCdtZWRpdW0nKSB8fCAhRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLiRlbGVtZW50LCBudWxsLCB0cnVlLCBmYWxzZSkpe1xuICAgICAgLy9pZiBzbWFsbGVyIHRoYW4gbWVkaXVtLCByZXNpemUgdG8gMTAwJSB3aWR0aCBtaW51cyBhbnkgY3VzdG9tIEwvUiBtYXJnaW5cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICd3aWR0aCc6IGVsZURpbXMud2luZG93RGltcy53aWR0aCAtICh0aGlzLm9wdGlvbnMuaE9mZnNldCAqIDIpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCwgbnVsbCwgJ2NlbnRlcicsIHRoaXMub3B0aW9ucy52T2Zmc2V0LCB0aGlzLm9wdGlvbnMuaE9mZnNldCkpO1xuICAgICAgLy9mbGFnIGEgYm9vbGVhbiBzbyB3ZSBjYW4gcmVzZXQgdGhlIHNpemUgYWZ0ZXIgdGhlIGVsZW1lbnQgaXMgY2xvc2VkLlxuICAgICAgdGhpcy5jaGFuZ2VkU2l6ZSA9IHRydWU7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAnbWF4LWhlaWdodCc6IGVsZURpbXMud2luZG93RGltcy5oZWlnaHQgLSAodGhpcy5vcHRpb25zLnZPZmZzZXQgKiAodGhpcy5vcHRpb25zLmJ0bU9mZnNldFBjdCAvIDEwMCArIDEpKSxcbiAgICAgICAgICAgICd3aWR0aCc6ICcnXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCwgbnVsbCwgZWxlUG9zLCB0aGlzLm9wdGlvbnMudk9mZnNldCkpO1xuICAgICAgICAgIC8vdGhlIG1heCBoZWlnaHQgYmFzZWQgb24gYSBwZXJjZW50YWdlIG9mIHZlcnRpY2FsIG9mZnNldCBwbHVzIHZlcnRpY2FsIG9mZnNldFxuICAgIH1cblxuICAgIGNiKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBtb2RhbCBjb250cm9sbGVkIGJ5IGB0aGlzLiRhbmNob3JgLCBhbmQgY2xvc2VzIGFsbCBvdGhlcnMgYnkgZGVmYXVsdC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBSZXZlYWwjY2xvc2VBbGxcbiAgICogQGZpcmVzIFJldmVhbCNvcGVuXG4gICAqL1xuICBSZXZlYWwucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgLy9tYWtlIGVsZW1lbnQgaW52aXNpYmxlLCBidXQgcmVtb3ZlIGRpc3BsYXk6IG5vbmUgc28gd2UgY2FuIGdldCBzaXplIGFuZCBwb3NpdGlvbmluZ1xuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLmNzcyh7J3Zpc2liaWxpdHknOiAnaGlkZGVuJ30pXG4gICAgICAgIC5zaG93KClcbiAgICAgICAgLnNjcm9sbFRvcCgwKTtcblxuICAgIHRoaXMuX3NldFBvc2l0aW9uKGZ1bmN0aW9uKCl7XG4gICAgICBfdGhpcy4kZWxlbWVudC5oaWRlKClcbiAgICAgICAgICAgICAgICAgICAuY3NzKHsndmlzaWJpbGl0eSc6ICcnfSk7XG4gICAgICBpZighX3RoaXMub3B0aW9ucy5tdWx0aXBsZU9wZW5lZCl7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIG1vZGFsIG9wZW5zLlxuICAgICAgICAgKiBDbG9zZXMgYW55IG90aGVyIG1vZGFscyB0aGF0IGFyZSBjdXJyZW50bHkgb3BlblxuICAgICAgICAgKiBAZXZlbnQgUmV2ZWFsI2Nsb3NlQWxsXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZW1lLnpmLnJldmVhbCcsIF90aGlzLmlkKTtcbiAgICAgIH1cbiAgICAgIGlmKF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uSW4pe1xuICAgICAgICBpZihfdGhpcy5vcHRpb25zLm92ZXJsYXkpe1xuICAgICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbihfdGhpcy4kb3ZlcmxheSwgJ2ZhZGUtaW4nLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKF90aGlzLiRlbGVtZW50LCBfdGhpcy5vcHRpb25zLmFuaW1hdGlvbkluLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbihfdGhpcy4kZWxlbWVudCwgX3RoaXMub3B0aW9ucy5hbmltYXRpb25JbiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIGlmKF90aGlzLm9wdGlvbnMub3ZlcmxheSl7XG4gICAgICAgICAgX3RoaXMuJG92ZXJsYXkuc2hvdygwLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuc2hvdyhfdGhpcy5vcHRpb25zLnNob3dEZWxheSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBfdGhpcy4kZWxlbWVudC5zaG93KF90aGlzLm9wdGlvbnMuc2hvd0RlbGF5LCBmdW5jdGlvbigpe1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8vIGhhbmRsZSBhY2Nlc3NpYmlsaXR5XG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKHsnYXJpYS1oaWRkZW4nOiBmYWxzZX0pLmF0dHIoJ3RhYmluZGV4JywgLTEpLmZvY3VzKClcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBtb2RhbCBoYXMgc3VjY2Vzc2Z1bGx5IG9wZW5lZC5cbiAgICAgKiBAZXZlbnQgUmV2ZWFsI29wZW5cbiAgICAgKi9cbiAgICAgICAgICAgICAgICAgLnRyaWdnZXIoJ29wZW4uemYucmV2ZWFsJyk7XG5cbiAgICAkKCdib2R5JykuYWRkQ2xhc3MoJ2lzLXJldmVhbC1vcGVuJylcbiAgICAgICAgICAgICAuYXR0cih7J2FyaWEtaGlkZGVuJzogKHRoaXMub3B0aW9ucy5vdmVybGF5IHx8IHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuKSA/IHRydWUgOiBmYWxzZX0pO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIF90aGlzLl9leHRyYUhhbmRsZXJzKCk7XG4gICAgICAvLyBGb3VuZGF0aW9uLnJlZmxvdygpO1xuICAgIH0sIDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGV4dHJhIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgYm9keSBhbmQgd2luZG93IGlmIG5lY2Vzc2FyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJldmVhbC5wcm90b3R5cGUuX2V4dHJhSGFuZGxlcnMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHZpc2libGVGb2N1c2FibGVFbGVtZW50cyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgKlt0YWJpbmRleF0sICpbY29udGVudGVkaXRhYmxlXScpLmZpbHRlcihmdW5jdGlvbigpIHtcbiAgICAgIGlmICghJCh0aGlzKS5pcygnOnZpc2libGUnKSB8fCAkKHRoaXMpLmF0dHIoJ3RhYmluZGV4JykgPCAwKXsgcmV0dXJuIGZhbHNlOyB9Ly9vbmx5IGhhdmUgdmlzaWJsZSBlbGVtZW50cyBhbmQgdGhvc2UgdGhhdCBoYXZlIGEgdGFiaW5kZXggZ3JlYXRlciBvciBlcXVhbCAwXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmKCF0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICYmICF0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbil7XG4gICAgICAkKCdib2R5Jykub24oJ2NsaWNrLnpmLnJldmVhbCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAvLyBpZigpXG4gICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZih0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYyl7XG4gICAgICAkKHdpbmRvdykub24oJ2tleWRvd24uemYucmV2ZWFsJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIGlmICh2aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoID09PSAwKSB7IC8vIG5vIGZvY3VzYWJsZSBlbGVtZW50cyBpbnNpZGUgdGhlIG1vZGFsIGF0IGFsbCwgcHJldmVudCB0YWJiaW5nIGluIGdlbmVyYWxcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgX3RoaXMsIHtcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcbiAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBsb2NrIGZvY3VzIHdpdGhpbiBtb2RhbCB3aGlsZSB0YWJiaW5nXG4gICAgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi56Zi5yZXZlYWwnLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgJHRhcmdldCA9ICQodGhpcyk7XG4gICAgICAvLyBoYW5kbGUga2V5Ym9hcmQgZXZlbnQgd2l0aCBrZXlib2FyZCB1dGlsXG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCBfdGhpcywge1xuICAgICAgICB0YWJfZm9yd2FyZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuZmluZCgnOmZvY3VzJykuaXModmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzLmVxKC0xKSkpIHsgLy8gbGVmdCBtb2RhbCBkb3dud2FyZHMsIHNldHRpbmcgZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgdmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzLmVxKDApLmZvY3VzKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0YWJfYmFja3dhcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLiRlbGVtZW50LmZpbmQoJzpmb2N1cycpLmlzKHZpc2libGVGb2N1c2FibGVFbGVtZW50cy5lcSgwKSkgfHwgdGhpcy4kZWxlbWVudC5pcygnOmZvY3VzJykpIHsgLy8gbGVmdCBtb2RhbCB1cHdhcmRzLCBzZXR0aW5nIGZvY3VzIHRvIGxhc3QgZWxlbWVudFxuICAgICAgICAgICAgdmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzLmVxKC0xKS5mb2N1cygpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCR0YXJnZXQuaXModmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzKSkgeyAvLyBkb250J3QgdHJpZ2dlciBpZiBhY3VhbCBlbGVtZW50IGhhcyBmb2N1cyAoaS5lLiBpbnB1dHMsIGxpbmtzLCAuLi4pXG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHZpc2libGVGb2N1c2FibGVFbGVtZW50cy5sZW5ndGggPT09IDApIHsgLy8gbm8gZm9jdXNhYmxlIGVsZW1lbnRzIGluc2lkZSB0aGUgbW9kYWwgYXQgYWxsLCBwcmV2ZW50IHRhYmJpbmcgaW4gZ2VuZXJhbFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBtb2RhbC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBSZXZlYWwjY2xvc2VkXG4gICAqL1xuICBSZXZlYWwucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgICBpZighdGhpcy5pc0FjdGl2ZSB8fCAhdGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZih0aGlzLm9wdGlvbnMuYW5pbWF0aW9uT3V0KXtcbiAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kZWxlbWVudCwgdGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCwgZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoX3RoaXMub3B0aW9ucy5vdmVybGF5KXtcbiAgICAgICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KF90aGlzLiRvdmVybGF5LCAnZmFkZS1vdXQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZShfdGhpcy5vcHRpb25zLmhpZGVEZWxheSwgZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoX3RoaXMub3B0aW9ucy5vdmVybGF5KXtcbiAgICAgICAgICBfdGhpcy4kb3ZlcmxheS5oaWRlKDAsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvL2NvbmRpdGlvbmFscyB0byByZW1vdmUgZXh0cmEgZXZlbnQgbGlzdGVuZXJzIGFkZGVkIG9uIG9wZW5cbiAgICBpZih0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYyl7XG4gICAgICAkKHdpbmRvdykub2ZmKCdrZXlkb3duLnpmLnJldmVhbCcpO1xuICAgIH1cbiAgICBpZighdGhpcy5vcHRpb25zLm92ZXJsYXkgJiYgdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayl7XG4gICAgICAkKCdib2R5Jykub2ZmKCdjbGljay56Zi5yZXZlYWwnKTtcbiAgICB9XG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJ2tleWRvd24uemYucmV2ZWFsJyk7XG5cbiAgICAvL2lmIHRoZSBtb2RhbCBjaGFuZ2VkIHNpemUsIHJlc2V0IGl0XG4gICAgaWYodGhpcy5jaGFuZ2VkU2l6ZSl7XG4gICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICAgICdoZWlnaHQnOiAnJyxcbiAgICAgICAgJ3dpZHRoJzogJydcbiAgICAgIH0pO1xuICAgIH1cblxuICAgICQoJ2JvZHknKS5yZW1vdmVDbGFzcygnaXMtcmV2ZWFsLW9wZW4nKS5hdHRyKHsnYXJpYS1oaWRkZW4nOiBmYWxzZSwgJ3RhYmluZGV4JzogJyd9KTtcblxuICAgIC8qKlxuICAgICogUmVzZXRzIHRoZSBtb2RhbCBjb250ZW50XG4gICAgKiBUaGlzIHByZXZlbnRzIGEgcnVubmluZyB2aWRlbyB0byBrZWVwIGdvaW5nIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgKi9cbiAgICBpZih0aGlzLm9wdGlvbnMucmVzZXRPbkNsb3NlKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lmh0bWwodGhpcy4kZWxlbWVudC5odG1sKCkpO1xuICAgIH1cblxuICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoeydhcmlhLWhpZGRlbic6IHRydWV9KVxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIG1vZGFsIGlzIGRvbmUgY2xvc2luZy5cbiAgICAgKiBAZXZlbnQgUmV2ZWFsI2Nsb3NlZFxuICAgICAqL1xuICAgICAgICAgICAgICAgICAudHJpZ2dlcignY2xvc2VkLnpmLnJldmVhbCcpO1xuICB9O1xuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgb3Blbi9jbG9zZWQgc3RhdGUgb2YgYSBtb2RhbC5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBSZXZlYWwucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5pc0FjdGl2ZSl7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGEgbW9kYWwuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgUmV2ZWFsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5vcHRpb25zLm92ZXJsYXkpe1xuICAgICAgdGhpcy4kb3ZlcmxheS5oaWRlKCkub2ZmKCkucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpO1xuICAgIHRoaXMuJGFuY2hvci5vZmYoKTtcblxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfTtcblxuICBGb3VuZGF0aW9uLnBsdWdpbihSZXZlYWwsICdSZXZlYWwnKTtcblxuICAvLyBFeHBvcnRzIGZvciBBTUQvQnJvd3NlcmlmeVxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJylcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJldmVhbDtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicpXG4gICAgZGVmaW5lKFsnZm91bmRhdGlvbiddLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBSZXZlYWw7XG4gICAgfSk7XG5cbn0oRm91bmRhdGlvbiwgalF1ZXJ5KTtcbiIsIi8qKlxuICogU2xpZGVyIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5zbGlkZXJcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRvdWNoXG4gKi9cbiFmdW5jdGlvbigkLCBGb3VuZGF0aW9uKXtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgZHJpbGxkb3duIG1lbnUuXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbiBtZW51LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAqL1xuICBmdW5jdGlvbiBTbGlkZXIoZWxlbWVudCwgb3B0aW9ucyl7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFNsaWRlci5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdTbGlkZXInLCB7XG4gICAgICAnbHRyJzoge1xuICAgICAgICAnQVJST1dfUklHSFQnOiAnaW5jcmVhc2UnLFxuICAgICAgICAnQVJST1dfVVAnOiAnaW5jcmVhc2UnLFxuICAgICAgICAnQVJST1dfRE9XTic6ICdkZWNyZWFzZScsXG4gICAgICAgICdBUlJPV19MRUZUJzogJ2RlY3JlYXNlJyxcbiAgICAgICAgJ1NISUZUX0FSUk9XX1JJR0hUJzogJ2luY3JlYXNlX2Zhc3QnLFxuICAgICAgICAnU0hJRlRfQVJST1dfVVAnOiAnaW5jcmVhc2VfZmFzdCcsXG4gICAgICAgICdTSElGVF9BUlJPV19ET1dOJzogJ2RlY3JlYXNlX2Zhc3QnLFxuICAgICAgICAnU0hJRlRfQVJST1dfTEVGVCc6ICdkZWNyZWFzZV9mYXN0J1xuICAgICAgfSxcbiAgICAgICdydGwnOiB7XG4gICAgICAgICdBUlJPV19MRUZUJzogJ2luY3JlYXNlJyxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ2RlY3JlYXNlJyxcbiAgICAgICAgJ1NISUZUX0FSUk9XX0xFRlQnOiAnaW5jcmVhc2VfZmFzdCcsXG4gICAgICAgICdTSElGVF9BUlJPV19SSUdIVCc6ICdkZWNyZWFzZV9mYXN0J1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgU2xpZGVyLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIE1pbmltdW0gdmFsdWUgZm9yIHRoZSBzbGlkZXIgc2NhbGUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDBcbiAgICAgKi9cbiAgICBzdGFydDogMCxcbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIHZhbHVlIGZvciB0aGUgc2xpZGVyIHNjYWxlLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxMDBcbiAgICAgKi9cbiAgICBlbmQ6IDEwMCxcbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHZhbHVlIGNoYW5nZSBwZXIgY2hhbmdlIGV2ZW50LiBOb3QgQ3VycmVudGx5IEltcGxlbWVudGVkIVxuXG4gICAgICovXG4gICAgc3RlcDogMSxcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBhdCB3aGljaCB0aGUgaGFuZGxlL2lucHV0ICoobGVmdCBoYW5kbGUvZmlyc3QgaW5wdXQpKiBzaG91bGQgYmUgc2V0IHRvIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAwXG4gICAgICovXG4gICAgaW5pdGlhbFN0YXJ0OiAwLFxuICAgIC8qKlxuICAgICAqIFZhbHVlIGF0IHdoaWNoIHRoZSByaWdodCBoYW5kbGUvc2Vjb25kIGlucHV0IHNob3VsZCBiZSBzZXQgdG8gb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDEwMFxuICAgICAqL1xuICAgIGluaXRpYWxFbmQ6IDEwMCxcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIGlucHV0IHRvIGJlIGxvY2F0ZWQgb3V0c2lkZSB0aGUgY29udGFpbmVyIGFuZCB2aXNpYmxlLiBTZXQgdG8gYnkgdGhlIEpTXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovXG4gICAgYmluZGluZzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGNsaWNrL3RhcCBvbiB0aGUgc2xpZGVyIGJhciB0byBzZWxlY3QgYSB2YWx1ZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL1xuICAgIGNsaWNrU2VsZWN0OiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGFuZCB1c2UgdGhlIGB2ZXJ0aWNhbGAgY2xhc3MgdG8gY2hhbmdlIGFsaWdubWVudCB0byB2ZXJ0aWNhbC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9cbiAgICB2ZXJ0aWNhbDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGRyYWcgdGhlIHNsaWRlciBoYW5kbGUocykgdG8gc2VsZWN0IGEgdmFsdWUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9cbiAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgdGhlIHNsaWRlciBhbmQgcHJldmVudHMgZXZlbnQgbGlzdGVuZXJzIGZyb20gYmVpbmcgYXBwbGllZC4gRG91YmxlIGNoZWNrZWQgYnkgSlMgd2l0aCBgZGlzYWJsZWRDbGFzc2AuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgdXNlIG9mIHR3byBoYW5kbGVzLiBEb3VibGUgY2hlY2tlZCBieSB0aGUgSlMuIENoYW5nZXMgc29tZSBsb2dpYyBoYW5kbGluZy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9cbiAgICBkb3VibGVTaWRlZDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlLlxuICAgICAqL1xuICAgIC8vIHN0ZXBzOiAxMDAsXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoZSBwbHVnaW4gc2hvdWxkIGdvIHRvIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24uXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDJcbiAgICAgKi9cbiAgICBkZWNpbWFsOiAyLFxuICAgIC8qKlxuICAgICAqIFRpbWUgZGVsYXkgZm9yIGRyYWdnZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgLy8gZHJhZ0RlbGF5OiAwLFxuICAgIC8qKlxuICAgICAqIFRpbWUsIGluIG1zLCB0byBhbmltYXRlIHRoZSBtb3ZlbWVudCBvZiBhIHNsaWRlciBoYW5kbGUgaWYgdXNlciBjbGlja3MvdGFwcyBvbiB0aGUgYmFyLiBOZWVkcyB0byBiZSBtYW51YWxseSBzZXQgaWYgdXBkYXRpbmcgdGhlIHRyYW5zaXRpb24gdGltZSBpbiB0aGUgU2FzcyBzZXR0aW5ncy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMjAwXG4gICAgICovXG4gICAgbW92ZVRpbWU6IDIwMCwvL3VwZGF0ZSB0aGlzIGlmIGNoYW5naW5nIHRoZSB0cmFuc2l0aW9uIHRpbWUgaW4gdGhlIHNhc3NcbiAgICAvKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIGRpc2FibGVkIHNsaWRlcnMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdkaXNhYmxlZCdcbiAgICAgKi9cbiAgICBkaXNhYmxlZENsYXNzOiAnZGlzYWJsZWQnXG4gIH07XG4gIC8qKlxuICAgKiBJbml0aWxpemVzIHRoZSBwbHVnaW4gYnkgcmVhZGluZy9zZXR0aW5nIGF0dHJpYnV0ZXMsIGNyZWF0aW5nIGNvbGxlY3Rpb25zIGFuZCBzZXR0aW5nIHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBoYW5kbGUocykuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5pbnB1dHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2lucHV0Jyk7XG4gICAgdGhpcy5oYW5kbGVzID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zbGlkZXItaGFuZGxlXScpO1xuXG4gICAgdGhpcy4kaGFuZGxlID0gdGhpcy5oYW5kbGVzLmVxKDApO1xuICAgIHRoaXMuJGlucHV0ID0gdGhpcy5pbnB1dHMubGVuZ3RoID8gdGhpcy5pbnB1dHMuZXEoMCkgOiAkKCcjJyArIHRoaXMuJGhhbmRsZS5hdHRyKCdhcmlhLWNvbnRyb2xzJykpO1xuICAgIHRoaXMuJGZpbGwgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXNsaWRlci1maWxsXScpLmNzcyh0aGlzLm9wdGlvbnMudmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCcsIDApO1xuXG4gICAgdmFyIGlzRGJsID0gZmFsc2UsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICBpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcykpe1xuICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpO1xuICAgIH1cbiAgICBpZighdGhpcy5pbnB1dHMubGVuZ3RoKXtcbiAgICAgIHRoaXMuaW5wdXRzID0gJCgpLmFkZCh0aGlzLiRpbnB1dCk7XG4gICAgICB0aGlzLm9wdGlvbnMuYmluZGluZyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3NldEluaXRBdHRyKDApO1xuICAgIHRoaXMuX2V2ZW50cyh0aGlzLiRoYW5kbGUpO1xuXG4gICAgaWYodGhpcy5oYW5kbGVzWzFdKXtcbiAgICAgIHRoaXMub3B0aW9ucy5kb3VibGVTaWRlZCA9IHRydWU7XG4gICAgICB0aGlzLiRoYW5kbGUyID0gdGhpcy5oYW5kbGVzLmVxKDEpO1xuICAgICAgdGhpcy4kaW5wdXQyID0gdGhpcy5pbnB1dHMubGVuZ3RoID8gdGhpcy5pbnB1dHMuZXEoMSkgOiAkKCcjJyArIHRoaXMuJGhhbmRsZTIuYXR0cignYXJpYS1jb250cm9scycpKTtcblxuICAgICAgaWYoIXRoaXMuaW5wdXRzWzFdKXtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSB0aGlzLmlucHV0cy5hZGQodGhpcy4kaW5wdXQyKTtcbiAgICAgIH1cbiAgICAgIGlzRGJsID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fc2V0SGFuZGxlUG9zKHRoaXMuJGhhbmRsZSwgdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCwgdHJ1ZSwgZnVuY3Rpb24oKXtcblxuICAgICAgICBfdGhpcy5fc2V0SGFuZGxlUG9zKF90aGlzLiRoYW5kbGUyLCBfdGhpcy5vcHRpb25zLmluaXRpYWxFbmQpO1xuICAgICAgfSk7XG4gICAgICAvLyB0aGlzLiRoYW5kbGUudHJpZ2dlckhhbmRsZXIoJ2NsaWNrLnpmLnNsaWRlcicpO1xuICAgICAgdGhpcy5fc2V0SW5pdEF0dHIoMSk7XG4gICAgICB0aGlzLl9ldmVudHModGhpcy4kaGFuZGxlMik7XG4gICAgfVxuXG4gICAgaWYoIWlzRGJsKXtcbiAgICAgIHRoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsIHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQsIHRydWUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBoYW5kbGUgYW5kIGZpbGwgYmFyLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtqUXVlcnl9ICRobmRsIC0gdGhlIHNlbGVjdGVkIGhhbmRsZSB0byBtb3ZlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbG9jYXRpb24gLSBmbG9hdGluZyBwb2ludCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHZhbHVlcyBvZiB0aGUgc2xpZGVyIGJhci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIG9uIGNvbXBsZXRpb24uXG4gICAqIEBmaXJlcyBTbGlkZXIjbW92ZWRcbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuX3NldEhhbmRsZVBvcyA9IGZ1bmN0aW9uKCRobmRsLCBsb2NhdGlvbiwgbm9JbnZlcnQsIGNiKXtcbiAgLy9taWdodCBuZWVkIHRvIGFsdGVyIHRoYXQgc2xpZ2h0bHkgZm9yIGJhcnMgdGhhdCB3aWxsIGhhdmUgb2RkIG51bWJlciBzZWxlY3Rpb25zLlxuICAgIGxvY2F0aW9uID0gcGFyc2VGbG9hdChsb2NhdGlvbik7Ly9vbiBpbnB1dCBjaGFuZ2UgZXZlbnRzLCBjb252ZXJ0IHN0cmluZyB0byBudW1iZXIuLi5ncnVtYmxlLlxuICAgIC8vIHByZXZlbnQgc2xpZGVyIGZyb20gcnVubmluZyBvdXQgb2YgYm91bmRzXG4gICAgaWYobG9jYXRpb24gPCB0aGlzLm9wdGlvbnMuc3RhcnQpeyBsb2NhdGlvbiA9IHRoaXMub3B0aW9ucy5zdGFydDsgfVxuICAgIGVsc2UgaWYobG9jYXRpb24gPiB0aGlzLm9wdGlvbnMuZW5kKXsgbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMuZW5kOyB9XG5cbiAgICB2YXIgaXNEYmwgPSB0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQsXG4gICAgICAgIGNhbGxiYWNrID0gY2IgfHwgbnVsbDtcblxuICAgIGlmKGlzRGJsKXtcbiAgICAgIGlmKHRoaXMuaGFuZGxlcy5pbmRleCgkaG5kbCkgPT09IDApe1xuICAgICAgICB2YXIgaDJWYWwgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZTIuYXR0cignYXJpYS12YWx1ZW5vdycpKTtcbiAgICAgICAgbG9jYXRpb24gPSBsb2NhdGlvbiA+PSBoMlZhbCA/IGgyVmFsIC0gdGhpcy5vcHRpb25zLnN0ZXAgOiBsb2NhdGlvbjtcbiAgICAgIH1lbHNle1xuICAgICAgICB2YXIgaDFWYWwgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JykpO1xuICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uIDw9IGgxVmFsID8gaDFWYWwgKyB0aGlzLm9wdGlvbnMuc3RlcCA6IGxvY2F0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMub3B0aW9ucy52ZXJ0aWNhbCAmJiAhbm9JbnZlcnQpe1xuICAgICAgbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMuZW5kIC0gbG9jYXRpb247XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIHZlcnQgPSB0aGlzLm9wdGlvbnMudmVydGljYWwsXG4gICAgICAgIGhPclcgPSB2ZXJ0ID8gJ2hlaWdodCcgOiAnd2lkdGgnLFxuICAgICAgICBsT3JUID0gdmVydCA/ICd0b3AnIDogJ2xlZnQnLFxuICAgICAgICBoYWxmT2ZIYW5kbGUgPSAkaG5kbFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtoT3JXXSAvIDIsXG4gICAgICAgIGVsZW1EaW0gPSB0aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2hPclddLFxuICAgICAgICBwY3RPZkJhciA9IHBlcmNlbnQobG9jYXRpb24sIHRoaXMub3B0aW9ucy5lbmQpLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpLFxuICAgICAgICBweFRvTW92ZSA9IChlbGVtRGltIC0gaGFsZk9mSGFuZGxlKSAqIHBjdE9mQmFyLFxuICAgICAgICBtb3ZlbWVudCA9IChwZXJjZW50KHB4VG9Nb3ZlLCBlbGVtRGltKSAqIDEwMCkudG9GaXhlZCh0aGlzLm9wdGlvbnMuZGVjaW1hbCksXG4gICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gPiAwID8gcGFyc2VGbG9hdChsb2NhdGlvbi50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKSkgOiAwLFxuICAgICAgICBhbmltLCBwcm9nLCBzdGFydCA9IG51bGwsIGNzcyA9IHt9O1xuXG4gICAgdGhpcy5fc2V0VmFsdWVzKCRobmRsLCBsb2NhdGlvbik7XG5cbiAgICBpZih0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQpey8vdXBkYXRlIHRvIGNhbGN1bGF0ZSBiYXNlZCBvbiB2YWx1ZXMgc2V0IHRvIHJlc3BlY3RpdmUgaW5wdXRzPz9cbiAgICAgIHZhciBpc0xlZnRIbmRsID0gdGhpcy5oYW5kbGVzLmluZGV4KCRobmRsKSA9PT0gMCxcbiAgICAgICAgICBkaW0sXG4gICAgICAgICAgaWR4ID0gdGhpcy5oYW5kbGVzLmluZGV4KCRobmRsKTtcblxuICAgICAgaWYoaXNMZWZ0SG5kbCl7XG4gICAgICAgIGNzc1tsT3JUXSA9IChwY3RPZkJhciA+IDAgPyBwY3RPZkJhciAqIDEwMCA6IDApICsgJyUnOy8vXG4gICAgICAgIGRpbSA9IC8qTWF0aC5hYnMqLygocGVyY2VudCh0aGlzLiRoYW5kbGUyLnBvc2l0aW9uKClbbE9yVF0gKyBoYWxmT2ZIYW5kbGUsIGVsZW1EaW0pIC0gcGFyc2VGbG9hdChwY3RPZkJhcikpICogMTAwKS50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKSArICclJztcbiAgICAgICAgY3NzWydtaW4tJyArIGhPclddID0gZGltO1xuICAgICAgICBpZihjYiAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpeyBjYigpOyB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgbG9jYXRpb24gPSAobG9jYXRpb24gPCAxMDAgPyBsb2NhdGlvbiA6IDEwMCkgLSAocGFyc2VGbG9hdCh0aGlzLiRoYW5kbGVbMF0uc3R5bGUubGVmdCkgfHwgdGhpcy5vcHRpb25zLmVuZCAtIGxvY2F0aW9uKTtcbiAgICAgICAgY3NzWydtaW4tJyArIGhPclddID0gbG9jYXRpb24gKyAnJSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC5vbmUoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hbmltQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGFuZGxlIGlzIGRvbmUgbW92aW5nLlxuICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnQgU2xpZGVyI21vdmVkXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdtb3ZlZC56Zi5zbGlkZXInLCBbJGhuZGxdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICB2YXIgbW92ZVRpbWUgPSBfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycpID8gMTAwMC82MCA6IF90aGlzLm9wdGlvbnMubW92ZVRpbWU7XG4gICAgLyp2YXIgbW92ZSA9IG5ldyAqL0ZvdW5kYXRpb24uTW92ZShtb3ZlVGltZSwgJGhuZGwsIGZ1bmN0aW9uKCl7XG4gICAgICAkaG5kbC5jc3MobE9yVCwgbW92ZW1lbnQgKyAnJScpO1xuICAgICAgaWYoIV90aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQpe1xuICAgICAgICBfdGhpcy4kZmlsbC5jc3MoaE9yVywgcGN0T2ZCYXIgKiAxMDAgKyAnJScpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIF90aGlzLiRmaWxsLmNzcyhjc3MpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIG1vdmUuZG8oKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgdGhlIGluaXRpYWwgYXR0cmlidXRlIGZvciB0aGUgc2xpZGVyIGVsZW1lbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gaW5kZXggb2YgdGhlIGN1cnJlbnQgaGFuZGxlL2lucHV0IHRvIHVzZS5cbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuX3NldEluaXRBdHRyID0gZnVuY3Rpb24oaWR4KXtcbiAgICB2YXIgaWQgPSB0aGlzLmlucHV0cy5lcShpZHgpLmF0dHIoJ2lkJykgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAnc2xpZGVyJyk7XG4gICAgdGhpcy5pbnB1dHMuZXEoaWR4KS5hdHRyKHtcbiAgICAgICdpZCc6IGlkLFxuICAgICAgJ21heCc6IHRoaXMub3B0aW9ucy5lbmQsXG4gICAgICAnbWluJzogdGhpcy5vcHRpb25zLnN0YXJ0XG5cbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZXMuZXEoaWR4KS5hdHRyKHtcbiAgICAgICdyb2xlJzogJ3NsaWRlcicsXG4gICAgICAnYXJpYS1jb250cm9scyc6IGlkLFxuICAgICAgJ2FyaWEtdmFsdWVtYXgnOiB0aGlzLm9wdGlvbnMuZW5kLFxuICAgICAgJ2FyaWEtdmFsdWVtaW4nOiB0aGlzLm9wdGlvbnMuc3RhcnQsXG4gICAgICAnYXJpYS12YWx1ZW5vdyc6IGlkeCA9PT0gMCA/IHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQgOiB0aGlzLm9wdGlvbnMuaW5pdGlhbEVuZCxcbiAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogdGhpcy5vcHRpb25zLnZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyxcbiAgICAgICd0YWJpbmRleCc6IDBcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGFuZCBgYXJpYS12YWx1ZW5vd2AgdmFsdWVzIGZvciB0aGUgc2xpZGVyIGVsZW1lbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaGFuZGxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsIC0gZmxvYXRpbmcgcG9pbnQgb2YgdGhlIG5ldyB2YWx1ZS5cbiAgICovXG4gIFNsaWRlci5wcm90b3R5cGUuX3NldFZhbHVlcyA9IGZ1bmN0aW9uKCRoYW5kbGUsIHZhbCl7XG4gICAgdmFyIGlkeCA9IHRoaXMub3B0aW9ucy5kb3VibGVTaWRlZCA/IHRoaXMuaGFuZGxlcy5pbmRleCgkaGFuZGxlKSA6IDA7XG4gICAgdGhpcy5pbnB1dHMuZXEoaWR4KS52YWwodmFsKTtcbiAgICAkaGFuZGxlLmF0dHIoJ2FyaWEtdmFsdWVub3cnLCB2YWwpO1xuICB9O1xuICAvKipcbiAgICogSGFuZGxlcyBldmVudHMgb24gdGhlIHNsaWRlciBlbGVtZW50LlxuICAgKiBDYWxjdWxhdGVzIHRoZSBuZXcgbG9jYXRpb24gb2YgdGhlIGN1cnJlbnQgaGFuZGxlLlxuICAgKiBJZiB0aGVyZSBhcmUgdHdvIGhhbmRsZXMgYW5kIHRoZSBiYXIgd2FzIGNsaWNrZWQsIGl0IGRldGVybWluZXMgd2hpY2ggaGFuZGxlIHRvIG1vdmUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZSAtIHRoZSBgZXZlbnRgIG9iamVjdCBwYXNzZWQgZnJvbSB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnQgaGFuZGxlIHRvIGNhbGN1bGF0ZSBmb3IsIGlmIHNlbGVjdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsIC0gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGZvciB0aGUgbmV3IHZhbHVlIG9mIHRoZSBzbGlkZXIuXG4gICAqL1xuICBTbGlkZXIucHJvdG90eXBlLl9oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGUsICRoYW5kbGUsIHZhbCl7XG4gICAgdmFyIHZhbHVlLCBoYXNWYWw7XG4gICAgaWYoIXZhbCl7Ly9jbGljayBvciBkcmFnIGV2ZW50c1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICB2ZXJ0aWNhbCA9IHRoaXMub3B0aW9ucy52ZXJ0aWNhbCxcbiAgICAgICAgICBwYXJhbSA9IHZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnLFxuICAgICAgICAgIGRpcmVjdGlvbiA9IHZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCcsXG4gICAgICAgICAgcGFnZVhZID0gdmVydGljYWwgPyBlLnBhZ2VZIDogZS5wYWdlWCxcbiAgICAgICAgICBoYWxmT2ZIYW5kbGUgPSB0aGlzLiRoYW5kbGVbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbcGFyYW1dIC8gMixcbiAgICAgICAgICBiYXJEaW0gPSB0aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3BhcmFtXSxcbiAgICAgICAgICBiYXJPZmZzZXQgPSAodGhpcy4kZWxlbWVudC5vZmZzZXQoKVtkaXJlY3Rpb25dIC0gIHBhZ2VYWSksXG4gICAgICAgICAgYmFyWFkgPSBiYXJPZmZzZXQgPiAwID8gLWhhbGZPZkhhbmRsZSA6IChiYXJPZmZzZXQgLSBoYWxmT2ZIYW5kbGUpIDwgLWJhckRpbSA/IGJhckRpbSA6IE1hdGguYWJzKGJhck9mZnNldCksLy9pZiB0aGUgY3Vyc29yIHBvc2l0aW9uIGlzIGxlc3MgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnRzIGJvdW5kaW5nIGNvb3JkaW5hdGVzLCBzZXQgY29vcmRpbmF0ZXMgd2l0aGluIHRob3NlIGJvdW5kc1xuICAgICAgICAgIC8vIGVsZURpbSA9IHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbcGFyYW1dLFxuICAgICAgICAgIG9mZnNldFBjdCA9IHBlcmNlbnQoYmFyWFksIGJhckRpbSk7XG4gICAgICB2YWx1ZSA9ICh0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KSAqIG9mZnNldFBjdDtcbiAgICAgIGhhc1ZhbCA9IGZhbHNlO1xuXG4gICAgICBpZighJGhhbmRsZSl7Ly9maWd1cmUgb3V0IHdoaWNoIGhhbmRsZSBpdCBpcywgcGFzcyBpdCB0byB0aGUgbmV4dCBmdW5jdGlvbi5cbiAgICAgICAgdmFyIGZpcnN0SG5kbFBvcyA9IGFic1Bvc2l0aW9uKHRoaXMuJGhhbmRsZSwgZGlyZWN0aW9uLCBiYXJYWSwgcGFyYW0pLFxuICAgICAgICAgICAgc2VjbmRIbmRsUG9zID0gYWJzUG9zaXRpb24odGhpcy4kaGFuZGxlMiwgZGlyZWN0aW9uLCBiYXJYWSwgcGFyYW0pO1xuICAgICAgICAgICAgJGhhbmRsZSA9IGZpcnN0SG5kbFBvcyA8PSBzZWNuZEhuZGxQb3MgPyB0aGlzLiRoYW5kbGUgOiB0aGlzLiRoYW5kbGUyO1xuICAgICAgfVxuXG4gICAgfWVsc2V7Ly9jaGFuZ2UgZXZlbnQgb24gaW5wdXRcbiAgICAgIHZhbHVlID0gdmFsO1xuICAgICAgaGFzVmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRIYW5kbGVQb3MoJGhhbmRsZSwgdmFsdWUsIGhhc1ZhbCk7XG4gIH07XG4gIC8qKlxuICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc2xpZGVyIGVsZW1lbnRzLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgY3VycmVudCBoYW5kbGUgdG8gYXBwbHkgbGlzdGVuZXJzIHRvLlxuICAgKi9cbiAgU2xpZGVyLnByb3RvdHlwZS5fZXZlbnRzID0gZnVuY3Rpb24oJGhhbmRsZSl7XG4gICAgaWYodGhpcy5vcHRpb25zLmRpc2FibGVkKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBjdXJIYW5kbGUsXG4gICAgICAgIHRpbWVyO1xuXG4gICAgICB0aGlzLmlucHV0cy5vZmYoJ2NoYW5nZS56Zi5zbGlkZXInKS5vbignY2hhbmdlLnpmLnNsaWRlcicsIGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgaWR4ID0gX3RoaXMuaW5wdXRzLmluZGV4KCQodGhpcykpO1xuICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSwgX3RoaXMuaGFuZGxlcy5lcShpZHgpLCAkKHRoaXMpLnZhbCgpKTtcbiAgICAgIH0pO1xuXG4gICAgaWYodGhpcy5vcHRpb25zLmNsaWNrU2VsZWN0KXtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdjbGljay56Zi5zbGlkZXInKS5vbignY2xpY2suemYuc2xpZGVyJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIGlmKF90aGlzLiRlbGVtZW50LmRhdGEoJ2RyYWdnaW5nJykpeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgX3RoaXMuYW5pbUNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIGlmKF90aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQpe1xuICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIF90aGlzLiRoYW5kbGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZih0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKXtcbiAgICAgIHRoaXMuaGFuZGxlcy5hZGRUb3VjaCgpO1xuICAgICAgLy8gdmFyIGN1ckhhbmRsZSxcbiAgICAgIC8vICAgICB0aW1lcixcbiAgICAgIHZhciAkYm9keSA9ICQoJ2JvZHknKTtcbiAgICAgICRoYW5kbGVcbiAgICAgICAgLm9mZignbW91c2Vkb3duLnpmLnNsaWRlcicpXG4gICAgICAgIC5vbignbW91c2Vkb3duLnpmLnNsaWRlcicsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICRoYW5kbGUuYWRkQ2xhc3MoJ2lzLWRyYWdnaW5nJyk7XG4gICAgICAgICAgX3RoaXMuJGZpbGwuYWRkQ2xhc3MoJ2lzLWRyYWdnaW5nJyk7Ly9cbiAgICAgICAgICBfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycsIHRydWUpO1xuICAgICAgICAgIF90aGlzLmFuaW1Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgIGN1ckhhbmRsZSA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcblxuICAgICAgICAgICRib2R5Lm9uKCdtb3VzZW1vdmUuemYuc2xpZGVyJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIC8vIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIGN1ckhhbmRsZSk7XG4gICAgICAgICAgICAvLyB9LCBfdGhpcy5vcHRpb25zLmRyYWdEZWxheSk7XG4gICAgICAgICAgfSkub24oJ21vdXNldXAuemYuc2xpZGVyJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAvLyBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgX3RoaXMuYW5pbUNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlLCBjdXJIYW5kbGUpO1xuICAgICAgICAgICAgJGhhbmRsZS5yZW1vdmVDbGFzcygnaXMtZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgIF90aGlzLiRmaWxsLnJlbW92ZUNsYXNzKCdpcy1kcmFnZ2luZycpO1xuICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyBGb3VuZGF0aW9uLnJlZmxvdyhfdGhpcy4kZWxlbWVudCwgJ3NsaWRlcicpO1xuICAgICAgICAgICAgJGJvZHkub2ZmKCdtb3VzZW1vdmUuemYuc2xpZGVyIG1vdXNldXAuemYuc2xpZGVyJyk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgJGhhbmRsZS5vZmYoJ2tleWRvd24uemYuc2xpZGVyJykub24oJ2tleWRvd24uemYuc2xpZGVyJywgZnVuY3Rpb24oZSl7XG4gICAgICB2YXIgaWR4ID0gX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCA/IF90aGlzLmhhbmRsZXMuaW5kZXgoJCh0aGlzKSkgOiAwLFxuICAgICAgICBvbGRWYWx1ZSA9IHBhcnNlRmxvYXQoX3RoaXMuaW5wdXRzLmVxKGlkeCkudmFsKCkpLFxuICAgICAgICBuZXdWYWx1ZTtcblxuICAgICAgdmFyIF8kaGFuZGxlID0gJCh0aGlzKTtcblxuICAgICAgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgX3RoaXMsIHtcbiAgICAgICAgZGVjcmVhc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgLSBfdGhpcy5vcHRpb25zLnN0ZXA7XG4gICAgICAgIH0sXG4gICAgICAgIGluY3JlYXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlICsgX3RoaXMub3B0aW9ucy5zdGVwO1xuICAgICAgICB9LFxuICAgICAgICBkZWNyZWFzZV9mYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlIC0gX3RoaXMub3B0aW9ucy5zdGVwICogMTA7XG4gICAgICAgIH0sXG4gICAgICAgIGluY3JlYXNlX2Zhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgKyBfdGhpcy5vcHRpb25zLnN0ZXAgKiAxMDtcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24oKSB7IC8vIG9ubHkgc2V0IGhhbmRsZSBwb3Mgd2hlbiBldmVudCB3YXMgaGFuZGxlZCBzcGVjaWFsbHlcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgX3RoaXMuX3NldEhhbmRsZVBvcyhfJGhhbmRsZSwgbmV3VmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8qaWYgKG5ld1ZhbHVlKSB7IC8vIGlmIHByZXNzZWQga2V5IGhhcyBzcGVjaWFsIGZ1bmN0aW9uLCB1cGRhdGUgdmFsdWVcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBfdGhpcy5fc2V0SGFuZGxlUG9zKF8kaGFuZGxlLCBuZXdWYWx1ZSk7XG4gICAgICB9Ki9cbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBzbGlkZXIgcGx1Z2luLlxuICAgKi9cbiAgIFNsaWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gICAgIHRoaXMuaGFuZGxlcy5vZmYoJy56Zi5zbGlkZXInKTtcbiAgICAgdGhpcy5pbnB1dHMub2ZmKCcuemYuc2xpZGVyJyk7XG4gICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYuc2xpZGVyJyk7XG5cbiAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgfTtcblxuICBGb3VuZGF0aW9uLnBsdWdpbihTbGlkZXIsICdTbGlkZXInKTtcblxuICBmdW5jdGlvbiBwZXJjZW50KGZyYWMsIG51bSl7XG4gICAgcmV0dXJuIChmcmFjIC8gbnVtKTtcbiAgfVxuICBmdW5jdGlvbiBhYnNQb3NpdGlvbigkaGFuZGxlLCBkaXIsIGNsaWNrUG9zLCBwYXJhbSl7XG4gICAgcmV0dXJuIE1hdGguYWJzKCgkaGFuZGxlLnBvc2l0aW9uKClbZGlyXSArICgkaGFuZGxlW3BhcmFtXSgpIC8gMikpIC0gY2xpY2tQb3MpO1xuICB9XG59KGpRdWVyeSwgd2luZG93LkZvdW5kYXRpb24pO1xuXG4vLyoqKioqKioqKnRoaXMgaXMgaW4gY2FzZSB3ZSBnbyB0byBzdGF0aWMsIGFic29sdXRlIHBvc2l0aW9ucyBpbnN0ZWFkIG9mIGR5bmFtaWMgcG9zaXRpb25pbmcqKioqKioqKlxuLy8gdGhpcy5zZXRTdGVwcyhmdW5jdGlvbigpe1xuLy8gICBfdGhpcy5fZXZlbnRzKCk7XG4vLyAgIHZhciBpbml0U3RhcnQgPSBfdGhpcy5vcHRpb25zLnBvc2l0aW9uc1tfdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCAtIDFdIHx8IG51bGw7XG4vLyAgIHZhciBpbml0RW5kID0gX3RoaXMub3B0aW9ucy5pbml0aWFsRW5kID8gX3RoaXMub3B0aW9ucy5wb3NpdGlvbltfdGhpcy5vcHRpb25zLmluaXRpYWxFbmQgLSAxXSA6IG51bGw7XG4vLyAgIGlmKGluaXRTdGFydCB8fCBpbml0RW5kKXtcbi8vICAgICBfdGhpcy5faGFuZGxlRXZlbnQoaW5pdFN0YXJ0LCBpbml0RW5kKTtcbi8vICAgfVxuLy8gfSk7XG5cbi8vKioqKioqKioqKip0aGUgb3RoZXIgcGFydCBvZiBhYnNvbHV0ZSBwb3NpdGlvbnMqKioqKioqKioqKioqXG4vLyBTbGlkZXIucHJvdG90eXBlLnNldFN0ZXBzID0gZnVuY3Rpb24oY2Ipe1xuLy8gICB2YXIgcG9zQ2hhbmdlID0gdGhpcy4kZWxlbWVudC5vdXRlcldpZHRoKCkgLyB0aGlzLm9wdGlvbnMuc3RlcHM7XG4vLyAgIHZhciBjb3VudGVyID0gMFxuLy8gICB3aGlsZShjb3VudGVyIDwgdGhpcy5vcHRpb25zLnN0ZXBzKXtcbi8vICAgICBpZihjb3VudGVyKXtcbi8vICAgICAgIHRoaXMub3B0aW9ucy5wb3NpdGlvbnMucHVzaCh0aGlzLm9wdGlvbnMucG9zaXRpb25zW2NvdW50ZXIgLSAxXSArIHBvc0NoYW5nZSk7XG4vLyAgICAgfWVsc2V7XG4vLyAgICAgICB0aGlzLm9wdGlvbnMucG9zaXRpb25zLnB1c2gocG9zQ2hhbmdlKTtcbi8vICAgICB9XG4vLyAgICAgY291bnRlcisrO1xuLy8gICB9XG4vLyAgIGNiKCk7XG4vLyB9O1xuIiwiLyoqXG4gKiBTdGlja3kgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnN0aWNreVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XG4gKi9cbiFmdW5jdGlvbigkLCBGb3VuZGF0aW9uKXtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgc3RpY2t5IHRoaW5nLlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2Ugc3RpY2t5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB3aGVuIGNyZWF0aW5nIHRoZSBlbGVtZW50IHByb2dyYW1tYXRpY2FsbHkuXG4gICAqL1xuICBmdW5jdGlvbiBTdGlja3koZWxlbWVudCwgb3B0aW9ucyl7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFN0aWNreS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxuICBTdGlja3kuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogQ3VzdG9taXphYmxlIGNvbnRhaW5lciB0ZW1wbGF0ZS4gQWRkIHlvdXIgb3duIGNsYXNzZXMgZm9yIHN0eWxpbmcgYW5kIHNpemluZy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJzxkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyIGNsYXNzPVwic21hbGwtNiBjb2x1bW5zXCI+PC9kaXY+J1xuICAgICAqL1xuICAgIGNvbnRhaW5lcjogJzxkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyPjwvZGl2PicsXG4gICAgLyoqXG4gICAgICogTG9jYXRpb24gaW4gdGhlIHZpZXcgdGhlIGVsZW1lbnQgc3RpY2tzIHRvLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAndG9wJ1xuICAgICAqL1xuICAgIHN0aWNrVG86ICd0b3AnLFxuICAgIC8qKlxuICAgICAqIElmIGFuY2hvcmVkIHRvIGEgc2luZ2xlIGVsZW1lbnQsIHRoZSBpZCBvZiB0aGF0IGVsZW1lbnQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdleGFtcGxlSWQnXG4gICAgICovXG4gICAgYW5jaG9yOiAnJyxcbiAgICAvKipcbiAgICAgKiBJZiB1c2luZyBtb3JlIHRoYW4gb25lIGVsZW1lbnQgYXMgYW5jaG9yIHBvaW50cywgdGhlIGlkIG9mIHRoZSB0b3AgYW5jaG9yLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnZXhhbXBsZUlkOnRvcCdcbiAgICAgKi9cbiAgICB0b3BBbmNob3I6ICcnLFxuICAgIC8qKlxuICAgICAqIElmIHVzaW5nIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBhcyBhbmNob3IgcG9pbnRzLCB0aGUgaWQgb2YgdGhlIGJvdHRvbSBhbmNob3IuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdleGFtcGxlSWQ6Ym90dG9tJ1xuICAgICAqL1xuICAgIGJ0bUFuY2hvcjogJycsXG4gICAgLyoqXG4gICAgICogTWFyZ2luLCBpbiBgZW1gJ3MgdG8gYXBwbHkgdG8gdGhlIHRvcCBvZiB0aGUgZWxlbWVudCB3aGVuIGl0IGJlY29tZXMgc3RpY2t5LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxXG4gICAgICovXG4gICAgbWFyZ2luVG9wOiAxLFxuICAgIC8qKlxuICAgICAqIE1hcmdpbiwgaW4gYGVtYCdzIHRvIGFwcGx5IHRvIHRoZSBib3R0b20gb2YgdGhlIGVsZW1lbnQgd2hlbiBpdCBiZWNvbWVzIHN0aWNreS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMVxuICAgICAqL1xuICAgIG1hcmdpbkJvdHRvbTogMSxcbiAgICAvKipcbiAgICAgKiBCcmVha3BvaW50IHN0cmluZyB0aGF0IGlzIHRoZSBtaW5pbXVtIHNjcmVlbiBzaXplIGFuIGVsZW1lbnQgc2hvdWxkIGJlY29tZSBzdGlja3kuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdtZWRpdW0nXG4gICAgICovXG4gICAgc3RpY2t5T246ICdtZWRpdW0nLFxuICAgIC8qKlxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gc3RpY2t5IGVsZW1lbnQsIGFuZCByZW1vdmVkIG9uIGRlc3RydWN0aW9uLiBGb3VuZGF0aW9uIGRlZmF1bHRzIHRvIGBzdGlja3lgLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnc3RpY2t5J1xuICAgICAqL1xuICAgIHN0aWNreUNsYXNzOiAnc3RpY2t5JyxcbiAgICAvKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIHN0aWNreSBjb250YWluZXIuIEZvdW5kYXRpb24gZGVmYXVsdHMgdG8gYHN0aWNreS1jb250YWluZXJgLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnc3RpY2t5LWNvbnRhaW5lcidcbiAgICAgKi9cbiAgICBjb250YWluZXJDbGFzczogJ3N0aWNreS1jb250YWluZXInLFxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBzY3JvbGwgZXZlbnRzIGJldHdlZW4gdGhlIHBsdWdpbidzIHJlY2FsY3VsYXRpbmcgc3RpY2t5IHBvaW50cy4gU2V0dGluZyBpdCB0byBgMGAgd2lsbCBjYXVzZSBpdCB0byByZWNhbGMgZXZlcnkgc2Nyb2xsIGV2ZW50LCBzZXR0aW5nIGl0IHRvIGAtMWAgd2lsbCBwcmV2ZW50IHJlY2FsYyBvbiBzY3JvbGwuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDUwXG4gICAgICovXG4gICAgY2hlY2tFdmVyeTogLTFcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHN0aWNreSBlbGVtZW50IGJ5IGFkZGluZyBjbGFzc2VzLCBnZXR0aW5nL3NldHRpbmcgZGltZW5zaW9ucywgYnJlYWtwb2ludHMgYW5kIGF0dHJpYnV0ZXNcbiAgICogQWxzbyB0cmlnZ2VyZWQgYnkgRm91bmRhdGlvbi5fcmVmbG93XG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU3RpY2t5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyICRwYXJlbnQgPSB0aGlzLiRlbGVtZW50LnBhcmVudCgnW2RhdGEtc3RpY2t5LWNvbnRhaW5lcl0nKSxcbiAgICAgICAgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ3N0aWNreScpLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZighJHBhcmVudC5sZW5ndGgpe1xuICAgICAgdGhpcy53YXNXcmFwcGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy4kY29udGFpbmVyID0gJHBhcmVudC5sZW5ndGggPyAkcGFyZW50IDogJCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKS53cmFwSW5uZXIodGhpcy4kZWxlbWVudCk7XG4gICAgdGhpcy4kY29udGFpbmVyLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcyk7XG5cblxuICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKVxuICAgICAgICAgICAgICAgICAuYXR0cih7J2RhdGEtcmVzaXplJzogaWR9KTtcblxuICAgIHRoaXMuc2Nyb2xsQ291bnQgPSB0aGlzLm9wdGlvbnMuY2hlY2tFdmVyeTtcbiAgICB0aGlzLmlzU3R1Y2sgPSBmYWxzZTtcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm9wdGlvbnMuYW5jaG9yLCB0aGlzLm9wdGlvbnMudG9wQW5jaG9yKTtcbiAgICBpZih0aGlzLm9wdGlvbnMudG9wQW5jaG9yICE9PSAnJyl7XG4gICAgICB0aGlzLl9wYXJzZVBvaW50cygpO1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5wb2ludHNbMF0pO1xuICAgIH1lbHNle1xuICAgICAgdGhpcy4kYW5jaG9yID0gdGhpcy5vcHRpb25zLmFuY2hvciA/ICQoJyMnICsgdGhpcy5vcHRpb25zLmFuY2hvcikgOiAkKGRvY3VtZW50LmJvZHkpO1xuICAgIH1cblxuXG4gICAgdGhpcy5fc2V0U2l6ZXMoZnVuY3Rpb24oKXtcbiAgICAgIF90aGlzLl9jYWxjKGZhbHNlKTtcbiAgICB9KTtcbiAgICB0aGlzLl9ldmVudHMoaWQuc3BsaXQoJy0nKS5yZXZlcnNlKCkuam9pbignLScpKTtcbiAgfTtcbiAgLyoqXG4gICAqIElmIHVzaW5nIG11bHRpcGxlIGVsZW1lbnRzIGFzIGFuY2hvcnMsIGNhbGN1bGF0ZXMgdGhlIHRvcCBhbmQgYm90dG9tIHBpeGVsIHZhbHVlcyB0aGUgc3RpY2t5IHRoaW5nIHNob3VsZCBzdGljayBhbmQgdW5zdGljayBvbi5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTdGlja3kucHJvdG90eXBlLl9wYXJzZVBvaW50cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRvcCA9IHRoaXMub3B0aW9ucy50b3BBbmNob3IsXG4gICAgICAgIGJ0bSA9IHRoaXMub3B0aW9ucy5idG1BbmNob3IsXG4gICAgICAgIHB0cyA9IFt0b3AsIGJ0bV0sXG4gICAgICAgIGJyZWFrcyA9IHt9O1xuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHB0cy5sZW5ndGg7IGkgPCBsZW4gJiYgcHRzW2ldOyBpKyspe1xuICAgICAgdmFyIHB0O1xuICAgICAgaWYodHlwZW9mIHB0c1tpXSA9PT0gJ251bWJlcicpe1xuICAgICAgICBwdCA9IHB0c1tpXTtcbiAgICAgIH1lbHNle1xuICAgICAgICB2YXIgcGxhY2UgPSBwdHNbaV0uc3BsaXQoJzonKSxcbiAgICAgICAgICAgIGFuY2hvciA9ICQoJyMnICsgcGxhY2VbMF0pO1xuXG4gICAgICAgIHB0ID0gYW5jaG9yLm9mZnNldCgpLnRvcDtcbiAgICAgICAgaWYocGxhY2VbMV0gJiYgcGxhY2VbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ2JvdHRvbScpe1xuICAgICAgICAgIHB0ICs9IGFuY2hvclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrc1tpXSA9IHB0O1xuICAgIH1cbiAgICAgIC8vIGNvbnNvbGUubG9nKGJyZWFrcyk7XG4gICAgdGhpcy5wb2ludHMgPSBicmVha3M7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5wb2ludHMpO1xuICAgIHJldHVybjtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgdGhlIHNjcm9sbGluZyBlbGVtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBwc3VlZG8tcmFuZG9tIGlkIGZvciB1bmlxdWUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgU3RpY2t5LnByb3RvdHlwZS5fZXZlbnRzID0gZnVuY3Rpb24oaWQpe1xuICAgIC8vIGNvbnNvbGUubG9nKCdjYWxsZWQnKTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBzY3JvbGxMaXN0ZW5lciA9ICdzY3JvbGwuemYuJyArIGlkO1xuICAgIGlmKHRoaXMuaXNPbil7IHJldHVybjsgfVxuICAgIGlmKHRoaXMuY2FuU3RpY2spe1xuICAgICAgdGhpcy5pc09uID0gdHJ1ZTtcbiAgICAgIC8vIHRoaXMuJGFuY2hvci5vZmYoJ2NoYW5nZS56Zi5zdGlja3knKVxuICAgICAgLy8gICAgICAgICAgICAgLm9uKCdjaGFuZ2UuemYuc3RpY2t5JywgZnVuY3Rpb24oKXtcbiAgICAgIC8vICAgICAgICAgICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uKCl7XG4gICAgICAvLyAgICAgICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UpO1xuICAgICAgLy8gICAgICAgICAgICAgICB9KTtcbiAgICAgIC8vICAgICAgICAgICAgIH0pO1xuXG4gICAgICAkKHdpbmRvdykub2ZmKHNjcm9sbExpc3RlbmVyKVxuICAgICAgICAgICAgICAgLm9uKHNjcm9sbExpc3RlbmVyLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgaWYoX3RoaXMuc2Nyb2xsQ291bnQgPT09IDApe1xuICAgICAgICAgICAgICAgICAgIF90aGlzLnNjcm9sbENvdW50ID0gX3RoaXMub3B0aW9ucy5jaGVja0V2ZXJ5O1xuICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRTaXplcyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgIF90aGlzLnNjcm9sbENvdW50LS07XG4gICAgICAgICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKVxuICAgICAgICAgICAgICAgICAub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbihlLCBlbCl7XG4gICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0U2l6ZXMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICBpZihfdGhpcy5jYW5TdGljayl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYoIV90aGlzLmlzT24pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2V2ZW50cyhpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZihfdGhpcy5pc09uKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcGF1c2VMaXN0ZW5lcnMoc2Nyb2xsTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBldmVudCBoYW5kbGVycyBmb3Igc2Nyb2xsIGFuZCBjaGFuZ2UgZXZlbnRzIG9uIGFuY2hvci5cbiAgICogQGZpcmVzIFN0aWNreSNwYXVzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2Nyb2xsTGlzdGVuZXIgLSB1bmlxdWUsIG5hbWVzcGFjZWQgc2Nyb2xsIGxpc3RlbmVyIGF0dGFjaGVkIHRvIGB3aW5kb3dgXG4gICAqL1xuICBTdGlja3kucHJvdG90eXBlLl9wYXVzZUxpc3RlbmVycyA9IGZ1bmN0aW9uKHNjcm9sbExpc3RlbmVyKXtcbiAgICB0aGlzLmlzT24gPSBmYWxzZTtcbiAgICAvLyB0aGlzLiRhbmNob3Iub2ZmKCdjaGFuZ2UuemYuc3RpY2t5Jyk7XG4gICAgJCh3aW5kb3cpLm9mZihzY3JvbGxMaXN0ZW5lcik7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaXMgcGF1c2VkIGR1ZSB0byByZXNpemUgZXZlbnQgc2hyaW5raW5nIHRoZSB2aWV3LlxuICAgICAqIEBldmVudCBTdGlja3kjcGF1c2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3BhdXNlLnpmLnN0aWNreScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgb24gZXZlcnkgYHNjcm9sbGAgZXZlbnQgYW5kIG9uIGBfaW5pdGBcbiAgICogZmlyZXMgZnVuY3Rpb25zIGJhc2VkIG9uIGJvb2xlYW5zIGFuZCBjYWNoZWQgdmFsdWVzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tTaXplcyAtIHRydWUgaWYgcGx1Z2luIHNob3VsZCByZWNhbGN1bGF0ZSBzaXplcyBhbmQgYnJlYWtwb2ludHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGwgLSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBwYXNzZWQgZnJvbSBzY3JvbGwgZXZlbnQgY2IgZnVuY3Rpb24uIElmIG5vdCBwYXNzZWQsIGRlZmF1bHRzIHRvIGB3aW5kb3cucGFnZVlPZmZzZXRgLlxuICAgKi9cbiAgU3RpY2t5LnByb3RvdHlwZS5fY2FsYyA9IGZ1bmN0aW9uKGNoZWNrU2l6ZXMsIHNjcm9sbCl7XG4gICAgaWYoY2hlY2tTaXplcyl7IHRoaXMuX3NldFNpemVzKCk7IH1cblxuICAgIGlmKCF0aGlzLmNhblN0aWNrKXtcbiAgICAgIGlmKHRoaXMuaXNTdHVjayl7XG4gICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZighc2Nyb2xsKXsgc2Nyb2xsID0gd2luZG93LnBhZ2VZT2Zmc2V0OyB9XG5cbiAgICBpZihzY3JvbGwgPj0gdGhpcy50b3BQb2ludCl7XG4gICAgICBpZihzY3JvbGwgPD0gdGhpcy5ib3R0b21Qb2ludCl7XG4gICAgICAgIGlmKCF0aGlzLmlzU3R1Y2spe1xuICAgICAgICAgIHRoaXMuX3NldFN0aWNreSgpO1xuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYodGhpcy5pc1N0dWNrKXtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3koZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICBpZih0aGlzLmlzU3R1Y2spe1xuICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3kodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQ2F1c2VzIHRoZSAkZWxlbWVudCB0byBiZWNvbWUgc3R1Y2suXG4gICAqIEFkZHMgYHBvc2l0aW9uOiBmaXhlZDtgLCBhbmQgaGVscGVyIGNsYXNzZXMuXG4gICAqIEBmaXJlcyBTdGlja3kjc3R1Y2t0b1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFN0aWNreS5wcm90b3R5cGUuX3NldFN0aWNreSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHN0aWNrVG8gPSB0aGlzLm9wdGlvbnMuc3RpY2tUbyxcbiAgICAgICAgbXJnbiA9IHN0aWNrVG8gPT09ICd0b3AnID8gJ21hcmdpblRvcCcgOiAnbWFyZ2luQm90dG9tJyxcbiAgICAgICAgbm90U3R1Y2tUbyA9IHN0aWNrVG8gPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJyxcbiAgICAgICAgY3NzID0ge307XG5cbiAgICBjc3NbbXJnbl0gPSB0aGlzLm9wdGlvbnNbbXJnbl0gKyAnZW0nO1xuICAgIGNzc1tzdGlja1RvXSA9IDA7XG4gICAgY3NzW25vdFN0dWNrVG9dID0gJ2F1dG8nO1xuICAgIGNzc1snbGVmdCddID0gdGhpcy4kY29udGFpbmVyLm9mZnNldCgpLmxlZnQgKyBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRjb250YWluZXJbMF0pW1wicGFkZGluZy1sZWZ0XCJdLCAxMCk7XG4gICAgdGhpcy5pc1N0dWNrID0gdHJ1ZTtcbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1hbmNob3JlZCBpcy1hdC0nICsgbm90U3R1Y2tUbylcbiAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdpcy1zdHVjayBpcy1hdC0nICsgc3RpY2tUbylcbiAgICAgICAgICAgICAgICAgLmNzcyhjc3MpXG4gICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSAkZWxlbWVudCBoYXMgYmVjb21lIGBwb3NpdGlvbjogZml4ZWQ7YFxuICAgICAgICAgICAgICAgICAgKiBOYW1lc3BhY2VkIHRvIGB0b3BgIG9yIGBib3R0b21gLlxuICAgICAgICAgICAgICAgICAgKiBAZXZlbnQgU3RpY2t5I3N0dWNrdG9cbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgIC50cmlnZ2VyKCdzdGlja3kuemYuc3R1Y2t0bzonICsgc3RpY2tUbyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhdXNlcyB0aGUgJGVsZW1lbnQgdG8gYmVjb21lIHVuc3R1Y2suXG4gICAqIFJlbW92ZXMgYHBvc2l0aW9uOiBmaXhlZDtgLCBhbmQgaGVscGVyIGNsYXNzZXMuXG4gICAqIEFkZHMgb3RoZXIgaGVscGVyIGNsYXNzZXMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNUb3AgLSB0ZWxscyB0aGUgZnVuY3Rpb24gaWYgdGhlICRlbGVtZW50IHNob3VsZCBhbmNob3IgdG8gdGhlIHRvcCBvciBib3R0b20gb2YgaXRzICRhbmNob3IgZWxlbWVudC5cbiAgICogQGZpcmVzIFN0aWNreSN1bnN0dWNrZnJvbVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU3RpY2t5LnByb3RvdHlwZS5fcmVtb3ZlU3RpY2t5ID0gZnVuY3Rpb24oaXNUb3Ape1xuICAgIHZhciBzdGlja1RvID0gdGhpcy5vcHRpb25zLnN0aWNrVG8sXG4gICAgICAgIHN0aWNrVG9Ub3AgPSBzdGlja1RvID09PSAndG9wJyxcbiAgICAgICAgY3NzID0ge30sIG1yZ24sIG5vdFN0dWNrVG8sXG4gICAgICAgIGFuY2hvclB0ID0gKHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gLSB0aGlzLnBvaW50c1swXSA6IHRoaXMuYW5jaG9ySGVpZ2h0KSAtIHRoaXMuZWxlbUhlaWdodDtcbiAgICAgICAgbXJnbiA9IHN0aWNrVG9Ub3AgPyAnbWFyZ2luVG9wJyA6ICdtYXJnaW5Cb3R0b20nO1xuICAgICAgICBub3RTdHVja1RvID0gc3RpY2tUb1RvcCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICBjc3NbbXJnbl0gPSAwO1xuICAgIGlmKChpc1RvcCAmJiAhc3RpY2tUb1RvcCkgfHwgKHN0aWNrVG9Ub3AgJiYgIWlzVG9wKSl7XG4gICAgICBjc3Nbc3RpY2tUb10gPSBhbmNob3JQdDtcbiAgICAgIGNzc1tub3RTdHVja1RvXSA9IDA7XG4gICAgfWVsc2V7XG4gICAgICBjc3Nbc3RpY2tUb10gPSAwO1xuICAgICAgY3NzW25vdFN0dWNrVG9dID0gYW5jaG9yUHQ7XG4gICAgfVxuICAgIGNzc1snbGVmdCddID0gJyc7XG4gICAgdGhpcy5pc1N0dWNrID0gZmFsc2U7XG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtc3R1Y2sgaXMtYXQtJyArIHN0aWNrVG8pXG4gICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnaXMtYW5jaG9yZWQgaXMtYXQtJyArIChpc1RvcCA/ICd0b3AnIDogJ2JvdHRvbScpKVxuICAgICAgICAgICAgICAgICAuY3NzKGNzcylcbiAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlICRlbGVtZW50IGhhcyBiZWNvbWUgYW5jaG9yZWQuXG4gICAgICAgICAgICAgICAgICAqIE5hbWVzcGFjZWQgdG8gYHRvcGAgb3IgYGJvdHRvbWAuXG4gICAgICAgICAgICAgICAgICAqIEBldmVudCBTdGlja3kjdW5zdHVja2Zyb21cbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgIC50cmlnZ2VyKCdzdGlja3kuemYudW5zdHVja2Zyb206JyArIGlzVG9wID8gJ3RvcCcgOiAnYm90dG9tJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlICRlbGVtZW50IGFuZCAkY29udGFpbmVyIHNpemVzIGZvciBwbHVnaW4uXG4gICAqIENhbGxzIGBfc2V0QnJlYWtQb2ludHNgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb24gY29tcGxldGlvbiBvZiBgX3NldEJyZWFrUG9pbnRzYC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFN0aWNreS5wcm90b3R5cGUuX3NldFNpemVzID0gZnVuY3Rpb24oY2Ipe1xuICAgIHRoaXMuY2FuU3RpY2sgPSBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuc3RpY2t5T24pO1xuICAgIGlmKCF0aGlzLmNhblN0aWNrKXsgY2IoKTsgfVxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIG5ld0VsZW1XaWR0aCA9IHRoaXMuJGNvbnRhaW5lclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxcbiAgICAgICAgY29tcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSksXG4gICAgICAgIHBkbmcgPSBwYXJzZUludChjb21wWydwYWRkaW5nLXJpZ2h0J10sIDEwKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuJGFuY2hvcik7XG4gICAgaWYodGhpcy4kYW5jaG9yICYmIHRoaXMuJGFuY2hvci5sZW5ndGgpe1xuICAgICAgdGhpcy5hbmNob3JIZWlnaHQgPSB0aGlzLiRhbmNob3JbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIH1lbHNle1xuICAgICAgdGhpcy5fcGFyc2VQb2ludHMoKTtcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICAnbWF4LXdpZHRoJzogbmV3RWxlbVdpZHRoIC0gcGRuZyArICdweCdcbiAgICB9KTtcblxuICAgIHZhciBuZXdDb250YWluZXJIZWlnaHQgPSB0aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCB8fCB0aGlzLmNvbnRhaW5lckhlaWdodDtcbiAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IG5ld0NvbnRhaW5lckhlaWdodDtcbiAgICB0aGlzLiRjb250YWluZXIuY3NzKHtcbiAgICAgIGhlaWdodDogbmV3Q29udGFpbmVySGVpZ2h0XG4gICAgfSk7XG4gICAgdGhpcy5lbGVtSGVpZ2h0ID0gbmV3Q29udGFpbmVySGVpZ2h0O1xuXG4gIFx0aWYgKHRoaXMuaXNTdHVjaykge1xuICBcdFx0dGhpcy4kZWxlbWVudC5jc3Moe1wibGVmdFwiOnRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0ICsgcGFyc2VJbnQoY29tcFsncGFkZGluZy1sZWZ0J10sIDEwKX0pO1xuICBcdH1cblxuICAgIHRoaXMuX3NldEJyZWFrUG9pbnRzKG5ld0NvbnRhaW5lckhlaWdodCwgZnVuY3Rpb24oKXtcbiAgICAgIGlmKGNiKXsgY2IoKTsgfVxuICAgIH0pO1xuXG4gIH07XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1cHBlciBhbmQgbG93ZXIgYnJlYWtwb2ludHMgZm9yIHRoZSBlbGVtZW50IHRvIGJlY29tZSBzdGlja3kvdW5zdGlja3kuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbGVtSGVpZ2h0IC0gcHggdmFsdWUgZm9yIHN0aWNreS4kZWxlbWVudCBoZWlnaHQsIGNhbGN1bGF0ZWQgYnkgYF9zZXRTaXplc2AuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGNvbXBsZXRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTdGlja3kucHJvdG90eXBlLl9zZXRCcmVha1BvaW50cyA9IGZ1bmN0aW9uKGVsZW1IZWlnaHQsIGNiKXtcbiAgICBpZighdGhpcy5jYW5TdGljayl7XG4gICAgICBpZihjYil7IGNiKCk7IH1cbiAgICAgIGVsc2V7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cbiAgICB2YXIgbVRvcCA9IGVtQ2FsYyh0aGlzLm9wdGlvbnMubWFyZ2luVG9wKSxcbiAgICAgICAgbUJ0bSA9IGVtQ2FsYyh0aGlzLm9wdGlvbnMubWFyZ2luQm90dG9tKSxcbiAgICAgICAgdG9wUG9pbnQgPSB0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzBdIDogdGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCxcbiAgICAgICAgYm90dG9tUG9pbnQgPSB0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzFdIDogdG9wUG9pbnQgKyB0aGlzLmFuY2hvckhlaWdodCxcbiAgICAgICAgLy8gdG9wUG9pbnQgPSB0aGlzLiRhbmNob3Iub2Zmc2V0KCkudG9wIHx8IHRoaXMucG9pbnRzWzBdLFxuICAgICAgICAvLyBib3R0b21Qb2ludCA9IHRvcFBvaW50ICsgdGhpcy5hbmNob3JIZWlnaHQgfHwgdGhpcy5wb2ludHNbMV0sXG4gICAgICAgIHdpbkhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgIGlmKHRoaXMub3B0aW9ucy5zdGlja1RvID09PSAndG9wJyl7XG4gICAgICB0b3BQb2ludCAtPSBtVG9wO1xuICAgICAgYm90dG9tUG9pbnQgLT0gKGVsZW1IZWlnaHQgKyBtVG9wKTtcbiAgICB9ZWxzZSBpZih0aGlzLm9wdGlvbnMuc3RpY2tUbyA9PT0gJ2JvdHRvbScpe1xuICAgICAgdG9wUG9pbnQgLT0gKHdpbkhlaWdodCAtIChlbGVtSGVpZ2h0ICsgbUJ0bSkpO1xuICAgICAgYm90dG9tUG9pbnQgLT0gKHdpbkhlaWdodCAtIG1CdG0pO1xuICAgIH1lbHNle1xuICAgICAgLy90aGlzIHdvdWxkIGJlIHRoZSBzdGlja1RvOiBib3RoIG9wdGlvbi4uLiB0cmlja3lcbiAgICB9XG5cbiAgICB0aGlzLnRvcFBvaW50ID0gdG9wUG9pbnQ7XG4gICAgdGhpcy5ib3R0b21Qb2ludCA9IGJvdHRvbVBvaW50O1xuXG4gICAgaWYoY2IpeyBjYigpOyB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjdXJyZW50IHN0aWNreSBlbGVtZW50LlxuICAgKiBSZXNldHMgdGhlIGVsZW1lbnQgdG8gdGhlIHRvcCBwb3NpdGlvbiBmaXJzdC5cbiAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMsIEpTLWFkZGVkIGNzcyBwcm9wZXJ0aWVzIGFuZCBjbGFzc2VzLCBhbmQgdW53cmFwcyB0aGUgJGVsZW1lbnQgaWYgdGhlIEpTIGFkZGVkIHRoZSAkY29udGFpbmVyLlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIFN0aWNreS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fcmVtb3ZlU3RpY2t5KHRydWUpO1xuXG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MgKyAnIGlzLWFuY2hvcmVkIGlzLWF0LXRvcCcpXG4gICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgIGhlaWdodDogJycsXG4gICAgICAgICAgICAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgICAgICAgICAgICBib3R0b206ICcnLFxuICAgICAgICAgICAgICAgICAgICdtYXgtd2lkdGgnOiAnJ1xuICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAub2ZmKCdyZXNpemVtZS56Zi50cmlnZ2VyJyk7XG5cbiAgICB0aGlzLiRhbmNob3Iub2ZmKCdjaGFuZ2UuemYuc3RpY2t5Jyk7XG4gICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsLnpmLnN0aWNreScpO1xuXG4gICAgaWYodGhpcy53YXNXcmFwcGVkKXtcbiAgICAgIHRoaXMuJGVsZW1lbnQudW53cmFwKCk7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKVxuICAgICAgICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJydcbiAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGVtIHZhbHVlc1xuICAgKiBAcGFyYW0gTnVtYmVyIHtlbX0gLSBudW1iZXIgb2YgZW0ncyB0byBjYWxjdWxhdGUgaW50byBwaXhlbHNcbiAgICovXG4gIGZ1bmN0aW9uIGVtQ2FsYyhlbSl7XG4gICAgcmV0dXJuIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHksIG51bGwpLmZvbnRTaXplLCAxMCkgKiBlbTtcbiAgfVxuICBGb3VuZGF0aW9uLnBsdWdpbihTdGlja3ksICdTdGlja3knKTtcbn0oalF1ZXJ5LCB3aW5kb3cuRm91bmRhdGlvbik7XG4iLCIvKipcbiAqIFRhYnMgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnRhYnNcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudGltZXJBbmRJbWFnZUxvYWRlciBpZiB0YWJzIGNvbnRhaW4gaW1hZ2VzXG4gKi9cbiFmdW5jdGlvbigkLCBGb3VuZGF0aW9uKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0YWJzLlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIFRhYnMjaW5pdFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIHRhYnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG4gIGZ1bmN0aW9uIFRhYnMoZWxlbWVudCwgb3B0aW9ucyl7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRhYnMuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2luaXQoKTtcbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ1RhYnMnLCB7XG4gICAgICAnRU5URVInOiAnb3BlbicsXG4gICAgICAnU1BBQ0UnOiAnb3BlbicsXG4gICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXG4gICAgICAnQVJST1dfVVAnOiAncHJldmlvdXMnLFxuICAgICAgJ0FSUk9XX0RPV04nOiAnbmV4dCcsXG4gICAgICAnQVJST1dfTEVGVCc6ICdwcmV2aW91cycsXG4gICAgICAvLyAnVEFCJzogJ25leHQnLFxuICAgICAgLy8gJ1NISUZUX1RBQic6ICdwcmV2aW91cydcbiAgICB9KTtcbiAgfVxuXG4gIFRhYnMuZGVmYXVsdHMgPSB7XG4gICAgLy8gLyoqXG4gICAgLy8gICogQWxsb3dzIHRoZSBKUyB0byBhbHRlciB0aGUgdXJsIG9mIHRoZSB3aW5kb3cuIE5vdCB5ZXQgaW1wbGVtZW50ZWQuXG4gICAgLy8gICovXG4gICAgLy8gZGVlcExpbmtpbmc6IGZhbHNlLFxuICAgIC8vIC8qKlxuICAgIC8vICAqIElmIGRlZXBMaW5raW5nIGlzIGVuYWJsZWQsIGFsbG93cyB0aGUgd2luZG93IHRvIHNjcm9sbCB0byBjb250ZW50IGlmIHdpbmRvdyBpcyBsb2FkZWQgd2l0aCBhIGhhc2ggaW5jbHVkaW5nIGEgdGFiLXBhbmUgaWRcbiAgICAvLyAgKi9cbiAgICAvLyBzY3JvbGxUb0NvbnRlbnQ6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgd2luZG93IHRvIHNjcm9sbCB0byBjb250ZW50IG9mIGFjdGl2ZSBwYW5lIG9uIGxvYWQgaWYgc2V0IHRvIHRydWUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovXG4gICAgYXV0b0ZvY3VzOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBBbGxvd3Mga2V5Ym9hcmQgaW5wdXQgdG8gJ3dyYXAnIGFyb3VuZCB0aGUgdGFiIGxpbmtzLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSB0cnVlXG4gICAgICovXG4gICAgd3JhcE9uS2V5czogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIHRhYiBjb250ZW50IHBhbmVzIHRvIG1hdGNoIGhlaWdodHMgaWYgc2V0IHRvIHRydWUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovXG4gICAgbWF0Y2hIZWlnaHQ6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gYGxpYCdzIGluIHRhYiBsaW5rIGxpc3QuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICd0YWJzLXRpdGxlJ1xuICAgICAqL1xuICAgIGxpbmtDbGFzczogJ3RhYnMtdGl0bGUnLFxuICAgIC8vIGNvbnRlbnRDbGFzczogJ3RhYnMtY29udGVudCcsXG4gICAgLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgY29udGVudCBjb250YWluZXJzLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAndGFicy1wYW5lbCdcbiAgICAgKi9cbiAgICBwYW5lbENsYXNzOiAndGFicy1wYW5lbCdcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHRhYnMgYnkgc2hvd2luZyBhbmQgZm9jdXNpbmcgKGlmIGF1dG9Gb2N1cz10cnVlKSB0aGUgcHJlc2V0IGFjdGl2ZSB0YWIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUYWJzLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuJHRhYlRpdGxlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMubGlua0NsYXNzKTtcbiAgICB0aGlzLiR0YWJDb250ZW50ID0gJCgnW2RhdGEtdGFicy1jb250ZW50PVwiJyArIHRoaXMuJGVsZW1lbnRbMF0uaWQgKyAnXCJdJyk7XG5cbiAgICB0aGlzLiR0YWJUaXRsZXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyICRlbGVtID0gJCh0aGlzKSxcbiAgICAgICAgICAkbGluayA9ICRlbGVtLmZpbmQoJ2EnKSxcbiAgICAgICAgICBpc0FjdGl2ZSA9ICRlbGVtLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSxcbiAgICAgICAgICBoYXNoID0gJGxpbmsuYXR0cignaHJlZicpLnNsaWNlKDEpLFxuICAgICAgICAgIGxpbmtJZCA9IGhhc2ggKyAnLWxhYmVsJyxcbiAgICAgICAgICAkdGFiQ29udGVudCA9ICQoaGFzaCk7XG5cbiAgICAgICRlbGVtLmF0dHIoeydyb2xlJzogJ3ByZXNlbnRhdGlvbid9KTtcblxuICAgICAgJGxpbmsuYXR0cih7XG4gICAgICAgICdyb2xlJzogJ3RhYicsXG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogaGFzaCxcbiAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBpc0FjdGl2ZSxcbiAgICAgICAgJ2lkJzogbGlua0lkXG4gICAgICB9KTtcblxuICAgICAgJHRhYkNvbnRlbnQuYXR0cih7XG4gICAgICAgICdyb2xlJzogJ3RhYnBhbmVsJyxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogIWlzQWN0aXZlLFxuICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogbGlua0lkXG4gICAgICB9KTtcblxuICAgICAgaWYoaXNBY3RpdmUgJiYgX3RoaXMub3B0aW9ucy5hdXRvRm9jdXMpe1xuICAgICAgICAkbGluay5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCl7XG4gICAgICB2YXIgJGltYWdlcyA9IHRoaXMuJHRhYkNvbnRlbnQuZmluZCgnaW1nJyk7XG4gICAgICBpZigkaW1hZ2VzLmxlbmd0aCl7XG4gICAgICAgIEZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQoJGltYWdlcywgdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcykpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRoaXMuX3NldEhlaWdodCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9ldmVudHMoKTtcbiAgfTtcbiAgLyoqXG4gICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIGl0ZW1zIHdpdGhpbiB0aGUgdGFicy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gICBUYWJzLnByb3RvdHlwZS5fZXZlbnRzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9hZGRLZXlIYW5kbGVyKCk7XG4gICAgdGhpcy5fYWRkQ2xpY2tIYW5kbGVyKCk7XG4gICAgaWYodGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0KXtcbiAgICAgICQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBjbGljayBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSB0YWJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVGFicy5wcm90b3R5cGUuX2FkZENsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLiR0YWJUaXRsZXMub2ZmKCdjbGljay56Zi50YWJzJylcbiAgICAgICAgICAgICAgICAgICAub24oJ2NsaWNrLnpmLnRhYnMnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICBpZigkKHRoaXMpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSl7XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMga2V5Ym9hcmQgZXZlbnQgaGFuZGxlcnMgZm9yIGl0ZW1zIHdpdGhpbiB0aGUgdGFicy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRhYnMucHJvdG90eXBlLl9hZGRLZXlIYW5kbGVyID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciAkZmlyc3RUYWIgPSBfdGhpcy4kZWxlbWVudC5maW5kKCdsaTpmaXJzdC1vZi10eXBlJyk7XG4gICAgdmFyICRsYXN0VGFiID0gX3RoaXMuJGVsZW1lbnQuZmluZCgnbGk6bGFzdC1vZi10eXBlJyk7XG5cbiAgICB0aGlzLiR0YWJUaXRsZXMub2ZmKCdrZXlkb3duLnpmLnRhYnMnKS5vbigna2V5ZG93bi56Zi50YWJzJywgZnVuY3Rpb24oZSl7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMpLFxuICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJyksXG4gICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgJG5leHRFbGVtZW50O1xuXG4gICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIGlmICgkKHRoaXMpLmlzKCRlbGVtZW50KSkge1xuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLndyYXBPbktleXMpIHtcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCA9IGkgPT09IDAgPyAkZWxlbWVudHMubGFzdCgpIDogJGVsZW1lbnRzLmVxKGktMSk7XG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSBpID09PSAkZWxlbWVudHMubGVuZ3RoIC0xID8gJGVsZW1lbnRzLmZpcnN0KCkgOiAkZWxlbWVudHMuZXEoaSsxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWF4KDAsIGktMSkpO1xuICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWluKGkrMSwgJGVsZW1lbnRzLmxlbmd0aC0xKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcbiAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsIF90aGlzLCB7XG4gICAgICAgIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRlbGVtZW50LmZpbmQoJ1tyb2xlPVwidGFiXCJdJykuZm9jdXMoKTtcbiAgICAgICAgICBfdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCRlbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRwcmV2RWxlbWVudC5maW5kKCdbcm9sZT1cInRhYlwiXScpLmZvY3VzKCk7XG4gICAgICAgICAgX3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkcHJldkVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkbmV4dEVsZW1lbnQuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKS5mb2N1cygpO1xuICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJG5leHRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cblxuICAvKipcbiAgICogT3BlbnMgdGhlIHRhYiBgJHRhcmdldENvbnRlbnRgIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFRhYiB0byBvcGVuLlxuICAgKiBAZmlyZXMgVGFicyNjaGFuZ2VcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBUYWJzLnByb3RvdHlwZS5faGFuZGxlVGFiQ2hhbmdlID0gZnVuY3Rpb24oJHRhcmdldCl7XG4gICAgdmFyICR0YWJMaW5rID0gJHRhcmdldC5maW5kKCdbcm9sZT1cInRhYlwiXScpLFxuICAgICAgICBoYXNoID0gJHRhYkxpbmsuYXR0cignaHJlZicpLFxuICAgICAgICAkdGFyZ2V0Q29udGVudCA9ICQoaGFzaCksXG5cbiAgICAgICAgJG9sZFRhYiA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMubGlua0NsYXNzICsgJy5pcy1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5maW5kKCdbcm9sZT1cInRhYlwiXScpXG4gICAgICAgICAgICAgICAgICAuYXR0cih7J2FyaWEtc2VsZWN0ZWQnOiAnZmFsc2UnfSkuYXR0cignaHJlZicpO1xuXG4gICAgJCgkb2xkVGFiKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJykuYXR0cih7J2FyaWEtaGlkZGVuJzogJ3RydWUnfSk7XG5cbiAgICAkdGFyZ2V0LmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcblxuICAgICR0YWJMaW5rLmF0dHIoeydhcmlhLXNlbGVjdGVkJzogJ3RydWUnfSk7XG5cbiAgICAkdGFyZ2V0Q29udGVudFxuICAgICAgLmFkZENsYXNzKCdpcy1hY3RpdmUnKVxuICAgICAgLmF0dHIoeydhcmlhLWhpZGRlbic6ICdmYWxzZSd9KTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgc3VjY2Vzc2Z1bGx5IGNoYW5nZWQgdGFicy5cbiAgICAgKiBAZXZlbnQgVGFicyNjaGFuZ2VcbiAgICAgKi9cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZS56Zi50YWJzJywgWyR0YXJnZXRdKTtcbiAgICAvLyBGb3VuZGF0aW9uLnJlZmxvdyh0aGlzLiRlbGVtZW50LCAndGFicycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kIGZvciBzZWxlY3RpbmcgYSBjb250ZW50IHBhbmUgdG8gZGlzcGxheS5cbiAgICogQHBhcmFtIHtqUXVlcnkgfCBTdHJpbmd9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IG9yIHN0cmluZyBvZiB0aGUgaWQgb2YgdGhlIHBhbmUgdG8gZGlzcGxheS5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBUYWJzLnByb3RvdHlwZS5zZWxlY3RUYWIgPSBmdW5jdGlvbihlbGVtKXtcbiAgICB2YXIgaWRTdHI7XG4gICAgaWYodHlwZW9mIGVsZW0gPT09ICdvYmplY3QnKXtcbiAgICAgIGlkU3RyID0gZWxlbVswXS5pZDtcbiAgICB9ZWxzZXtcbiAgICAgIGlkU3RyID0gZWxlbTtcbiAgICB9XG5cbiAgICBpZihpZFN0ci5pbmRleE9mKCcjJykgPCAwKXtcbiAgICAgIGlkU3RyID0gJyMnICsgaWRTdHI7XG4gICAgfVxuICAgIHZhciAkdGFyZ2V0ID0gdGhpcy4kdGFiVGl0bGVzLmZpbmQoJ1tocmVmPVwiJyArIGlkU3RyICsgJ1wiXScpLnBhcmVudCgnLicgKyB0aGlzLm9wdGlvbnMubGlua0NsYXNzKTtcblxuICAgIHRoaXMuX2hhbmRsZVRhYkNoYW5nZSgkdGFyZ2V0KTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgdGhlIGhlaWdodCBvZiBlYWNoIHBhbmVsIHRvIHRoZSBoZWlnaHQgb2YgdGhlIHRhbGxlc3QgcGFuZWwuXG4gICAqIElmIGVuYWJsZWQgaW4gb3B0aW9ucywgZ2V0cyBjYWxsZWQgb24gbWVkaWEgcXVlcnkgY2hhbmdlLlxuICAgKiBJZiBsb2FkaW5nIGNvbnRlbnQgdmlhIGV4dGVybmFsIHNvdXJjZSwgY2FuIGJlIGNhbGxlZCBkaXJlY3RseSBvciB3aXRoIF9yZWZsb3cuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVGFicy5wcm90b3R5cGUuX3NldEhlaWdodCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG1heCA9IDA7XG4gICAgdGhpcy4kdGFiQ29udGVudC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5wYW5lbENsYXNzKVxuICAgICAgICAgICAgICAgICAgICAuY3NzKCdoZWlnaHQnLCAnJylcbiAgICAgICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZWwgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZSA9IHBhbmVsLmhhc0NsYXNzKCdpcy1hY3RpdmUnKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmKCFpc0FjdGl2ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lbC5jc3Moeyd2aXNpYmlsaXR5JzogJ2hpZGRlbicsICdkaXNwbGF5JzogJ2Jsb2NrJ30pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYoIWlzQWN0aXZlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLmNzcyh7J3Zpc2liaWxpdHknOiAnJywgJ2Rpc3BsYXknOiAnJ30pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIG1heCA9IHRlbXAgPiBtYXggPyB0ZW1wIDogbWF4O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY3NzKCdoZWlnaHQnLCBtYXggKyAncHgnKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYW4gdGFicy5cbiAgICogQGZpcmVzIFRhYnMjZGVzdHJveWVkXG4gICAqL1xuICBUYWJzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWxlbWVudC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpXG4gICAgICAgICAgICAgICAgIC5vZmYoJy56Zi50YWJzJykuaGlkZSgpLmVuZCgpXG4gICAgICAgICAgICAgICAgIC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5wYW5lbENsYXNzKVxuICAgICAgICAgICAgICAgICAuaGlkZSgpO1xuICAgIGlmKHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCl7XG4gICAgICAkKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknKTtcbiAgICB9XG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9O1xuXG4gIEZvdW5kYXRpb24ucGx1Z2luKFRhYnMsICdUYWJzJyk7XG5cbiAgZnVuY3Rpb24gY2hlY2tDbGFzcygkZWxlbSl7XG4gICAgcmV0dXJuICRlbGVtLmhhc0NsYXNzKCdpcy1hY3RpdmUnKTtcbiAgfVxufShqUXVlcnksIHdpbmRvdy5Gb3VuZGF0aW9uKTtcbiIsIi8qKlxuICogVG9nZ2xlciBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24udG9nZ2xlclxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAqL1xuXG4hZnVuY3Rpb24oRm91bmRhdGlvbiwgJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgVG9nZ2xlci5cbiAgICogQGNsYXNzXG4gICAqIEBmaXJlcyBUb2dnbGVyI2luaXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgKi9cbiAgZnVuY3Rpb24gVG9nZ2xlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRvZ2dsZXIuZGVmYXVsdHMsIGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9ICcnO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxuXG4gIFRvZ2dsZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHBsdWdpbiBpZiB0aGUgZWxlbWVudCBzaG91bGQgYW5pbWF0ZWQgd2hlbiB0b2dnbGVkLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgICAqL1xuICAgIGFuaW1hdGU6IGZhbHNlXG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBUb2dnbGVyIHBsdWdpbiBieSBwYXJzaW5nIHRoZSB0b2dnbGUgY2xhc3MgZnJvbSBkYXRhLXRvZ2dsZXIsIG9yIGFuaW1hdGlvbiBjbGFzc2VzIGZyb20gZGF0YS1hbmltYXRlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRvZ2dsZXIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlucHV0O1xuICAgIC8vIFBhcnNlIGFuaW1hdGlvbiBjbGFzc2VzIGlmIHRoZXkgd2VyZSBzZXRcbiAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgIGlucHV0ID0gdGhpcy5vcHRpb25zLmFuaW1hdGUuc3BsaXQoJyAnKTtcblxuICAgICAgdGhpcy5hbmltYXRpb25JbiA9IGlucHV0WzBdO1xuICAgICAgdGhpcy5hbmltYXRpb25PdXQgPSBpbnB1dFsxXSB8fCBudWxsO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIHBhcnNlIHRvZ2dsZSBjbGFzc1xuICAgIGVsc2Uge1xuICAgICAgaW5wdXQgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3RvZ2dsZXInKTtcblxuICAgICAgLy8gQWxsb3cgZm9yIGEgLiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmdcbiAgICAgIGlmIChpbnB1dFswXSA9PT0gJy4nKSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBpbnB1dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIHRvIHRyaWdnZXJzXG4gICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZDtcbiAgICAkKCdbZGF0YS1vcGVuPVwiJytpZCsnXCJdLCBbZGF0YS1jbG9zZT1cIicraWQrJ1wiXSwgW2RhdGEtdG9nZ2xlPVwiJytpZCsnXCJdJylcbiAgICAgIC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgaWQpO1xuXG4gICAgLy8gSWYgdGhlIHRhcmdldCBpcyBoaWRkZW4sIGFkZCBhcmlhLWhpZGRlblxuICAgIGlmICh0aGlzLiRlbGVtZW50LmlzKCc6aGlkZGVuJykpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciB0aGUgdG9nZ2xlIHRyaWdnZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVG9nZ2xlci5wcm90b3R5cGUuX2V2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLiRlbGVtZW50Lm9uKCd0b2dnbGUuemYudHJpZ2dlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMudG9nZ2xlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHRhcmdldCBjbGFzcyBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuIEFuIGV2ZW50IGlzIGZpcmVkIGZyb20gdGhlIG9yaWdpbmFsIHRyaWdnZXIgZGVwZW5kaW5nIG9uIGlmIHRoZSByZXN1bHRhbnQgc3RhdGUgd2FzIFwib25cIiBvciBcIm9mZlwiLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGZpcmVzIFRvZ2dsZXIjb25cbiAgICogQGZpcmVzIFRvZ2dsZXIjb2ZmXG4gICAqL1xuICBUb2dnbGVyLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRlKSB7XG4gICAgICB0aGlzLl90b2dnbGVDbGFzcygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3RvZ2dsZUFuaW1hdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVG9nZ2xlci5wcm90b3R5cGUuX3RvZ2dsZUNsYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKHRoaXMuY2xhc3NOYW1lKTtcblxuICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMuY2xhc3NOYW1lKSkge1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBhZnRlciBhIHRvZ2dsZS5cbiAgICAgICAqIEBldmVudCBUb2dnbGVyI29uXG4gICAgICAgKi9cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb24uemYudG9nZ2xlcicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgaWYgdGhlIHRhcmdldCBlbGVtZW50IGRvZXMgbm90IGhhdmUgdGhlIGNsYXNzIGFmdGVyIGEgdG9nZ2xlLlxuICAgICAgICogQGV2ZW50IFRvZ2dsZXIjb2ZmXG4gICAgICAgKi9cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb2ZmLnpmLnRvZ2dsZXInKTtcbiAgICB9XG5cbiAgICBfdGhpcy5fdXBkYXRlQVJJQSgpO1xuICB9O1xuXG4gIFRvZ2dsZXIucHJvdG90eXBlLl90b2dnbGVBbmltYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLiRlbGVtZW50LmlzKCc6aGlkZGVuJykpIHtcbiAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbih0aGlzLiRlbGVtZW50LCB0aGlzLmFuaW1hdGlvbkluLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdvbi56Zi50b2dnbGVyJyk7XG4gICAgICAgIF90aGlzLl91cGRhdGVBUklBKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsIHRoaXMuYW5pbWF0aW9uT3V0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdvZmYuemYudG9nZ2xlcicpO1xuICAgICAgICBfdGhpcy5fdXBkYXRlQVJJQSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIFRvZ2dsZXIucHJvdG90eXBlLl91cGRhdGVBUklBID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuJGVsZW1lbnQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZSBvZiBUb2dnbGVyIG9uIHRoZSBlbGVtZW50LlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIFRvZ2dsZXIucHJvdG90eXBlLmRlc3Ryb3k9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudG9nZ2xlcicpO1xuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfTtcblxuICBGb3VuZGF0aW9uLnBsdWdpbihUb2dnbGVyLCAnVG9nZ2xlcicpO1xuXG4gIC8vIEV4cG9ydHMgZm9yIEFNRC9Ccm93c2VyaWZ5XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKVxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9nZ2xlcjtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicpXG4gICAgZGVmaW5lKFsnZm91bmRhdGlvbiddLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBUb2dnbGVyO1xuICAgIH0pO1xuXG59KEZvdW5kYXRpb24sIGpRdWVyeSk7XG4iLCIvKipcbiAqIFRvb2x0aXAgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnRvb2x0aXBcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKi9cbiFmdW5jdGlvbigkLCBkb2N1bWVudCwgRm91bmRhdGlvbil7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIFRvb2x0aXAuXG4gICAqIEBjbGFzc1xuICAgKiBAZmlyZXMgVG9vbHRpcCNpbml0XG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhdHRhY2ggYSB0b29sdGlwIHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9iamVjdCB0byBleHRlbmQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIFRvb2x0aXAoZWxlbWVudCwgb3B0aW9ucyl7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRvb2x0aXAuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmlzQ2xpY2sgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9XG5cbiAgVG9vbHRpcC5kZWZhdWx0cyA9IHtcbiAgICBkaXNhYmxlRm9yVG91Y2g6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFRpbWUsIGluIG1zLCBiZWZvcmUgYSB0b29sdGlwIHNob3VsZCBvcGVuIG9uIGhvdmVyLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAyMDBcbiAgICAgKi9cbiAgICBob3ZlckRlbGF5OiAyMDAsXG4gICAgLyoqXG4gICAgICogVGltZSwgaW4gbXMsIGEgdG9vbHRpcCBzaG91bGQgdGFrZSB0byBmYWRlIGludG8gdmlldy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMTUwXG4gICAgICovXG4gICAgZmFkZUluRHVyYXRpb246IDE1MCxcbiAgICAvKipcbiAgICAgKiBUaW1lLCBpbiBtcywgYSB0b29sdGlwIHNob3VsZCB0YWtlIHRvIGZhZGUgb3V0IG9mIHZpZXcuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDE1MFxuICAgICAqL1xuICAgIGZhZGVPdXREdXJhdGlvbjogMTUwLFxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIGhvdmVyIGV2ZW50cyBmcm9tIG9wZW5pbmcgdGhlIHRvb2x0aXAgaWYgc2V0IHRvIHRydWVcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9cbiAgICBkaXNhYmxlSG92ZXI6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIGFkZHRpb25hbCBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSB0b29sdGlwIHRlbXBsYXRlIG9uIGluaXQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdteS1jb29sLXRpcC1jbGFzcydcbiAgICAgKi9cbiAgICB0ZW1wbGF0ZUNsYXNzZXM6ICcnLFxuICAgIC8qKlxuICAgICAqIE5vbi1vcHRpb25hbCBjbGFzcyBhZGRlZCB0byB0b29sdGlwIHRlbXBsYXRlcy4gRm91bmRhdGlvbiBkZWZhdWx0IGlzICd0b29sdGlwJy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ3Rvb2x0aXAnXG4gICAgICovXG4gICAgdG9vbHRpcENsYXNzOiAndG9vbHRpcCcsXG4gICAgLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgdG9vbHRpcCBhbmNob3IgZWxlbWVudC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ2hhcy10aXAnXG4gICAgICovXG4gICAgdHJpZ2dlckNsYXNzOiAnaGFzLXRpcCcsXG4gICAgLyoqXG4gICAgICogTWluaW11bSBicmVha3BvaW50IHNpemUgYXQgd2hpY2ggdG8gb3BlbiB0aGUgdG9vbHRpcC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ3NtYWxsJ1xuICAgICAqL1xuICAgIHNob3dPbjogJ3NtYWxsJyxcbiAgICAvKipcbiAgICAgKiBDdXN0b20gdGVtcGxhdGUgdG8gYmUgdXNlZCB0byBnZW5lcmF0ZSBtYXJrdXAgZm9yIHRvb2x0aXAuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICc8ZGl2IGNsYXNzPVwidG9vbHRpcFwiPjwvZGl2PidcbiAgICAgKi9cbiAgICB0ZW1wbGF0ZTogJycsXG4gICAgLyoqXG4gICAgICogVGV4dCBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXAgdGVtcGxhdGUgb24gb3Blbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ1NvbWUgY29vbCBzcGFjZSBmYWN0IGhlcmUuJ1xuICAgICAqL1xuICAgIHRpcFRleHQ6ICcnLFxuICAgIHRvdWNoQ2xvc2VUZXh0OiAnVGFwIHRvIGNsb3NlLicsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRoZSB0b29sdGlwIHRvIHJlbWFpbiBvcGVuIGlmIHRyaWdnZXJlZCB3aXRoIGEgY2xpY2sgb3IgdG91Y2ggZXZlbnQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9cbiAgICBjbGlja09wZW46IHRydWUsXG4gICAgLyoqXG4gICAgICogQWRkaXRpb25hbCBwb3NpdGlvbmluZyBjbGFzc2VzLCBzZXQgYnkgdGhlIEpTXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICd0b3AnXG4gICAgICovXG4gICAgcG9zaXRpb25DbGFzczogJycsXG4gICAgLyoqXG4gICAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHRlbXBsYXRlIHNob3VsZCBwdXNoIGF3YXkgZnJvbSB0aGUgYW5jaG9yIG9uIHRoZSBZIGF4aXMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDEwXG4gICAgICovXG4gICAgdk9mZnNldDogMTAsXG4gICAgLyoqXG4gICAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHRlbXBsYXRlIHNob3VsZCBwdXNoIGF3YXkgZnJvbSB0aGUgYW5jaG9yIG9uIHRoZSBYIGF4aXMsIGlmIGFsaWduZWQgdG8gYSBzaWRlLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxMlxuICAgICAqL1xuICAgIGhPZmZzZXQ6IDEyXG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSB0b29sdGlwIGJ5IHNldHRpbmcgdGhlIGNyZWF0aW5nIHRoZSB0aXAgZWxlbWVudCwgYWRkaW5nIGl0J3MgdGV4dCwgc2V0dGluZyBwcml2YXRlIHZhcmlhYmxlcyBhbmQgc2V0dGluZyBhdHRyaWJ1dGVzIG9uIHRoZSBhbmNob3IuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUb29sdGlwLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZW1JZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1kZXNjcmliZWRieScpIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ3Rvb2x0aXAnKTtcblxuICAgIHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzID0gdGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLiRlbGVtZW50KTtcbiAgICB0aGlzLm9wdGlvbnMudGlwVGV4dCA9IHRoaXMub3B0aW9ucy50aXBUZXh0IHx8IHRoaXMuJGVsZW1lbnQuYXR0cigndGl0bGUnKTtcbiAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlID8gJCh0aGlzLm9wdGlvbnMudGVtcGxhdGUpIDogdGhpcy5fYnVpbGRUZW1wbGF0ZShlbGVtSWQpO1xuXG4gICAgdGhpcy50ZW1wbGF0ZS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KVxuICAgICAgICAudGV4dCh0aGlzLm9wdGlvbnMudGlwVGV4dClcbiAgICAgICAgLmhpZGUoKTtcblxuICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAndGl0bGUnOiAnJyxcbiAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogZWxlbUlkLFxuICAgICAgJ2RhdGEteWV0aS1ib3gnOiBlbGVtSWQsXG4gICAgICAnZGF0YS10b2dnbGUnOiBlbGVtSWQsXG4gICAgICAnZGF0YS1yZXNpemUnOiBlbGVtSWRcbiAgICB9KS5hZGRDbGFzcyh0aGlzLnRyaWdnZXJDbGFzcyk7XG5cbiAgICAvL2hlbHBlciB2YXJpYWJsZXMgdG8gdHJhY2sgbW92ZW1lbnQgb24gY29sbGlzaW9uc1xuICAgIHRoaXMudXNlZFBvc2l0aW9ucyA9IFtdO1xuICAgIHRoaXMuY291bnRlciA9IDQ7XG4gICAgdGhpcy5jbGFzc0NoYW5nZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2V2ZW50cygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHcmFicyB0aGUgY3VycmVudCBwb3NpdGlvbmluZyBjbGFzcywgaWYgcHJlc2VudCwgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRvb2x0aXAucHJvdG90eXBlLl9nZXRQb3NpdGlvbkNsYXNzID0gZnVuY3Rpb24oZWxlbWVudCl7XG4gICAgaWYoIWVsZW1lbnQpeyByZXR1cm4gJyc7IH1cbiAgICAvLyB2YXIgcG9zaXRpb24gPSBlbGVtZW50LmF0dHIoJ2NsYXNzJykubWF0Y2goL3RvcHxsZWZ0fHJpZ2h0L2cpO1xuICAgIHZhciBwb3NpdGlvbiA9IGVsZW1lbnRbMF0uY2xhc3NOYW1lLm1hdGNoKC8odG9wfGxlZnR8cmlnaHQpL2cpO1xuICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID8gcG9zaXRpb25bMF0gOiAnJztcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH07XG4gIC8qKlxuICAgKiBidWlsZHMgdGhlIHRvb2x0aXAgZWxlbWVudCwgYWRkcyBhdHRyaWJ1dGVzLCBhbmQgcmV0dXJucyB0aGUgdGVtcGxhdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUb29sdGlwLnByb3RvdHlwZS5fYnVpbGRUZW1wbGF0ZSA9IGZ1bmN0aW9uKGlkKXtcbiAgICB2YXIgdGVtcGxhdGVDbGFzc2VzID0gKHRoaXMub3B0aW9ucy50b29sdGlwQ2xhc3MgKyAnICcgKyB0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcykudHJpbSgpO1xuICAgIHZhciAkdGVtcGxhdGUgPSAgJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcyh0ZW1wbGF0ZUNsYXNzZXMpLmF0dHIoe1xuICAgICAgJ3JvbGUnOiAndG9vbHRpcCcsXG4gICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgJ2RhdGEtaXMtYWN0aXZlJzogZmFsc2UsXG4gICAgICAnZGF0YS1pcy1mb2N1cyc6IGZhbHNlLFxuICAgICAgJ2lkJzogaWRcbiAgICB9KTtcbiAgICByZXR1cm4gJHRlbXBsYXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGlmIGEgY29sbGlzaW9uIGV2ZW50IGlzIGRldGVjdGVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24gLSBwb3NpdGlvbmluZyBjbGFzcyB0byB0cnlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRvb2x0aXAucHJvdG90eXBlLl9yZXBvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pe1xuICAgIHRoaXMudXNlZFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uID8gcG9zaXRpb24gOiAnYm90dG9tJyk7XG5cbiAgICAvL2RlZmF1bHQsIHRyeSBzd2l0Y2hpbmcgdG8gb3Bwb3NpdGUgc2lkZVxuICAgIGlmKCFwb3NpdGlvbiAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3RvcCcpIDwgMCkpe1xuICAgICAgdGhpcy50ZW1wbGF0ZS5hZGRDbGFzcygndG9wJyk7XG4gICAgfWVsc2UgaWYocG9zaXRpb24gPT09ICd0b3AnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignYm90dG9tJykgPCAwKSl7XG4gICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKTtcbiAgICB9ZWxzZSBpZihwb3NpdGlvbiA9PT0gJ2xlZnQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKSA8IDApKXtcbiAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pXG4gICAgICAgICAgLmFkZENsYXNzKCdyaWdodCcpO1xuICAgIH1lbHNlIGlmKHBvc2l0aW9uID09PSAncmlnaHQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkpe1xuICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhwb3NpdGlvbilcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2xlZnQnKTtcbiAgICB9XG5cbiAgICAvL2lmIGRlZmF1bHQgY2hhbmdlIGRpZG4ndCB3b3JrLCB0cnkgYm90dG9tIG9yIGxlZnQgZmlyc3RcbiAgICBlbHNlIGlmKCFwb3NpdGlvbiAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3RvcCcpID4gLTEpICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkpe1xuICAgICAgdGhpcy50ZW1wbGF0ZS5hZGRDbGFzcygnbGVmdCcpO1xuICAgIH1lbHNlIGlmKHBvc2l0aW9uID09PSAndG9wJyAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpID4gLTEpICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkpe1xuICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhwb3NpdGlvbilcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2xlZnQnKTtcbiAgICB9ZWxzZSBpZihwb3NpdGlvbiA9PT0gJ2xlZnQnICYmICh0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKSA+IC0xKSAmJiAodGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpIDwgMCkpe1xuICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XG4gICAgfWVsc2UgaWYocG9zaXRpb24gPT09ICdyaWdodCcgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0JykgPiAtMSkgJiYgKHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKSA8IDApKXtcbiAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xuICAgIH1cbiAgICAvL2lmIG5vdGhpbmcgY2xlYXJlZCwgc2V0IHRvIGJvdHRvbVxuICAgIGVsc2V7XG4gICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5jbGFzc0NoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuY291bnRlci0tO1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIHNldHMgdGhlIHBvc2l0aW9uIGNsYXNzIG9mIGFuIGVsZW1lbnQgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxzIGl0c2VsZiB1bnRpbCB0aGVyZSBhcmUgbm8gbW9yZSBwb3NzaWJsZSBwb3NpdGlvbnMgdG8gYXR0ZW1wdCwgb3IgdGhlIHRvb2x0aXAgZWxlbWVudCBpcyBubyBsb25nZXIgY29sbGlkaW5nLlxuICAgKiBpZiB0aGUgdG9vbHRpcCBpcyBsYXJnZXIgdGhhbiB0aGUgc2NyZWVuIHdpZHRoLCBkZWZhdWx0IHRvIGZ1bGwgd2lkdGggLSBhbnkgdXNlciBzZWxlY3RlZCBtYXJnaW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRvb2x0aXAucHJvdG90eXBlLl9zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLnRlbXBsYXRlKSxcbiAgICAgICAgJHRpcERpbXMgPSBGb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMudGVtcGxhdGUpLFxuICAgICAgICAkYW5jaG9yRGltcyA9IEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kZWxlbWVudCksXG4gICAgICAgIGRpcmVjdGlvbiA9IChwb3NpdGlvbiA9PT0gJ2xlZnQnID8gJ2xlZnQnIDogKChwb3NpdGlvbiA9PT0gJ3JpZ2h0JykgPyAnbGVmdCcgOiAndG9wJykpLFxuICAgICAgICBwYXJhbSA9IChkaXJlY3Rpb24gPT09ICd0b3AnKSA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcbiAgICAgICAgb2Zmc2V0ID0gKHBhcmFtID09PSAnaGVpZ2h0JykgPyB0aGlzLm9wdGlvbnMudk9mZnNldCA6IHRoaXMub3B0aW9ucy5oT2Zmc2V0LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZigoJHRpcERpbXMud2lkdGggPj0gJHRpcERpbXMud2luZG93RGltcy53aWR0aCkgfHwgKCF0aGlzLmNvdW50ZXIgJiYgIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkpKXtcbiAgICAgIHRoaXMudGVtcGxhdGUub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSwgdGhpcy4kZWxlbWVudCwgJ2NlbnRlciBib3R0b20nLCB0aGlzLm9wdGlvbnMudk9mZnNldCwgdGhpcy5vcHRpb25zLmhPZmZzZXQsIHRydWUpKS5jc3Moe1xuICAgICAgLy8gdGhpcy4kZWxlbWVudC5vZmZzZXQoRm91bmRhdGlvbi5HZXRPZmZzZXRzKHRoaXMudGVtcGxhdGUsIHRoaXMuJGVsZW1lbnQsICdjZW50ZXIgYm90dG9tJywgdGhpcy5vcHRpb25zLnZPZmZzZXQsIHRoaXMub3B0aW9ucy5oT2Zmc2V0LCB0cnVlKSkuY3NzKHtcbiAgICAgICAgJ3dpZHRoJzogJGFuY2hvckRpbXMud2luZG93RGltcy53aWR0aCAtICh0aGlzLm9wdGlvbnMuaE9mZnNldCAqIDIpLFxuICAgICAgICAnaGVpZ2h0JzogJ2F1dG8nXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnRlbXBsYXRlLm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMudGVtcGxhdGUsIHRoaXMuJGVsZW1lbnQsJ2NlbnRlciAnICsgKHBvc2l0aW9uIHx8ICdib3R0b20nKSwgdGhpcy5vcHRpb25zLnZPZmZzZXQsIHRoaXMub3B0aW9ucy5oT2Zmc2V0KSk7XG5cbiAgICB3aGlsZSghRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLnRlbXBsYXRlKSAmJiB0aGlzLmNvdW50ZXIpe1xuICAgICAgdGhpcy5fcmVwb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogcmV2ZWFscyB0aGUgdG9vbHRpcCwgYW5kIGZpcmVzIGFuIGV2ZW50IHRvIGNsb3NlIGFueSBvdGhlciBvcGVuIHRvb2x0aXBzIG9uIHRoZSBwYWdlXG4gICAqIEBmaXJlcyBDbG9zZW1lI3Rvb2x0aXBcbiAgICogQGZpcmVzIFRvb2x0aXAjc2hvd1xuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMub3B0aW9ucy5zaG93T24gIT09ICdhbGwnICYmICFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuc2hvd09uKSl7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdUaGUgc2NyZWVuIGlzIHRvbyBzbWFsbCB0byBkaXNwbGF5IHRoaXMgdG9vbHRpcCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy50ZW1wbGF0ZS5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuc2hvdygpO1xuICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB0byBjbG9zZSBhbGwgb3RoZXIgb3BlbiB0b29sdGlwcyBvbiB0aGUgcGFnZVxuICAgICAqIEBldmVudCBDbG9zZW1lI3Rvb2x0aXBcbiAgICAgKi9cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYudG9vbHRpcCcsIHRoaXMudGVtcGxhdGUuYXR0cignaWQnKSk7XG5cblxuICAgIHRoaXMudGVtcGxhdGUuYXR0cih7XG4gICAgICAnZGF0YS1pcy1hY3RpdmUnOiB0cnVlLFxuICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2VcbiAgICB9KTtcbiAgICBfdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy50ZW1wbGF0ZSk7XG4gICAgdGhpcy50ZW1wbGF0ZS5zdG9wKCkuaGlkZSgpLmNzcygndmlzaWJpbGl0eScsICcnKS5mYWRlSW4odGhpcy5vcHRpb25zLmZhZGVJbkR1cmF0aW9uLCBmdW5jdGlvbigpe1xuICAgICAgLy9tYXliZSBkbyBzdHVmZj9cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSB0b29sdGlwIGlzIHNob3duXG4gICAgICogQGV2ZW50IFRvb2x0aXAjc2hvd1xuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2hvdy56Zi50b29sdGlwJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBjdXJyZW50IHRvb2x0aXAsIGFuZCByZXNldHMgdGhlIHBvc2l0aW9uaW5nIGNsYXNzIGlmIGl0IHdhcyBjaGFuZ2VkIGR1ZSB0byBjb2xsaXNpb25cbiAgICogQGZpcmVzIFRvb2x0aXAjaGlkZVxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIFRvb2x0aXAucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpe1xuICAgIC8vIGNvbnNvbGUubG9nKCdoaWRpbmcnLCB0aGlzLiRlbGVtZW50LmRhdGEoJ3lldGktYm94JykpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy50ZW1wbGF0ZS5zdG9wKCkuYXR0cih7XG4gICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgJ2RhdGEtaXMtYWN0aXZlJzogZmFsc2VcbiAgICB9KS5mYWRlT3V0KHRoaXMub3B0aW9ucy5mYWRlT3V0RHVyYXRpb24sIGZ1bmN0aW9uKCl7XG4gICAgICBfdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgX3RoaXMuaXNDbGljayA9IGZhbHNlO1xuICAgICAgaWYoX3RoaXMuY2xhc3NDaGFuZ2VkKXtcbiAgICAgICAgX3RoaXMudGVtcGxhdGVcbiAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoX3RoaXMuX2dldFBvc2l0aW9uQ2xhc3MoX3RoaXMudGVtcGxhdGUpKVxuICAgICAgICAgICAgIC5hZGRDbGFzcyhfdGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MpO1xuXG4gICAgICAgX3RoaXMudXNlZFBvc2l0aW9ucyA9IFtdO1xuICAgICAgIF90aGlzLmNvdW50ZXIgPSA0O1xuICAgICAgIF90aGlzLmNsYXNzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIGZpcmVzIHdoZW4gdGhlIHRvb2x0aXAgaXMgaGlkZGVuXG4gICAgICogQGV2ZW50IFRvb2x0aXAjaGlkZVxuICAgICAqL1xuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi50b29sdGlwJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGFkZHMgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgdG9vbHRpcCBhbmQgaXRzIGFuY2hvclxuICAgKiBUT0RPIGNvbWJpbmUgc29tZSBvZiB0aGUgbGlzdGVuZXJzIGxpa2UgZm9jdXMgYW5kIG1vdXNlZW50ZXIsIGV0Yy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRvb2x0aXAucHJvdG90eXBlLl9ldmVudHMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyICR0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgdmFyIGlzRm9jdXMgPSBmYWxzZTtcblxuICAgIGlmKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyKXtcblxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgLm9uKCdtb3VzZWVudGVyLnpmLnRvb2x0aXAnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgaWYoIV90aGlzLmlzQWN0aXZlKXtcbiAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xuICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ21vdXNlbGVhdmUuemYudG9vbHRpcCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgIGlmKCFpc0ZvY3VzIHx8ICghX3RoaXMuaXNDbGljayAmJiBfdGhpcy5vcHRpb25zLmNsaWNrT3Blbikpe1xuICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmKHRoaXMub3B0aW9ucy5jbGlja09wZW4pe1xuICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2Vkb3duLnpmLnRvb2x0aXAnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYoX3RoaXMuaXNDbGljayl7XG4gICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgIC8vIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgX3RoaXMuaXNDbGljayA9IHRydWU7XG4gICAgICAgICAgaWYoKF90aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyIHx8ICFfdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpKSAmJiAhX3RoaXMuaXNBY3RpdmUpe1xuICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYoIXRoaXMub3B0aW9ucy5kaXNhYmxlRm9yVG91Y2gpe1xuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgLm9uKCd0YXAuemYudG9vbHRpcCB0b3VjaGVuZC56Zi50b29sdGlwJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIF90aGlzLmlzQWN0aXZlID8gX3RoaXMuaGlkZSgpIDogX3RoaXMuc2hvdygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAvLyAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxuICAgICAgLy8gJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmhpZGUuYmluZCh0aGlzKVxuICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmhpZGUuYmluZCh0aGlzKVxuICAgIH0pO1xuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLm9uKCdmb2N1cy56Zi50b29sdGlwJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIGlzRm9jdXMgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmxvZyhfdGhpcy5pc0NsaWNrKTtcbiAgICAgICAgaWYoX3RoaXMuaXNDbGljayl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAvLyAkKHdpbmRvdylcbiAgICAgICAgICBfdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC5vbignZm9jdXNvdXQuemYudG9vbHRpcCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBpc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgfSlcblxuICAgICAgLm9uKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoX3RoaXMuaXNBY3RpdmUpe1xuICAgICAgICAgIF90aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIGFkZHMgYSB0b2dnbGUgbWV0aG9kLCBpbiBhZGRpdGlvbiB0byB0aGUgc3RhdGljIHNob3coKSAmIGhpZGUoKSBmdW5jdGlvbnNcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBUb29sdGlwLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuaXNBY3RpdmUpe1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiB0b29sdGlwLCByZW1vdmVzIHRlbXBsYXRlIGVsZW1lbnQgZnJvbSB0aGUgdmlldy5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBUb29sdGlwLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ3RpdGxlJywgdGhpcy50ZW1wbGF0ZS50ZXh0KCkpXG4gICAgICAgICAgICAgICAgIC5vZmYoJy56Zi50cmlnZ2VyIC56Zi50b290aXAnKVxuICAgICAgICAgICAgICAgIC8vICAucmVtb3ZlQ2xhc3MoJ2hhcy10aXAnKVxuICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieScpXG4gICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLXlldGktYm94JylcbiAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtdG9nZ2xlJylcbiAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtcmVzaXplJyk7XG5cbiAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZSgpO1xuXG4gICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICB9O1xuICAvKipcbiAgICogVE9ETyB1dGlsaXplIHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqL1xuXG4gIEZvdW5kYXRpb24ucGx1Z2luKFRvb2x0aXAsICdUb29sdGlwJyk7XG59KGpRdWVyeSwgd2luZG93LmRvY3VtZW50LCB3aW5kb3cuRm91bmRhdGlvbik7XG4iLCIvKiAgICAgICAgICAgICAgXG4gKiBDaGFydE5ldy5qcyAgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gKiBWYW5jb3BwZW5vbGxlIEZyYW5jb2lzIC0gSmFudWFyeSAyMDE0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICogZnJhbmNvaXMudmFuY29wcGVub2xsZUBmYXZvbW8uYmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gKlxuICogR2l0SHViIGNvbW11bml0eSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9GVkFOQ09QL0NoYXJ0TmV3LmpzXG4gKlxuICogVGhpcyBmaWxlIGlzIG9yaWdpbmFsbHkgYW4gYWRhcHRhdGlvbiBvZiB0aGUgY2hhcnQuanMgc291cmNlIGRldmVsb3BwZWQgYnkgTmljayBEb3duaWUgKDIwMTMpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm5uaWNrL0NoYXJ0LmpzLiBCdXQgc2luY2UganVuZSAyMDE0LCBOaWNrIHB1dHMgYSBuZXcgdmVyc2lvbiB3aXRoIGFcbiAqIHJlZnVuZGVkIGNvZGUuIEN1cnJlbnQgY29kZSBvZiBDaGFydE5ldy5qcyBpcyBubyBtb3JlIGNvbXBhcmFibGUgdG8gdGhlIGNvZGUgb2YgQ2hhcnQuanMgXG4gKlxuICogbmV3IGNoYXJ0cyBjb21wYXJlZCB0byBDaGFydC5qc1xuICpcbiAqICAgICBob3Jpem9udGFsQmFyXG4gKiAgICAgaG9yaXpvbnRhbFN0YWNrZWRCYXJcbiAqXG4gKiBBZGRlZCBpdGVtcyBjb21wYXJlZCB0byBDaGFydC5qczpcbiAqXG4gKiAgICAgVGl0bGUsIFN1YnRpdGxlLCBmb290bm90ZXMsIGF4aXMgbGFiZWxzLCB1bml0IGxhYmVsXG4gKiAgICAgWSBBeGlzIG9uIHRoZSByaWdodCBhbmQvb3IgdGhlIGxlZnRcbiAqICAgICBjYW52YXMgQm9yZGVyXG4gKiAgICAgTGVnZW5kXG4gKiAgICAgY3Jvc3NUZXh0LCBjcm9zc0ltYWdlXG4gKiAgICAgZ3JhcGhNaW4sIGdyYXBoTWF4XG4gKiAgICAgbG9nYXJpdGhtaWMgeS1heGlzIChmb3IgbGluZSBhbmQgYmFyKVxuICogICAgIHJvdGF0ZUxhYmVsc1xuICogICAgIGFuZCBsb3Qgb2Ygb3RoZXJzLi4uXG4gKlxuICovXG5cbi8vIGN0eC5maXJzdFBhc3M9MCBvciBcInVuZGVmaW5lZFwiIDogQ2hhcnQgaGFzIG5ldmVyIGJlZW4gZHJhd24gKGJlY2F1c2UgZHluYW1pY0Rpc3BsYXkgPSB0cnVlIGFuZCBjdHggaGFzIG5ldmVyIGJlZW4gZGlzcGxheWVkIGluIGN1cnJlbnQgc2NyZWVuKVxuLy8gY3R4LmZpcnN0UGFzcz0xIDogQ2hhcnQgaGFzIHRvIGJlIGRyYXduIHdpdGggYW5pbWF0aW9uIChpZiBjb25maWcuYW5pbWF0aW9uID0gdHJ1ZSk7XG4vLyBjdHguZmlyc3RQYXNzPTIgOiBjaGFydCBoYXMgdG8gYmUgZHJhd24gd2l0aG91dCBhbmltYXRpb247XG4vLyBjdHguZmlyc3RQYXNzPTkgOiBjaGFydCBpcyBjb21wbGV0ZWx5IGRyYXduO1xuLy8gSWYgY2hhcnRKc1Jlc2l6ZSBjYWxsZWQgOiBpbmNyZW1lbnQgdGhlIHZhbHVlIG9mIGN0eC5maXJzdFBhc3Mgd2l0aCBhIHZhbHVlIG9mIDEwLlxuXG5cbi8vIG5vbiBzdGFuZGFyZCBmdW5jdGlvbnM7XG5cbnZhciBjaGFydEpTTGluZVN0eWxlPVtdO1xuY2hhcnRKU0xpbmVTdHlsZVtcInNvbGlkXCJdPVtdO1xuY2hhcnRKU0xpbmVTdHlsZVtcImRvdHRlZFwiXT1bMSw0XTtcbmNoYXJ0SlNMaW5lU3R5bGVbXCJzaG9ydERhc2hcIl09WzIsMV07XG5jaGFydEpTTGluZVN0eWxlW1wiZGFzaGVkXCJdPVs0LDJdO1xuY2hhcnRKU0xpbmVTdHlsZVtcImRhc2hTcGFjZVwiXT1bNCw2XTtcbmNoYXJ0SlNMaW5lU3R5bGVbXCJsb25nRGFzaERvdFwiXT1bNywyLDEsMl07XG5jaGFydEpTTGluZVN0eWxlW1wibG9uZ0Rhc2hTaG9ydERhc2hcIl09WzEwLDQsNCw0XTtcbmNoYXJ0SlNMaW5lU3R5bGVbXCJncmFkaWVudFwiXT1bMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDksOSw4LDgsNyw3LDYsNiw1LDUsNCw0LDMsMywyLDIsMV07XG5cbmZ1bmN0aW9uIGxpbmVTdHlsZUZuKGRhdGEpXG57XG5pZiAoKHR5cGVvZiBjaGFydEpTTGluZVN0eWxlW2RhdGFdKSA9PT0gXCJvYmplY3RcIilyZXR1cm4gY2hhcnRKU0xpbmVTdHlsZVtkYXRhXTtcbmVsc2UgcmV0dXJuIGNoYXJ0SlNMaW5lU3R5bGVbXCJzb2xpZFwiXTtcbn07XG5cbmlmICh0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50cmltICE9PSAnZnVuY3Rpb24nKSB7XG5cdFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcblx0fVxufTtcbmlmICghQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcblx0QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8gKSB7XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0aWYgKHRoaXMgPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXHRcdH1cblx0XHR2YXIgdCA9IE9iamVjdCh0aGlzKTtcblx0XHR2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG5cdFx0aWYgKGxlbiA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblx0XHR2YXIgbiA9IDA7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRuID0gTnVtYmVyKGFyZ3VtZW50c1sxXSk7XG5cdFx0XHRpZiAobiAhPSBuKSB7IC8vIHNob3J0Y3V0IGZvciB2ZXJpZnlpbmcgaWYgaXQncyBOYU5cblx0XHRcdFx0biA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKG4gIT0gMCAmJiBuICE9IEluZmluaXR5ICYmIG4gIT0gLUluZmluaXR5KSB7XG5cdFx0XHRcdG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChuID49IGxlbikge1xuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblx0XHR2YXIgayA9IG4gPj0gMCA/IG4gOiBNYXRoLm1heChsZW4gLSBNYXRoLmFicyhuKSwgMCk7XG5cdFx0Zm9yICg7IGsgPCBsZW47IGsrKykge1xuXHRcdFx0aWYgKGsgaW4gdCAmJiB0W2tdID09PSBzZWFyY2hFbGVtZW50KSB7XG5cdFx0XHRcdHJldHVybiBrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH1cbn07XG52YXIgY2hhckpTUGVyc29uYWxEZWZhdWx0T3B0aW9ucyA9IHt9O1xudmFyIGNoYXJKU1BlcnNvbmFsRGVmYXVsdE9wdGlvbnNMaW5lID0ge30gO1xudmFyIGNoYXJKU1BlcnNvbmFsRGVmYXVsdE9wdGlvbnNSYWRhciA9IHt9IDtcbnZhciBjaGFySlNQZXJzb25hbERlZmF1bHRPcHRpb25zUG9sYXJBcmVhID0ge30gO1xudmFyIGNoYXJKU1BlcnNvbmFsRGVmYXVsdE9wdGlvbnNQaWUgPSB7fTtcbnZhciBjaGFySlNQZXJzb25hbERlZmF1bHRPcHRpb25zRG91Z2hudXQgPSB7fTtcbnZhciBjaGFySlNQZXJzb25hbERlZmF1bHRPcHRpb25zQmFyID0ge307XG52YXIgY2hhckpTUGVyc29uYWxEZWZhdWx0T3B0aW9uc1N0YWNrZWRCYXIgPSB7fTtcbnZhciBjaGFySlNQZXJzb25hbERlZmF1bHRPcHRpb25zSG9yaXpvbnRhbEJhciA9IHt9O1xudmFyIGNoYXJKU1BlcnNvbmFsRGVmYXVsdE9wdGlvbnNIb3Jpem9udGFsU3RhY2tlZEJhciA9IHt9O1xuXHQvLy8vLy8vLy8gRlVOQ1RJT05TIFRIQU4gQ0FOIEJFIFVTRUQgSU4gVEhFIFRFTVBMQVRFUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHJvdW5kVG9XaXRoVGhvdXNhbmRzKGNvbmZpZywgbnVtLCBwbGFjZSkge1xuXHR2YXIgbmV3dmFsID0gMSAqIHVuRm9ybWF0KGNvbmZpZywgbnVtKTtcblx0aWYgKHR5cGVvZihuZXd2YWwpID09IFwibnVtYmVyXCIgJiYgcGxhY2UgIT0gXCJub25lXCIpIHtcblx0XHR2YXIgcm91bmRWYWw7XG5cdFx0aWYgKHBsYWNlIDw9IDApIHtcblx0XHRcdHJvdW5kVmFsID0gLXBsYWNlO1xuXHRcdFx0bmV3dmFsID0gKyhNYXRoLnJvdW5kKG5ld3ZhbCArIFwiZStcIiArIHJvdW5kVmFsKSArIFwiZS1cIiArIHJvdW5kVmFsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cm91bmRWYWwgPSBwbGFjZTtcblx0XHRcdHZhciBkaXZ2YWwgPSBcIjFlK1wiICsgcm91bmRWYWw7XG5cdFx0XHRuZXd2YWwgPSArKE1hdGgucm91bmQobmV3dmFsIC8gZGl2dmFsKSkgKiBkaXZ2YWw7XG5cdFx0fVxuXHR9XG5cdG5ld3ZhbCA9IGZtdENoYXJ0SlMoY29uZmlnLCBuZXd2YWwsIFwibm9uZVwiKTtcblx0cmV0dXJuIChuZXd2YWwpO1xufTtcblxuZnVuY3Rpb24gdW5Gb3JtYXQoY29uZmlnLCBudW0pIHtcblx0aWYgKChjb25maWcuZGVjaW1hbFNlcGFyYXRvciAhPSBcIi5cIiB8fCBjb25maWcudGhvdXNhbmRTZXBhcmF0b3IgIT0gXCJcIikgJiYgdHlwZW9mKG51bSkgPT0gXCJzdHJpbmdcIikge1xuXHRcdHZhciB2MSA9IFwiXCIgKyBudW07XG5cdFx0aWYgKGNvbmZpZy50aG91c2FuZFNlcGFyYXRvciAhPSBcIlwiKSB7XG5cdFx0XHR3aGlsZSAodjEuaW5kZXhPZihjb25maWcudGhvdXNhbmRTZXBhcmF0b3IpID49IDApIHYxID0gXCJcIiArIHYxLnJlcGxhY2UoY29uZmlnLnRob3VzYW5kU2VwYXJhdG9yLCBcIlwiKTtcblx0XHR9XG5cdFx0aWYgKGNvbmZpZy5kZWNpbWFsU2VwYXJhdG9yICE9IFwiLlwiKSB2MSA9IFwiXCIgKyB2MS5yZXBsYWNlKGNvbmZpZy5kZWNpbWFsU2VwYXJhdG9yLCBcIi5cIilcblx0XHRyZXR1cm4gMSAqIHYxO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBudW07XG5cdH1cbn07XG4vLy8vLy8vLy8gQU5OT1RBVEUgUEFSVCBPRiBUSEUgU0NSSVBUIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChDKSAxOTk5IFRob21hcyBCcmF0dGxpXG5UaGlzIHNjcmlwdCBpcyBtYWRlIGJ5IGFuZCBjb3B5cmlnaHRlZCB0byBUaG9tYXMgQnJhdHRsaVxuVmlzaXQgZm9yIG1vcmUgZ3JlYXQgc2NyaXB0cy4gVGhpcyBtYXkgYmUgdXNlZCBmcmVlbHkgYXMgbG9uZyBhcyB0aGlzIG1zZyBpcyBpbnRhY3QhXG5JIHdpbGwgYWxzbyBhcHByaWNpYXRlIGFueSBsaW5rcyB5b3UgY291bGQgZ2l2ZSBtZS5cbkRpc3RyaWJ1dGVkIGJ5IEh5cGVyZ3VybFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgY2FjaGViaXMgPSB7fTtcblxuZnVuY3Rpb24gZm10Q2hhcnRKU1BlcnNvKGNvbmZpZywgdmFsdWUsIGZtdCkge1xuXHRzd2l0Y2ggKGZtdCkge1xuXHRcdGNhc2UgXCJTYW1wbGVKU19Gb3JtYXRcIjpcblx0XHRcdGlmICh0eXBlb2YodmFsdWUpID09IFwibnVtYmVyXCIpIHJldHVybl92YWx1ZSA9IFwiTXkgRm9ybWF0IDogXCIgKyB2YWx1ZS50b1N0cmluZygpICsgXCIgJFwiO1xuXHRcdFx0ZWxzZSByZXR1cm5fdmFsdWUgPSB2YWx1ZSArIFwiWFhcIjtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJDaGFuZ2VfTW9udGhcIjpcblx0XHRcdGlmICh0eXBlb2YodmFsdWUpID09IFwic3RyaW5nXCIpIHJldHVybl92YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCkgKyBcIiAyMDE0XCI7XG5cdFx0XHRlbHNlIHJldHVybl92YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCkgKyBcIllZXCI7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuX3ZhbHVlID0gdmFsdWU7XG5cdFx0XHRicmVhaztcblx0fVxuXHRyZXR1cm4gKHJldHVybl92YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiBmbXRDaGFydEpTKGNvbmZpZywgdmFsdWUsIGZtdCkge1xuXHR2YXIgcmV0dXJuX3ZhbHVlO1xuXHRpZiAoZm10ID09IFwibm90Zm9ybWF0dGVkXCIpIHtcblx0XHRyZXR1cm5fdmFsdWUgPSB2YWx1ZTtcblx0fSBlbHNlIGlmICgoZm10ID09IFwibm9uZVwiIHx8IGZtdD09XCJtb25leVwiKSAmJiB0eXBlb2YodmFsdWUpID09IFwibnVtYmVyXCIpIHtcblx0XHRpZiAoY29uZmlnLnJvdW5kTnVtYmVyICE9IFwibm9uZVwiKSB7XG5cdFx0XHR2YXIgcm91bmRWYWw7XG5cdFx0XHRpZiAoY29uZmlnLnJvdW5kTnVtYmVyIDw9IDApIHtcblx0XHRcdFx0cm91bmRWYWwgPSAtY29uZmlnLnJvdW5kTnVtYmVyO1xuXHRcdFx0XHR2YWx1ZSA9ICsoTWF0aC5yb3VuZCh2YWx1ZSArIFwiZStcIiArIHJvdW5kVmFsKSArIFwiZS1cIiArIHJvdW5kVmFsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJvdW5kVmFsID0gY29uZmlnLnJvdW5kTnVtYmVyO1xuXHRcdFx0XHR2YXIgZGl2dmFsID0gXCIxZStcIiArIHJvdW5kVmFsO1xuXHRcdFx0XHR2YWx1ZSA9ICsoTWF0aC5yb3VuZCh2YWx1ZSAvIGRpdnZhbCkpICogZGl2dmFsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY29uZmlnLmRlY2ltYWxTZXBhcmF0b3IgIT0gXCIuXCIgfHwgY29uZmlnLnRob3VzYW5kU2VwYXJhdG9yICE9IFwiXCIpIHtcblx0XHRcdHJldHVybl92YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZSgvXFwuL2csIGNvbmZpZy5kZWNpbWFsU2VwYXJhdG9yKTtcblx0XHRcdGlmIChjb25maWcudGhvdXNhbmRTZXBhcmF0b3IgIT0gXCJcIikge1xuXHRcdFx0XHR2YXIgcGFydDEgPSByZXR1cm5fdmFsdWU7XG5cdFx0XHRcdHZhciBwYXJ0MiA9IFwiXCI7XG5cdFx0XHRcdHZhciBwb3NkZWMgPSBwYXJ0MS5pbmRleE9mKGNvbmZpZy5kZWNpbWFsU2VwYXJhdG9yKTtcblx0XHRcdFx0aWYgKHBvc2RlYyA+PSAwKSB7XG5cdFx0XHRcdFx0cGFydDIgPSBwYXJ0MS5zdWJzdHJpbmcocG9zZGVjICsgMSwgcGFydDEubGVuZ3RoKTtcblx0XHRcdFx0XHRwYXJ0MiA9IHBhcnQyLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7IC8vIHJldmVyc2Ugc3RyaW5nXG5cdFx0XHRcdFx0cGFydDEgPSBwYXJ0MS5zdWJzdHJpbmcoMCwgcG9zZGVjKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJ0MSA9IHBhcnQxLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgY29uZmlnLnRob3VzYW5kU2VwYXJhdG9yKTtcblx0XHRcdFx0cGFydDIgPSBwYXJ0Mi5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpOyAvLyByZXZlcnNlIHN0cmluZ1xuXHRcdFx0XHRyZXR1cm5fdmFsdWUgPSBwYXJ0MVxuXHRcdFx0XHRpZiAocGFydDIgIT0gXCJcIikgcmV0dXJuX3ZhbHVlID0gcmV0dXJuX3ZhbHVlICsgY29uZmlnLmRlY2ltYWxTZXBhcmF0b3IgKyBwYXJ0Mjtcblx0XHRcdH1cblx0XHR9IGVsc2UgcmV0dXJuX3ZhbHVlID0gdmFsdWU7XG5cdFx0aWYoZm10PT1cIm1vbmV5XCIpIHtcblx0XHRcdGlmKGNvbmZpZy5jdXJyZW5jeVBvc2l0aW9uPT1cImJlZm9yZVwiKXJldHVybl92YWx1ZT1jb25maWcuY3VycmVuY3krcmV0dXJuX3ZhbHVlO1xuXHRcdFx0ZWxzZSByZXR1cm5fdmFsdWU9cmV0dXJuX3ZhbHVlK2NvbmZpZy5jdXJyZW5jeTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoZm10ICE9IFwibm9uZVwiICYmIGZtdCAhPSBcIm5vdGZvcm1hdHRlZFwiKSB7XG5cdFx0cmV0dXJuX3ZhbHVlID0gZm10Q2hhcnRKU1BlcnNvKGNvbmZpZywgdmFsdWUsIGZtdCk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuX3ZhbHVlID0gdmFsdWU7XG5cdH1cblx0cmV0dXJuIChyZXR1cm5fdmFsdWUpO1xufTtcblxuZnVuY3Rpb24gYWRkUGFyYW1ldGVyczJGdW5jdGlvbihkYXRhLCBmY3ROYW1lLCBmY3RMaXN0KSB7XG5cdHZhciBtYXRoRnVuY3Rpb25zID0ge1xuXHRcdG1lYW46IHtcblx0XHRcdGRhdGE6IGRhdGEuZGF0YSxcblx0XHRcdGRhdGFzZXROcjogZGF0YS52MTFcblx0XHR9LFxuXHRcdHZhcmlhbno6IHtcblx0XHRcdGRhdGE6IGRhdGEuZGF0YSxcblx0XHRcdGRhdGFzZXROcjogZGF0YS52MTFcblx0XHR9LFxuXHRcdHN0ZGRldjoge1xuXHRcdFx0ZGF0YTogZGF0YS5kYXRhLFxuXHRcdFx0ZGF0YXNldE5yOiBkYXRhLnYxMVxuXHRcdH0sXG5cdFx0Y3Y6IHtcblx0XHRcdGRhdGE6IGRhdGEuZGF0YSxcblx0XHRcdGRhdGFzZXROcjogZGF0YS52MTFcblx0XHR9LFxuXHRcdG1lZGlhbjoge1xuXHRcdFx0ZGF0YTogZGF0YS5kYXRhLFxuXHRcdFx0ZGF0YXNldE5yOiBkYXRhLnYxMVxuXHRcdH1cblx0fTtcblx0Ly8gZGlmZmVyZW5jZSB0byBjdXJyZW50IHZhbHVlICh2Mylcblx0ZGlmID0gZmFsc2U7XG5cdGlmIChmY3ROYW1lLnN1YnN0cigtMykgPT0gXCJEaWZcIikge1xuXHRcdGZjdE5hbWUgPSBmY3ROYW1lLnN1YnN0cigwLCBmY3ROYW1lLmxlbmd0aCAtIDMpO1xuXHRcdGRpZiA9IHRydWU7XG5cdH1cblx0aWYgKHR5cGVvZiBldmFsKGZjdE5hbWUpID09IFwiZnVuY3Rpb25cIikge1xuXHRcdHZhciBwYXJhbWV0ZXIgPSBldmFsKGZjdExpc3QgKyBcIi5cIiArIGZjdE5hbWUpO1xuXHRcdGlmIChkaWYpIHtcblx0XHRcdC8vIGRpZmZlcmVuY2UgYmV0d2VlbiB2MyAoY3VycmVudCB2YWx1ZSkgYW5kIG1hdGggZnVuY3Rpb25cblx0XHRcdHJldHVybiBkYXRhLnYzIC0gd2luZG93W2ZjdE5hbWVdKHBhcmFtZXRlcik7XG5cdFx0fVxuXHRcdHJldHVybiB3aW5kb3dbZmN0TmFtZV0ocGFyYW1ldGVyKTtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcblx0cmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn07XG5cbmZ1bmN0aW9uIHRtcGxiaXMoc3RyLCBkYXRhLGNvbmZpZykge1xuXHRuZXdzdHI9c3RyO1xuXHRpZihuZXdzdHIuc3Vic3RyKDAsY29uZmlnLnRlbXBsYXRlc09wZW5UYWcubGVuZ3RoKT09Y29uZmlnLnRlbXBsYXRlc09wZW5UYWcpbmV3c3RyPVwiPCU9XCIrbmV3c3RyLnN1YnN0cihjb25maWcudGVtcGxhdGVzT3BlblRhZy5sZW5ndGgsbmV3c3RyLmxlbmd0aC1jb25maWcudGVtcGxhdGVzT3BlblRhZy5sZW5ndGgpO1xuXHRpZihuZXdzdHIuc3Vic3RyKG5ld3N0ci5sZW5ndGgtY29uZmlnLnRlbXBsYXRlc0Nsb3NlVGFnLmxlbmd0aCxjb25maWcudGVtcGxhdGVzQ2xvc2VUYWcubGVuZ3RoKT09Y29uZmlnLnRlbXBsYXRlc0Nsb3NlVGFnKW5ld3N0cj1uZXdzdHIuc3Vic3RyKDAsbmV3c3RyLmxlbmd0aC1jb25maWcudGVtcGxhdGVzQ2xvc2VUYWcubGVuZ3RoKStcIiU+XCI7XG5cdHJldHVybiB0bXBsdGVyKG5ld3N0cixkYXRhKTtcbn1cblxuZnVuY3Rpb24gdG1wbHRlcihzdHIsIGRhdGEpIHtcblx0dmFyIG1hdGhGdW5jdGlvbkxpc3QgPSBbXCJtZWFuXCIsIFwidmFyaWFuelwiLCBcInN0ZGRldlwiLCBcImN2XCIsIFwibWVkaWFuXCJdO1xuXHR2YXIgcmVnZXhNYXRoID0gbmV3IFJlZ0V4cCgnPCU9KCg/Oig/Oi4qPylcXFxcVyk/PykoKD86JyArIG1hdGhGdW5jdGlvbkxpc3Quam9pbignfCcpICsgJykoPzpEaWYpPylcXFxcKChbMC05XSo/KVxcXFwpKC4qPyklPicsICdnJyk7XG5cdHdoaWxlIChyZWdleE1hdGgudGVzdChzdHIpKSB7XG5cdFx0c3RyID0gc3RyLnJlcGxhY2UocmVnZXhNYXRoLCBmdW5jdGlvbigkMCwgJDEsICQyLCAkMywgJDQpIHtcblx0XHRcdHZhciBybmRGYWM7XG5cdFx0XHRpZiAoJDMpIHJuZEZhYyA9ICQzO1xuXHRcdFx0ZWxzZSBybmRGYWMgPSAyO1xuXHRcdFx0dmFyIHZhbHVlID0gYWRkUGFyYW1ldGVyczJGdW5jdGlvbihkYXRhLCAkMiwgXCJtYXRoRnVuY3Rpb25zXCIpO1xuXHRcdFx0aWYgKGlzTnVtYmVyKHZhbHVlKSkgXG5cdFx0XHRcdHJldHVybiAnPCU9JyArICQxICsgJycgKyBNYXRoLnJvdW5kKE1hdGgucG93KDEwLCBybmRGYWMpICogdmFsdWUpIC8gTWF0aC5wb3coMTAsIHJuZEZhYykgKyAnJyArICQ0ICsgJyU+Jztcblx0XHRcdHJldHVybiAnPCU9ICU+Jztcblx0XHR9KTtcblx0fVxuXHQvLyBGaWd1cmUgb3V0IGlmIHdlJ3JlIGdldHRpbmcgYSB0ZW1wbGF0ZSwgb3IgaWYgd2UgbmVlZCB0b1xuXHQvLyBsb2FkIHRoZSB0ZW1wbGF0ZSAtIGFuZCBiZSBzdXJlIHRvIGNhY2hlIHRoZSByZXN1bHQuXG5cdC8vIGZpcnN0IGNoZWNrIGlmIGl0J3MgY2FuIGJlIGFuIGlkXG5cdHZhciBmbiA9IC9eW0EtWmEtel1bLUEtWmEtejAtOV86Ll0qJC8udGVzdChzdHIpID8gY2FjaGViaXNbc3RyXSA9IGNhY2hlYmlzW3N0cl0gfHxcblx0XHR0bXBsdGVyKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0cikuaW5uZXJIVE1MKSA6XG5cdFx0Ly8gR2VuZXJhdGUgYSByZXVzYWJsZSBmdW5jdGlvbiB0aGF0IHdpbGwgc2VydmUgYXMgYSB0ZW1wbGF0ZVxuXHRcdC8vIGdlbmVyYXRvciAoYW5kIHdoaWNoIHdpbGwgYmUgY2FjaGVkKS5cblx0XHRuZXcgRnVuY3Rpb24oXCJvYmpcIixcblx0XHRcdFwidmFyIHA9W10scHJpbnQ9ZnVuY3Rpb24oKXtwLnB1c2guYXBwbHkocCxhcmd1bWVudHMpO307XCIgK1xuXHRcdFx0Ly8gSW50cm9kdWNlIHRoZSBkYXRhIGFzIGxvY2FsIHZhcmlhYmxlcyB1c2luZyB3aXRoKCl7fVxuXHRcdFx0XCJ3aXRoKG9iail7cC5wdXNoKCdcIiArXG5cdFx0XHQvLyBDb252ZXJ0IHRoZSB0ZW1wbGF0ZSBpbnRvIHB1cmUgSmF2YVNjcmlwdFxuXHRcdFx0c3RyXG5cdFx0XHQucmVwbGFjZSgvW1xcclxcbl0vZywgXCJcXFxcblwiKVxuXHRcdFx0LnJlcGxhY2UoL1tcXHRdL2csIFwiIFwiKVxuXHRcdFx0LnNwbGl0KFwiPCVcIikuam9pbihcIlxcdFwiKVxuXHRcdFx0LnJlcGxhY2UoLygoXnwlPilbXlxcdF0qKScvZywgXCIkMVxcclwiKVxuXHRcdFx0LnJlcGxhY2UoL1xcdD0oLio/KSU+L2csIFwiJywkMSwnXCIpXG5cdFx0XHQuc3BsaXQoXCJcXHRcIikuam9pbihcIicpO1wiKVxuXHRcdFx0LnNwbGl0KFwiJT5cIikuam9pbihcInAucHVzaCgnXCIpXG5cdFx0XHQuc3BsaXQoXCJcXHJcIikuam9pbihcIlxcXFwnXCIpICsgXCInKTt9cmV0dXJuIHAuam9pbignJyk7XCIpO1xuXHQvLyBQcm92aWRlIHNvbWUgYmFzaWMgY3VycnlpbmcgdG8gdGhlIHVzZXJcblx0cmV0dXJuIGRhdGEgPyBmbihkYXRhKSA6IGZuO1xufTtcbmlmICh0eXBlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICE9PSAndW5kZWZpbmVkJykge1xuXHQvKipcblx0ICogY3R4LnByb3RvdHlwZVxuXHQgKiBmaWxsVGV4dCBvcHRpb24gZm9yIGNhbnZhcyBNdWx0aWxpbmUgU3VwcG9ydFxuXHQgKiBAcGFyYW0gdGV4dCBzdHJpbmcgXFxuIGZvciBuZXdsaW5lXG5cdCAqIEBwYXJhbSB4IHggcG9zaXRpb25cblx0ICogQHBhcmFtIHkgeSBwb3NpdGlvblxuXHQgKiBAcGFyYW0geUxldmVsID0gXCJib3R0b21cIiA9PiBsYXN0IGxpbmUgaGFzIHRoaXMgeS1Qb3MgW2RlZmF1bHRdLCA9IFwibWlkZGxlXCIgPT4gdGhlIG1pZGRsZSBsaW5lIGhhcyB0aGlzIHktUG9zKVxuXHQgKiBAcGFyYW0gbGluZUhlaWdodCBsaW5lSGVpZ2h0XG5cdCAqIEBwYXJhbSBob3Jpem9udGFsIGhvcml6b250YWxcblx0ICovXG5cdENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZmlsbFRleHRNdWx0aUxpbmUgPSBmdW5jdGlvbih0ZXh0LCB4LCB5LCB5TGV2ZWwsIGxpbmVIZWlnaHQsaG9yaXpvbnRhbCxkZXRlY3RNb3VzZU9uVGV4dCxjdHgsaWRUZXh0LHJvdGF0ZSx4X2RlY2FsLHlfZGVjYWwscG9zaSxwb3NqKSB7XG5cdFx0dmFyIGxpbmVzID0gKFwiXCIgKyB0ZXh0KS5zcGxpdChcIlxcblwiKTtcblx0XHQvLyBpZiBpdHMgb25lIGxpbmUgPT4gaW4gdGhlIG1pZGRsZSBcblx0XHQvLyB0d28gbGluZXMgb25lIGFib3ZlIHRoZSBtaWQgb25lIGJlbG93IGV0Yy5cdFxuXHRcdGlmICh5TGV2ZWwgPT0gXCJtaWRkbGVcIikge1xuXHRcdFx0aWYoaG9yaXpvbnRhbCl5IC09ICgobGluZXMubGVuZ3RoIC0gMSkgLyAyKSAqIGxpbmVIZWlnaHQ7XG5cdFx0fSBlbHNlIGlmICh5TGV2ZWwgPT0gXCJib3R0b21cIikgeyAvLyBkZWZhdWx0XG5cdFx0XHRpZihob3Jpem9udGFsKXkgLT0gKGxpbmVzLmxlbmd0aCAtIDEpICogbGluZUhlaWdodDtcblx0XHR9XG5cblx0XHR2YXIgeV9wb3M9eS1saW5lSGVpZ2h0O1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5maWxsVGV4dChsaW5lc1tpXSwgeCwgeSk7XG5cdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0fVxuXHRcdGlmKGRldGVjdE1vdXNlT25UZXh0KSB7XG5cdFx0XHR2YXIgdHh0U2l6ZT1jdHgubWVhc3VyZVRleHRNdWx0aUxpbmUodGV4dCxsaW5lSGVpZ2h0KTtcblx0XHRcdHZhciB4X3Bvcz1bXTtcblx0XHRcdHZhciB5X3Bvcz1bXTtcblx0XHRcdHhfcG9zLnAxPXhfZGVjYWwreDtcblx0XHRcdHlfcG9zLnAxPXlfZGVjYWwreS1saW5lSGVpZ2h0O1xuXHRcdFx0dmFyIHJvdGF0ZVJWPShNYXRoLlBJLzIpK3JvdGF0ZTtcblx0XHRcdCAgICAgICBpZihjdHgudGV4dEFsaWduPT1cImxlZnRcIiAmJiB5TGV2ZWw9PVwidG9wXCIpe1xuXHRcdFx0XHR4X3Bvcy5wMSs9bGluZUhlaWdodCpNYXRoLmNvcyhyb3RhdGVSVik7XG5cdFx0XHRcdHlfcG9zLnAxKz1saW5lSGVpZ2h0Kk1hdGguc2luKHJvdGF0ZVJWKTtcblx0XHRcdH0gZWxzZSBpZihjdHgudGV4dEFsaWduPT1cImxlZnRcIiAmJiB5TGV2ZWw9PVwibWlkZGxlXCIpe1xuXHRcdFx0XHR4X3Bvcy5wMSs9KGxpbmVIZWlnaHQvMikqTWF0aC5jb3Mocm90YXRlUlYpO1xuXHRcdFx0XHR5X3Bvcy5wMSs9KGxpbmVIZWlnaHQvMikqTWF0aC5zaW4ocm90YXRlUlYpO1xuXHRcdFx0fSBlbHNlIGlmKGN0eC50ZXh0QWxpZ249PVwibGVmdFwiICYmIHlMZXZlbD09XCJib3R0b21cIil7XG5cdFx0XHQgICAgICAgLy8gbm90aGluZyB0byBhZGFwdDtcblx0XHRcdH0gZWxzZSBpZihjdHgudGV4dEFsaWduPT1cImNlbnRlclwiICYmIHlMZXZlbD09XCJ0b3BcIil7XG5cdFx0XHRcdHhfcG9zLnAxKz1saW5lSGVpZ2h0Kk1hdGguY29zKHJvdGF0ZVJWKS0odHh0U2l6ZS50ZXh0V2lkdGgvMikqTWF0aC5jb3Mocm90YXRlKTtcblx0XHRcdFx0eV9wb3MucDErPWxpbmVIZWlnaHQqTWF0aC5zaW4ocm90YXRlUlYpLSh0eHRTaXplLnRleHRXaWR0aC8yKSpNYXRoLnNpbihyb3RhdGUpO1xuXHRcdFx0fSBlbHNlIGlmKGN0eC50ZXh0QWxpZ249PVwiY2VudGVyXCIgJiYgeUxldmVsPT1cIm1pZGRsZVwiKXtcblx0XHRcdFx0eF9wb3MucDErPShsaW5lSGVpZ2h0LzIpKk1hdGguY29zKHJvdGF0ZVJWKS0odHh0U2l6ZS50ZXh0V2lkdGgvMikqTWF0aC5jb3Mocm90YXRlKTtcblx0XHRcdFx0eV9wb3MucDErPShsaW5lSGVpZ2h0LzIpKk1hdGguc2luKHJvdGF0ZVJWKS0odHh0U2l6ZS50ZXh0V2lkdGgvMikqTWF0aC5zaW4ocm90YXRlKTtcblx0XHRcdH0gZWxzZSBpZihjdHgudGV4dEFsaWduPT1cImNlbnRlclwiICYmIHlMZXZlbD09XCJib3R0b21cIil7XG5cdFx0XHRcdHhfcG9zLnAxLT0odHh0U2l6ZS50ZXh0V2lkdGgvMikqTWF0aC5jb3Mocm90YXRlKTtcblx0XHRcdFx0eV9wb3MucDEtPSh0eHRTaXplLnRleHRXaWR0aC8yKSpNYXRoLnNpbihyb3RhdGUpO1xuXHRcdFx0fSBlbHNlIGlmKGN0eC50ZXh0QWxpZ249PVwicmlnaHRcIiAmJiB5TGV2ZWw9PVwidG9wXCIpe1xuXHRcdFx0XHR4X3Bvcy5wMSs9KGxpbmVIZWlnaHQqTWF0aC5jb3Mocm90YXRlUlYpLXR4dFNpemUudGV4dFdpZHRoKk1hdGguY29zKHJvdGF0ZSkpO1xuXHRcdFx0XHR5X3Bvcy5wMSs9KGxpbmVIZWlnaHQqTWF0aC5zaW4ocm90YXRlUlYpLXR4dFNpemUudGV4dFdpZHRoKk1hdGguc2luKHJvdGF0ZSkpO1xuXHRcdFx0fSBlbHNlIGlmKGN0eC50ZXh0QWxpZ249PVwicmlnaHRcIiAmJiB5TGV2ZWw9PVwibWlkZGxlXCIpe1xuXHRcdFx0XHR4X3Bvcy5wMSs9KGxpbmVIZWlnaHQvMikqTWF0aC5jb3Mocm90YXRlUlYpLXR4dFNpemUudGV4dFdpZHRoKk1hdGguY29zKHJvdGF0ZSk7XG5cdFx0XHRcdHlfcG9zLnAxKz0obGluZUhlaWdodC8yKSpNYXRoLnNpbihyb3RhdGVSViktdHh0U2l6ZS50ZXh0V2lkdGgqTWF0aC5zaW4ocm90YXRlKTtcblx0XHRcdH0gZWxzZSBpZihjdHgudGV4dEFsaWduPT1cInJpZ2h0XCIgJiYgeUxldmVsPT1cImJvdHRvbVwiKXtcblx0XHRcdFx0eF9wb3MucDEtPXR4dFNpemUudGV4dFdpZHRoKk1hdGguY29zKHJvdGF0ZSk7XG5cdFx0XHRcdHlfcG9zLnAxLT10eHRTaXplLnRleHRXaWR0aCpNYXRoLnNpbihyb3RhdGUpO1xuXHRcdFx0fSBcblxuXHRcdFx0Ly8gT3RoZXIgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlO1xuXHRcdFx0XG5cdFx0XHR4X3Bvcy5wMj14X3Bvcy5wMSt0eHRTaXplLnRleHRXaWR0aCpNYXRoLmNvcyhyb3RhdGUpO1xuXHRcdFx0eV9wb3MucDI9eV9wb3MucDErdHh0U2l6ZS50ZXh0V2lkdGgqTWF0aC5zaW4ocm90YXRlKTtcblx0XHRcdFxuXHRcdFx0eF9wb3MucDM9eF9wb3MucDEtbGluZUhlaWdodCpNYXRoLmNvcyhyb3RhdGVSVik7XG5cdFx0XHR5X3Bvcy5wMz15X3Bvcy5wMS1saW5lSGVpZ2h0Kk1hdGguc2luKHJvdGF0ZVJWKTtcblx0XHRcdFxuXHRcdFx0eF9wb3MucDQ9eF9wb3MucDMrdHh0U2l6ZS50ZXh0V2lkdGgqTWF0aC5jb3Mocm90YXRlKTtcblx0XHRcdHlfcG9zLnA0PXlfcG9zLnAzK3R4dFNpemUudGV4dFdpZHRoKk1hdGguc2luKHJvdGF0ZSk7XG5cblx0XHRcdGpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtqc1RleHRNb3VzZVBvc1tjdHguQ2hhcnROZXdJZF0ubGVuZ3RoXSA9IFtpZFRleHQsdGV4dCx4X3Bvcyx5X3Bvcyxyb3RhdGUsdHh0U2l6ZS50ZXh0V2lkdGgsdHh0U2l6ZS50ZXh0SGVpZ2h0LHBvc2kscG9zal07XG5cdFx0XHRcdFx0XHRcblx0XHR9XHRcblx0fTtcblx0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5tZWFzdXJlVGV4dE11bHRpTGluZSA9IGZ1bmN0aW9uKHRleHQsIGxpbmVIZWlnaHQpIHtcblx0XHR2YXIgdGV4dFdpZHRoID0gMDtcblx0XHR2YXIgbGc7XG5cdFx0dmFyIGxpbmVzID0gKFwiXCIgKyB0ZXh0KS5yZXBsYWNlKC88QlI+L2lnLCBcIlxcblwiKS5zcGxpdChcIlxcblwiKTtcblx0XHR2YXIgdGV4dEhlaWdodCA9IGxpbmVzLmxlbmd0aCAqIGxpbmVIZWlnaHQ7XG5cdFx0Ly8gaWYgaXRzIG9uZSBsaW5lID0+IGluIHRoZSBtaWRkbGUgXG5cdFx0Ly8gdHdvIGxpbmVzIG9uZSBhYm92ZSB0aGUgbWlkIG9uZSBiZWxvdyBldGMuXHRcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZyA9IHRoaXMubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoO1xuXHRcdFx0aWYgKGxnID4gdGV4dFdpZHRoKSB0ZXh0V2lkdGggPSBsZztcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRleHRXaWR0aDogdGV4dFdpZHRoLFxuXHRcdFx0dGV4dEhlaWdodDogMS41KnRleHRIZWlnaHRcblx0XHR9O1xuXHR9O1xuXHRpZiAodHlwZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuc2V0TGluZURhc2ggIT09ICdmdW5jdGlvbicpIHtcblx0XHRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLnNldExpbmVEYXNoID0gZnVuY3Rpb24oIGxpc3RkYXNoKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHR9O1xuXHRcblx0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5kcmF3UmVjdGFuZ2xlID0gZnVuY3Rpb24oVGhlUmVjdGFuZ2xlKXtcblx0XHQvL3RoaXMuc2hhZG93Q29sb3IgPSAnIzk5OSc7XG4gICAgIFx0XHQvLyB0aGlzLnNoYWRvd0JsdXIgPSA1O1xuXHQgICAgXHQvLyB0aGlzLnNoYWRvd09mZnNldFggPSAxNTtcbiAgICAgXHRcdC8vdGhpcy5zaGFkb3dPZmZzZXRZID0gMTU7XG5cdFx0b3JpZ2luYWxmaWxsU3R5bGUgPXRoaXMuZmlsbFN0eWxlO1xuICAgIFx0XHRpZih0eXBlb2YgVGhlUmVjdGFuZ2xlLng9PSd1bmRlZmluZWQnKXtUaGVSZWN0YW5nbGUueD0wfVxuICAgICAgXHRcdGlmKFRoZVJlY3RhbmdsZS53aWR0aDwwKXtUaGVSZWN0YW5nbGUueCs9VGhlUmVjdGFuZ2xlLndpZHRoO1RoZVJlY3RhbmdsZS53aWR0aCo9LTF9XG4gICAgICAgIFx0aWYoVGhlUmVjdGFuZ2xlLmhlaWdodDwwKXtUaGVSZWN0YW5nbGUueSs9VGhlUmVjdGFuZ2xlLmhlaWdodDtUaGVSZWN0YW5nbGUuaGVpZ2h0Kj0tMX1cbiAgICBcdFx0aWYodHlwZW9mIFRoZVJlY3RhbmdsZS55PT0ndW5kZWZpbmVkJyl7VGhlUmVjdGFuZ2xlLnk9MH1cbiAgXHRcdGlmKHR5cGVvZiBUaGVSZWN0YW5nbGUueT09J3VuZGVmaW5lZCcpe1RoZVJlY3RhbmdsZS55PTB9XG4gIFx0XHRpZih0eXBlb2YgVGhlUmVjdGFuZ2xlLmJhY2tncm91bmRDb2xvciE9J3VuZGVmaW5lZCcpe3RoaXMuZmlsbFN0eWxlPVRoZVJlY3RhbmdsZS5iYWNrZ3JvdW5kQ29sb3J9XG4gIFx0XHRpZih0eXBlb2YgVGhlUmVjdGFuZ2xlLmJvcmRlclJhZGl1cz09J3VuZGVmaW5lZCcpe1RoZVJlY3RhbmdsZS5ib3JkZXJSYWRpdXM9MH1cbiAgXG4gIFx0XHRpZihUaGVSZWN0YW5nbGUuYm9yZGVyUmFkaXVzPT0wICYmIFRoZVJlY3RhbmdsZS5maWxsPT10cnVlKXt0aGlzLmZpbGxSZWN0KFRoZVJlY3RhbmdsZS54LFRoZVJlY3RhbmdsZS55LFRoZVJlY3RhbmdsZS53aWR0aCxUaGVSZWN0YW5nbGUuaGVpZ2h0KTt9XG4gICAgXHRcdGlmKFRoZVJlY3RhbmdsZS5ib3JkZXJSYWRpdXM9PTAgJiYgVGhlUmVjdGFuZ2xlLnN0cm9rZT09dHJ1ZSl7dGhpcy5zdHJva2VSZWN0KFRoZVJlY3RhbmdsZS54LFRoZVJlY3RhbmdsZS55LFRoZVJlY3RhbmdsZS53aWR0aCxUaGVSZWN0YW5nbGUuaGVpZ2h0KTt9XG4gICAgXHRcdGlmKFRoZVJlY3RhbmdsZS5ib3JkZXJSYWRpdXMhPTApe1xuICAgICAgXHRcdFx0cmVjdGFuZ2xlUmFkaXVzPXBhcnNlSW50KFRoZVJlY3RhbmdsZS5ib3JkZXJSYWRpdXMpO1xuICAgICAgXHRcdFx0aWYocmVjdGFuZ2xlUmFkaXVzPlRoZVJlY3RhbmdsZS53aWR0aC8yICl7cmVjdGFuZ2xlUmFkaXVzPVRoZVJlY3RhbmdsZS53aWR0aC8yfVxuICAgICAgXHRcdFx0aWYoVGhlUmVjdGFuZ2xlLmhlaWdodDxUaGVSZWN0YW5nbGUud2lkdGggJiZyZWN0YW5nbGVSYWRpdXM+VGhlUmVjdGFuZ2xlLmhlaWdodC8yICl7cmVjdGFuZ2xlUmFkaXVzPVRoZVJlY3RhbmdsZS5oZWlnaHQvMn1cbiAgICAgIFx0XHRcdHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICBcdFx0XHR0aGlzLm1vdmVUbyhUaGVSZWN0YW5nbGUueCtyZWN0YW5nbGVSYWRpdXMsVGhlUmVjdGFuZ2xlLnkpO1xuICAgICAgXHRcdFx0dGhpcy5saW5lVG8oVGhlUmVjdGFuZ2xlLngrVGhlUmVjdGFuZ2xlLndpZHRoLXJlY3RhbmdsZVJhZGl1cyxUaGVSZWN0YW5nbGUueSk7XG4gICAgIFx0XHRcdHRoaXMuYXJjKFRoZVJlY3RhbmdsZS54K1RoZVJlY3RhbmdsZS53aWR0aC1yZWN0YW5nbGVSYWRpdXMsVGhlUmVjdGFuZ2xlLnkrcmVjdGFuZ2xlUmFkaXVzLHJlY3RhbmdsZVJhZGl1cywxLjUqTWF0aC5QSSwwKTsgXG4gICAgICBcdFx0XHR0aGlzLmxpbmVUbyhUaGVSZWN0YW5nbGUueCtUaGVSZWN0YW5nbGUud2lkdGgsVGhlUmVjdGFuZ2xlLnkrVGhlUmVjdGFuZ2xlLmhlaWdodC1yZWN0YW5nbGVSYWRpdXMpO1xuICAgIFx0XHRcdHRoaXMuYXJjKFRoZVJlY3RhbmdsZS54K1RoZVJlY3RhbmdsZS53aWR0aC1yZWN0YW5nbGVSYWRpdXMsVGhlUmVjdGFuZ2xlLnkrVGhlUmVjdGFuZ2xlLmhlaWdodC1yZWN0YW5nbGVSYWRpdXMscmVjdGFuZ2xlUmFkaXVzLDAsMC41Kk1hdGguUEkpOyBcbiAgICAgXHRcdFx0dGhpcy5saW5lVG8oVGhlUmVjdGFuZ2xlLngrcmVjdGFuZ2xlUmFkaXVzLFRoZVJlY3RhbmdsZS55K1RoZVJlY3RhbmdsZS5oZWlnaHQpO1xuICAgICAgIFx0XHRcdHRoaXMuYXJjKFRoZVJlY3RhbmdsZS54K3JlY3RhbmdsZVJhZGl1cyxUaGVSZWN0YW5nbGUueStUaGVSZWN0YW5nbGUuaGVpZ2h0LXJlY3RhbmdsZVJhZGl1cyxyZWN0YW5nbGVSYWRpdXMsMC41Kk1hdGguUEksMSpNYXRoLlBJKTsgXG4gICAgICAgXHRcdFx0dGhpcy5saW5lVG8oVGhlUmVjdGFuZ2xlLngsVGhlUmVjdGFuZ2xlLnkrcmVjdGFuZ2xlUmFkaXVzKTtcbiAgICAgICBcdFx0XHR0aGlzLmFyYyhUaGVSZWN0YW5nbGUueCtyZWN0YW5nbGVSYWRpdXMsVGhlUmVjdGFuZ2xlLnkrcmVjdGFuZ2xlUmFkaXVzLHJlY3RhbmdsZVJhZGl1cywxKk1hdGguUEksMS41Kk1hdGguUEkpOyBcblx0ICAgXHRcdHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgXHRcdFx0aWYoVGhlUmVjdGFuZ2xlLmZpbGw9PXRydWUpIHt0aGlzLmZpbGwoKX07XG4gICAgICBcdFx0XHRpZihUaGVSZWN0YW5nbGUuc3Ryb2tlPT10cnVlKSB7dGhpcy5zdHJva2UoKX07XG5cdCAgICBcdH0gXG4gXHRcdHRoaXMuZmlsbFN0eWxlPSBvcmlnaW5hbGZpbGxTdHlsZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcbn07XG5cbmN1cnNvckRpdkNyZWF0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yRGl2KCkge1xuXHRpZiAoY3Vyc29yRGl2Q3JlYXRlZCA9PSBmYWxzZSkge1xuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXZDdXJzb3InKTtcblx0XHRkaXYuaWQgPSAnZGl2Q3Vyc29yJztcblx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcblx0XHRjdXJzb3JEaXZDcmVhdGVkID0gdHJ1ZTtcblx0fVxufTtcblxuaW5pdENoYXJ0SnNSZXNpemUgPSBmYWxzZTtcbnZhciBqc0dyYXBoUmVzaXplID0gbmV3IEFycmF5KCk7XG5cbmZ1bmN0aW9uIGFkZFJlc3BvbnNpdmVDaGFydChpZCxjdHgsZGF0YSxjb25maWcpIHtcblx0aWYoaW5pdENoYXJ0SnNSZXNpemU9PWZhbHNlKSB7XG5cdFx0aWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBjaGFydEpzUmVzaXplKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LmF0dGFjaEV2ZW50KFwicmVzaXplXCIsIGNoYXJ0SnNSZXNpemUpO1xuXHRcdH1cblx0fVxuXHRqc0dyYXBoUmVzaXplW2pzR3JhcGhSZXNpemUubGVuZ3RoXT0gW2lkLGN0eC50cGNoYXJ0LGN0eCxkYXRhLGNvbmZpZ107XG59O1xuXG5cbnZhciBjb250YWluZXI7XG5mdW5jdGlvbiBnZXRNYXhpbXVtV2lkdGgoZG9tTm9kZSl7XG4gICAgaWYoZG9tTm9kZS5wYXJlbnROb2RlIT1udWxsKVxuICAgICAgICBpZihkb21Ob2RlLnBhcmVudE5vZGUhPXVuZGVmaW5lZClcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gY29udGFpbmVyLmNsaWVudFdpZHRoO1xufTtcblxuZnVuY3Rpb24gZ2V0TWF4aW11bUhlaWdodChkb21Ob2RlKXtcblx0aWYoZG9tTm9kZS5wYXJlbnROb2RlIT1udWxsKVxuICAgICAgICAgICAgaWYoZG9tTm9kZS5wYXJlbnROb2RlIT11bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuXHRyZXR1cm4gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbn07XG5cbmZ1bmN0aW9uIHJlc2l6ZUN0eChjdHgsY29uZmlnKVxue1xuXHRpZiAoaXNJRSgpIDwgOSAmJiBpc0lFKCkgIT0gZmFsc2UpIHJldHVybih0cnVlKTtcblxuXHRpZihjb25maWcucmVzcG9uc2l2ZSkge1x0XG5cdFx0aWYodHlwZW9mIGNvbmZpZy5tYWludGFpbkFzcGVjdFJhdGlvID09IFwidW5kZWZpbmVkXCIpY29uZmlnLm1haW50YWluQXNwZWN0UmF0aW89dHJ1ZTtcblx0XHRpZih0eXBlb2YgY29uZmlnLnJlc3BvbnNpdmVNaW5XaWR0aCA9PSBcInVuZGVmaW5lZFwiKWNvbmZpZy5yZXNwb25zaXZlTWluV2lkdGg9MDtcblx0XHRpZih0eXBlb2YgY29uZmlnLnJlc3BvbnNpdmVNaW5IZWlnaHQgID09IFwidW5kZWZpbmVkXCIpY29uZmlnLnJlc3BvbnNpdmVNaW5IZWlnaHQ9MDtcblx0XHRpZih0eXBlb2YgY29uZmlnLnJlc3BvbnNpdmVNYXhXaWR0aCAgPT0gXCJ1bmRlZmluZWRcIiljb25maWcucmVzcG9uc2l2ZU1heFdpZHRoPTk5OTk5OTk7XG5cdFx0aWYodHlwZW9mIGNvbmZpZy5yZXNwb25zaXZlTWF4SGVpZ2h0ICA9PSBcInVuZGVmaW5lZFwiKWNvbmZpZy5yZXNwb25zaXZlTWF4SGVpZ2h0PTk5OTk5OTk7XG5cdFx0dmFyIGNhbnZhcyA9IGN0eC5jYW52YXM7XG5cdFx0aWYodHlwZW9mIGN0eC5hc3BlY3RSYXRpbyA9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRjdHguYXNwZWN0UmF0aW8gPSBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0O1xuXHRcdH1cbiAgXHRcdHZhciBuZXdXaWR0aCA9IGdldE1heGltdW1XaWR0aChjYW52YXMpO1xuXHRcdHZhciBuZXdIZWlnaHQgPSBjb25maWcubWFpbnRhaW5Bc3BlY3RSYXRpbyA/IG5ld1dpZHRoIC8gY3R4LmFzcGVjdFJhdGlvIDogZ2V0TWF4aW11bUhlaWdodChjYW52YXMpO1xuXHRcdG5ld1dpZHRoPU1hdGgubWluKGNvbmZpZy5yZXNwb25zaXZlTWF4V2lkdGgsTWF0aC5tYXgoY29uZmlnLnJlc3BvbnNpdmVNaW5XaWR0aCxuZXdXaWR0aCkpO1xuXHRcdG5ld0hlaWdodD1NYXRoLm1pbihjb25maWcucmVzcG9uc2l2ZU1heEhlaWdodCxNYXRoLm1heChjb25maWcucmVzcG9uc2l2ZU1pbkhlaWdodCxuZXdIZWlnaHQpKTtcblxuXHRcdGlmKHR5cGVvZiBjdHguRGVmYXVsdGNoYXJ0VGV4dFNjYWxlPT1cInVuZGVmaW5lZFwiKWN0eC5EZWZhdWx0Y2hhcnRUZXh0U2NhbGU9Y29uZmlnLmNoYXJ0VGV4dFNjYWxlO1xuXHRcdGlmKHR5cGVvZiBjdHguRGVmYXVsdGNoYXJ0TGluZVNjYWxlPT1cInVuZGVmaW5lZFwiKWN0eC5EZWZhdWx0Y2hhcnRMaW5lU2NhbGU9Y29uZmlnLmNoYXJ0TGluZVNjYWxlO1xuXHRcdGlmKHR5cGVvZiBjdHguRGVmYXVsdGNoYXJ0U3BhY2VTY2FsZT09XCJ1bmRlZmluZWRcIiljdHguRGVmYXVsdGNoYXJ0U3BhY2VTY2FsZT1jb25maWcuY2hhcnRTcGFjZVNjYWxlO1xuXHRcdC8qIG5ldyByYXRpbyAqL1xuXHRcdGlmKHR5cGVvZiBjdHguY2hhcnRUZXh0U2NhbGUgIT0gXCJ1bmRlZmluZWRcIiAmJiBjb25maWcucmVzcG9uc2l2ZVNjYWxlQ29udGVudCkge1xuXHRcdFx0Y3R4LmNoYXJ0VGV4dFNjYWxlPWN0eC5EZWZhdWx0Y2hhcnRUZXh0U2NhbGUqKG5ld1dpZHRoL2N0eC5pbml0aWFsV2lkdGgpO1xuXHRcdFx0Y3R4LmNoYXJ0TGluZVNjYWxlPWN0eC5EZWZhdWx0Y2hhcnRMaW5lU2NhbGUqKG5ld1dpZHRoL2N0eC5pbml0aWFsV2lkdGgpO1xuXHRcdFx0Y3R4LmNoYXJ0U3BhY2VTY2FsZT1jdHguRGVmYXVsdGNoYXJ0U3BhY2VTY2FsZSoobmV3V2lkdGgvY3R4LmluaXRpYWxXaWR0aCk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbz4xKSB7XG5cdFx0XHRjdHguY2FudmFzLnN0eWxlLndpZHRoID0gbmV3V2lkdGggKyBcInB4XCI7XG5cdFx0XHRjdHguY2FudmFzLnN0eWxlLmhlaWdodCA9IG5ld0hlaWdodCArIFwicHhcIjtcblx0XHR9XG5cdFx0Y3R4LmNhbnZhcy5oZWlnaHQgPSBuZXdIZWlnaHQgKiBNYXRoLm1heCgxLHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcblx0XHRjdHguY2FudmFzLndpZHRoID0gbmV3V2lkdGggKiBNYXRoLm1heCgxLHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcblx0XHRjdHguc2NhbGUod2luZG93LmRldmljZVBpeGVsUmF0aW8sIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcblx0fSBlbHNlIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbz4xKSB7XG5cdFx0aWYodHlwZW9mIGN0eC5vcmlnaW5hbF93aWR0aD09XCJ1bmRlZmluZWRcIikge1xuXHRcdFx0Y3R4Lm9yaWdpbmFsX3dpZHRoPWN0eC5jYW52YXMud2lkdGg7XG5cdFx0XHRjdHgub3JpZ2luYWxfaGVpZ2h0PWN0eC5jYW52YXMuaGVpZ2h0O1xuXHRcdH1cblx0XHRjdHguY2FudmFzLnN0eWxlLndpZHRoID0gY3R4Lm9yaWdpbmFsX3dpZHRoICsgXCJweFwiO1xuXHRcdGN0eC5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gY3R4Lm9yaWdpbmFsX2hlaWdodCArIFwicHhcIjtcblx0XHRjdHguY2FudmFzLmhlaWdodCA9IGN0eC5vcmlnaW5hbF9oZWlnaHQgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblx0XHRjdHguY2FudmFzLndpZHRoID0gY3R4Lm9yaWdpbmFsX3dpZHRoICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cdFx0Y3R4LnNjYWxlKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG5cdH1cbn07XG5cblxuXG5cbmZ1bmN0aW9uIGNoYXJ0SnNSZXNpemUoKSB7XG5cdGZvciAodmFyIGk9MDtpPGpzR3JhcGhSZXNpemUubGVuZ3RoO2krKykgIHtcblx0XHRpZihqc0dyYXBoUmVzaXplW2ldWzJdLmZpcnN0UGFzcyA9PTApICB7XG5cdFx0fSBlbHNlIGlmKGpzR3JhcGhSZXNpemVbaV1bMl0uZmlyc3RQYXNzID09OSkge1xuXHRcdFx0anNHcmFwaFJlc2l6ZVtpXVsyXS5maXJzdFBhc3M9Mjtcblx0XHRcdHJlZHJhd0dyYXBoKGpzR3JhcGhSZXNpemVbaV1bMl0sanNHcmFwaFJlc2l6ZVtpXVszXSxqc0dyYXBoUmVzaXplW2ldWzRdKTtcblx0XHR9IGVsc2UgaWYoanNHcmFwaFJlc2l6ZVtpXVsyXS5maXJzdFBhc3MgPCAxMCApIHtcblx0XHRcdGpzR3JhcGhSZXNpemVbaV1bMl0uZmlyc3RQYXNzKz0xMDtcblx0XHR9IFxuXHR9XG59O1xuXG5mdW5jdGlvbiB0ZXN0UmVkcmF3KGN0eCxkYXRhLGNvbmZpZykge1xuXHRpZiAoY3R4LmZpcnN0UGFzcz4xMCkge1xuXHRcdGN0eC5maXJzdFBhc3M9Mjtcblx0XHRyZWRyYXdHcmFwaChjdHgsZGF0YSxjb25maWcpIDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cdFx0XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVDaGFydChjdHgsZGF0YSxjb25maWcsYW5pbWF0aW9uLHJ1bmFuaW1hdGlvbmNvbXBsZXRlZnVuY3Rpb24pIHtcblxuXHRpZiAoY3R4LmZpcnN0UGFzcz09OSlcblx0e1xuXHRcdFxuXHRcdGN0eC5ydW5hbmltYXRpb25jb21wbGV0ZWZ1bmN0aW9uPXJ1bmFuaW1hdGlvbmNvbXBsZXRlZnVuY3Rpb247XG5cblx0XHRpZihhbmltYXRpb24pY3R4LmZpcnN0UGFzcz0xO1xuXHRcdGVsc2UgICAgICAgICBjdHguZmlyc3RQYXNzPTI7XG5cblx0XHRpZihjb25maWcucmVzcG9uc2l2ZSkge1xuXHRcdFx0Ly8gdXBkYXRlIGpzR3JhcGhSZXNpemU7XG5cdFx0XHRmb3IgKHZhciBpPTA7aTxqc0dyYXBoUmVzaXplLmxlbmd0aDtpKyspICB7XG5cdFx0XHRcdGlmKGpzR3JhcGhSZXNpemVbaV1bMl0uQ2hhcnROZXdJZD09IGN0eC5DaGFydE5ld0lkKSB7XG5cdFx0XHRcdFx0anNHcmFwaFJlc2l6ZVtpXVszXT1kYXRhO1xuXHRcdFx0XHRcdGpzR3JhcGhSZXNpemVbaV1bNF09Y29uZmlnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlZHJhd0dyYXBoKGN0eCxkYXRhLGNvbmZpZyk7XG5cdH1cbn07XG5cblxuZnVuY3Rpb24gcmVkcmF3R3JhcGgoY3R4LGRhdGEsY29uZmlnKSB7XG5cdHZhciBteUdyYXBoID0gbmV3IENoYXJ0KGN0eCk7XHRcbiAgICAgICAgZXZhbChcIm15R3JhcGguXCIrY3R4LnRwY2hhcnQrXCIoZGF0YSxjb25maWcpO1wiKTtcbn07XG5cblxuLy9EZWZhdWx0IGJyb3dzZXJjaGVjaywgYWRkZWQgdG8gYWxsIHNjcmlwdHMhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmZ1bmN0aW9uIGNoZWNrQnJvd3NlcigpIHtcblx0dGhpcy52ZXIgPSBuYXZpZ2F0b3IuYXBwVmVyc2lvblxuXHR0aGlzLmRvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkID8gMSA6IDBcblx0dGhpcy5pZTUgPSAodGhpcy52ZXIuaW5kZXhPZihcIk1TSUUgNVwiKSA+IC0xICYmIHRoaXMuZG9tKSA/IDEgOiAwO1xuXHR0aGlzLmllNCA9IChkb2N1bWVudC5hbGwgJiYgIXRoaXMuZG9tKSA/IDEgOiAwO1xuXHR0aGlzLm5zNSA9ICh0aGlzLmRvbSAmJiBwYXJzZUludCh0aGlzLnZlcikgPj0gNSkgPyAxIDogMDtcblx0dGhpcy5uczQgPSAoZG9jdW1lbnQubGF5ZXJzICYmICF0aGlzLmRvbSkgPyAxIDogMDtcblx0dGhpcy5idyA9ICh0aGlzLmllNSB8fCB0aGlzLmllNCB8fCB0aGlzLm5zNCB8fCB0aGlzLm5zNSlcblx0cmV0dXJuIHRoaXNcbn07XG5idyA9IG5ldyBjaGVja0Jyb3dzZXIoKTtcbi8vU2V0IHRoZXNlIHZhcmlhYmxlczpcbmZyb21MZWZ0ID0gMTA7IC8vIEhvdyBtdWNoIGZyb20gdGhlIGxlZnQgb2YgdGhlIGN1cnNvciBzaG91bGQgdGhlIGRpdiBiZT9cbmZyb21Ub3AgPSAxMDsgLy8gSG93IG11Y2ggZnJvbSB0aGUgdG9wIG9mIHRoZSBjdXJzb3Igc2hvdWxkIHRoZSBkaXYgYmU/XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkluaXRpbGl6ZXMgdGhlIG9iamVjdHNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmZ1bmN0aW9uIGN1cnNvckluaXQoKSB7XG5cdHNjcm9sbGVkID0gYncubnM0IHx8IGJ3Lm5zNSA/IFwid2luZG93LnBhZ2VZT2Zmc2V0XCIgOiBcImRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wXCJcblx0aWYgKGJ3Lm5zNCkgZG9jdW1lbnQuY2FwdHVyZUV2ZW50cyhFdmVudC5NT1VTRU1PVkUpXG59O1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db250cnVjdHMgdGhlIGN1cnNvcm9iamVjdHNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmZ1bmN0aW9uIG1ha2VDdXJzb3JPYmoob2JqLCBuZXN0KSB7XG5cdGNyZWF0ZUN1cnNvckRpdigpO1xuXHRuZXN0ID0gKCFuZXN0KSA/ICcnIDogJ2RvY3VtZW50LicgKyBuZXN0ICsgJy4nXG5cdHRoaXMuY3NzID0gYncuZG9tID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob2JqKS5zdHlsZSA6IGJ3LmllNCA/IGRvY3VtZW50LmFsbFtvYmpdLnN0eWxlIDogYncubnM0ID8gZXZhbChuZXN0ICsgXCJkb2N1bWVudC5sYXllcnMuXCIgKyBvYmopIDogMDtcblx0dGhpcy5tb3ZlSXQgPSBiX21vdmVJdDtcblx0Y3Vyc29ySW5pdCgpO1xuXHRyZXR1cm4gdGhpc1xufTtcblxuZnVuY3Rpb24gYl9tb3ZlSXQoeCwgeSkge1xuXHR0aGlzLnggPSB4O1xuXHR0aGlzLnkgPSB5O1xuXHR0aGlzLmNzcy5sZWZ0ID0gdGhpcy54ICsgXCJweFwiO1xuXHR0aGlzLmNzcy50b3AgPSB0aGlzLnkgKyBcInB4XCI7XG59O1xuXG5mdW5jdGlvbiBpc0lFKCkge1xuXHR2YXIgbXlOYXYgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG5cdHJldHVybiAobXlOYXYuaW5kZXhPZignbXNpZScpICE9IC0xKSA/IHBhcnNlSW50KG15TmF2LnNwbGl0KCdtc2llJylbMV0pIDogZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBtZXJnZUNoYXJ0Q29uZmlnKGRlZmF1bHRzLCB1c2VyRGVmaW5lZCkge1xuXHR2YXIgcmV0dXJuT2JqID0ge307XG5cdGZvciAodmFyIGF0dHJuYW1lIGluIGRlZmF1bHRzKSB7XG5cdFx0cmV0dXJuT2JqW2F0dHJuYW1lXSA9IGRlZmF1bHRzW2F0dHJuYW1lXTtcblx0fVxuXHRmb3IgKHZhciBhdHRybmFtZUJpcyBpbiB1c2VyRGVmaW5lZCkge1xuXHRcdHJldHVybk9ialthdHRybmFtZUJpc10gPSB1c2VyRGVmaW5lZFthdHRybmFtZUJpc107XG5cdH1cblx0cmV0dXJuIHJldHVybk9iajtcbn07XG5cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG5cdHZhciBkdCA9IG5ldyBEYXRlKCk7XG5cdGR0LnNldFRpbWUoZHQuZ2V0VGltZSgpICsgbXMpO1xuXHR3aGlsZSAobmV3IERhdGUoKS5nZXRUaW1lKCkgPCBkdC5nZXRUaW1lKCkpIHt9O1xufTtcblxuZnVuY3Rpb24gc2F2ZUNhbnZhcyhjdHgsIGRhdGEsIGNvbmZpZykge1xuXHRjdlNhdmUgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGN0eC5jYW52YXMud2lkdGgsIGN0eC5jYW52YXMuaGVpZ2h0KTtcblx0dmFyIHNhdmVDYW52YXNDb25maWcgPSB7XG5cdFx0c2F2ZVBuZzogZmFsc2UsXG5cdFx0YW5ub3RhdGVEaXNwbGF5OiBmYWxzZSxcblx0XHRhbmltYXRpb246IGZhbHNlLFxuXHRcdGR5bmFtaWNEaXNwbGF5OiBmYWxzZVxuXHR9O1xuXHR2YXIgc2F2ZVBuZ0NvbmZpZyA9IG1lcmdlQ2hhcnRDb25maWcoY29uZmlnLCBzYXZlQ2FudmFzQ29uZmlnKTtcblx0c2F2ZVBuZ0NvbmZpZy5jbGVhclJlY3QgPSBmYWxzZTtcblx0LyogQW5kIGluayB0aGVtICovXG5cblx0cmVkcmF3R3JhcGgoY3R4LGRhdGEsc2F2ZVBuZ0NvbmZpZyk7XG5cdHZhciBpbWFnZTtcblx0aWYgKGNvbmZpZy5zYXZlUG5nT3V0cHV0ID09IFwiTmV3V2luZG93XCIpIHtcblx0XHRpbWFnZSA9IGN0eC5jYW52YXMudG9EYXRhVVJMKCk7XG5cdFx0Y3R4LnB1dEltYWdlRGF0YShjdlNhdmUsIDAsIDApO1xuXHRcdHdpbmRvdy5vcGVuKGltYWdlLCAnX2JsYW5rJyk7XG5cdH1cblx0aWYgKGNvbmZpZy5zYXZlUG5nT3V0cHV0ID09IFwiQ3VycmVudFdpbmRvd1wiKSB7XG5cdFx0aW1hZ2UgPSBjdHguY2FudmFzLnRvRGF0YVVSTCgpO1xuXHRcdGN0eC5wdXRJbWFnZURhdGEoY3ZTYXZlLCAwLCAwKTtcblx0XHR3aW5kb3cubG9jYXRpb24uaHJlZiA9IGltYWdlO1xuXHR9XG5cdGlmIChjb25maWcuc2F2ZVBuZ091dHB1dCA9PSBcIlNhdmVcIikge1xuXHRcdGltYWdlID0gY3R4LmNhbnZhcy50b0RhdGFVUkwoKTtcblx0XHR2YXIgZG93bmxvYWRMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cdFx0ZG93bmxvYWRMaW5rLmhyZWYgPSBpbWFnZTtcblx0XHRkb3dubG9hZExpbmsuZG93bmxvYWQgPSBjb25maWcuc2F2ZVBuZ05hbWUgKyBcIi5wbmdcIjtcblx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvd25sb2FkTGluayk7XG5cdFx0ZG93bmxvYWRMaW5rLmNsaWNrKCk7XG5cdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkb3dubG9hZExpbmspO1xuXHR9XG59O1xuaWYgKHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRyaW0gIT09ICdmdW5jdGlvbicpIHtcblx0U3RyaW5nLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuXHR9XG59O1xudmFyIGR5bmFtaWNEaXNwbGF5ID0gbmV3IEFycmF5KCk7XG52YXIgZHluYW1pY0Rpc3BsYXlMaXN0ID0gbmV3IEFycmF5KCk7XG5cbmZ1bmN0aW9uIGR5bmFtaWNGdW5jdGlvbihkYXRhLCBjb25maWcsIGN0eCkge1xuXHRpZiAoaXNJRSgpIDwgOSAmJiBpc0lFKCkgIT0gZmFsc2UpIHJldHVybih0cnVlKTtcblxuXHRpZiAoY29uZmlnLmR5bmFtaWNEaXNwbGF5ICYmIGN0eC5maXJzdFBhc3M9PTApIHtcblx0XHRpZiAoY3R4LmNhbnZhcy5pZCA9PSBcIlwiKSB7XG5cdFx0XHR2YXIgY3ZkYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdHZhciBjdm1pbGxzZWMgPSBjdmRhdGUuZ2V0VGltZSgpO1xuXHRcdFx0Y3R4LmNhbnZhcy5pZCA9IFwiQ2FudmFzX1wiICsgY3ZtaWxsc2VjO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mKGR5bmFtaWNEaXNwbGF5W2N0eC5jYW52YXMuaWRdKSA9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRkeW5hbWljRGlzcGxheUxpc3RbZHluYW1pY0Rpc3BsYXlMaXN0W1wibGVuZ3RoXCJdXSA9IGN0eC5jYW52YXMuaWQ7XG5cdFx0XHRkeW5hbWljRGlzcGxheVtjdHguY2FudmFzLmlkXSA9IFtjdHgsIGRhdGEsIGNvbmZpZ107XG5cdFx0XHR3aW5kb3cub25zY3JvbGwgPSBzY3JvbGxGdW5jdGlvbjtcblx0XHR9IFxuXHRcdGlmICghaXNTY3JvbGxlZEludG9WaWV3KGN0eC5jYW52YXMsY29uZmlnKSkgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gaXNTY3JvbGxlZEludG9WaWV3KGVsZW1lbnQsY29uZmlnKSB7XG5cdHZhciB4UG9zaXRpb24gPSAwO1xuXHR2YXIgeVBvc2l0aW9uID0gMDtcblx0dmFyIGVsdFdpZHRoLCBlbHRIZWlnaHQ7XG5cdGlmKHR5cGVvZiBlbGVtZW50LnJlY29tcHV0ZWRIZWlnaHQ9PVwidW5kZWZpbmVkXCIpIHtcblx0XHRpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8pIHtcblx0XHRcdC8vIDMxLzEyLzIwMTUgLSBPbiByZXRpbmEgZGlzcGxheSwgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyBjaGFuZ2VzIGFmdGVyIHRoZSBjYW52YXMgaXMgZGlzcGxheWVkLlxuXHRcdFx0Ly8gICAgICAgICAgICAgIGJlZm9yZSBpdCBpcyBkaXNwbGF5ZCwgdGhlIHNpemUgb24gdGhlIHNjcmVlbiBpcyB0aGUgc2l6ZSBvbiBub24gcmV0aW5hIGRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgSWYgd2UgZG8gbm90IGRpdmlkZSB0aGUgaGVpZ2h0ICYgd2lkdGggYnkgdGhlIGRldmljZVBpeGVsUmF0aW8sIGFuZCBpZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICB2YWx1ZSBvZiBjb25maWcuZHluYW1pY0Rpc3BsYXlZUGFydE9mQ2hhcnQgYW5kIGlmIHRoZXJlIGlzIGEgY2hhcnQgb24gdG8gYm90dG9tIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgIHdlYiBwYWdlLCB0aGlzIGNoYXJ0IHdpbGwgbmV2ZXIgYmUgZGlzcGxheWVkLi4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgIElmIHRoZSBTaXplIG9mIHRoZSBjYW52YXMgd2FzIGRpcmVjdGx5IHRoZSByZWFsIHNpemUgZGlzcGxheWVkIG9uIHRoZSB3ZWIgcGFnZSwgd2Ugc2hvdWxkIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGRpdmlkZSB0aGUgaGVpZ2h0L3dpZHRoIGJ5IHRoZSBkZXZpY2VQaXhlbFJhdGlvLi4uLiAoQnVnIGluIEJyb3NlcnMgPylcblx0XHRcdGVsZW1lbnQucmVjb21wdXRlZEhlaWdodD1lbGVtZW50LmhlaWdodC93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblx0XHRcdGVsZW1lbnQucmVjb21wdXRlZFdpZHRoPWVsZW1lbnQud2lkdGgvd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnQucmVjb21wdXRlZEhlaWdodD1lbGVtZW50LmhlaWdodDtcblx0XHRcdGVsZW1lbnQucmVjb21wdXRlZFdpZHRoPWVsZW1lbnQud2lkdGg7XG5cdFx0fVxuXHR9XG5cdGVsdFdpZHRoPWVsZW1lbnQucmVjb21wdXRlZFdpZHRoO1xuXHRlbHRIZWlnaHQ9ZWxlbWVudC5yZWNvbXB1dGVkSGVpZ2h0O1xuXHRlbGVtID0gZWxlbWVudDtcblx0d2hpbGUgKGVsZW0pIHtcblx0XHR4UG9zaXRpb24gKz0gKGVsZW0ub2Zmc2V0TGVmdCArIGVsZW0uY2xpZW50TGVmdCk7XG5cdFx0eVBvc2l0aW9uICs9IChlbGVtLm9mZnNldFRvcCArIGVsZW0uY2xpZW50VG9wKTtcblx0XHRlbGVtID0gZWxlbS5vZmZzZXRQYXJlbnQ7XG5cdH1cblxuXHRpZiAoeFBvc2l0aW9uICsgKGVsdFdpZHRoICogY29uZmlnLmR5bmFtaWNEaXNwbGF5WFBhcnRPZkNoYXJ0KSA+PSB3aW5kb3cucGFnZVhPZmZzZXQgJiZcblx0XHR4UG9zaXRpb24gKyAoZWx0V2lkdGggKiBjb25maWcuZHluYW1pY0Rpc3BsYXlYUGFydE9mQ2hhcnQpIDw9IHdpbmRvdy5wYWdlWE9mZnNldCArIHdpbmRvdy5pbm5lcldpZHRoICYmXG5cdFx0eVBvc2l0aW9uICsgKGVsdEhlaWdodCAqIGNvbmZpZy5keW5hbWljRGlzcGxheVlQYXJ0T2ZDaGFydCkgPj0gd2luZG93LnBhZ2VZT2Zmc2V0ICYmXG5cdFx0eVBvc2l0aW9uICsgKGVsdEhlaWdodCAqIGNvbmZpZy5keW5hbWljRGlzcGxheVlQYXJ0T2ZDaGFydCkgPD0gd2luZG93LnBhZ2VZT2Zmc2V0ICsgd2luZG93LmlubmVySGVpZ2h0XG5cdCkge1xuXHRcdHJldHVybiAodHJ1ZSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG5mdW5jdGlvbiBzY3JvbGxGdW5jdGlvbigpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkeW5hbWljRGlzcGxheUxpc3RbXCJsZW5ndGhcIl07IGkrKykge1xuXHRcdGlmICgoZHluYW1pY0Rpc3BsYXlbZHluYW1pY0Rpc3BsYXlMaXN0W2ldXVswXSkuZmlyc3RQYXNzPT0wKSB7XG5cdFx0XHRyZWRyYXdHcmFwaChkeW5hbWljRGlzcGxheVtkeW5hbWljRGlzcGxheUxpc3RbaV1dWzBdLGR5bmFtaWNEaXNwbGF5W2R5bmFtaWNEaXNwbGF5TGlzdFtpXV1bMV0sIGR5bmFtaWNEaXNwbGF5W2R5bmFtaWNEaXNwbGF5TGlzdFtpXV1bMl0pO1xuXHRcdH1cblx0fVxufTtcblxudmFyIGpzR3JhcGhBbm5vdGF0ZSA9IG5ldyBBcnJheSgpO1xudmFyIGpzVGV4dE1vdXNlUG9zID0gbmV3IEFycmF5KCk7XG52YXIgbW91c2VBY3Rpb25EYXRhPW5ldyBBcnJheSgpO1xuXG5mdW5jdGlvbiBjbGVhckFubm90YXRlKGN0eGlkKSB7XG5cdGpzR3JhcGhBbm5vdGF0ZVtjdHhpZF0gPSBbXTtcblx0anNUZXh0TW91c2VQb3NbY3R4aWRdID0gW107XG59O1xuXG5mdW5jdGlvbiBnZXRNb3VzZVBvcyhjYW52YXMsIGV2dCkge1xuXHR2YXIgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0cmV0dXJuIHtcblx0XHR4OiBldnQuY2xpZW50WCAtIHJlY3QubGVmdCxcblx0XHR5OiBldnQuY2xpZW50WSAtIHJlY3QudG9wXG5cdH07XG59O1xuXG5mdW5jdGlvbiBpc0hpZ2hMaWdodGVkKHJlZmVyZW5jZSxjdHgsZGF0YSxzdGF0RGF0YSxwb3NpLHBvc2osb3RoZXJ2YXJzKXtcblx0dmFyIGk7XG5cdGlmKGN0eC50cGRhdGE9PTApIHtcblx0XHRpZih0eXBlb2YgZGF0YS5zcGVjaWFsPT1cIm9iamVjdFwiKSB7XG5cdFx0XHRmb3IoaT1kYXRhLnNwZWNpYWwubGVuZ3RoLTE7aT49MDtpLS0pe1xuXHRcdFx0XHRpZihkYXRhLnNwZWNpYWxbaV0udHlwZXNwZWNpYWw9PVwiaGlnaExpZ2h0XCIgJiYgZGF0YS5zcGVjaWFsW2ldLnBvc2k9PXBvc2kgJiYgZGF0YS5zcGVjaWFsW2ldLnBvc2o9PXBvc2opIHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZih0eXBlb2YgZGF0YVswXS5zcGVjaWFsPT1cIm9iamVjdFwiKSB7XG5cdFx0XHRmb3IoaT1kYXRhWzBdLnNwZWNpYWwubGVuZ3RoLTE7aT49MDtpLS0pe1xuXHRcdFx0XHRpZihkYXRhWzBdLnNwZWNpYWxbaV0udHlwZXNwZWNpYWw9PVwiaGlnaExpZ2h0XCIgJiYgZGF0YVswXS5zcGVjaWFsW2ldLnBvc2k9PXBvc2kpIHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBpc05vdEhpZ2hMaWdodGVkKHJlZmVyZW5jZSxjdHgsZGF0YSxzdGF0RGF0YSxwb3NpLHBvc2osb3RoZXJ2YXJzKSB7XG5cdHJldHVybighaXNIaWdoTGlnaHRlZChyZWZlcmVuY2UsY3R4LGRhdGEsc3RhdERhdGEscG9zaSxwb3NqLG90aGVydmFycykpO1xufVxuZnVuY3Rpb24gZGVsZXRlSGlnaExpZ2h0KGN0eCxkYXRhKSB7XG5cdHZhciBpO1xuXHRpZihjdHgudHBkYXRhPT0wKSB7XG5cdFx0aWYodHlwZW9mIGRhdGEuc3BlY2lhbD09XCJvYmplY3RcIikge1xuXHRcdFx0Zm9yKGk9ZGF0YS5zcGVjaWFsLmxlbmd0aC0xO2k+PTA7aS0tKXtcblx0XHRcdFx0aWYoZGF0YS5zcGVjaWFsW2ldLnR5cGVzcGVjaWFsPT1cImhpZ2hMaWdodFwiKSBkYXRhLnNwZWNpYWwuc3BsaWNlKGksMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmKHR5cGVvZiBkYXRhWzBdLnNwZWNpYWw9PVwib2JqZWN0XCIpIHtcblx0XHRcdGZvcihpPWRhdGFbMF0uc3BlY2lhbC5sZW5ndGgtMTtpPj0wO2ktLSl7XG5cdFx0XHRcdGlmKGRhdGFbMF0uc3BlY2lhbFtpXS50eXBlc3BlY2lhbD09XCJoaWdoTGlnaHRcIikgZGF0YVswXS5zcGVjaWFsLnNwbGljZShpLDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG59O1xuXG5mdW5jdGlvbiBoaWdoTGlnaHRBY3Rpb24oYWN0aW9uLGN0eCxkYXRhLGNvbmZpZyx2MSx2Mikge1xuXHRpZiAoY3R4LmZpcnN0UGFzcyE9OSlyZXR1cm47XG5cblx0dmFyIGN1cnJlbnRseURpc3BsYXllZD1bLTEsLTFdO1xuXHR2YXIgcmVkaXNwbGF5PWZhbHNlO1xuXHR2YXIgaSxqO1xuXG5cblx0aWYoY3R4LnRwZGF0YT09MCkge1xuXHRcdGlmKHR5cGVvZiBkYXRhLnNwZWNpYWw9PVwib2JqZWN0XCIpIHtcblx0XHRcdGZvcihpPTA7aTxkYXRhLnNwZWNpYWwubGVuZ3RoICYmIGN1cnJlbnRseURpc3BsYXllZFswXT09LTE7aSsrKXtcblx0XHRcdFx0aWYoZGF0YS5zcGVjaWFsW2ldLnR5cGVzcGVjaWFsPT1cImhpZ2hMaWdodFwiKSBjdXJyZW50bHlEaXNwbGF5ZWQ9W2RhdGEuc3BlY2lhbFtpXS5wb3NpLGRhdGEuc3BlY2lhbFtpXS5wb3NqXTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYodHlwZW9mIGRhdGFbMF0uc3BlY2lhbD09XCJvYmplY3RcIikge1xuXHRcdFx0Zm9yKGk9MDtpPGRhdGFbMF0uc3BlY2lhbC5sZW5ndGggJiYgY3VycmVudGx5RGlzcGxheWVkWzBdPT0tMTtpKyspe1xuXHRcdFx0XHRpZihkYXRhWzBdLnNwZWNpYWxbaV0udHlwZXNwZWNpYWw9PVwiaGlnaExpZ2h0XCIpIGN1cnJlbnRseURpc3BsYXllZD1bZGF0YVswXS5zcGVjaWFsW2ldLnBvc2ksLTFdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHR2YXIgZGVsZXRlT2xkPWZhbHNlO1xuXHR2YXIgYWRkTmV3PWZhbHNlO1xuXHR2YXIgcHJvcGVydHk7XG5cdHZhciBvdXRwdXQ7XG5cblx0aWYoYWN0aW9uPT1cIkhJREVcIiAmJiBjdXJyZW50bHlEaXNwbGF5ZWRbMF0hPS0xKWRlbGV0ZU9sZD10cnVlO1xuXHRlbHNlIGlmKGN0eC50cGRhdGE9PTAgJiYgYWN0aW9uIT1cIkhJREVcIiAmJiBjb25maWcuaGlnaExpZ2h0RnVsbExpbmU9PSBcImdyb3VwXCIgJiYgKGN1cnJlbnRseURpc3BsYXllZFsxXSE9djIgKSkgeyBpZihjdXJyZW50bHlEaXNwbGF5ZWRbMF0hPS0xKWRlbGV0ZU9sZD10cnVlOyBhZGROZXc9dHJ1ZTt9XG5cdGVsc2UgaWYoY3R4LnRwZGF0YT09MCAmJiBhY3Rpb24hPVwiSElERVwiICYmIGNvbmZpZy5oaWdoTGlnaHRGdWxsTGluZT09IGZhbHNlICYmIChjdXJyZW50bHlEaXNwbGF5ZWRbMF0hPXYxIHx8IGN1cnJlbnRseURpc3BsYXllZFsxXSE9djIpKSB7IGlmKGN1cnJlbnRseURpc3BsYXllZFswXSE9LTEpZGVsZXRlT2xkPXRydWU7IGFkZE5ldz10cnVlO31cblx0ZWxzZSBpZihjdHgudHBkYXRhPT0wICYmIGFjdGlvbiE9XCJISURFXCIgJiYgY29uZmlnLmhpZ2hMaWdodEZ1bGxMaW5lPT0gdHJ1ZSAmJiAoY3VycmVudGx5RGlzcGxheWVkWzBdIT12MSApKSB7IGlmKGN1cnJlbnRseURpc3BsYXllZFswXSE9LTEpZGVsZXRlT2xkPXRydWU7IGFkZE5ldz10cnVlO31cblx0ZWxzZSBpZihjdHgudHBkYXRhPT0xICYmIGFjdGlvbiE9XCJISURFXCIgJiYgY3VycmVudGx5RGlzcGxheWVkWzBdIT12MSkgeyBpZihjdXJyZW50bHlEaXNwbGF5ZWRbMF0hPS0xKWRlbGV0ZU9sZD10cnVlOyBhZGROZXc9dHJ1ZTt9XG5cdFxuXHRpZihkZWxldGVPbGQpIHtcblx0XHRyZWRpc3BsYXk9dHJ1ZTtcblx0XHRpZihjdHgudHBkYXRhPT0wKSB7XG5cdFx0XHRmb3IoaT1kYXRhLnNwZWNpYWwubGVuZ3RoLTE7aT49MDtpLS0pe1xuXHRcdFx0XHRpZihkYXRhLnNwZWNpYWxbaV0udHlwZXNwZWNpYWw9PVwiaGlnaExpZ2h0XCIpIGRhdGEuc3BlY2lhbC5zcGxpY2UoaSwxKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yKGk9ZGF0YVswXS5zcGVjaWFsLmxlbmd0aC0xO2k+PTA7aS0tKXtcblx0XHRcdFx0aWYoZGF0YVswXS5zcGVjaWFsW2ldLnR5cGVzcGVjaWFsPT1cImhpZ2hMaWdodFwiKSBkYXRhWzBdLnNwZWNpYWwuc3BsaWNlKGksMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmKGFkZE5ldykge1xuXHRcdHJlZGlzcGxheT10cnVlO1xuXHRcdGlmKGN0eC50cGRhdGE9PTApIHtcblx0XHRcdGlmKHR5cGVvZiBkYXRhLnNwZWNpYWwgPT0gXCJ1bmRlZmluZWRcIikgZGF0YS5zcGVjaWFsPVtdO1xuXHRcdFx0aWYoY29uZmlnLmhpZ2hMaWdodEZ1bGxMaW5lID09IFwiZ3JvdXBcIikge1xuXHRcdFx0XHRmb3Ioaj0wO2o8ZGF0YS5kYXRhc2V0cy5sZW5ndGg7aisrKSB7XG5cdFx0XHRcdFx0aWYoIShkYXRhLmRhdGFzZXRzW2pdLm1vdXNlRGV0ZWN0aW9uPT1mYWxzZSkpIHtcblx0XHRcdFx0XHRcdG91dHB1dD1cIlwiO1xuXHRcdFx0XHRcdFx0Zm9yIChwcm9wZXJ0eSBpbiBjb25maWcuaGlnaExpZ2h0U2V0KSB7XG4gIFx0XHRcdFx0XHRcdFx0aWYgKG91dHB1dCAhPVwiXCIpIG91dHB1dD1vdXRwdXQrXCIsXCI7ICBcbiAgXHRcdFx0XHRcdFx0XHRpZih0eXBlb2YgY29uZmlnLmhpZ2hMaWdodFNldFtwcm9wZXJ0eV09PVwic3RyaW5nXCIpb3V0cHV0ICs9IHByb3BlcnR5ICsgJzogXCInICsgY29uZmlnLmhpZ2hMaWdodFNldFtwcm9wZXJ0eV0rJ1wiJztcbiAgXHRcdFx0XHRcdFx0XHRlbHNlIG91dHB1dCArPSBwcm9wZXJ0eSArICc6ICcgKyBjb25maWcuaGlnaExpZ2h0U2V0W3Byb3BlcnR5XTtcblx0XHRcdFx0XHRcdH1cbiAgICAgICAgXHRcdFx0XHRcdGV2YWwoXCJkYXRhLnNwZWNpYWxbZGF0YS5zcGVjaWFsLmxlbmd0aF09e1wiK291dHB1dCtcIn07XCIpO1xuXHRcdFx0XHRcdFx0ZGF0YS5zcGVjaWFsW2RhdGEuc3BlY2lhbC5sZW5ndGgtMV0ucG9zaT1qO1xuXHRcdFx0XHRcdFx0ZGF0YS5zcGVjaWFsW2RhdGEuc3BlY2lhbC5sZW5ndGgtMV0ucG9zaj12Mjtcblx0XHRcdFx0XHRcdGRhdGEuc3BlY2lhbFtkYXRhLnNwZWNpYWwubGVuZ3RoLTFdLnR5cGVzcGVjaWFsPVwiaGlnaExpZ2h0XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdH0gZWxzZSBpZihjb25maWcuaGlnaExpZ2h0RnVsbExpbmUgPT0gdHJ1ZSkge1xuXHRcdFx0XHRpZighKGRhdGEuZGF0YXNldHNbdjFdLm1vdXNlRGV0ZWN0aW9uPT1mYWxzZSkpIHtcblx0XHRcdFx0XHRmb3Ioaj0wO2o8ZGF0YS5kYXRhc2V0c1t2MV0uZGF0YS5sZW5ndGg7aisrKSB7XG5cdFx0XHRcdFx0XHRvdXRwdXQ9XCJcIjtcblx0XHRcdFx0XHRcdGZvciAocHJvcGVydHkgaW4gY29uZmlnLmhpZ2hMaWdodFNldCkge1xuICBcdFx0XHRcdFx0XHRcdGlmIChvdXRwdXQgIT1cIlwiKSBvdXRwdXQ9b3V0cHV0K1wiLFwiOyAgXG4gIFx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIGNvbmZpZy5oaWdoTGlnaHRTZXRbcHJvcGVydHldPT1cInN0cmluZ1wiKW91dHB1dCArPSBwcm9wZXJ0eSArICc6IFwiJyArIGNvbmZpZy5oaWdoTGlnaHRTZXRbcHJvcGVydHldKydcIic7XG4gIFx0XHRcdFx0XHRcdFx0ZWxzZSBvdXRwdXQgKz0gcHJvcGVydHkgKyAnOiAnICsgY29uZmlnLmhpZ2hMaWdodFNldFtwcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHR9XG4gICAgICAgIFx0XHRcdFx0XHRldmFsKFwiZGF0YS5zcGVjaWFsW2RhdGEuc3BlY2lhbC5sZW5ndGhdPXtcIitvdXRwdXQrXCJ9O1wiKTtcblx0XHRcdFx0XHRcdGRhdGEuc3BlY2lhbFtkYXRhLnNwZWNpYWwubGVuZ3RoLTFdLnBvc2k9djE7XG5cdFx0XHRcdFx0XHRkYXRhLnNwZWNpYWxbZGF0YS5zcGVjaWFsLmxlbmd0aC0xXS5wb3NqPWo7XG5cdFx0XHRcdFx0XHRkYXRhLnNwZWNpYWxbZGF0YS5zcGVjaWFsLmxlbmd0aC0xXS50eXBlc3BlY2lhbD1cImhpZ2hMaWdodFwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmKCEoZGF0YS5kYXRhc2V0c1t2MV0ubW91c2VEZXRlY3Rpb249PWZhbHNlKSkge1xuXHRcdFx0XHRvdXRwdXQ9XCJcIjtcblx0XHRcdFx0Zm9yIChwcm9wZXJ0eSBpbiBjb25maWcuaGlnaExpZ2h0U2V0KSB7XG4gIFx0XHRcdFx0XHRpZiAob3V0cHV0ICE9XCJcIikgb3V0cHV0PW91dHB1dCtcIixcIjsgIFxuICBcdFx0XHRcdFx0aWYodHlwZW9mIGNvbmZpZy5oaWdoTGlnaHRTZXRbcHJvcGVydHldPT1cInN0cmluZ1wiKW91dHB1dCArPSBwcm9wZXJ0eSArICc6IFwiJyArIGNvbmZpZy5oaWdoTGlnaHRTZXRbcHJvcGVydHldKydcIic7XG4gIFx0XHRcdFx0XHRlbHNlIG91dHB1dCArPSBwcm9wZXJ0eSArICc6ICcgKyBjb25maWcuaGlnaExpZ2h0U2V0W3Byb3BlcnR5XTtcblx0XHRcdFx0fVxuICAgICAgICBcdFx0XHRldmFsKFwiZGF0YS5zcGVjaWFsW2RhdGEuc3BlY2lhbC5sZW5ndGhdPXtcIitvdXRwdXQrXCJ9O1wiKTtcblx0XHRcdFx0ZGF0YS5zcGVjaWFsW2RhdGEuc3BlY2lhbC5sZW5ndGgtMV0ucG9zaT12MTtcblx0XHRcdFx0ZGF0YS5zcGVjaWFsW2RhdGEuc3BlY2lhbC5sZW5ndGgtMV0ucG9zaj12Mjtcblx0XHRcdFx0ZGF0YS5zcGVjaWFsW2RhdGEuc3BlY2lhbC5sZW5ndGgtMV0udHlwZXNwZWNpYWw9XCJoaWdoTGlnaHRcIjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYodHlwZW9mIGRhdGFbMF0uc3BlY2lhbCA9PSBcInVuZGVmaW5lZFwiKSBkYXRhWzBdLnNwZWNpYWw9W107XG5cdFx0XHRvdXRwdXQ9XCJcIjtcblx0XHRcdGZvciAocHJvcGVydHkgaW4gY29uZmlnLmhpZ2hMaWdodFNldCkge1xuXHRcdFx0XHRpZiAob3V0cHV0ICE9XCJcIikgb3V0cHV0PW91dHB1dCtcIixcIjsgIFxuXHRcdFx0XHRpZih0eXBlb2YgY29uZmlnLmhpZ2hMaWdodFNldFtwcm9wZXJ0eV09PVwic3RyaW5nXCIpb3V0cHV0ICs9IHByb3BlcnR5ICsgJzogXCInICsgY29uZmlnLmhpZ2hMaWdodFNldFtwcm9wZXJ0eV0rJ1wiJztcblx0XHRcdFx0ZWxzZSBvdXRwdXQgKz0gcHJvcGVydHkgKyAnOiAnICsgY29uZmlnLmhpZ2hMaWdodFNldFtwcm9wZXJ0eV07XG5cdFx0XHR9XG5cdFx0XHRldmFsKFwiZGF0YVswXS5zcGVjaWFsW2RhdGFbMF0uc3BlY2lhbC5sZW5ndGhdPXtcIitvdXRwdXQrXCJ9O1wiKTtcblx0XHRcdGRhdGFbMF0uc3BlY2lhbFtkYXRhWzBdLnNwZWNpYWwubGVuZ3RoLTFdLnBvc2k9djE7XG5cdFx0XHRkYXRhWzBdLnNwZWNpYWxbZGF0YVswXS5zcGVjaWFsLmxlbmd0aC0xXS5wb3NqPXYyO1xuXHRcdFx0ZGF0YVswXS5zcGVjaWFsW2RhdGFbMF0uc3BlY2lhbC5sZW5ndGgtMV0udHlwZXNwZWNpYWw9XCJoaWdoTGlnaHRcIjtcblx0XHR9XG5cdH1cblx0aWYocmVkaXNwbGF5PT10cnVlKSB7XG5cdFx0dXBkYXRlQ2hhcnQoY3R4LGRhdGEsY29uZmlnLGZhbHNlLGNvbmZpZy5oaWdoTGlnaHRSZXJ1bkVuZEZ1bmN0aW9uKTtcblx0fVxufTtcblxudmFyIGluTW91c2VBY3Rpb249bmV3IEFycmF5KCk7XG5cbmZ1bmN0aW9uIGRvTW91c2VBY3Rpb24oZXZlbnQsIGN0eCwgYWN0aW9uKSB7XG5cdGlmIChjdHguZmlyc3RQYXNzICE9IDkpcmV0dXJuO1xuXHRpZihhY3Rpb249PVwibW91c2Vkb3duXCIpIGFjdGlvbj1hY3Rpb24rXCIgXCIrZXZlbnQud2hpY2g7XG5cdGlmKGN0eC5tb3VzZUFjdGlvbi5pbmRleE9mKGFjdGlvbik8MCl7cmV0dXJuO31cblx0dmFyIGNvbmZpZz1tb3VzZUFjdGlvbkRhdGFbY3R4LkNoYXJ0TmV3SWRdLmNvbmZpZztcblx0dmFyIGRhdGE9bW91c2VBY3Rpb25EYXRhW2N0eC5DaGFydE5ld0lkXS5kYXRhO1xuXHR2YXIgaSxwcmV2U2hvd24scHJldlNob3dTYXZlZDtcblx0dmFyIGluUmVjdCxQMTIsRDEyLEQzNCxQMTMsRDEzLEQyNCwgeTEseTIseTMseTQ7XG5cdHZhciBwaWVjZU9mQ2hhcnRGb3VuZD1bXTtcblx0dmFyIHRleHRPbkNoYXJ0Rm91bmQ9W107XG5cdHZhciBkaXN0YW5jZSwgYW5nbGUsdG9wWSwgYm90dG9tWSxsZWZ0WCwgcmlnaHRYO1xuXHR2YXIgbW91c2V3aGVlbGV2dD0oL0ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKT8gXCJET01Nb3VzZVNjcm9sbFwiIDogXCJtb3VzZXdoZWVsXCIgXG5cdHZhciBjYW52YXNfcG9zID0gZ2V0TW91c2VQb3MoY3R4LmNhbnZhcywgZXZlbnQpO1xuXHR2YXIgcmVhbEFjdGlvbjtcblx0dmFyIGFubm90YXRlRElWLHNob3dEaXY7XG5cblx0ICAgICBpZihhY3Rpb249PVwibW91c2Vkb3duIDFcIilyZWFsQWN0aW9uPVwibW91c2Vkb3duIGxlZnRcIjtcblx0ZWxzZSBpZihhY3Rpb249PVwibW91c2Vkb3duIDJcIilyZWFsQWN0aW9uPVwibW91c2Vkb3duIG1pZGRsZVwiO1xuXHRlbHNlIGlmKGFjdGlvbj09XCJtb3VzZWRvd24gM1wiKXJlYWxBY3Rpb249XCJtb3VzZWRvd24gcmlnaHRcIjtcblx0ZWxzZSBpZihhY3Rpb249PW1vdXNld2hlZWxldnQpcmVhbEFjdGlvbj1cIm1vdXNld2hlZWxcIjtcblx0ZWxzZSByZWFsQWN0aW9uPWFjdGlvbjtcblxuXHQvLyBzZWFyY2ggaWYgbW91c2Ugb3ZlciBvbmUgb3IgbW9yZSBwaWVjZXMgb2YgY2hhcnQ7XG5cblx0Zm9yIChpID0gMDsgaSA8IGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bXCJsZW5ndGhcIl07IGkrKykge1xuXHRcdGlmIChqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW2ldWzBdID09IFwiQVJDXCIpIHtcblx0XHRcdG15U3RhdERhdGE9anNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtpXVszXVtqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW2ldWzFdXTtcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5zcXJ0KChjYW52YXNfcG9zLnggLSBteVN0YXREYXRhLm1pZFBvc1gpICogKGNhbnZhc19wb3MueCAtIG15U3RhdERhdGEubWlkUG9zWCkgKyAoY2FudmFzX3Bvcy55IC0gbXlTdGF0RGF0YS5taWRQb3NZKSAqIChjYW52YXNfcG9zLnkgLSBteVN0YXREYXRhLm1pZFBvc1kpKTtcblx0XHRcdGlmIChkaXN0YW5jZSA+IG15U3RhdERhdGEuaW50X3JhZGl1cyAmJiBkaXN0YW5jZSA8IG15U3RhdERhdGEucmFkaXVzT2Zmc2V0KSB7XG5cdFx0XHRcdGFuZ2xlID0gKE1hdGguYWNvcygoY2FudmFzX3Bvcy54IC0gbXlTdGF0RGF0YS5taWRQb3NYKSAvIGRpc3RhbmNlKSAlICgyKiBNYXRoLlBJKSArIDIqTWF0aC5QSSkgJSAoMipNYXRoLlBJKTtcblx0XHRcdFx0aWYgKGNhbnZhc19wb3MueSA8IG15U3RhdERhdGEubWlkUG9zWSkgYW5nbGUgPSAtYW5nbGU7XG5cdFx0XHRcdGFuZ2xlID0gKCgoYW5nbGUgICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSkgKyAyKiBNYXRoLlBJKSAlICgyKiBNYXRoLlBJKSA7IFxuXHRcdFx0XHRteVN0YXREYXRhLnN0YXJ0QW5nbGU9KCgobXlTdGF0RGF0YS5zdGFydEFuZ2xlICArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkpICsgMiogTWF0aC5QSSkgJSAoMiogTWF0aC5QSSk7XG5cdFx0XHRcdG15U3RhdERhdGEuZW5kQW5nbGU9KCgobXlTdGF0RGF0YS5lbmRBbmdsZSAgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpKSArIDIqIE1hdGguUEkpICUgKDIqIE1hdGguUEkpO1xuXHRcdFx0XHRpZihteVN0YXREYXRhLmVuZEFuZ2xlPG15U3RhdERhdGEuc3RhcnRBbmdsZSlteVN0YXREYXRhLmVuZEFuZ2xlKz0yICogTWF0aC5QSTtcblx0XHRcdFx0aWYgKChhbmdsZSA+IG15U3RhdERhdGEuc3RhcnRBbmdsZSAmJiBhbmdsZSA8IG15U3RhdERhdGEuZW5kQW5nbGUpIHx8IChhbmdsZSA+IG15U3RhdERhdGEuc3RhcnRBbmdsZSAtIDIgKiBNYXRoLlBJICYmIGFuZ2xlIDwgbXlTdGF0RGF0YS5lbmRBbmdsZSAtIDIgKiBNYXRoLlBJKSB8fCAoYW5nbGUgPiBteVN0YXREYXRhLnN0YXJ0QW5nbGUgKyAyICogTWF0aC5QSSAmJiBhbmdsZSA8IG15U3RhdERhdGEuZW5kQW5nbGUgKyAyICogTWF0aC5QSSkpIHtcblx0XHRcdFx0XHRteVN0YXREYXRhLmdyYXBoUG9zWCA9IGNhbnZhc19wb3MueDtcblx0XHRcdFx0XHRteVN0YXREYXRhLmdyYXBoUG9zWSA9IGNhbnZhc19wb3MueTtcblx0XHRcdFx0XHRwaWVjZU9mQ2hhcnRGb3VuZFtwaWVjZU9mQ2hhcnRGb3VuZC5sZW5ndGhdPXtcblx0XHRcdFx0XHRcdHBpZWNlIDogaSxcblx0XHRcdFx0XHRcdG15U3RhdERhdGE6IG15U3RhdERhdGFcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW2ldWzBdID09IFwiUkVDVFwiKSB7XG5cdFx0XHRteVN0YXREYXRhPWpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1baV1bM11banNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtpXVsxXV1banNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtpXVsyXV07XG5cdFx0XHR0b3BZPU1hdGgubWF4KG15U3RhdERhdGEueVBvc0JvdHRvbSxteVN0YXREYXRhLnlQb3NUb3ApO1xuXHRcdFx0Ym90dG9tWT1NYXRoLm1pbihteVN0YXREYXRhLnlQb3NCb3R0b20sbXlTdGF0RGF0YS55UG9zVG9wKTtcblx0XHRcdGlmICh0b3BZLWJvdHRvbVkgPGNvbmZpZy5hbm5vdGF0ZUJhck1pbmltdW1EZXRlY3Rpb25IZWlnaHQpIHtcblx0XHRcdFx0dG9wWT0odG9wWStib3R0b21ZK2NvbmZpZy5hbm5vdGF0ZUJhck1pbmltdW1EZXRlY3Rpb25IZWlnaHQpLzI7XG5cdFx0XHQgICAgICAgIGJvdHRvbVk9dG9wWS1jb25maWcuYW5ub3RhdGVCYXJNaW5pbXVtRGV0ZWN0aW9uSGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0bGVmdFg9TWF0aC5taW4obXlTdGF0RGF0YS54UG9zTGVmdCxteVN0YXREYXRhLnhQb3NSaWdodCk7XG5cdFx0XHRyaWdodFg9TWF0aC5tYXgobXlTdGF0RGF0YS54UG9zTGVmdCxteVN0YXREYXRhLnhQb3NSaWdodCk7XG5cdFx0XHRpZiAocmlnaHRYLWxlZnRYIDxjb25maWcuYW5ub3RhdGVCYXJNaW5pbXVtRGV0ZWN0aW9uSGVpZ2h0KSB7XG5cdFx0XHRcdHJpZ2h0WD0ocmlnaHRYK2xlZnRYK2NvbmZpZy5hbm5vdGF0ZUJhck1pbmltdW1EZXRlY3Rpb25IZWlnaHQpLzI7XG5cdFx0XHQgICAgICAgIGxlZnRYPXJpZ2h0WC1jb25maWcuYW5ub3RhdGVCYXJNaW5pbXVtRGV0ZWN0aW9uSGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbnZhc19wb3MueCA+IGxlZnRYICYmIGNhbnZhc19wb3MueCA8IHJpZ2h0WCAmJiBjYW52YXNfcG9zLnkgPCB0b3BZICYmIGNhbnZhc19wb3MueSA+IGJvdHRvbVkpIHtcblx0XHRcdFx0bXlTdGF0RGF0YS5ncmFwaFBvc1ggPSBjYW52YXNfcG9zLng7XG5cdFx0XHRcdG15U3RhdERhdGEuZ3JhcGhQb3NZID0gY2FudmFzX3Bvcy55O1xuXHRcdFx0XHRwaWVjZU9mQ2hhcnRGb3VuZFtwaWVjZU9mQ2hhcnRGb3VuZC5sZW5ndGhdPXtcblx0XHRcdFx0XHRwaWVjZSA6IGksXG5cdFx0XHRcdFx0bXlTdGF0RGF0YTogbXlTdGF0RGF0YVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoanNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtpXVswXSA9PSBcIlBPSU5UXCIpIHtcblx0XHRcdG15U3RhdERhdGE9anNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtpXVszXVtqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW2ldWzFdXVtqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW2ldWzJdXTtcblx0XHRcdGlmKGNvbmZpZy5kZXRlY3RBbm5vdGF0ZU9uRnVsbExpbmUpIHtcblx0XHRcdFx0aWYoY2FudmFzX3Bvcy54IDwgTWF0aC5taW4obXlTdGF0RGF0YS5hbm5vdGF0ZVN0YXJ0UG9zWCxteVN0YXREYXRhLmFubm90YXRlRW5kUG9zWCktTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnBvaW50SGl0RGV0ZWN0aW9uUmFkaXVzKSB8fCBjYW52YXNfcG9zLnggPiBNYXRoLm1heChteVN0YXREYXRhLmFubm90YXRlU3RhcnRQb3NYLG15U3RhdERhdGEuYW5ub3RhdGVFbmRQb3NYKStNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcucG9pbnRIaXREZXRlY3Rpb25SYWRpdXMpIHx8IGNhbnZhc19wb3MueSA8IE1hdGgubWluKG15U3RhdERhdGEuYW5ub3RhdGVTdGFydFBvc1ksbXlTdGF0RGF0YS5hbm5vdGF0ZUVuZFBvc1kpLU1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5wb2ludEhpdERldGVjdGlvblJhZGl1cykgfHwgY2FudmFzX3Bvcy55ID4gTWF0aC5tYXgobXlTdGF0RGF0YS5hbm5vdGF0ZVN0YXJ0UG9zWSxteVN0YXREYXRhLmFubm90YXRlRW5kUG9zWSkrTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnBvaW50SGl0RGV0ZWN0aW9uUmFkaXVzKSkge1xuXHRcdFx0XHRcdGRpc3RhbmNlPU1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5wb2ludEhpdERldGVjdGlvblJhZGl1cykrMTtcblx0XHRcdFx0fSBlbHNlIHsgXG5cdFx0XHRcdFx0aWYodHlwZW9mIG15U3RhdERhdGEuRDFBPT1cInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0XHRkaXN0YW5jZT1NYXRoLmFicyhjYW52YXNfcG9zLngtbXlTdGF0RGF0YS5wb3NYKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYodHlwZW9mIG15U3RhdERhdGEuRDJBPT1cInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0XHRkaXN0YW5jZT1NYXRoLmFicyhjYW52YXNfcG9zLnktbXlTdGF0RGF0YS5wb3NZKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIEQyQj0tbXlTdGF0RGF0YS5EMkEqY2FudmFzX3Bvcy54K2NhbnZhc19wb3MueTtcblx0XHRcdFx0XHRcdHZhciBnPS0obXlTdGF0RGF0YS5EMUItRDJCKS8obXlTdGF0RGF0YS5EMUEtbXlTdGF0RGF0YS5EMkEpO1xuXHRcdFx0XHRcdFx0dmFyIGg9bXlTdGF0RGF0YS5EMkEqZytEMkI7XG5cdFx0XHRcdFx0XHRkaXN0YW5jZT1NYXRoLnNxcnQoKGNhbnZhc19wb3MueCAtIGcpICogKGNhbnZhc19wb3MueCAtIGcpICsgKGNhbnZhc19wb3MueSAtIGgpICogKGNhbnZhc19wb3MueSAtIGgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc3RhbmNlID0gTWF0aC5zcXJ0KChjYW52YXNfcG9zLnggLSBteVN0YXREYXRhLnBvc1gpICogKGNhbnZhc19wb3MueCAtIG15U3RhdERhdGEucG9zWCkgKyAoY2FudmFzX3Bvcy55IC0gbXlTdGF0RGF0YS5wb3NZKSAqIChjYW52YXNfcG9zLnkgLSBteVN0YXREYXRhLnBvc1kpKTtcblx0XHRcdH1cblx0XHRcdGlmIChkaXN0YW5jZSA8IE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5wb2ludEhpdERldGVjdGlvblJhZGl1cykpIHtcblx0XHRcdFx0bXlTdGF0RGF0YS5ncmFwaFBvc1ggPSBjYW52YXNfcG9zLng7XG5cdFx0XHRcdG15U3RhdERhdGEuZ3JhcGhQb3NZID0gY2FudmFzX3Bvcy55O1xuXHRcdFx0XHRwaWVjZU9mQ2hhcnRGb3VuZFtwaWVjZU9mQ2hhcnRGb3VuZC5sZW5ndGhdPXtcblx0XHRcdFx0XHRwaWVjZSA6IGksXG5cdFx0XHRcdFx0bXlTdGF0RGF0YTogbXlTdGF0RGF0YVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIHNlYXJjaCBpZiBtb3VzZSBvdmVyIG9uZSBvciBtb3JlIHRleHQ7XG5cdGlmKGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCkge1xuXHRcdGZvcihpPTA7aTxqc1RleHRNb3VzZVBvc1tjdHguQ2hhcnROZXdJZF1bXCJsZW5ndGhcIl07aSsrKXtcblx0XHQgICAgICAgIGluUmVjdD10cnVlO1xuXHRcdFx0aWYoTWF0aC5hYnMoanNUZXh0TW91c2VQb3NbY3R4LkNoYXJ0TmV3SWRdW2ldWzNdLnAxIC0ganNUZXh0TW91c2VQb3NbY3R4LkNoYXJ0TmV3SWRdW2ldWzNdLnAyKSA8IGNvbmZpZy56ZXJvVmFsdWUpIHtcblx0XHRcdFx0Ly8gSG9yaXpvbnRhbDtcblx0XHRcdFx0aWYoY2FudmFzX3Bvcy54IDwgTWF0aC5taW4oanNUZXh0TW91c2VQb3NbY3R4LkNoYXJ0TmV3SWRdW2ldWzJdLnAxLGpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVsyXS5wMikpaW5SZWN0PWZhbHNlOyBcblx0XHRcdFx0aWYoY2FudmFzX3Bvcy54ID4gTWF0aC5tYXgoanNUZXh0TW91c2VQb3NbY3R4LkNoYXJ0TmV3SWRdW2ldWzJdLnAxLGpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVsyXS5wMikpaW5SZWN0PWZhbHNlOyBcblx0XHRcdFx0aWYoY2FudmFzX3Bvcy55IDwgTWF0aC5taW4oanNUZXh0TW91c2VQb3NbY3R4LkNoYXJ0TmV3SWRdW2ldWzNdLnAxLGpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVszXS5wMykpaW5SZWN0PWZhbHNlOyBcblx0XHRcdFx0aWYoY2FudmFzX3Bvcy55ID4gTWF0aC5tYXgoanNUZXh0TW91c2VQb3NbY3R4LkNoYXJ0TmV3SWRdW2ldWzNdLnAxLGpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVszXS5wMykpaW5SZWN0PWZhbHNlOyBcblx0XHRcdH0gZWxzZSBpZihNYXRoLmFicyhqc1RleHRNb3VzZVBvc1tjdHguQ2hhcnROZXdJZF1baV1bMl0ucDEgLSBqc1RleHRNb3VzZVBvc1tjdHguQ2hhcnROZXdJZF1baV1bMl0ucDIpPGNvbmZpZy56ZXJvVmFsdWUpIHtcblx0XHRcdFx0Ly8gVmVydGljYWw7XG5cdFx0XHRcdGlmKGNhbnZhc19wb3MueCA8IE1hdGgubWluKGpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVsyXS5wMSxqc1RleHRNb3VzZVBvc1tjdHguQ2hhcnROZXdJZF1baV1bMl0ucDMpKWluUmVjdD1mYWxzZTsgXG5cdFx0XHRcdGlmKGNhbnZhc19wb3MueCA+IE1hdGgubWF4KGpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVsyXS5wMSxqc1RleHRNb3VzZVBvc1tjdHguQ2hhcnROZXdJZF1baV1bMl0ucDMpKWluUmVjdD1mYWxzZTsgXG5cdFx0XHRcdGlmKGNhbnZhc19wb3MueSA8IE1hdGgubWluKGpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVszXS5wMSxqc1RleHRNb3VzZVBvc1tjdHguQ2hhcnROZXdJZF1baV1bM10ucDIpKWluUmVjdD1mYWxzZTsgXG5cdFx0XHRcdGlmKGNhbnZhc19wb3MueSA+IE1hdGgubWF4KGpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVszXS5wMSxqc1RleHRNb3VzZVBvc1tjdHguQ2hhcnROZXdJZF1baV1bM10ucDIpKWluUmVjdD1mYWxzZTsgXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBEMTIgJiBEMzQ7XG5cblx0XHRcdFx0UDEyPU1hdGgudGFuKGpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVs0XSk7XG5cdFx0XHRcdEQxMj1qc1RleHRNb3VzZVBvc1tjdHguQ2hhcnROZXdJZF1baV1bM10ucDEtUDEyKmpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVsyXS5wMTtcblx0XHRcdFx0RDM0PWpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVszXS5wMy1QMTIqanNUZXh0TW91c2VQb3NbY3R4LkNoYXJ0TmV3SWRdW2ldWzJdLnAzO1xuXHRcdFx0XHQvLyBEMTMgJiBEMjQ7XG5cdFx0XHRcdFAxMz0tMS9QMTI7XG5cdFx0XHRcdEQxMz1qc1RleHRNb3VzZVBvc1tjdHguQ2hhcnROZXdJZF1baV1bM10ucDEtUDEzKmpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVsyXS5wMTtcblx0XHRcdFx0RDI0PWpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVtpXVszXS5wNC1QMTMqanNUZXh0TW91c2VQb3NbY3R4LkNoYXJ0TmV3SWRdW2ldWzJdLnA0O1xuXHRcdFx0XHQvLyBDaGVjayBpZiBpbiByZWN0YW5nbGU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdHkxPVAxMipjYW52YXNfcG9zLngrRDEyO1xuXHRcdFx0XHR5Mj1QMTIqY2FudmFzX3Bvcy54K0QzNDtcblx0XHRcdFx0eTM9UDEzKmNhbnZhc19wb3MueCtEMTM7XG5cdFx0XHRcdHk0PVAxMypjYW52YXNfcG9zLngrRDI0O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYoY2FudmFzX3Bvcy55IDwgTWF0aC5taW4oeTEseTIpKWluUmVjdD1mYWxzZTtcblx0XHRcdFx0aWYoY2FudmFzX3Bvcy55ID4gTWF0aC5tYXgoeTEseTIpKWluUmVjdD1mYWxzZTtcblx0XHRcdFx0aWYoY2FudmFzX3Bvcy55IDwgTWF0aC5taW4oeTMseTQpKWluUmVjdD1mYWxzZTtcblx0XHRcdFx0aWYoY2FudmFzX3Bvcy55ID4gTWF0aC5tYXgoeTMseTQpKWluUmVjdD1mYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKGluUmVjdCl0ZXh0T25DaGFydEZvdW5kW3RleHRPbkNoYXJ0Rm91bmQubGVuZ3RoXT1pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGlzQWN0aW9uKG9wdGlvbixhY3Rpb24pIHtcblx0XHRyZXR1cm4ob3B0aW9uPT1hY3Rpb24gfHwgKG9wdGlvbj09XCJtb3VzZW1vdmVcIiAmJiAoYWN0aW9uPT1cIm1vdXNld2hlZWxcIiB8fCBhY3Rpb249PVwibW91c2VvdXRcIikpKTtcblx0fVxuXG5cdGlmKGNvbmZpZy5zYXZlUG5nICYmIGlzQWN0aW9uKGNvbmZpZy5zYXZlUG5nRnVuY3Rpb24scmVhbEFjdGlvbikpIHtcblx0XHQvLyBjYWxsIHNhdmVQbmcgZnVuY3Rpb247XG5cdFx0c2F2ZUNhbnZhcyhjdHgsIGRhdGEsIGNvbmZpZyk7XG5cdH1cblx0XG5cdHZhciB3aG9Ub1JlZmVyQW5ub3RhdGU9LTE7XG5cdHZhciB3aG9Ub1JlZmVySGlnaExpZ2h0PS0xO1xuXHR2YXIgcmVmZXJBbm5vdGF0ZUlzUG9pbnQ9ZmFsc2U7XG5cdHZhciByZWZlckhpZ2hMaWdodElzUG9pbnQ9ZmFsc2U7XG5cdGZvcihpPXBpZWNlT2ZDaGFydEZvdW5kLmxlbmd0aC0xO2k+PTA7aS0tKSB7XG5cdFx0aWYgKGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcGllY2VPZkNoYXJ0Rm91bmRbaV0ucGllY2VdWzRdKSB7XG5cdFx0XHRpZihyZWZlckFubm90YXRlSXNQb2ludD09ZmFsc2UpIHtcblx0XHRcdFx0aWYod2hvVG9SZWZlckFubm90YXRlPT0tMSl3aG9Ub1JlZmVyQW5ub3RhdGU9aTtcblx0XHRcdFx0aWYoanNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtwaWVjZU9mQ2hhcnRGb3VuZFtpXS5waWVjZV1bMF0gPT0gXCJQT0lOVFwiKSB7XG5cdFx0XHRcdFx0d2hvVG9SZWZlckFubm90YXRlPWk7XG5cdFx0XHRcdFx0cmVmZXJBbm5vdGF0ZUlzUG9pbnQ9dHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihyZWZlckhpZ2hMaWdodElzUG9pbnQ9PWZhbHNlKSB7XG5cdFx0XHRpZih3aG9Ub1JlZmVySGlnaExpZ2h0PT0tMSl3aG9Ub1JlZmVySGlnaExpZ2h0PWk7XG5cdFx0XHRpZihqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW3BpZWNlT2ZDaGFydEZvdW5kW2ldLnBpZWNlXVswXSA9PSBcIlBPSU5UXCIpIHtcblx0XHRcdFx0d2hvVG9SZWZlckhpZ2hMaWdodD1pO1xuXHRcdFx0XHRyZWZlckhpZ2hMaWdodElzUG9pbnQ9dHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdH1cblx0XG5cdGlmKGNvbmZpZy5hbm5vdGF0ZURpc3BsYXkgJiYgaXNBY3Rpb24oY29uZmlnLmFubm90YXRlRnVuY3Rpb24scmVhbEFjdGlvbikpIHtcblx0XHQvLyBhbm5vdGF0ZSBkaXNwbGF5IGZ1bmN0aW9uYWxpdHk7XG5cdFx0YW5ub3RhdGVESVYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGl2Q3Vyc29yJyk7XG5cdFx0YW5ub3RhdGVESVYuc3R5bGUuZGlzcGxheSA9IGZhbHNlID8gJycgOiAnbm9uZSc7XG5cdFx0aWYocGllY2VPZkNoYXJ0Rm91bmQubGVuZ3RoPjApIHtcblx0XHRcdGFubm90YXRlRElWLmNsYXNzTmFtZSA9IChjb25maWcuYW5ub3RhdGVDbGFzc05hbWUpID8gY29uZmlnLmFubm90YXRlQ2xhc3NOYW1lIDogJyc7XG5cdFx0XHRhbm5vdGF0ZURJVi5zdHlsZS5ib3JkZXIgPSAoY29uZmlnLmFubm90YXRlQ2xhc3NOYW1lKSA/ICcnIDogY29uZmlnLmFubm90YXRlQm9yZGVyO1xuXHRcdFx0YW5ub3RhdGVESVYuc3R5bGUucGFkZGluZyA9IChjb25maWcuYW5ub3RhdGVDbGFzc05hbWUpID8gJycgOiBjb25maWcuYW5ub3RhdGVQYWRkaW5nO1xuXHRcdFx0YW5ub3RhdGVESVYuc3R5bGUuYm9yZGVyUmFkaXVzID0gKGNvbmZpZy5hbm5vdGF0ZUNsYXNzTmFtZSkgPyAnJyA6IGNvbmZpZy5hbm5vdGF0ZUJvcmRlclJhZGl1cztcblx0XHRcdGFubm90YXRlRElWLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IChjb25maWcuYW5ub3RhdGVDbGFzc05hbWUpID8gJycgOiBjb25maWcuYW5ub3RhdGVCYWNrZ3JvdW5kQ29sb3I7XG5cdFx0XHRhbm5vdGF0ZURJVi5zdHlsZS5jb2xvciA9IChjb25maWcuYW5ub3RhdGVDbGFzc05hbWUpID8gJycgOiBjb25maWcuYW5ub3RhdGVGb250Q29sb3I7XG5cdFx0XHRhbm5vdGF0ZURJVi5zdHlsZS5mb250RmFtaWx5ID0gKGNvbmZpZy5hbm5vdGF0ZUNsYXNzTmFtZSkgPyAnJyA6IGNvbmZpZy5hbm5vdGF0ZUZvbnRGYW1pbHk7XG5cdFx0XHRhbm5vdGF0ZURJVi5zdHlsZS5mb250U2l6ZSA9IChjb25maWcuYW5ub3RhdGVDbGFzc05hbWUpID8gJycgOiAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuYW5ub3RhdGVGb250U2l6ZSkpLnRvU3RyaW5nKCkgKyBcInB0XCI7XG5cdFx0XHRhbm5vdGF0ZURJVi5zdHlsZS5mb250U3R5bGUgPSAoY29uZmlnLmFubm90YXRlQ2xhc3NOYW1lKSA/ICcnIDogY29uZmlnLmFubm90YXRlRm9udFN0eWxlO1xuXHRcdFx0YW5ub3RhdGVESVYuc3R5bGUuekluZGV4ID0gOTk5O1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5mb250PSBhbm5vdGF0ZURJVi5zdHlsZS5mb250U3R5bGUrXCIgXCIrIGFubm90YXRlRElWLnN0eWxlLmZvbnRTaXplK1wiIFwiK2Fubm90YXRlRElWLnN0eWxlLmZvbnRGYW1pbHk7XG5cdFx0XHR2YXIgcmVjdCA9IGN0eC5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRzaG93RGl2PWZhbHNlO1xuXHRcdFx0aWYod2hvVG9SZWZlckFubm90YXRlIT0tMSkge1xuXHRcdFx0XHRpZiAoanNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtwaWVjZU9mQ2hhcnRGb3VuZFt3aG9Ub1JlZmVyQW5ub3RhdGVdLnBpZWNlXVs0XSkge1xuXHRcdFx0XHRcdGlmIChqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW3BpZWNlT2ZDaGFydEZvdW5kW3dob1RvUmVmZXJBbm5vdGF0ZV0ucGllY2VdWzBdID09IFwiQVJDXCIpIGRpc3BTdHJpbmcgPSB0bXBsYmlzKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkFOTk9UQVRFTEFCRUxcIixjdHgsZGF0YSxqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW3BpZWNlT2ZDaGFydEZvdW5kW3dob1RvUmVmZXJBbm5vdGF0ZV0ucGllY2VdWzNdLHVuZGVmaW5lZCxjb25maWcuYW5ub3RhdGVMYWJlbCxcImFubm90YXRlTGFiZWxcIixqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW3BpZWNlT2ZDaGFydEZvdW5kW3dob1RvUmVmZXJBbm5vdGF0ZV0ucGllY2VdWzFdLC0xLHtvdGhlclZhbDp0cnVlfSksIHBpZWNlT2ZDaGFydEZvdW5kW3dob1RvUmVmZXJBbm5vdGF0ZV0ubXlTdGF0RGF0YSxjb25maWcpO1xuXHRcdFx0XHRcdGVsc2UgZGlzcFN0cmluZyA9IHRtcGxiaXMoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiQU5OT1RBVEVMQUJFTFwiLGN0eCxkYXRhLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcGllY2VPZkNoYXJ0Rm91bmRbd2hvVG9SZWZlckFubm90YXRlXS5waWVjZV1bM10sdW5kZWZpbmVkLGNvbmZpZy5hbm5vdGF0ZUxhYmVsLFwiYW5ub3RhdGVMYWJlbFwiLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcGllY2VPZkNoYXJ0Rm91bmRbd2hvVG9SZWZlckFubm90YXRlXS5waWVjZV1bMV0sanNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtwaWVjZU9mQ2hhcnRGb3VuZFt3aG9Ub1JlZmVyQW5ub3RhdGVdLnBpZWNlXVsyXSx7b3RoZXJWYWw6dHJ1ZX0pLCBwaWVjZU9mQ2hhcnRGb3VuZFt3aG9Ub1JlZmVyQW5ub3RhdGVdLm15U3RhdERhdGEsY29uZmlnKTtcblx0XHRcdFx0XHR0ZXh0TXNyPWN0eC5tZWFzdXJlVGV4dE11bHRpTGluZShkaXNwU3RyaW5nLDEqYW5ub3RhdGVESVYuc3R5bGUuZm9udFNpemUucmVwbGFjZShcInB0XCIsXCJcIikpO1xuXHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdFx0YW5ub3RhdGVESVYuaW5uZXJIVE1MID0gZGlzcFN0cmluZztcblx0XHRcdFx0XHR4ID0gYncubnM0IHx8IGJ3Lm5zNSA/IGV2ZW50LnBhZ2VYIDogZXZlbnQueDtcblx0XHRcdFx0XHR5ID0gYncubnM0IHx8IGJ3Lm5zNSA/IGV2ZW50LnBhZ2VZIDogZXZlbnQueTtcblx0XHRcdFx0XHRpZiAoYncuaWU0IHx8IGJ3LmllNSkgeSA9IHkgKyBldmFsKHNjcm9sbGVkKTtcblx0XHRcdFx0XHRpZihjb25maWcuYW5ub3RhdGVSZWxvY2F0ZT09PXRydWUpIHtcblx0XHRcdFx0XHRcdHZhciByZWxvY2F0ZVgsIHJlbG9jYXRlWTtcblx0XHRcdFx0XHRcdHJlbG9jYXRlWD0wO3JlbG9jYXRlWT0wO1xuXHRcdFx0XHQgXHRcdGlmKHgrZnJvbUxlZnQrdGV4dE1zci50ZXh0V2lkdGggPiB3aW5kb3cuaW5uZXJXaWR0aC1yZWN0LmxlZnQtZnJvbUxlZnQpcmVsb2NhdGVYPS10ZXh0TXNyLnRleHRXaWR0aDtcblx0XHQgXHRcdFx0XHRpZih5K2Zyb21Ub3ArdGV4dE1zci50ZXh0SGVpZ2h0ID4gMSp3aW5kb3cuaW5uZXJIZWlnaHQtMSpyZWN0LnRvcCtmcm9tVG9wKXJlbG9jYXRlWS09KHRleHRNc3IudGV4dEhlaWdodCsyKmZyb21Ub3ApO1xuXHRcdFx0XHRcdFx0b0N1cnNvci5tb3ZlSXQoTWF0aC5tYXgoOC1yZWN0LmxlZnQseCArIGZyb21MZWZ0K3JlbG9jYXRlWCksIE1hdGgubWF4KDgtcmVjdC50b3AseSArIGZyb21Ub3AgKyByZWxvY2F0ZVkpKTtcblx0XHRcdFx0XHR9IGVsc2Ugb0N1cnNvci5tb3ZlSXQoeCArIGZyb21MZWZ0LCB5ICsgZnJvbVRvcCk7XG5cdFx0XHRcdFx0YW5ub3RhdGVESVYuc3R5bGUuZGlzcGxheSA9IHRydWUgPyAnJyA6ICdub25lJzsgXG5cdFx0XHRcdFx0c2hvd0Rpdj10cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVx0XHRcblx0XHRcblxuXHR9XG5cblx0aWYoaW5Nb3VzZUFjdGlvbltjdHguQ2hhcnROZXdJZF09PWZhbHNlICYmIG1vdXNlQWN0aW9uRGF0YVtjdHguQ2hhcnROZXdJZF0ucHJldlNob3c+PTAgJiYgaXNBY3Rpb24oXCJtb3VzZW1vdmVcIixyZWFsQWN0aW9uKSAmJiAocGllY2VPZkNoYXJ0Rm91bmQubGVuZ3RoPT0wIHx8IG1vdXNlQWN0aW9uRGF0YVtjdHguQ2hhcnROZXdJZF0ucHJldlNob3chPXBpZWNlT2ZDaGFydEZvdW5kW3BpZWNlT2ZDaGFydEZvdW5kLmxlbmd0aC0xXS5waWVjZSkpIHtcbiAgICAgICAgICAgICAgICBpbk1vdXNlQWN0aW9uW2N0eC5DaGFydE5ld0lkXT10cnVlO1xuXHRcdHByZXZTaG93PW1vdXNlQWN0aW9uRGF0YVtjdHguQ2hhcnROZXdJZF0ucHJldlNob3c7XG5cdFx0bW91c2VBY3Rpb25EYXRhW2N0eC5DaGFydE5ld0lkXS5wcmV2U2hvdz0tMTtcblxuXHQgICAgICAgXHRpZihjb25maWcuaGlnaExpZ2h0ICYmIGlzQWN0aW9uKGNvbmZpZy5oaWdoTGlnaHRNb3VzZUZ1bmN0aW9uLHJlYWxBY3Rpb24pICYmIHBpZWNlT2ZDaGFydEZvdW5kLmxlbmd0aD09MCkge1xuXHRcdFx0aGlnaExpZ2h0QWN0aW9uKFwiSElERVwiLGN0eCxkYXRhLGNvbmZpZyxudWxsLG51bGwpO1xuXHRcdH1cdFxuICAgICAgICAgICAgICAgIFx0XG5cdFx0aWYodHlwZW9mIGNvbmZpZy5hbm5vdGF0ZUZ1bmN0aW9uT3V0PT1cImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmKGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcHJldlNob3ddWzBdID09IFwiQVJDXCIpY29uZmlnLmFubm90YXRlRnVuY3Rpb25PdXQoXCJPVVRBTk5PVEFURVwiLGN0eCxkYXRhLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcHJldlNob3ddWzNdLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcHJldlNob3ddWzFdLC0xLG51bGwpO1xuXHRcdFx0ZWxzZSAgY29uZmlnLmFubm90YXRlRnVuY3Rpb25PdXQoXCJPVVRBTk5PVEFURVwiLGN0eCxkYXRhLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcHJldlNob3ddWzNdLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcHJldlNob3ddWzFdLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcHJldlNob3ddWzJdLG51bGwpO1xuXHRcdH1cblx0XHRpbk1vdXNlQWN0aW9uW2N0eC5DaGFydE5ld0lkXT1mYWxzZTtcblx0fVxuXHRcblxuXHRpZihwaWVjZU9mQ2hhcnRGb3VuZC5sZW5ndGg+MCAmJiBpbk1vdXNlQWN0aW9uW2N0eC5DaGFydE5ld0lkXT09ZmFsc2UgJiYgbW91c2VBY3Rpb25EYXRhW2N0eC5DaGFydE5ld0lkXS5wcmV2U2hvdyE9cGllY2VPZkNoYXJ0Rm91bmRbd2hvVG9SZWZlckhpZ2hMaWdodF0ucGllY2UgJiYgaXNBY3Rpb24oXCJtb3VzZW1vdmVcIixyZWFsQWN0aW9uKSkge1xuXHRcdGluTW91c2VBY3Rpb25bY3R4LkNoYXJ0TmV3SWRdPXRydWU7XG5cdFx0cHJldlNob3c9bW91c2VBY3Rpb25EYXRhW2N0eC5DaGFydE5ld0lkXS5wcmV2U2hvdztcblx0ICAgICAgIFx0aWYoY29uZmlnLmhpZ2hMaWdodCAmJiBpc0FjdGlvbihjb25maWcuaGlnaExpZ2h0TW91c2VGdW5jdGlvbixyZWFsQWN0aW9uKSkge1xuXHRcdFx0aWYod2hvVG9SZWZlckhpZ2hMaWdodCE9LTEpIHtcblx0XHRcdFx0aWYoanNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtwaWVjZU9mQ2hhcnRGb3VuZFt3aG9Ub1JlZmVySGlnaExpZ2h0XS5waWVjZV1bMF0gPT0gXCJBUkNcIikgaGlnaExpZ2h0QWN0aW9uKFwiQVJDXCIsY3R4LGRhdGEsY29uZmlnLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcGllY2VPZkNoYXJ0Rm91bmRbd2hvVG9SZWZlckhpZ2hMaWdodF0ucGllY2VdWzFdLC0xKTtcblx0XHRcdFx0ZWxzZSBoaWdoTGlnaHRBY3Rpb24oanNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtwaWVjZU9mQ2hhcnRGb3VuZFt3aG9Ub1JlZmVySGlnaExpZ2h0XS5waWVjZV1bMF0sY3R4LGRhdGEsY29uZmlnLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcGllY2VPZkNoYXJ0Rm91bmRbd2hvVG9SZWZlckhpZ2hMaWdodF0ucGllY2VdWzFdLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcGllY2VPZkNoYXJ0Rm91bmRbd2hvVG9SZWZlckhpZ2hMaWdodF0ucGllY2VdWzJdKTtcblx0XHRcdH1cblx0XHR9XHRcblxuXHRcdGlmKHR5cGVvZiBjb25maWcuYW5ub3RhdGVGdW5jdGlvbkluPT1cImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmKGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcGllY2VPZkNoYXJ0Rm91bmRbcGllY2VPZkNoYXJ0Rm91bmQubGVuZ3RoLTFdLnBpZWNlXVswXSA9PSBcIkFSQ1wiKWNvbmZpZy5hbm5vdGF0ZUZ1bmN0aW9uSW4oXCJJTkFOTk9UQVRFXCIsY3R4LGRhdGEsanNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtwaWVjZU9mQ2hhcnRGb3VuZFtwaWVjZU9mQ2hhcnRGb3VuZC5sZW5ndGgtMV0ucGllY2VdWzNdLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcGllY2VPZkNoYXJ0Rm91bmRbcGllY2VPZkNoYXJ0Rm91bmQubGVuZ3RoLTFdLnBpZWNlXVsxXSwtMSxudWxsKTtcblx0XHRcdGVsc2UgIGNvbmZpZy5hbm5vdGF0ZUZ1bmN0aW9uSW4oXCJJTkFOTk9UQVRFXCIsY3R4LGRhdGEsanNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtwaWVjZU9mQ2hhcnRGb3VuZFtwaWVjZU9mQ2hhcnRGb3VuZC5sZW5ndGgtMV0ucGllY2VdWzNdLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcGllY2VPZkNoYXJ0Rm91bmRbcGllY2VPZkNoYXJ0Rm91bmQubGVuZ3RoLTFdLnBpZWNlXVsxXSxqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW3BpZWNlT2ZDaGFydEZvdW5kW3BpZWNlT2ZDaGFydEZvdW5kLmxlbmd0aC0xXS5waWVjZV1bMl0sbnVsbCk7XG5cdFx0fVxuXHRcdGluTW91c2VBY3Rpb25bY3R4LkNoYXJ0TmV3SWRdPWZhbHNlO1xuXHRcdG1vdXNlQWN0aW9uRGF0YVtjdHguQ2hhcnROZXdJZF0ucHJldlNob3c9cGllY2VPZkNoYXJ0Rm91bmRbd2hvVG9SZWZlckhpZ2hMaWdodF0ucGllY2U7XG5cdH1cblxuICAgICAgIFx0aWYgKGNvbmZpZy5oaWdoTGlnaHQgJiYgaXNBY3Rpb24oY29uZmlnLmhpZ2hMaWdodE1vdXNlRnVuY3Rpb24scmVhbEFjdGlvbikgJiYgaXNBY3Rpb24oXCJtb3VzZW1vdmVcIixyZWFsQWN0aW9uKT09ZmFsc2UpIHtcblx0XHRpZihwaWVjZU9mQ2hhcnRGb3VuZC5sZW5ndGg9PTApaGlnaExpZ2h0QWN0aW9uKFwiSElERVwiLGN0eCxkYXRhLGNvbmZpZyxudWxsLG51bGwpO1xuXHRcdGVsc2Uge1xuXHRcdFx0aWYod2hvVG9SZWZlckhpZ2hMaWdodCE9LTEpIHtcblx0XHRcdFx0aWYoanNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtwaWVjZU9mQ2hhcnRGb3VuZFt3aG9Ub1JlZmVySGlnaExpZ2h0XS5waWVjZV1bMF0gPT0gXCJBUkNcIikgaGlnaExpZ2h0QWN0aW9uKFwiQVJDXCIsY3R4LGRhdGEsY29uZmlnLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcGllY2VPZkNoYXJ0Rm91bmRbd2hvVG9SZWZlckhpZ2hMaWdodF0ucGllY2VdWzFdLC0xKTtcblx0XHRcdFx0ZWxzZSBoaWdoTGlnaHRBY3Rpb24oanNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtwaWVjZU9mQ2hhcnRGb3VuZFt3aG9Ub1JlZmVySGlnaExpZ2h0XS5waWVjZV1bMF0sY3R4LGRhdGEsY29uZmlnLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcGllY2VPZkNoYXJ0Rm91bmRbd2hvVG9SZWZlckhpZ2hMaWdodF0ucGllY2VdWzFdLGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1bcGllY2VPZkNoYXJ0Rm91bmRbd2hvVG9SZWZlckhpZ2hMaWdodF0ucGllY2VdWzJdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHJ1bkZ1bmN0aW9uKHRvQmVSdW4pe1xuXHRcdHZhciBpO1xuXHRcdGZvcihpPTA7aTxwaWVjZU9mQ2hhcnRGb3VuZC5sZW5ndGg7aSsrKSB7XG5cdFx0XHR0b0JlUnVuKGV2ZW50LCBjdHgsIGNvbmZpZywgZGF0YSwgcGllY2VPZkNoYXJ0Rm91bmRbaV0ubXlTdGF0RGF0YSk7XG5cdFx0fVxuXHRcdGZvcihpPTA7aTx0ZXh0T25DaGFydEZvdW5kLmxlbmd0aDtpKyspIHtcblx0XHRcdHRvQmVSdW4oZXZlbnQsIGN0eCwgY29uZmlnLCBkYXRhLCB7dHlwZTpcIkNMSUNLT05URVhUXCIsdmFsdWVzOmpzVGV4dE1vdXNlUG9zW2N0eC5DaGFydE5ld0lkXVt0ZXh0T25DaGFydEZvdW5kW2ldXX0pO1xuXHRcdH1cblx0XHRpZihwaWVjZU9mQ2hhcnRGb3VuZC5sZW5ndGg9PTAgJiYgdGV4dE9uQ2hhcnRGb3VuZC5sZW5ndGg9PTApIHtcblx0XHRcdHRvQmVSdW4oZXZlbnQsIGN0eCwgY29uZmlnLCBkYXRhLCBudWxsKTtcblx0XHR9XG5cdH07XG5cblx0aWYodHlwZW9mIGNvbmZpZy5tb3VzZU1vdmU9PVwiZnVuY3Rpb25cIiAmJiBpc0FjdGlvbihcIm1vdXNlbW92ZVwiLHJlYWxBY3Rpb24pKSBydW5GdW5jdGlvbihjb25maWcubW91c2VNb3ZlKTtcblx0aWYodHlwZW9mIGNvbmZpZy5tb3VzZURvd25MZWZ0PT1cImZ1bmN0aW9uXCIgJiYgaXNBY3Rpb24oXCJtb3VzZWRvd24gbGVmdFwiLHJlYWxBY3Rpb24pKXJ1bkZ1bmN0aW9uKGNvbmZpZy5tb3VzZURvd25MZWZ0KTtcblx0aWYodHlwZW9mIGNvbmZpZy5tb3VzZURvd25SaWdodD09XCJmdW5jdGlvblwiICYmIGlzQWN0aW9uKFwibW91c2Vkb3duIHJpZ2h0XCIscmVhbEFjdGlvbikpIHJ1bkZ1bmN0aW9uKGNvbmZpZy5tb3VzZURvd25SaWdodCk7XG5cdGlmKHR5cGVvZiBjb25maWcubW91c2VEb3duTWlkZGxlPT1cImZ1bmN0aW9uXCIgJiYgaXNBY3Rpb24oXCJtb3VzZWRvd24gbWlkZGxlXCIscmVhbEFjdGlvbikpIHJ1bkZ1bmN0aW9uKGNvbmZpZy5tb3VzZURvd25NaWRkbGUpO1xuXHRpZih0eXBlb2YgY29uZmlnLm1vdXNlV2hlZWw9PVwiZnVuY3Rpb25cIiAmJiBpc0FjdGlvbihcIm1vdXNld2hlZWxcIixyZWFsQWN0aW9uKSkgcnVuRnVuY3Rpb24oY29uZmlnLm1vdXNlV2hlZWwpO1xuXHRpZih0eXBlb2YgY29uZmlnLm1vdXNlT3V0PT1cImZ1bmN0aW9uXCIgJiYgaXNBY3Rpb24oXCJtb3VzZW91dFwiLHJlYWxBY3Rpb24pKSBydW5GdW5jdGlvbihjb25maWcubW91c2VPdXQpO1xuXHRpZih0eXBlb2YgY29uZmlnLm1vdXNlRGJsQ2xpY2s9PVwiZnVuY3Rpb25cIiAmJiBpc0FjdGlvbihcImRibGNsaWNrXCIscmVhbEFjdGlvbikpIHJ1bkZ1bmN0aW9uKGNvbmZpZy5tb3VzZURibENsaWNrKTtcbn07XG4gICAgICAgICAgICAgICAgICAgICAgICAgXG4vLy8vLy8vLy8gR1JBUEhJQ0FMIFBBUlQgT0YgVEhFIFNDUklQVCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL0RlZmluZSB0aGUgZ2xvYmFsIENoYXJ0IFZhcmlhYmxlIGFzIGEgY2xhc3MuXG53aW5kb3cuQ2hhcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdHZhciBjaGFydCA9IHRoaXM7XG5cdC8vRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gUm9iZXJ0IFBlbm5lcidzIGVhc2luZyBlcXVhdGlvbnNcblx0Ly9odHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nL1xuXHR2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHtcblx0XHRsaW5lYXI6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiB0O1xuXHRcdH0sXG5cdFx0ZWFzZUluUXVhZDogZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIHQgKiB0O1xuXHRcdH0sXG5cdFx0ZWFzZU91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAtMSAqIHQgKiAodCAtIDIpO1xuXHRcdH0sXG5cdFx0ZWFzZUluT3V0UXVhZDogZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKCh0IC89IDEgLyAyKSA8IDEpIHJldHVybiAxIC8gMiAqIHQgKiB0O1xuXHRcdFx0cmV0dXJuIC0xIC8gMiAqICgoLS10KSAqICh0IC0gMikgLSAxKTtcblx0XHR9LFxuXHRcdGVhc2VJbkN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gdCAqIHQgKiB0O1xuXHRcdH0sXG5cdFx0ZWFzZU91dEN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gMSAqICgodCA9IHQgLyAxIC0gMSkgKiB0ICogdCArIDEpO1xuXHRcdH0sXG5cdFx0ZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICgodCAvPSAxIC8gMikgPCAxKSByZXR1cm4gMSAvIDIgKiB0ICogdCAqIHQ7XG5cdFx0XHRyZXR1cm4gMSAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpO1xuXHRcdH0sXG5cdFx0ZWFzZUluUXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiB0ICogdCAqIHQgKiB0O1xuXHRcdH0sXG5cdFx0ZWFzZU91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gLTEgKiAoKHQgPSB0IC8gMSAtIDEpICogdCAqIHQgKiB0IC0gMSk7XG5cdFx0fSxcblx0XHRlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKCh0IC89IDEgLyAyKSA8IDEpIHJldHVybiAxIC8gMiAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0XHRyZXR1cm4gLTEgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMik7XG5cdFx0fSxcblx0XHRlYXNlSW5RdWludDogZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIDEgKiAodCAvPSAxKSAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0fSxcblx0XHRlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAxICogKCh0ID0gdCAvIDEgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxKTtcblx0XHR9LFxuXHRcdGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAoKHQgLz0gMSAvIDIpIDwgMSkgcmV0dXJuIDEgLyAyICogdCAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0XHRyZXR1cm4gMSAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMik7XG5cdFx0fSxcblx0XHRlYXNlSW5TaW5lOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gLTEgKiBNYXRoLmNvcyh0IC8gMSAqIChNYXRoLlBJIC8gMikpICsgMTtcblx0XHR9LFxuXHRcdGVhc2VPdXRTaW5lOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gMSAqIE1hdGguc2luKHQgLyAxICogKE1hdGguUEkgLyAyKSk7XG5cdFx0fSxcblx0XHRlYXNlSW5PdXRTaW5lOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gLTEgLyAyICogKE1hdGguY29zKE1hdGguUEkgKiB0IC8gMSkgLSAxKTtcblx0XHR9LFxuXHRcdGVhc2VJbkV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAodCA9PSAwKSA/IDEgOiAxICogTWF0aC5wb3coMiwgMTAgKiAodCAvIDEgLSAxKSk7XG5cdFx0fSxcblx0XHRlYXNlT3V0RXhwbzogZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuICh0ID09IDEpID8gMSA6IDEgKiAoLU1hdGgucG93KDIsIC0xMCAqIHQgLyAxKSArIDEpO1xuXHRcdH0sXG5cdFx0ZWFzZUluT3V0RXhwbzogZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKHQgPT0gMCkgcmV0dXJuIDA7XG5cdFx0XHRpZiAodCA9PSAxKSByZXR1cm4gMTtcblx0XHRcdGlmICgodCAvPSAxIC8gMikgPCAxKSByZXR1cm4gMSAvIDIgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuXHRcdFx0cmV0dXJuIDEgLyAyICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMik7XG5cdFx0fSxcblx0XHRlYXNlSW5DaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAodCA+PSAxKSByZXR1cm4gdDtcblx0XHRcdHJldHVybiAtMSAqIChNYXRoLnNxcnQoMSAtICh0IC89IDEpICogdCkgLSAxKTtcblx0XHR9LFxuXHRcdGVhc2VPdXRDaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gMSAqIE1hdGguc3FydCgxIC0gKHQgPSB0IC8gMSAtIDEpICogdCk7XG5cdFx0fSxcblx0XHRlYXNlSW5PdXRDaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAoKHQgLz0gMSAvIDIpIDwgMSkgcmV0dXJuIC0xIC8gMiAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuXHRcdFx0cmV0dXJuIDEgLyAyICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpO1xuXHRcdH0sXG5cdFx0ZWFzZUluRWxhc3RpYzogZnVuY3Rpb24odCkge1xuXHRcdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdFx0dmFyIHAgPSAwO1xuXHRcdFx0dmFyIGEgPSAxO1xuXHRcdFx0aWYgKHQgPT0gMCkgcmV0dXJuIDA7XG5cdFx0XHRpZiAoKHQgLz0gMSkgPT0gMSkgcmV0dXJuIDE7XG5cdFx0XHRpZiAoIXApIHAgPSAxICogLjM7XG5cdFx0XHRpZiAoYSA8IE1hdGguYWJzKDEpKSB7XG5cdFx0XHRcdGEgPSAxO1xuXHRcdFx0XHRzID0gcCAvIDQ7XG5cdFx0XHR9IGVsc2UgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEgLyBhKTtcblx0XHRcdHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0ICogMSAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcblx0XHR9LFxuXHRcdGVhc2VPdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0XHR2YXIgcCA9IDA7XG5cdFx0XHR2YXIgYSA9IDE7XG5cdFx0XHRpZiAodCA9PSAwKSByZXR1cm4gMDtcblx0XHRcdGlmICgodCAvPSAxKSA9PSAxKSByZXR1cm4gMTtcblx0XHRcdGlmICghcCkgcCA9IDEgKiAuMztcblx0XHRcdGlmIChhIDwgTWF0aC5hYnMoMSkpIHtcblx0XHRcdFx0YSA9IDE7XG5cdFx0XHRcdHMgPSBwIC8gNDtcblx0XHRcdH0gZWxzZSBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdFx0cmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0ICogMSAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMTtcblx0XHR9LFxuXHRcdGVhc2VJbk91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRcdHZhciBwID0gMDtcblx0XHRcdHZhciBhID0gMTtcblx0XHRcdGlmICh0ID09IDApIHJldHVybiAwO1xuXHRcdFx0aWYgKCh0IC89IDEgLyAyKSA9PSAyKSByZXR1cm4gMTtcblx0XHRcdGlmICghcCkgcCA9IDEgKiAoLjMgKiAxLjUpO1xuXHRcdFx0aWYgKGEgPCBNYXRoLmFicygxKSkge1xuXHRcdFx0XHRhID0gMTtcblx0XHRcdFx0cyA9IHAgLyA0O1xuXHRcdFx0fSBlbHNlIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG5cdFx0XHRpZiAodCA8IDEpIHJldHVybiAtLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgKiAxIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHRcdFx0cmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAqIDEgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIC41ICsgMTtcblx0XHR9LFxuXHRcdGVhc2VJbkJhY2s6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRcdHJldHVybiAxICogKHQgLz0gMSkgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG5cdFx0fSxcblx0XHRlYXNlT3V0QmFjazogZnVuY3Rpb24odCkge1xuXHRcdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdFx0cmV0dXJuIDEgKiAoKHQgPSB0IC8gMSAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMSk7XG5cdFx0fSxcblx0XHRlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0XHRpZiAoKHQgLz0gMSAvIDIpIDwgMSkgcmV0dXJuIDEgLyAyICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKTtcblx0XHRcdHJldHVybiAxIC8gMiAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKTtcblx0XHR9LFxuXHRcdGVhc2VJbkJvdW5jZTogZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIDEgLSBhbmltYXRpb25PcHRpb25zLmVhc2VPdXRCb3VuY2UoMSAtIHQpO1xuXHRcdH0sXG5cdFx0ZWFzZU91dEJvdW5jZTogZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKCh0IC89IDEpIDwgKDEgLyAyLjc1KSkge1xuXHRcdFx0XHRyZXR1cm4gMSAqICg3LjU2MjUgKiB0ICogdCk7XG5cdFx0XHR9IGVsc2UgaWYgKHQgPCAoMiAvIDIuNzUpKSB7XG5cdFx0XHRcdHJldHVybiAxICogKDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgLjc1KTtcblx0XHRcdH0gZWxzZSBpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xuXHRcdFx0XHRyZXR1cm4gMSAqICg3LjU2MjUgKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAuOTM3NSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gMSAqICg3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgLjk4NDM3NSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlYXNlSW5PdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICh0IDwgMSAvIDIpIHJldHVybiBhbmltYXRpb25PcHRpb25zLmVhc2VJbkJvdW5jZSh0ICogMikgKiAuNTtcblx0XHRcdHJldHVybiBhbmltYXRpb25PcHRpb25zLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIC41ICsgMSAqIC41O1xuXHRcdH1cblx0fTtcblx0Ly9WYXJpYWJsZXMgZ2xvYmFsIHRvIHRoZSBjaGFydFxuXHRcblx0dmFyIHdpZHRoID0gY29udGV4dC5jYW52YXMud2lkdGg7XG5cdHZhciBoZWlnaHQgPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQ7XG4gICAgXG5cdHRoaXMuUG9sYXJBcmVhID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuXHRcdGNoYXJ0LlBvbGFyQXJlYS5kZWZhdWx0cyA9IHtcblx0XHRcdGhpZ2hMaWdodFNldCA6IHsgY29sb3IgOiBcInJlZFwiIH0sXG5cdFx0XHRpbkdyYXBoRGF0YVNob3c6IGZhbHNlLFxuXHRcdFx0aW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzOiA1LFxuXHRcdFx0aW5HcmFwaERhdGFQYWRkaW5nQW5nbGU6IDAsXG5cdFx0XHRpbkdyYXBoRGF0YVRtcGw6IFwiPCU9KHYxID09ICcnPyAnJyA6IHYxKyc6JykrIHYyICsgJyAoJyArIHY2ICsgJyAlKSclPlwiLFxuXHRcdFx0aW5HcmFwaERhdGFBbGlnbjogXCJvZmYtY2VudGVyXCIsIC8vIFwicmlnaHRcIiwgXCJjZW50ZXJcIiwgXCJsZWZ0XCIsIFwib2ZmLWNlbnRlclwiIG9yIFwidG8tY2VudGVyXCJcblx0XHRcdGluR3JhcGhEYXRhVkFsaWduOiBcIm9mZi1jZW50ZXJcIiwgLy8gXCJib3R0b21cIiwgXCJjZW50ZXJcIiwgXCJ0b3BcIiwgXCJvZmYtY2VudGVyXCIgb3IgXCJ0by1jZW50ZXJcIlxuXHRcdFx0aW5HcmFwaERhdGFSb3RhdGU6IDAsIC8vIHJvdGF0ZUFuZ2xlIHZhbHVlICgwLT4zNjApICwgXCJpblJhZGl1c0F4aXNcIiBvciBcImluUmFkaXVzQXhpc1JvdGF0ZUxhYmVsc1wiXG5cdFx0XHRpbkdyYXBoRGF0YUZvbnRGYW1pbHk6IFwiJ0FyaWFsJ1wiLFxuXHRcdFx0aW5HcmFwaERhdGFGb250U2l6ZTogMTIsXG5cdFx0XHRpbkdyYXBoRGF0YUZvbnRTdHlsZTogXCJub3JtYWxcIixcblx0XHRcdGluR3JhcGhEYXRhRm9udENvbG9yOiBcIiM2NjZcIixcblx0XHRcdGluR3JhcGhEYXRhUmFkaXVzUG9zaXRpb246IDMsXG5cdFx0XHRpbkdyYXBoRGF0YUFuZ2xlUG9zaXRpb246IDIsXG5cdFx0XHRzY2FsZU92ZXJsYXk6IHRydWUsXG5cdFx0XHRzY2FsZU92ZXJyaWRlOiBmYWxzZSxcblx0XHRcdHNjYWxlT3ZlcnJpZGUyOiBmYWxzZSxcblx0XHRcdHNjYWxlR3JpZExpbmVzU3RlcCA6IDEsXG5cdFx0XHRzY2FsZVN0ZXBzOiBudWxsLFxuXHRcdFx0c2NhbGVTdGVwV2lkdGg6IG51bGwsXG5cdFx0XHRzY2FsZVN0YXJ0VmFsdWU6IG51bGwsXG5cdFx0XHRzY2FsZVNob3dMaW5lOiB0cnVlLFxuXHRcdFx0c2NhbGVMaW5lQ29sb3I6IFwicmdiYSgwLDAsMCwuMSlcIixcblx0XHRcdHNjYWxlTGluZVdpZHRoOiAxLFxuXHRcdFx0c2NhbGVMaW5lU3R5bGU6IFwic29saWRcIixcblx0XHRcdHNjYWxlU2hvd0xhYmVsczogdHJ1ZSxcblx0XHRcdHNjYWxlU2hvd0xhYmVsczI6IHRydWUsXG5cdFx0XHRzY2FsZUxhYmVsOiBcIjwlPXZhbHVlJT5cIixcblx0XHRcdHNjYWxlRm9udEZhbWlseTogXCInQXJpYWwnXCIsXG5cdFx0XHRzY2FsZUZvbnRTaXplOiAxMixcblx0XHRcdHNjYWxlRm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuXHRcdFx0c2NhbGVGb250Q29sb3I6IFwiIzY2NlwiLFxuXHRcdFx0c2NhbGVTaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcblx0XHRcdHNjYWxlQmFja2Ryb3BDb2xvcjogXCJyZ2JhKDI1NSwyNTUsMjU1LDAuNzUpXCIsXG5cdFx0XHRzY2FsZUJhY2tkcm9wUGFkZGluZ1k6IDIsXG5cdFx0XHRzY2FsZUJhY2tkcm9wUGFkZGluZ1g6IDIsXG5cdFx0XHRzZWdtZW50U2hvd1N0cm9rZTogdHJ1ZSxcblx0XHRcdHNlZ21lbnRTdHJva2VDb2xvcjogXCIjZmZmXCIsXG5cdFx0XHRzZWdtZW50U3Ryb2tlU3R5bGU6IFwic29saWRcIixcblx0XHRcdHNlZ21lbnRTdHJva2VXaWR0aDogMixcblx0XHRcdGFuaW1hdGlvbjogdHJ1ZSxcblx0XHRcdGFuaW1hdGlvbkJ5RGF0YSA6IFwiQnlBcmNcIixcblx0XHRcdGFuaW1hdGlvblN0ZXBzOiAxMDAsXG5cdFx0XHRhbmltYXRpb25FYXNpbmc6IFwiZWFzZU91dEJvdW5jZVwiLFxuXHRcdFx0YW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcblx0XHRcdGFuaW1hdGVTY2FsZTogZmFsc2UsXG5cdFx0XHRvbkFuaW1hdGlvbkNvbXBsZXRlOiBudWxsLFxuXHRcdFx0YW5ub3RhdGVMYWJlbDogXCI8JT0odjEgPT0gJyc/ICcnIDogdjErJzonKSsgdjIgKyAnICgnICsgdjYgKyAnICUpJyU+XCIsXG5cdFx0XHRzdGFydEFuZ2xlOiA5MCxcblx0XHRcdHRvdGFsQW1wbGl0dWRlIDogMzYwLFxuXHRcdFx0cmFkaXVzU2NhbGUgOiAxXG5cdFx0fTtcblx0XHRpZihpc0lFKCk8OSAmJiBpc0lFKCkgIT0gZmFsc2UpY2hhcnQuUG9sYXJBcmVhLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5kZWZhdWx0cy5JRXhwbG9yZXI4LCBjaGFydC5Qb2xhckFyZWEuZGVmYXVsdHMpO1xuXHRcdGNoYXJ0LlBvbGFyQXJlYS5kZWZhdWx0cyA9IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuZGVmYXVsdHMuY29tbW9uT3B0aW9ucywgY2hhcnQuUG9sYXJBcmVhLmRlZmF1bHRzKTtcblx0XHRjaGFydC5Qb2xhckFyZWEuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LlBvbGFyQXJlYS5kZWZhdWx0cywgY2hhckpTUGVyc29uYWxEZWZhdWx0T3B0aW9ucyk7XG5cdFx0Y2hhcnQuUG9sYXJBcmVhLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5Qb2xhckFyZWEuZGVmYXVsdHMsIGNoYXJKU1BlcnNvbmFsRGVmYXVsdE9wdGlvbnNQb2xhckFyZWEpO1xuXHRcdHZhciBjb25maWcgPSAob3B0aW9ucykgPyBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LlBvbGFyQXJlYS5kZWZhdWx0cywgb3B0aW9ucykgOiBjaGFydC5Qb2xhckFyZWEuZGVmYXVsdHM7XG5cdFx0cmV0dXJuIG5ldyBQb2xhckFyZWEoZGF0YSwgY29uZmlnLCBjb250ZXh0KTtcblx0fTtcblx0dGhpcy5SYWRhciA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcblx0XHRjaGFydC5SYWRhci5kZWZhdWx0cyA9IHtcblx0XHRcdGhpZ2hMaWdodFNldCA6IHsgcG9pbnREb3RSYWRpdXM6IDE1LCBwb2ludERvdCA6IHRydWUgfSxcblx0XHRcdGluR3JhcGhEYXRhU2hvdzogZmFsc2UsXG5cdFx0XHRpbkdyYXBoRGF0YVBhZGRpbmdSYWRpdXM6IDUsXG5cdFx0XHRpbkdyYXBoRGF0YVRtcGw6IFwiPCU9djMlPlwiLFxuXHRcdFx0aW5HcmFwaERhdGFBbGlnbjogXCJvZmYtY2VudGVyXCIsIC8vIFwicmlnaHRcIiwgXCJjZW50ZXJcIiwgXCJsZWZ0XCIsIFwib2ZmLWNlbnRlclwiIG9yIFwidG8tY2VudGVyXCJcblx0XHRcdGluR3JhcGhEYXRhVkFsaWduOiBcIm9mZi1jZW50ZXJcIiwgLy8gXCJyaWdodFwiLCBcImNlbnRlclwiLCBcImxlZnRcIiwgXCJvZmYtY2VudGVyXCIgb3IgXCJ0by1jZW50ZXJcIlxuXHRcdFx0aW5HcmFwaERhdGFSb3RhdGU6IDAsIC8vIHJvdGF0ZUFuZ2xlIHZhbHVlICgwLT4zNjApICwgXCJpblJhZGl1c0F4aXNcIiBvciBcImluUmFkaXVzQXhpc1JvdGF0ZUxhYmVsc1wiXG5cdFx0XHRpbkdyYXBoRGF0YUZvbnRGYW1pbHk6IFwiJ0FyaWFsJ1wiLFxuXHRcdFx0aW5HcmFwaERhdGFGb250U2l6ZTogMTIsXG5cdFx0XHRpbkdyYXBoRGF0YUZvbnRTdHlsZTogXCJub3JtYWxcIixcblx0XHRcdGluR3JhcGhEYXRhRm9udENvbG9yOiBcIiM2NjZcIixcblx0XHRcdGluR3JhcGhEYXRhUmFkaXVzUG9zaXRpb246IDMsXG5cdFx0XHR5QXhpc01pbmltdW1JbnRlcnZhbDogXCJub25lXCIsXG5cdFx0XHRzY2FsZUdyaWRMaW5lc1N0ZXAgOiAxLFxuXHRcdFx0c2NhbGVPdmVybGF5OiBmYWxzZSxcblx0XHRcdHNjYWxlT3ZlcnJpZGU6IGZhbHNlLFxuXHRcdFx0c2NhbGVPdmVycmlkZTI6IGZhbHNlLFxuXHRcdFx0c2NhbGVTdGVwczogbnVsbCxcblx0XHRcdHNjYWxlU3RlcFdpZHRoOiBudWxsLFxuXHRcdFx0c2NhbGVTdGFydFZhbHVlOiBudWxsLFxuXHRcdFx0c2NhbGVTaG93TGluZTogdHJ1ZSxcblx0XHRcdHNjYWxlTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsLjEpXCIsXG5cdFx0XHRzY2FsZUxpbmVTdHlsZTogXCJzb2xpZFwiLFxuXHRcdFx0c2NhbGVMaW5lV2lkdGg6IDEsXG5cdFx0XHRzY2FsZVNob3dMYWJlbHM6IGZhbHNlLFxuXHRcdFx0c2NhbGVTaG93TGFiZWxzMjogdHJ1ZSxcblx0XHRcdHNjYWxlTGFiZWw6IFwiPCU9dmFsdWUlPlwiLFxuXHRcdFx0c2NhbGVGb250RmFtaWx5OiBcIidBcmlhbCdcIixcblx0XHRcdHNjYWxlRm9udFNpemU6IDEyLFxuXHRcdFx0c2NhbGVGb250U3R5bGU6IFwibm9ybWFsXCIsXG5cdFx0XHRzY2FsZUZvbnRDb2xvcjogXCIjNjY2XCIsXG5cdFx0XHRzY2FsZVNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuXHRcdFx0c2NhbGVCYWNrZHJvcENvbG9yOiBcInJnYmEoMjU1LDI1NSwyNTUsMC43NSlcIixcblx0XHRcdHNjYWxlQmFja2Ryb3BQYWRkaW5nWTogMixcblx0XHRcdHNjYWxlQmFja2Ryb3BQYWRkaW5nWDogMixcblx0XHRcdGFuZ2xlU2hvd0xpbmVPdXQ6IHRydWUsXG5cdFx0XHRhbmdsZUxpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLC4xKVwiLFxuXHRcdFx0YW5nbGVMaW5lU3R5bGU6IFwic29saWRcIixcblx0XHRcdGFuZ2xlTGluZVdpZHRoOiAxLFxuXHRcdFx0cG9pbnRMYWJlbEZvbnRGYW1pbHk6IFwiJ0FyaWFsJ1wiLFxuXHRcdFx0cG9pbnRMYWJlbEZvbnRTdHlsZTogXCJub3JtYWxcIixcblx0XHRcdHBvaW50TGFiZWxGb250U2l6ZTogMTIsXG5cdFx0XHRwb2ludExhYmVsRm9udENvbG9yOiBcIiM2NjZcIixcblx0XHRcdHBvaW50RG90OiB0cnVlLFxuXHRcdFx0cG9pbnREb3RSYWRpdXM6IDMsXG5cdFx0XHRwb2ludERvdFN0cm9rZVdpZHRoOiAxLFxuXHRcdFx0cG9pbnREb3RTdHJva2VTdHlsZTpcInNvbGlkXCIsXG5cdFx0XHRkYXRhc2V0RmlsbDogdHJ1ZSxcblx0XHRcdGRhdGFzZXRTdHJva2VXaWR0aDogMixcblx0XHRcdGRhdGFzZXRTdHJva2VTdHlsZTpcInNvbGlkXCIsXG5cdFx0XHRhbmltYXRpb246IHRydWUsXG5cdFx0XHRhbmltYXRpb25TdGVwczogNjAsXG5cdFx0XHRhbmltYXRpb25FYXNpbmc6IFwiZWFzZU91dFF1YXJ0XCIsXG5cdFx0XHRvbkFuaW1hdGlvbkNvbXBsZXRlOiBudWxsLFxuXHRcdFx0YW5ub3RhdGVMYWJlbDogXCI8JT0odjEgPT0gJycgPyAnJyA6IHYxKSArICh2MSE9JycgJiYgdjIgIT0nJyA/ICcgLSAnIDogJycpKyh2MiA9PSAnJyA/ICcnIDogdjIpKyh2MSE9JycgfHwgdjIgIT0nJyA/ICc6JyA6ICcnKSArIHYzJT5cIixcblx0XHRcdHBvaW50SGl0RGV0ZWN0aW9uUmFkaXVzIDogMTAsXG5cdFx0XHRzdGFydEFuZ2xlOiA5MFxuXHRcdH07XG5cdFx0Ly8gbWVyZ2UgYW5ub3RhdGUgZGVmYXVsdHNcblx0XHRpZihpc0lFKCk8OSAmJiBpc0lFKCkgIT0gZmFsc2UpY2hhcnQuUmFkYXIuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LmRlZmF1bHRzLklFeHBsb3JlcjgsIGNoYXJ0LlJhZGFyLmRlZmF1bHRzKTtcblx0XHRjaGFydC5SYWRhci5kZWZhdWx0cyA9IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuZGVmYXVsdHMuY29tbW9uT3B0aW9ucywgY2hhcnQuUmFkYXIuZGVmYXVsdHMpO1xuXHRcdGNoYXJ0LlJhZGFyLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5SYWRhci5kZWZhdWx0cywgY2hhckpTUGVyc29uYWxEZWZhdWx0T3B0aW9ucyk7XG5cdFx0Y2hhcnQuUmFkYXIuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LlJhZGFyLmRlZmF1bHRzLCBjaGFySlNQZXJzb25hbERlZmF1bHRPcHRpb25zUmFkYXIpO1xuXHRcdHZhciBjb25maWcgPSAob3B0aW9ucykgPyBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LlJhZGFyLmRlZmF1bHRzLCBvcHRpb25zKSA6IGNoYXJ0LlJhZGFyLmRlZmF1bHRzO1xuXHRcdHJldHVybiBuZXcgUmFkYXIoZGF0YSwgY29uZmlnLCBjb250ZXh0KTtcblx0fTtcblx0dGhpcy5QaWUgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG5cdFx0Y2hhcnQuUGllLmRlZmF1bHRzID0gY2hhcnQuZGVmYXVsdHMuUGllQW5kRG91Z2hudXQ7XG5cdFx0Ly8gbWVyZ2UgYW5ub3RhdGUgZGVmYXVsdHNcblx0XHRpZihpc0lFKCk8OSAmJiBpc0lFKCkgIT0gZmFsc2UpY2hhcnQuUGllLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5kZWZhdWx0cy5JRXhwbG9yZXI4LCBjaGFydC5QaWUuZGVmYXVsdHMpO1xuXHRcdGNoYXJ0LlBpZS5kZWZhdWx0cyA9IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuZGVmYXVsdHMuY29tbW9uT3B0aW9ucywgY2hhcnQuUGllLmRlZmF1bHRzKTtcblx0XHRjaGFydC5QaWUuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LlBpZS5kZWZhdWx0cywgY2hhckpTUGVyc29uYWxEZWZhdWx0T3B0aW9ucyk7XG5cdFx0Y2hhcnQuUGllLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5QaWUuZGVmYXVsdHMsIGNoYXJKU1BlcnNvbmFsRGVmYXVsdE9wdGlvbnNQaWUpO1xuXHRcdHZhciBjb25maWcgPSAob3B0aW9ucykgPyBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LlBpZS5kZWZhdWx0cywgb3B0aW9ucykgOiBjaGFydC5QaWUuZGVmYXVsdHM7XG5cdFx0cmV0dXJuIG5ldyBQaWUoZGF0YSwgY29uZmlnLCBjb250ZXh0KTtcblx0fTtcblx0dGhpcy5Eb3VnaG51dCA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcblx0XHRjaGFydC5Eb3VnaG51dC5kZWZhdWx0cyA9IGNoYXJ0LmRlZmF1bHRzLlBpZUFuZERvdWdobnV0O1xuXHRcdC8vIG1lcmdlIGFubm90YXRlIGRlZmF1bHRzXG5cdFx0aWYoaXNJRSgpPDkgJiYgaXNJRSgpICE9IGZhbHNlKWNoYXJ0LkRvdWdobnV0LmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5kZWZhdWx0cy5JRXhwbG9yZXI4LCBjaGFydC5Eb3VnaG51dC5kZWZhdWx0cyk7XG5cdFx0Y2hhcnQuRG91Z2hudXQuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LmRlZmF1bHRzLmNvbW1vbk9wdGlvbnMsIGNoYXJ0LkRvdWdobnV0LmRlZmF1bHRzKTtcblx0XHRjaGFydC5Eb3VnaG51dC5kZWZhdWx0cyA9IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuRG91Z2hudXQuZGVmYXVsdHMsIGNoYXJKU1BlcnNvbmFsRGVmYXVsdE9wdGlvbnMpO1xuXHRcdGNoYXJ0LkRvdWdobnV0LmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5Eb3VnaG51dC5kZWZhdWx0cywgY2hhckpTUGVyc29uYWxEZWZhdWx0T3B0aW9uc0RvdWdobnV0KTtcblx0XHR2YXIgY29uZmlnID0gKG9wdGlvbnMpID8gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5Eb3VnaG51dC5kZWZhdWx0cywgb3B0aW9ucykgOiBjaGFydC5Eb3VnaG51dC5kZWZhdWx0cztcblx0XHRyZXR1cm4gbmV3IERvdWdobnV0KGRhdGEsIGNvbmZpZywgY29udGV4dCk7XG5cdH07XG5cdHRoaXMuTGluZSA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcblx0XHRjaGFydC5MaW5lLmRlZmF1bHRzID0ge1xuXHRcdFx0aW5HcmFwaERhdGFTaG93OiBmYWxzZSxcblx0XHRcdGhpZ2hMaWdodFNldCA6IHsgcG9pbnREb3RSYWRpdXM6IDE1LCBwb2ludERvdCA6IHRydWUgfSxcblx0XHRcdGluR3JhcGhEYXRhUGFkZGluZ1g6IDMsXG5cdFx0XHRpbkdyYXBoRGF0YVBhZGRpbmdZOiAzLFxuXHRcdFx0aW5HcmFwaERhdGFUbXBsOiBcIjwlPXYzJT5cIixcblx0XHRcdGluR3JhcGhEYXRhQWxpZ246IFwibGVmdFwiLFxuXHRcdFx0aW5HcmFwaERhdGFWQWxpZ246IFwiYm90dG9tXCIsXG5cdFx0XHRpbkdyYXBoRGF0YVJvdGF0ZTogMCxcblx0XHRcdGluR3JhcGhEYXRhRm9udEZhbWlseTogXCInQXJpYWwnXCIsXG5cdFx0XHRpbkdyYXBoRGF0YUZvbnRTaXplOiAxMixcblx0XHRcdGluR3JhcGhEYXRhRm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuXHRcdFx0aW5HcmFwaERhdGFGb250Q29sb3I6IFwiIzY2NlwiLFxuXHRcdFx0ZHJhd1hTY2FsZUxpbmU6IFt7XG5cdFx0XHRcdHBvc2l0aW9uOiBcImJvdHRvbVwiXG5cdFx0XHR9XSxcblx0XHRcdHNjYWxlT3ZlcmxheTogZmFsc2UsXG5cdFx0XHRzY2FsZU92ZXJyaWRlOiBmYWxzZSxcblx0XHRcdHNjYWxlT3ZlcnJpZGUyOiBmYWxzZSxcblx0XHRcdHNjYWxlU3RlcHM6IG51bGwsXG5cdFx0XHRzY2FsZVN0ZXBXaWR0aDogbnVsbCxcblx0XHRcdHNjYWxlU3RhcnRWYWx1ZTogbnVsbCxcblx0XHRcdHNjYWxlU3RlcHMyOiBudWxsLFxuXHRcdFx0c2NhbGVTdGVwV2lkdGgyOiBudWxsLFxuXHRcdFx0c2NhbGVTdGFydFZhbHVlMjogbnVsbCxcblx0XHRcdHNjYWxlTGFiZWwyIDogXCI8JT12YWx1ZSU+XCIsXG5cdFx0XHRzY2FsZUxpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLC4xKVwiLFxuXHRcdFx0c2NhbGVMaW5lU3R5bGU6IFwic29saWRcIixcblx0XHRcdHNjYWxlTGluZVdpZHRoOiAxLFxuXHRcdFx0c2NhbGVTaG93TGFiZWxzOiB0cnVlLFxuXHRcdFx0c2NhbGVTaG93TGFiZWxzMjogdHJ1ZSxcblx0XHRcdHNjYWxlTGFiZWw6IFwiPCU9dmFsdWUlPlwiLFxuXHRcdFx0c2NhbGVGb250RmFtaWx5OiBcIidBcmlhbCdcIixcblx0XHRcdHNjYWxlRm9udFNpemU6IDEyLFxuXHRcdFx0c2NhbGVGb250U3R5bGU6IFwibm9ybWFsXCIsXG5cdFx0XHRzY2FsZUZvbnRDb2xvcjogXCIjNjY2XCIsXG5cdFx0XHRzY2FsZVNob3dHcmlkTGluZXM6IHRydWUsXG5cdFx0XHRzY2FsZVhHcmlkTGluZXNTdGVwOiAxLFxuXHRcdFx0c2NhbGVZR3JpZExpbmVzU3RlcDogMSxcblx0XHRcdHNjYWxlR3JpZExpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLC4wNSlcIixcblx0XHRcdHNjYWxlR3JpZExpbmVTdHlsZTogXCJzb2xpZFwiLFxuXHRcdFx0c2NhbGVHcmlkTGluZVdpZHRoOiAxLFxuXHRcdFx0c2hvd1lBeGlzTWluOiB0cnVlLCAvLyBTaG93IHRoZSBtaW5pbXVtIHZhbHVlIG9uIFkgYXhpcyAoaW4gb3JpZ2luYWwgdmVyc2lvbiwgdGhpcyBtaW5pbXVtIGlzIG5vdCBkaXNwbGF5ZWQgLSBpdCBjYW4gb3ZlcmxhcCB0aGUgWCBsYWJlbHMpXG5cdFx0XHRyb3RhdGVMYWJlbHM6IFwic21hcnRcIiwgLy8gc21hcnQgPD0+IDAgZGVncmUgaWYgc3BhY2UgZW5vdWdoOyBvdGhlcndpc2UgNDUgZGVncmVzIGlmIHNwYWNlIGVub3VnaCBvdGhlcndpc2U5MCBkZWdyZTsgXG5cdFx0XHQvLyB5b3UgY2FuIGZvcmNlIGFuIGludGVnZXIgdmFsdWUgYmV0d2VlbiAwIGFuZCAxODAgZGVncmVzXG5cdFx0XHRsb2dhcml0aG1pYzogZmFsc2UsIC8vIGNhbiBiZSAnZnV6enknLHRydWUgYW5kIGZhbHNlICgnZnV6enknID0+IGlmIHRoZSBnYXAgYmV0d2VlbiBtaW4gYW5kIG1heGltdW0gaXMgYmlnIGl0J3MgdXNpbmcgYSBsb2dhcml0aG1pYyB5LUF4aXMgc2NhbGVcblx0XHRcdGxvZ2FyaXRobWljMjogZmFsc2UsIC8vIGNhbiBiZSAnZnV6enknLHRydWUgYW5kIGZhbHNlICgnZnV6enknID0+IGlmIHRoZSBnYXAgYmV0d2VlbiBtaW4gYW5kIG1heGltdW0gaXMgYmlnIGl0J3MgdXNpbmcgYSBsb2dhcml0aG1pYyB5LUF4aXMgc2NhbGVcblx0XHRcdHNjYWxlVGlja1NpemVMZWZ0OiA1LFxuXHRcdFx0c2NhbGVUaWNrU2l6ZVJpZ2h0OiA1LFxuXHRcdFx0c2NhbGVUaWNrU2l6ZUJvdHRvbTogNSxcblx0XHRcdHNjYWxlVGlja1NpemVUb3A6IDUsXG5cdFx0XHRiZXppZXJDdXJ2ZTogdHJ1ZSxcblx0XHRcdGxpbmtUeXBlIDogMCwgICAvLzAgOiBkaXJlY3QgcG9pbnQgdG8gcG9pbnQ7IDEgPSB2ZXJ0aWNhbCBsaW5lczsgMj1hbmd1bGFyIGxpbms7XG5cdFx0XHRiZXppZXJDdXJ2ZVRlbnNpb24gOiAwLjQsXG5cdFx0XHRwb2ludERvdDogdHJ1ZSxcblx0XHRcdHBvaW50RG90UmFkaXVzOiA0LFxuXHRcdFx0cG9pbnREb3RTdHJva2VTdHlsZTogXCJzb2xpZFwiLFxuXHRcdFx0cG9pbnREb3RTdHJva2VXaWR0aDogMixcblx0XHRcdGRhdGFzZXRTdHJva2VTdHlsZTogXCJzb2xpZFwiLFxuXHRcdFx0ZGF0YXNldFN0cm9rZVdpZHRoOiAyLFxuXHRcdFx0ZGF0YXNldEZpbGw6IHRydWUsXG5cdFx0XHRhbmltYXRpb246IHRydWUsXG5cdFx0XHRhbmltYXRpb25TdGVwczogNjAsXG5cdFx0XHRhbmltYXRpb25FYXNpbmc6IFwiZWFzZU91dFF1YXJ0XCIsXG5cdFx0XHRleHRyYXBvbGF0ZU1pc3NpbmdEYXRhOiB0cnVlLFxuXHRcdFx0b25BbmltYXRpb25Db21wbGV0ZTogbnVsbCxcblx0XHRcdGFubm90YXRlTGFiZWw6IFwiPCU9KHYxID09ICcnID8gJycgOiB2MSkgKyAodjEhPScnICYmIHYyICE9JycgPyAnIC0gJyA6ICcnKSsodjIgPT0gJycgPyAnJyA6IHYyKSsodjEhPScnIHx8IHYyICE9JycgPyAnOicgOiAnJykgKyB2MyU+XCIsXG5cdFx0XHRwb2ludEhpdERldGVjdGlvblJhZGl1cyA6IDEwXG5cdFx0fTtcblx0XHQvLyBtZXJnZSBhbm5vdGF0ZSBkZWZhdWx0c1xuXHRcdGlmKGlzSUUoKTw5ICYmIGlzSUUoKSAhPSBmYWxzZSljaGFydC5MaW5lLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5kZWZhdWx0cy5JRXhwbG9yZXI4LCBjaGFydC5MaW5lLmRlZmF1bHRzKTtcblx0XHRjaGFydC5MaW5lLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5kZWZhdWx0cy5jb21tb25PcHRpb25zLCBjaGFydC5MaW5lLmRlZmF1bHRzKTtcblx0XHRjaGFydC5MaW5lLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5kZWZhdWx0cy54eUF4aXNDb21tb25PcHRpb25zLCBjaGFydC5MaW5lLmRlZmF1bHRzKTtcblx0XHRjaGFydC5MaW5lLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5MaW5lLmRlZmF1bHRzLCBjaGFySlNQZXJzb25hbERlZmF1bHRPcHRpb25zKTtcblx0XHRjaGFydC5MaW5lLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5MaW5lLmRlZmF1bHRzLCBjaGFySlNQZXJzb25hbERlZmF1bHRPcHRpb25zTGluZSk7XG5cdFx0dmFyIGNvbmZpZyA9IChvcHRpb25zKSA/IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuTGluZS5kZWZhdWx0cywgb3B0aW9ucykgOiBjaGFydC5MaW5lLmRlZmF1bHRzO1xuXHRcdHJldHVybiBuZXcgTGluZShkYXRhLCBjb25maWcsIGNvbnRleHQpO1xuXHR9O1xuXHR0aGlzLlN0YWNrZWRCYXIgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG5cdFx0Y2hhcnQuU3RhY2tlZEJhci5kZWZhdWx0cyA9IHtcblx0XHRcdGFubm90YXRlQmFyTWluaW11bURldGVjdGlvbkhlaWdodCA6IDAsXG5cdFx0XHRoaWdoTGlnaHRTZXQgOiB7IHBvaW50RG90UmFkaXVzOiAxNSwgYmFyU3Ryb2tlV2lkdGggOiA1LCBwb2ludERvdCA6IHRydWUgfSxcblx0XHRcdGluR3JhcGhEYXRhU2hvdzogZmFsc2UsXG5cdFx0XHRpbkdyYXBoRGF0YVBhZGRpbmdYOiAwLFxuXHRcdFx0aW5HcmFwaERhdGFQYWRkaW5nWTogLTMsXG5cdFx0XHRpbkdyYXBoRGF0YVRtcGw6IFwiPCU9djMlPlwiLFxuXHRcdFx0aW5HcmFwaERhdGFBbGlnbjogXCJjZW50ZXJcIixcblx0XHRcdGluR3JhcGhEYXRhVkFsaWduOiBcInRvcFwiLFxuXHRcdFx0aW5HcmFwaERhdGFSb3RhdGU6IDAsXG5cdFx0XHRpbkdyYXBoRGF0YUZvbnRGYW1pbHk6IFwiJ0FyaWFsJ1wiLFxuXHRcdFx0aW5HcmFwaERhdGFGb250U2l6ZTogMTIsXG5cdFx0XHRpbkdyYXBoRGF0YUZvbnRTdHlsZTogXCJub3JtYWxcIixcblx0XHRcdGluR3JhcGhEYXRhRm9udENvbG9yOiBcIiM2NjZcIixcblx0XHRcdGluR3JhcGhEYXRhWFBvc2l0aW9uOiAyLFxuXHRcdFx0aW5HcmFwaERhdGFZUG9zaXRpb246IDMsXG5cdFx0XHRzY2FsZU92ZXJsYXk6IGZhbHNlLFxuXHRcdFx0c2NhbGVPdmVycmlkZTogZmFsc2UsXG5cdFx0XHRzY2FsZU92ZXJyaWRlMjogZmFsc2UsXG5cdFx0XHRzY2FsZVN0ZXBzOiBudWxsLFxuXHRcdFx0c2NhbGVTdGVwV2lkdGg6IG51bGwsXG5cdFx0XHRzY2FsZVN0YXJ0VmFsdWU6IG51bGwsXG5cdFx0XHRzY2FsZUxpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLC4xKVwiLFxuXHRcdFx0c2NhbGVMaW5lU3R5bGU6IFwic29saWRcIixcblx0XHRcdHNjYWxlTGluZVdpZHRoOiAxLFxuXHRcdFx0c2NhbGVTaG93TGFiZWxzOiB0cnVlLFxuXHRcdFx0c2NhbGVTaG93TGFiZWxzMjogdHJ1ZSxcblx0XHRcdHNjYWxlTGFiZWw6IFwiPCU9dmFsdWUlPlwiLFxuXHRcdFx0c2NhbGVGb250RmFtaWx5OiBcIidBcmlhbCdcIixcblx0XHRcdHNjYWxlRm9udFNpemU6IDEyLFxuXHRcdFx0c2NhbGVGb250U3R5bGU6IFwibm9ybWFsXCIsXG5cdFx0XHRzY2FsZUZvbnRDb2xvcjogXCIjNjY2XCIsXG5cdFx0XHRzY2FsZVNob3dHcmlkTGluZXM6IHRydWUsXG5cdFx0XHRzY2FsZVhHcmlkTGluZXNTdGVwOiAxLFxuXHRcdFx0c2NhbGVZR3JpZExpbmVzU3RlcDogMSxcblx0XHRcdHNjYWxlR3JpZExpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLC4wNSlcIixcblx0XHRcdHNjYWxlR3JpZExpbmVTdHlsZTogXCJzb2xpZFwiLFxuXHRcdFx0c2NhbGVHcmlkTGluZVdpZHRoOiAxLFxuXHRcdFx0c2hvd1lBeGlzTWluOiB0cnVlLCAvLyBTaG93IHRoZSBtaW5pbXVtIHZhbHVlIG9uIFkgYXhpcyAoaW4gb3JpZ2luYWwgdmVyc2lvbiwgdGhpcyBtaW5pbXVtIGlzIG5vdCBkaXNwbGF5ZWQgLSBpdCBjYW4gb3ZlcmxhcCB0aGUgWCBsYWJlbHMpXG5cdFx0XHRyb3RhdGVMYWJlbHM6IFwic21hcnRcIiwgLy8gc21hcnQgPD0+IDAgZGVncmUgaWYgc3BhY2UgZW5vdWdoOyBvdGhlcndpc2UgNDUgZGVncmVzIGlmIHNwYWNlIGVub3VnaCBvdGhlcndpc2U5MCBkZWdyZTsgXG5cdFx0XHQvLyB5b3UgY2FuIGZvcmNlIGFuIGludGVnZXIgdmFsdWUgYmV0d2VlbiAwIGFuZCAxODAgZGVncmVzXG5cdFx0XHRzY2FsZVRpY2tTaXplTGVmdDogNSxcblx0XHRcdHNjYWxlVGlja1NpemVSaWdodDogNSxcblx0XHRcdHNjYWxlVGlja1NpemVCb3R0b206IDUsXG5cdFx0XHRzY2FsZVRpY2tTaXplVG9wOiA1LFxuXHRcdFx0cG9pbnREb3Q6IHRydWUsXG5cdFx0XHRwb2ludERvdFJhZGl1czogNCxcblx0XHRcdHBvaW50RG90U3Ryb2tlU3R5bGU6IFwic29saWRcIixcblx0XHRcdHBvaW50RG90U3Ryb2tlV2lkdGg6IDIsXG5cdFx0XHRiYXJTaG93U3Ryb2tlOiB0cnVlLFxuLy9cdFx0XHRiYXJTdHJva2VTdHlsZTogXCJzb2xpZFwiLFxuXHRcdFx0YmFyU3Ryb2tlV2lkdGg6IDIsXG5cdFx0XHRiYXJWYWx1ZVNwYWNpbmc6IDUsXG5cdFx0XHRiYXJEYXRhc2V0U3BhY2luZzogMSxcblx0XHRcdHNwYWNlQmV0d2VlbkJhciA6IDAsXG5cdFx0XHRhbmltYXRpb246IHRydWUsXG5cdFx0XHRhbmltYXRpb25TdGVwczogNjAsXG5cdFx0XHRhbmltYXRpb25FYXNpbmc6IFwiZWFzZU91dFF1YXJ0XCIsXG5cdFx0XHRvbkFuaW1hdGlvbkNvbXBsZXRlOiBudWxsLFxuXHRcdFx0YmV6aWVyQ3VydmU6IHRydWUsXG5cdFx0XHRsaW5rVHlwZSA6IDAsICAgLy8wIDogZGlyZWN0IHBvaW50IHRvIHBvaW50OyAxID0gdmVydGljYWwgbGluZXM7IDI9YW5ndWxhciBsaW5rO1xuXHRcdFx0YmV6aWVyQ3VydmVUZW5zaW9uIDogMC40LFxuXHRcdFx0YW5ub3RhdGVMYWJlbDogXCI8JT0odjEgPT0gJycgPyAnJyA6IHYxKSArICh2MSE9JycgJiYgdjIgIT0nJyA/ICcgLSAnIDogJycpKyh2MiA9PSAnJyA/ICcnIDogdjIpKyh2MSE9JycgfHwgdjIgIT0nJyA/ICc6JyA6ICcnKSArIHYzICsgJyAoJyArIHY2ICsgJyAlKSclPlwiLFxuXHRcdFx0cG9pbnRIaXREZXRlY3Rpb25SYWRpdXMgOiAxMFxuXHRcdH07XG5cdFx0Ly8gbWVyZ2UgYW5ub3RhdGUgZGVmYXVsdHNcblx0XHRpZihpc0lFKCk8OSAmJiBpc0lFKCkgIT0gZmFsc2UpY2hhcnQuU3RhY2tlZEJhci5kZWZhdWx0cyA9IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuZGVmYXVsdHMuSUV4cGxvcmVyOCwgY2hhcnQuU3RhY2tlZEJhci5kZWZhdWx0cyk7XG5cdFx0Y2hhcnQuU3RhY2tlZEJhci5kZWZhdWx0cyA9IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuZGVmYXVsdHMuY29tbW9uT3B0aW9ucywgY2hhcnQuU3RhY2tlZEJhci5kZWZhdWx0cyk7XG5cdFx0Y2hhcnQuU3RhY2tlZEJhci5kZWZhdWx0cyA9IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuZGVmYXVsdHMueHlBeGlzQ29tbW9uT3B0aW9ucywgY2hhcnQuU3RhY2tlZEJhci5kZWZhdWx0cyk7XG5cdFx0Y2hhcnQuU3RhY2tlZEJhci5kZWZhdWx0cyA9IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuU3RhY2tlZEJhci5kZWZhdWx0cywgY2hhckpTUGVyc29uYWxEZWZhdWx0T3B0aW9ucyk7XG5cdFx0Y2hhcnQuU3RhY2tlZEJhci5kZWZhdWx0cyA9IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuU3RhY2tlZEJhci5kZWZhdWx0cywgY2hhckpTUGVyc29uYWxEZWZhdWx0T3B0aW9uc1N0YWNrZWRCYXIpO1xuXHRcdHZhciBjb25maWcgPSAob3B0aW9ucykgPyBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LlN0YWNrZWRCYXIuZGVmYXVsdHMsIG9wdGlvbnMpIDogY2hhcnQuU3RhY2tlZEJhci5kZWZhdWx0cztcblx0XHRyZXR1cm4gbmV3IFN0YWNrZWRCYXIoZGF0YSwgY29uZmlnLCBjb250ZXh0KTtcblx0fTtcblx0dGhpcy5Ib3Jpem9udGFsU3RhY2tlZEJhciA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcblx0XHRjaGFydC5Ib3Jpem9udGFsU3RhY2tlZEJhci5kZWZhdWx0cyA9IHtcblx0XHRcdGFubm90YXRlQmFyTWluaW11bURldGVjdGlvbkhlaWdodCA6IDAsXG5cdFx0XHRoaWdoTGlnaHRTZXQgOiB7IHBvaW50RG90UmFkaXVzOiAxNSwgYmFyU3Ryb2tlV2lkdGggOiA1LCBwb2ludERvdCA6IHRydWUgfSxcblx0XHRcdGluR3JhcGhEYXRhU2hvdzogZmFsc2UsXG5cdFx0XHRpbkdyYXBoRGF0YVBhZGRpbmdYOiAtMyxcblx0XHRcdGluR3JhcGhEYXRhUGFkZGluZ1k6IDAsXG5cdFx0XHRpbkdyYXBoRGF0YVRtcGw6IFwiPCU9djMlPlwiLFxuXHRcdFx0aW5HcmFwaERhdGFBbGlnbjogXCJyaWdodFwiLFxuXHRcdFx0aW5HcmFwaERhdGFWQWxpZ246IFwibWlkZGxlXCIsXG5cdFx0XHRpbkdyYXBoRGF0YVJvdGF0ZTogMCxcblx0XHRcdGluR3JhcGhEYXRhRm9udEZhbWlseTogXCInQXJpYWwnXCIsXG5cdFx0XHRpbkdyYXBoRGF0YUZvbnRTaXplOiAxMixcblx0XHRcdGluR3JhcGhEYXRhRm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuXHRcdFx0aW5HcmFwaERhdGFGb250Q29sb3I6IFwiIzY2NlwiLFxuXHRcdFx0aW5HcmFwaERhdGFYUG9zaXRpb246IDMsXG5cdFx0XHRpbkdyYXBoRGF0YVlQb3NpdGlvbjogMixcblx0XHRcdHNjYWxlT3ZlcmxheTogZmFsc2UsXG5cdFx0XHRzY2FsZU92ZXJyaWRlOiBmYWxzZSxcblx0XHRcdHNjYWxlT3ZlcnJpZGUyOiBmYWxzZSxcblx0XHRcdHNjYWxlU3RlcHM6IG51bGwsXG5cdFx0XHRzY2FsZVN0ZXBXaWR0aDogbnVsbCxcblx0XHRcdHNjYWxlU3RhcnRWYWx1ZTogbnVsbCxcblx0XHRcdHNjYWxlTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsLjEpXCIsXG5cdFx0XHRzY2FsZUxpbmVTdHlsZTogXCJzb2xpZFwiLFxuXHRcdFx0c2NhbGVMaW5lV2lkdGg6IDEsXG5cdFx0XHRzY2FsZVNob3dMYWJlbHM6IHRydWUsXG5cdFx0XHRzY2FsZVNob3dMYWJlbHMyOiB0cnVlLFxuXHRcdFx0c2NhbGVMYWJlbDogXCI8JT12YWx1ZSU+XCIsXG5cdFx0XHRzY2FsZUZvbnRGYW1pbHk6IFwiJ0FyaWFsJ1wiLFxuXHRcdFx0c2NhbGVGb250U2l6ZTogMTIsXG5cdFx0XHRzY2FsZUZvbnRTdHlsZTogXCJub3JtYWxcIixcblx0XHRcdHNjYWxlRm9udENvbG9yOiBcIiM2NjZcIixcblx0XHRcdHNjYWxlU2hvd0dyaWRMaW5lczogdHJ1ZSxcblx0XHRcdHNjYWxlWEdyaWRMaW5lc1N0ZXA6IDEsXG5cdFx0XHRzY2FsZVlHcmlkTGluZXNTdGVwOiAxLFxuXHRcdFx0c2NhbGVHcmlkTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsLjA1KVwiLFxuXHRcdFx0c2NhbGVHcmlkTGluZVN0eWxlOiBcInNvbGlkXCIsXG5cdFx0XHRzY2FsZUdyaWRMaW5lV2lkdGg6IDEsXG5cdFx0XHRzY2FsZVRpY2tTaXplTGVmdDogNSxcblx0XHRcdHNjYWxlVGlja1NpemVSaWdodDogNSxcblx0XHRcdHNjYWxlVGlja1NpemVCb3R0b206IDUsXG5cdFx0XHRzY2FsZVRpY2tTaXplVG9wOiA1LFxuXHRcdFx0c2hvd1lBeGlzTWluOiB0cnVlLCAvLyBTaG93IHRoZSBtaW5pbXVtIHZhbHVlIG9uIFkgYXhpcyAoaW4gb3JpZ2luYWwgdmVyc2lvbiwgdGhpcyBtaW5pbXVtIGlzIG5vdCBkaXNwbGF5ZWQgLSBpdCBjYW4gb3ZlcmxhcCB0aGUgWCBsYWJlbHMpXG5cdFx0XHRyb3RhdGVMYWJlbHM6IFwic21hcnRcIiwgLy8gc21hcnQgPD0+IDAgZGVncmUgaWYgc3BhY2UgZW5vdWdoOyBvdGhlcndpc2UgNDUgZGVncmVzIGlmIHNwYWNlIGVub3VnaCBvdGhlcndpc2U5MCBkZWdyZTsgXG5cdFx0XHRiYXJTaG93U3Ryb2tlOiB0cnVlLFxuLy9cdFx0XHRiYXJTdHJva2VTdHlsZTogXCJzb2xpZFwiLFxuXHRcdFx0YmFyU3Ryb2tlV2lkdGg6IDIsXG5cdFx0XHRiYXJWYWx1ZVNwYWNpbmc6IDUsXG5cdFx0XHRiYXJEYXRhc2V0U3BhY2luZzogMSxcblx0XHRcdHNwYWNlQmV0d2VlbkJhciA6IDAsXG5cdFx0XHRhbmltYXRpb246IHRydWUsXG5cdFx0XHRhbmltYXRpb25TdGVwczogNjAsXG5cdFx0XHRhbmltYXRpb25FYXNpbmc6IFwiZWFzZU91dFF1YXJ0XCIsXG5cdFx0XHRvbkFuaW1hdGlvbkNvbXBsZXRlOiBudWxsLFxuXHRcdFx0YW5ub3RhdGVMYWJlbDogXCI8JT0odjEgPT0gJycgPyAnJyA6IHYxKSArICh2MSE9JycgJiYgdjIgIT0nJyA/ICcgLSAnIDogJycpKyh2MiA9PSAnJyA/ICcnIDogdjIpKyh2MSE9JycgfHwgdjIgIT0nJyA/ICc6JyA6ICcnKSArIHYzICsgJyAoJyArIHY2ICsgJyAlKSclPlwiLFxuXHRcdFx0cmV2ZXJzZU9yZGVyOiBmYWxzZVxuXHRcdH07XG5cdFx0Ly8gbWVyZ2UgYW5ub3RhdGUgZGVmYXVsdHNcblx0XHRpZihpc0lFKCk8OSAmJiBpc0lFKCkgIT0gZmFsc2UpY2hhcnQuSG9yaXpvbnRhbFN0YWNrZWRCYXIuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LmRlZmF1bHRzLklFeHBsb3JlcjgsIGNoYXJ0Lkhvcml6b250YWxTdGFja2VkQmFyLmRlZmF1bHRzKTtcblx0XHRjaGFydC5Ib3Jpem9udGFsU3RhY2tlZEJhci5kZWZhdWx0cyA9IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuZGVmYXVsdHMuY29tbW9uT3B0aW9ucywgY2hhcnQuSG9yaXpvbnRhbFN0YWNrZWRCYXIuZGVmYXVsdHMpO1xuXHRcdGNoYXJ0Lkhvcml6b250YWxTdGFja2VkQmFyLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5kZWZhdWx0cy54eUF4aXNDb21tb25PcHRpb25zLCBjaGFydC5Ib3Jpem9udGFsU3RhY2tlZEJhci5kZWZhdWx0cyk7XG5cdFx0Y2hhcnQuSG9yaXpvbnRhbFN0YWNrZWRCYXIuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0Lkhvcml6b250YWxTdGFja2VkQmFyLmRlZmF1bHRzLCBjaGFySlNQZXJzb25hbERlZmF1bHRPcHRpb25zKTtcblx0XHRjaGFydC5Ib3Jpem9udGFsU3RhY2tlZEJhci5kZWZhdWx0cyA9IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuSG9yaXpvbnRhbFN0YWNrZWRCYXIuZGVmYXVsdHMsIGNoYXJKU1BlcnNvbmFsRGVmYXVsdE9wdGlvbnNIb3Jpem9udGFsU3RhY2tlZEJhcik7XG5cdFx0dmFyIGNvbmZpZyA9IChvcHRpb25zKSA/IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuSG9yaXpvbnRhbFN0YWNrZWRCYXIuZGVmYXVsdHMsIG9wdGlvbnMpIDogY2hhcnQuSG9yaXpvbnRhbFN0YWNrZWRCYXIuZGVmYXVsdHM7XG5cdFx0cmV0dXJuIG5ldyBIb3Jpem9udGFsU3RhY2tlZEJhcihkYXRhLCBjb25maWcsIGNvbnRleHQpO1xuXHR9O1xuXHR0aGlzLkJhciA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcblx0XHRjaGFydC5CYXIuZGVmYXVsdHMgPSB7XG5cdFx0XHRhbm5vdGF0ZUJhck1pbmltdW1EZXRlY3Rpb25IZWlnaHQgOiAwLFxuXHRcdFx0aGlnaExpZ2h0U2V0IDogeyBwb2ludERvdFJhZGl1czogMTUsIGJhclN0cm9rZVdpZHRoIDogNSwgcG9pbnREb3QgOiB0cnVlIH0sXG5cdFx0XHRpbkdyYXBoRGF0YVNob3c6IGZhbHNlLFxuXHRcdFx0aW5HcmFwaERhdGFQYWRkaW5nWDogMCxcblx0XHRcdGluR3JhcGhEYXRhUGFkZGluZ1k6IDMsXG5cdFx0XHRpbkdyYXBoRGF0YVRtcGw6IFwiPCU9djMlPlwiLFxuXHRcdFx0aW5HcmFwaERhdGFBbGlnbjogXCJjZW50ZXJcIixcblx0XHRcdGluR3JhcGhEYXRhVkFsaWduOiBcImJvdHRvbVwiLFxuXHRcdFx0aW5HcmFwaERhdGFSb3RhdGU6IDAsXG5cdFx0XHRpbkdyYXBoRGF0YUZvbnRGYW1pbHk6IFwiJ0FyaWFsJ1wiLFxuXHRcdFx0aW5HcmFwaERhdGFGb250U2l6ZTogMTIsXG5cdFx0XHRpbkdyYXBoRGF0YUZvbnRTdHlsZTogXCJub3JtYWxcIixcblx0XHRcdGluR3JhcGhEYXRhRm9udENvbG9yOiBcIiM2NjZcIixcblx0XHRcdGluR3JhcGhEYXRhWFBvc2l0aW9uOiAyLFxuXHRcdFx0aW5HcmFwaERhdGFZUG9zaXRpb246IDMsXG5cdFx0XHRzY2FsZU92ZXJsYXk6IGZhbHNlLFxuXHRcdFx0c2NhbGVPdmVycmlkZTogZmFsc2UsXG5cdFx0XHRzY2FsZU92ZXJyaWRlMjogZmFsc2UsXG5cdFx0XHRzY2FsZVN0ZXBzOiBudWxsLFxuXHRcdFx0c2NhbGVTdGVwV2lkdGg6IG51bGwsXG5cdFx0XHRzY2FsZVN0YXJ0VmFsdWU6IG51bGwsXG5cdFx0XHRzY2FsZVN0ZXBzMjogbnVsbCxcblx0XHRcdHNjYWxlU3RlcFdpZHRoMjogbnVsbCxcblx0XHRcdHNjYWxlU3RhcnRWYWx1ZTI6IG51bGwsXG5cdFx0XHRzY2FsZUxpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLC4xKVwiLFxuXHRcdFx0c2NhbGVMaW5lU3R5bGU6IFwic29saWRcIixcblx0XHRcdHNjYWxlTGluZVdpZHRoOiAxLFxuXHRcdFx0c2NhbGVTaG93TGFiZWxzOiB0cnVlLFxuXHRcdFx0c2NhbGVTaG93TGFiZWxzMjogdHJ1ZSxcblx0XHRcdHNjYWxlTGFiZWw6IFwiPCU9dmFsdWUlPlwiLFxuXHRcdFx0c2NhbGVMYWJlbDI6IFwiPCU9dmFsdWUlPlwiLFxuXHRcdFx0c2NhbGVGb250RmFtaWx5OiBcIidBcmlhbCdcIixcblx0XHRcdHNjYWxlRm9udFNpemU6IDEyLFxuXHRcdFx0c2NhbGVGb250U3R5bGU6IFwibm9ybWFsXCIsXG5cdFx0XHRzY2FsZUZvbnRDb2xvcjogXCIjNjY2XCIsXG5cdFx0XHRzY2FsZVNob3dHcmlkTGluZXM6IHRydWUsXG5cdFx0XHRzY2FsZVhHcmlkTGluZXNTdGVwOiAxLFxuXHRcdFx0c2NhbGVZR3JpZExpbmVzU3RlcDogMSxcblx0XHRcdHNjYWxlR3JpZExpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLC4wNSlcIixcblx0XHRcdHNjYWxlR3JpZExpbmVXaWR0aDogMSxcblx0XHRcdHNjYWxlR3JpZExpbmVTdHlsZTogXCJzb2xpZFwiLFxuXHRcdFx0c2hvd1lBeGlzTWluOiB0cnVlLCAvLyBTaG93IHRoZSBtaW5pbXVtIHZhbHVlIG9uIFkgYXhpcyAoaW4gb3JpZ2luYWwgdmVyc2lvbiwgdGhpcyBtaW5pbXVtIGlzIG5vdCBkaXNwbGF5ZWQgLSBpdCBjYW4gb3ZlcmxhcCB0aGUgWCBsYWJlbHMpXG5cdFx0XHRyb3RhdGVMYWJlbHM6IFwic21hcnRcIiwgLy8gc21hcnQgPD0+IDAgZGVncmUgaWYgc3BhY2UgZW5vdWdoOyBvdGhlcndpc2UgNDUgZGVncmVzIGlmIHNwYWNlIGVub3VnaCBvdGhlcndpc2U5MCBkZWdyZTsgXG5cdFx0XHQvLyB5b3UgY2FuIGZvcmNlIGFuIGludGVnZXIgdmFsdWUgYmV0d2VlbiAwIGFuZCAxODAgZGVncmVzXG5cdFx0XHRsb2dhcml0aG1pYzogZmFsc2UsIC8vIGNhbiBiZSAnZnV6enknLHRydWUgYW5kIGZhbHNlICgnZnV6enknID0+IGlmIHRoZSBnYXAgYmV0d2VlbiBtaW4gYW5kIG1heGltdW0gaXMgYmlnIGl0J3MgdXNpbmcgYSBsb2dhcml0aG1pYyB5LUF4aXMgc2NhbGVcblx0XHRcdGxvZ2FyaXRobWljMjogZmFsc2UsIC8vIGNhbiBiZSAnZnV6enknLHRydWUgYW5kIGZhbHNlICgnZnV6enknID0+IGlmIHRoZSBnYXAgYmV0d2VlbiBtaW4gYW5kIG1heGltdW0gaXMgYmlnIGl0J3MgdXNpbmcgYSBsb2dhcml0aG1pYyB5LUF4aXMgc2NhbGVcblx0XHRcdHNjYWxlVGlja1NpemVMZWZ0OiA1LFxuXHRcdFx0c2NhbGVUaWNrU2l6ZVJpZ2h0OiA1LFxuXHRcdFx0c2NhbGVUaWNrU2l6ZUJvdHRvbTogNSxcblx0XHRcdHNjYWxlVGlja1NpemVUb3A6IDUsXG5cdFx0XHRiYXJTaG93U3Ryb2tlOiB0cnVlLFxuLy9cdFx0XHRiYXJTdHJva2VTdHlsZTogXCJzb2xpZFwiLFxuXHRcdFx0YmFyU3Ryb2tlV2lkdGg6IDIsXG5cdFx0XHRiYXJWYWx1ZVNwYWNpbmc6IDUsXG5cdFx0XHRiYXJEYXRhc2V0U3BhY2luZzogMSxcblx0XHRcdGJhckJvcmRlclJhZGl1czogMCxcblx0XHRcdHBvaW50RG90OiB0cnVlLFxuXHRcdFx0cG9pbnREb3RSYWRpdXM6IDQsXG5cdFx0XHRwb2ludERvdFN0cm9rZVN0eWxlOiBcInNvbGlkXCIsXG5cdFx0XHRwb2ludERvdFN0cm9rZVdpZHRoOiAyLFxuXHRcdFx0ZXh0cmFwb2xhdGVNaXNzaW5nRGF0YTogdHJ1ZSxcblx0XHRcdGFuaW1hdGlvbjogdHJ1ZSxcblx0XHRcdGFuaW1hdGlvblN0ZXBzOiA2MCxcblx0XHRcdGFuaW1hdGlvbkVhc2luZzogXCJlYXNlT3V0UXVhcnRcIixcblx0XHRcdG9uQW5pbWF0aW9uQ29tcGxldGU6IG51bGwsXG5cdFx0XHRiZXppZXJDdXJ2ZTogdHJ1ZSxcblx0XHRcdGxpbmtUeXBlIDogMCwgICAvLzAgOiBkaXJlY3QgcG9pbnQgdG8gcG9pbnQ7IDEgPSB2ZXJ0aWNhbCBsaW5lczsgMj1hbmd1bGFyIGxpbms7XG5cdFx0XHRiZXppZXJDdXJ2ZVRlbnNpb24gOiAwLjQsXG5cdFx0XHRhbm5vdGF0ZUxhYmVsOiBcIjwlPSh2MSA9PSAnJyA/ICcnIDogdjEpICsgKHYxIT0nJyAmJiB2MiAhPScnID8gJyAtICcgOiAnJykrKHYyID09ICcnID8gJycgOiB2MikrKHYxIT0nJyB8fCB2MiAhPScnID8gJzonIDogJycpICsgdjMgKyAnICgnICsgdjYgKyAnICUpJyU+XCIsXG5cdFx0XHRwb2ludEhpdERldGVjdGlvblJhZGl1cyA6IDEwXG5cdFx0fTtcblx0XHQvLyBtZXJnZSBhbm5vdGF0ZSBkZWZhdWx0c1xuXHRcdGlmKGlzSUUoKTw5ICYmIGlzSUUoKSAhPSBmYWxzZSljaGFydC5CYXIuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LmRlZmF1bHRzLklFeHBsb3JlcjgsIGNoYXJ0LkJhci5kZWZhdWx0cyk7XG5cdFx0Y2hhcnQuQmFyLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5kZWZhdWx0cy5jb21tb25PcHRpb25zLCBjaGFydC5CYXIuZGVmYXVsdHMpO1xuXHRcdGNoYXJ0LkJhci5kZWZhdWx0cyA9IG1lcmdlQ2hhcnRDb25maWcoY2hhcnQuZGVmYXVsdHMueHlBeGlzQ29tbW9uT3B0aW9ucywgY2hhcnQuQmFyLmRlZmF1bHRzKTtcblx0XHRjaGFydC5CYXIuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LkJhci5kZWZhdWx0cywgY2hhckpTUGVyc29uYWxEZWZhdWx0T3B0aW9ucyk7XG5cdFx0Y2hhcnQuQmFyLmRlZmF1bHRzID0gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5CYXIuZGVmYXVsdHMsIGNoYXJKU1BlcnNvbmFsRGVmYXVsdE9wdGlvbnNCYXIpO1xuXHRcdHZhciBjb25maWcgPSAob3B0aW9ucykgPyBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LkJhci5kZWZhdWx0cywgb3B0aW9ucykgOiBjaGFydC5CYXIuZGVmYXVsdHM7XG5cdFx0cmV0dXJuIG5ldyBCYXIoZGF0YSwgY29uZmlnLCBjb250ZXh0KTtcblx0fTtcblx0dGhpcy5Ib3Jpem9udGFsQmFyID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuXHRcdGNoYXJ0Lkhvcml6b250YWxCYXIuZGVmYXVsdHMgPSB7XG5cdFx0XHRhbm5vdGF0ZUJhck1pbmltdW1EZXRlY3Rpb25IZWlnaHQgOiAwLFxuXHRcdFx0aGlnaExpZ2h0U2V0IDogeyBwb2ludERvdFJhZGl1czogMTUsIGJhclN0cm9rZVdpZHRoIDogNSwgcG9pbnREb3QgOiB0cnVlIH0sXG5cdFx0XHRpbkdyYXBoRGF0YVNob3c6IGZhbHNlLFxuXHRcdFx0aW5HcmFwaERhdGFQYWRkaW5nWDogMyxcblx0XHRcdGluR3JhcGhEYXRhUGFkZGluZ1k6IDAsXG5cdFx0XHRpbkdyYXBoRGF0YVRtcGw6IFwiPCU9djMlPlwiLFxuXHRcdFx0aW5HcmFwaERhdGFBbGlnbjogXCJsZWZ0XCIsXG5cdFx0XHRpbkdyYXBoRGF0YVZBbGlnbjogXCJtaWRkbGVcIixcblx0XHRcdGluR3JhcGhEYXRhUm90YXRlOiAwLFxuXHRcdFx0aW5HcmFwaERhdGFGb250RmFtaWx5OiBcIidBcmlhbCdcIixcblx0XHRcdGluR3JhcGhEYXRhRm9udFNpemU6IDEyLFxuXHRcdFx0aW5HcmFwaERhdGFGb250U3R5bGU6IFwibm9ybWFsXCIsXG5cdFx0XHRpbkdyYXBoRGF0YUZvbnRDb2xvcjogXCIjNjY2XCIsXG5cdFx0XHRpbkdyYXBoRGF0YVhQb3NpdGlvbjogMyxcblx0XHRcdGluR3JhcGhEYXRhWVBvc2l0aW9uOiAyLFxuXHRcdFx0c2NhbGVPdmVybGF5OiBmYWxzZSxcblx0XHRcdHNjYWxlT3ZlcnJpZGU6IGZhbHNlLFxuXHRcdFx0c2NhbGVPdmVycmlkZTI6IGZhbHNlLFxuXHRcdFx0c2NhbGVTdGVwczogbnVsbCxcblx0XHRcdHNjYWxlU3RlcFdpZHRoOiBudWxsLFxuXHRcdFx0c2NhbGVTdGFydFZhbHVlOiBudWxsLFxuXHRcdFx0c2NhbGVMaW5lQ29sb3I6IFwicmdiYSgwLDAsMCwuMSlcIixcblx0XHRcdHNjYWxlTGluZVN0eWxlOiBcInNvbGlkXCIsXG5cdFx0XHRzY2FsZUxpbmVXaWR0aDogMSxcblx0XHRcdHNjYWxlU2hvd0xhYmVsczogdHJ1ZSxcblx0XHRcdHNjYWxlU2hvd0xhYmVsczI6IHRydWUsXG5cdFx0XHRzY2FsZUxhYmVsOiBcIjwlPXZhbHVlJT5cIixcblx0XHRcdHNjYWxlRm9udEZhbWlseTogXCInQXJpYWwnXCIsXG5cdFx0XHRzY2FsZUZvbnRTaXplOiAxMixcblx0XHRcdHNjYWxlRm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuXHRcdFx0c2NhbGVGb250Q29sb3I6IFwiIzY2NlwiLFxuXHRcdFx0c2NhbGVTaG93R3JpZExpbmVzOiB0cnVlLFxuXHRcdFx0c2NhbGVYR3JpZExpbmVzU3RlcDogMSxcblx0XHRcdHNjYWxlWUdyaWRMaW5lc1N0ZXA6IDEsXG5cdFx0XHRzY2FsZUdyaWRMaW5lQ29sb3I6IFwicmdiYSgwLDAsMCwuMDUpXCIsXG5cdFx0XHRzY2FsZUdyaWRMaW5lU3R5bGU6IFwic29saWRcIixcblx0XHRcdHNjYWxlR3JpZExpbmVXaWR0aDogMSxcblx0XHRcdHNjYWxlVGlja1NpemVMZWZ0OiA1LFxuXHRcdFx0c2NhbGVUaWNrU2l6ZVJpZ2h0OiA1LFxuXHRcdFx0c2NhbGVUaWNrU2l6ZUJvdHRvbTogNSxcblx0XHRcdHNjYWxlVGlja1NpemVUb3A6IDUsXG5cdFx0XHRzaG93WUF4aXNNaW46IHRydWUsIC8vIFNob3cgdGhlIG1pbmltdW0gdmFsdWUgb24gWSBheGlzIChpbiBvcmlnaW5hbCB2ZXJzaW9uLCB0aGlzIG1pbmltdW0gaXMgbm90IGRpc3BsYXllZCAtIGl0IGNhbiBvdmVybGFwIHRoZSBYIGxhYmVscylcblx0XHRcdHJvdGF0ZUxhYmVsczogXCJzbWFydFwiLCAvLyBzbWFydCA8PT4gMCBkZWdyZSBpZiBzcGFjZSBlbm91Z2g7IG90aGVyd2lzZSA0NSBkZWdyZXMgaWYgc3BhY2UgZW5vdWdoIG90aGVyd2lzZTkwIGRlZ3JlOyBcblx0XHRcdGJhclNob3dTdHJva2U6IHRydWUsXG4vL1x0XHRcdGJhclN0cm9rZVN0eWxlOiBcInNvbGlkXCIsXG5cdFx0XHRiYXJTdHJva2VXaWR0aDogMixcblx0XHRcdGJhclZhbHVlU3BhY2luZzogNSxcblx0XHRcdGJhckRhdGFzZXRTcGFjaW5nOiAxLFxuXHRcdFx0YmFyQm9yZGVyUmFkaXVzOiAwLFxuXHRcdFx0YW5pbWF0aW9uOiB0cnVlLFxuXHRcdFx0YW5pbWF0aW9uU3RlcHM6IDYwLFxuXHRcdFx0YW5pbWF0aW9uRWFzaW5nOiBcImVhc2VPdXRRdWFydFwiLFxuXHRcdFx0b25BbmltYXRpb25Db21wbGV0ZTogbnVsbCxcblx0XHRcdGFubm90YXRlTGFiZWw6IFwiPCU9KHYxID09ICcnID8gJycgOiB2MSkgKyAodjEhPScnICYmIHYyICE9JycgPyAnIC0gJyA6ICcnKSsodjIgPT0gJycgPyAnJyA6IHYyKSsodjEhPScnIHx8IHYyICE9JycgPyAnOicgOiAnJykgKyB2MyArICcgKCcgKyB2NiArICcgJSknJT5cIixcblx0XHRcdHJldmVyc2VPcmRlcjogZmFsc2Vcblx0XHR9O1xuXHRcdC8vIG1lcmdlIGFubm90YXRlIGRlZmF1bHRzXG5cdFx0aWYoaXNJRSgpPDkgJiYgaXNJRSgpICE9IGZhbHNlKWNoYXJ0Lkhvcml6b250YWxCYXIuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LmRlZmF1bHRzLklFeHBsb3JlcjgsIGNoYXJ0Lkhvcml6b250YWxCYXIuZGVmYXVsdHMpO1xuXHRcdGNoYXJ0Lkhvcml6b250YWxCYXIuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LmRlZmF1bHRzLmNvbW1vbk9wdGlvbnMsIGNoYXJ0Lkhvcml6b250YWxCYXIuZGVmYXVsdHMpO1xuXHRcdGNoYXJ0Lkhvcml6b250YWxCYXIuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0LmRlZmF1bHRzLnh5QXhpc0NvbW1vbk9wdGlvbnMsIGNoYXJ0Lkhvcml6b250YWxCYXIuZGVmYXVsdHMpO1xuXHRcdGNoYXJ0Lkhvcml6b250YWxCYXIuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0Lkhvcml6b250YWxCYXIuZGVmYXVsdHMsIGNoYXJKU1BlcnNvbmFsRGVmYXVsdE9wdGlvbnMpO1xuXHRcdGNoYXJ0Lkhvcml6b250YWxCYXIuZGVmYXVsdHMgPSBtZXJnZUNoYXJ0Q29uZmlnKGNoYXJ0Lkhvcml6b250YWxCYXIuZGVmYXVsdHMsIGNoYXJKU1BlcnNvbmFsRGVmYXVsdE9wdGlvbnNIb3Jpem9udGFsQmFyKTtcblx0XHR2YXIgY29uZmlnID0gKG9wdGlvbnMpID8gbWVyZ2VDaGFydENvbmZpZyhjaGFydC5Ib3Jpem9udGFsQmFyLmRlZmF1bHRzLCBvcHRpb25zKSA6IGNoYXJ0Lkhvcml6b250YWxCYXIuZGVmYXVsdHM7XG5cdFx0cmV0dXJuIG5ldyBIb3Jpem9udGFsQmFyKGRhdGEsIGNvbmZpZywgY29udGV4dCk7XG5cdH07XG5cdGNoYXJ0LmRlZmF1bHRzID0ge307XG5cdFxuXHRjaGFydC5kZWZhdWx0cy5JRXhwbG9yZXI4ID17XG5cdFx0YW5ub3RhdGVCYWNrZ3JvdW5kQ29sb3IgOiBcImJsYWNrXCIsXG5cdFx0YW5ub3RhdGVGb250Q29sb3I6IFwid2hpdGVcIlxuXHR9O1xuXHRjaGFydC5kZWZhdWx0cy5jb21tb25PcHRpb25zID0ge1xuXHRcdGNoYXJ0VGV4dFNjYWxlIDogMSxcblx0XHRjaGFydExpbmVTY2FsZSA6IDEsXG5cdFx0Y2hhcnRTcGFjZVNjYWxlIDogMSxcblx0XHRtdWx0aUdyYXBoOiBmYWxzZSxcblx0XHRjbGVhclJlY3Q6IHRydWUsIC8vIGRvIG5vdCBjaGFuZ2UgY2xlYXJSZWN0IG9wdGlvbnM7IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuXHRcdGR5bmFtaWNEaXNwbGF5OiBmYWxzZSxcblx0XHRkeW5hbWljRGlzcGxheVhQYXJ0T2ZDaGFydCA6IDAuNSxcblx0XHRkeW5hbWljRGlzcGxheVlQYXJ0T2ZDaGFydCA6IDAuNSxcblx0XHRhbmltYXRpb25Gb3JjZVNldFRpbWVPdXQgOiBmYWxzZSxcblx0XHRncmFwaFNwYWNlQmVmb3JlOiA1LFxuXHRcdGdyYXBoU3BhY2VBZnRlcjogNSxcblx0XHRjYW52YXNCb3JkZXJzOiBmYWxzZSxcblx0XHRjYW52YXNCYWNrZ3JvdW5kQ29sb3I6IFwibm9uZVwiLFxuXHRcdGNhbnZhc0JvcmRlcnNSYWRpdXMgOiAwLFxuXHRcdGNhbnZhc0JvcmRlcnNXaWR0aDogMyxcblx0XHRjYW52YXNCb3JkZXJzU3R5bGU6IFwic29saWRcIixcblx0XHRjYW52YXNCb3JkZXJzQ29sb3I6IFwiYmxhY2tcIixcblx0XHR6ZXJvVmFsdWUgOiAwLjAwMDAwMDAwMDEsXG5cdFx0Z3JhcGhUaXRsZTogXCJcIixcblx0XHRncmFwaFRpdGxlRm9udEZhbWlseTogXCInQXJpYWwnXCIsXG5cdFx0Z3JhcGhUaXRsZUZvbnRTaXplOiAyNCxcblx0XHRncmFwaFRpdGxlRm9udFN0eWxlOiBcImJvbGRcIixcblx0XHRncmFwaFRpdGxlRm9udENvbG9yOiBcIiM2NjZcIixcblx0XHRncmFwaFRpdGxlU3BhY2VCZWZvcmU6IDUsXG5cdFx0Z3JhcGhUaXRsZVNwYWNlQWZ0ZXI6IDUsXG5cdFx0Z3JhcGhUaXRsZUJvcmRlcnMgOiBmYWxzZSxcblx0XHRncmFwaFRpdGxlQm9yZGVyc1JhZGl1cyA6IDAsXG5cdFx0Z3JhcGhUaXRsZUJvcmRlcnNDb2xvciA6IFwiYmxhY2tcIixcblx0XHRncmFwaFRpdGxlQm9yZGVyc1hTcGFjZSA6IDMsXG5cdFx0Z3JhcGhUaXRsZUJvcmRlcnNZU3BhY2UgOiAzLFxuXHRcdGdyYXBoVGl0bGVCb3JkZXJzV2lkdGggOiAxLFxuXHRcdGdyYXBoVGl0bGVCb3JkZXJzU3R5bGUgOiBcInNvbGlkXCIsXG5cdFx0Z3JhcGhUaXRsZUJhY2tncm91bmRDb2xvciA6IFwibm9uZVwiLFxuICAgXHRcdGdyYXBoU3ViVGl0bGU6IFwiXCIsXG5cdFx0Z3JhcGhTdWJUaXRsZUZvbnRGYW1pbHk6IFwiJ0FyaWFsJ1wiLFxuXHRcdGdyYXBoU3ViVGl0bGVGb250U2l6ZTogMTgsXG5cdFx0Z3JhcGhTdWJUaXRsZUZvbnRTdHlsZTogXCJub3JtYWxcIixcblx0XHRncmFwaFN1YlRpdGxlRm9udENvbG9yOiBcIiM2NjZcIixcblx0XHRncmFwaFN1YlRpdGxlU3BhY2VCZWZvcmU6IDUsXG5cdFx0Z3JhcGhTdWJUaXRsZVNwYWNlQWZ0ZXI6IDUsXG5cdFx0Z3JhcGhTdWJUaXRsZUJvcmRlcnMgOiBmYWxzZSxcblx0XHRncmFwaFN1YlRpdGxlQm9yZGVyc0NvbG9yIDogXCJibGFja1wiLFxuICAgICAgICAgICAgICAgIGdyYXBoU3ViVGl0bGVCb3JkZXJzUmFkaXVzIDogMCxcblx0XHRncmFwaFN1YlRpdGxlQm9yZGVyc1hTcGFjZSA6IDMsXG5cdFx0Z3JhcGhTdWJUaXRsZUJvcmRlcnNZU3BhY2UgOiAzLFxuXHRcdGdyYXBoU3ViVGl0bGVCb3JkZXJzV2lkdGggOiAxLFxuXHRcdGdyYXBoU3ViVGl0bGVCb3JkZXJzU3R5bGUgOiBcInNvbGlkXCIsXG5cdFx0Z3JhcGhTdWJUaXRsZUJhY2tncm91bmRDb2xvciA6IFwibm9uZVwiLFxuXHRcdGZvb3ROb3RlOiBcIlwiLFxuXHRcdGZvb3ROb3RlRm9udEZhbWlseTogXCInQXJpYWwnXCIsXG5cdFx0Zm9vdE5vdGVGb250U2l6ZTogOCxcblx0XHRmb290Tm90ZUZvbnRTdHlsZTogXCJib2xkXCIsXG5cdFx0Zm9vdE5vdGVGb250Q29sb3I6IFwiIzY2NlwiLFxuXHRcdGZvb3ROb3RlU3BhY2VCZWZvcmU6IDUsXG5cdFx0Zm9vdE5vdGVTcGFjZUFmdGVyOiA1LFxuXHRcdGZvb3ROb3RlQm9yZGVycyA6IGZhbHNlLFxuXHRcdGZvb3ROb3RlQm9yZGVyc0NvbG9yIDogXCJibGFja1wiLFxuICAgICAgICAgICAgICAgIGZvb3ROb3RlQm9yZGVyc1JhZGl1cyA6IDAsXG5cdFx0Zm9vdE5vdGVCb3JkZXJzWFNwYWNlIDogMyxcblx0XHRmb290Tm90ZUJvcmRlcnNZU3BhY2UgOiAzLFxuXHRcdGZvb3ROb3RlQm9yZGVyc1dpZHRoIDogMSxcblx0XHRmb290Tm90ZUJvcmRlcnNTdHlsZSA6IFwic29saWRcIixcblx0XHRmb290Tm90ZUJhY2tncm91bmRDb2xvciA6IFwibm9uZVwiLFxuXHRcdGxlZ2VuZCA6IGZhbHNlLFxuXHRcdHNob3dTaW5nbGVMZWdlbmQ6IGZhbHNlLFxuXHRcdG1heExlZ2VuZENvbHMgOiA5OTksXG5cdFx0bGVnZW5kUG9zWSA6NCxcblx0XHRsZWdlbmRQb3NYIDogLTIsIFxuXHRcdGxlZ2VuZEZvbnRGYW1pbHk6IFwiJ0FyaWFsJ1wiLFxuXHRcdGxlZ2VuZEZvbnRTaXplOiAxMixcblx0XHRsZWdlbmRGb250U3R5bGU6IFwibm9ybWFsXCIsXG5cdFx0bGVnZW5kRm9udENvbG9yOiBcIiM2NjZcIixcblx0XHRsZWdlbmRCbG9ja1NpemU6IDE1LFxuICAgICAgICAgICAgICAgIGxlZ2VuZEJsb2NrUmFkaXVzOjAsXG5cdFx0bGVnZW5kQm9yZGVyczogdHJ1ZSxcblx0XHRsZWdlbmRCb3JkZXJzU3R5bGU6IFwic29saWRcIixcblx0XHRsZWdlbmRCb3JkZXJzV2lkdGg6IDEsXG5cdFx0bGVnZW5kQm9yZGVyc0NvbG9yczogXCIjNjY2XCIsXG4gICAgICAgICAgICAgICAgbGVnZW5kQm9yZGVyc1JhZGl1czogMCxcblx0XHRsZWdlbmRCb3JkZXJzU3BhY2VCZWZvcmU6IDUsXG5cdFx0bGVnZW5kQm9yZGVyc1NwYWNlQWZ0ZXI6IDUsXG5cdFx0bGVnZW5kQm9yZGVyc1NwYWNlTGVmdDogNSxcblx0XHRsZWdlbmRCb3JkZXJzU3BhY2VSaWdodDogNSxcblx0XHRsZWdlbmRTcGFjZUJlZm9yZVRleHQ6IDUsXG5cdFx0bGVnZW5kU3BhY2VBZnRlclRleHQ6IDUsXG5cdFx0bGVnZW5kU3BhY2VMZWZ0VGV4dDogNSxcblx0XHRsZWdlbmRTcGFjZVJpZ2h0VGV4dDogNSxcblx0XHRsZWdlbmRTcGFjZUJldHdlZW5UZXh0VmVydGljYWw6IDUsXG5cdFx0bGVnZW5kU3BhY2VCZXR3ZWVuVGV4dEhvcml6b250YWw6IDUsXG5cdFx0bGVnZW5kU3BhY2VCZXR3ZWVuQm94QW5kVGV4dDogNSxcblx0XHRsZWdlbmRGaWxsQ29sb3IgOiBcInJnYmEoMCwwLDAsMClcIixcblx0XHRsZWdlbmRYUGFkZGluZyA6IDAsXG5cdFx0bGVnZW5kWVBhZGRpbmcgOiAwLFxuXHRcdGluR3JhcGhEYXRhQm9yZGVycyA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGluR3JhcGhEYXRhQm9yZGVyc1JhZGl1cyA6IDAsXG5cdFx0aW5HcmFwaERhdGFCb3JkZXJzQ29sb3IgOiBcImJsYWNrXCIsXG5cdFx0aW5HcmFwaERhdGFCb3JkZXJzWFNwYWNlIDogMyxcblx0XHRpbkdyYXBoRGF0YUJvcmRlcnNZU3BhY2UgOiAzLFxuXHRcdGluR3JhcGhEYXRhQm9yZGVyc1dpZHRoIDogMSxcblx0XHRpbkdyYXBoRGF0YUJvcmRlcnNTdHlsZSA6IFwic29saWRcIixcblx0XHRpbkdyYXBoRGF0YUJhY2tncm91bmRDb2xvciA6IFwibm9uZVwiLFxuXHRcdGFubm90YXRlRGlzcGxheTogZmFsc2UsXG5cdFx0YW5ub3RhdGVSZWxvY2F0ZTogZmFsc2UsXG5cdFx0c2F2ZVBuZzogZmFsc2UsXG5cdFx0c2F2ZVBuZ091dHB1dDogXCJOZXdXaW5kb3dcIiwgLy8gQWxsb3dlZCB2YWx1ZXMgOiBcIk5ld1dpbmRvd1wiLCBcIkN1cnJlbnRXaW5kb3dcIiwgXCJTYXZlXCJcblx0XHRzYXZlUG5nRnVuY3Rpb246IFwibW91c2Vkb3duIHJpZ2h0XCIsXG5cdFx0c2F2ZVBuZ0JhY2tncm91bmRDb2xvcjogJ1dISVRFJyxcblx0XHRhbm5vdGF0ZUZ1bmN0aW9uOiBcIm1vdXNlbW92ZVwiLFxuXHRcdGFubm90YXRlRm9udEZhbWlseTogXCInQXJpYWwnXCIsXG5cdFx0YW5ub3RhdGVCb3JkZXI6ICdub25lJyxcblx0XHRhbm5vdGF0ZUJvcmRlclJhZGl1czogJzJweCcsXG5cdFx0YW5ub3RhdGVCYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuXHRcdGFubm90YXRlRm9udFNpemU6IDEyLFxuXHRcdGFubm90YXRlRm9udENvbG9yOiAnd2hpdGUnLFxuXHRcdGFubm90YXRlRm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuXHRcdGFubm90YXRlUGFkZGluZzogXCIzcHhcIixcblx0XHRhbm5vdGF0ZUNsYXNzTmFtZTogXCJcIixcblx0XHRhbm5vdGF0ZUZ1bmN0aW9uSW46IG51bGwsXG5cdFx0YW5ub3RhdGVGdW5jdGlvbk91dCA6IG51bGwsXG5cdFx0ZGV0ZWN0TW91c2VPblRleHQ6IGZhbHNlLFxuXHRcdGNyb3NzVGV4dDogW1wiXCJdLFxuXHRcdGNyb3NzVGV4dEl0ZXI6IFtcImFsbFwiXSxcblx0XHRjcm9zc1RleHRPdmVybGF5OiBbdHJ1ZV0sXG5cdFx0Y3Jvc3NUZXh0Rm9udEZhbWlseTogW1wiJ0FyaWFsJ1wiXSxcblx0XHRjcm9zc1RleHRGb250U2l6ZTogWzEyXSxcblx0XHRjcm9zc1RleHRGb250U3R5bGU6IFtcIm5vcm1hbFwiXSxcblx0XHRjcm9zc1RleHRGb250Q29sb3I6IFtcInJnYmEoMjIwLDIyMCwyMjAsMSlcIl0sXG5cdFx0Y3Jvc3NUZXh0UmVsYXRpdmVQb3NYOiBbMl0sXG5cdFx0Y3Jvc3NUZXh0UmVsYXRpdmVQb3NZOiBbMl0sXG5cdFx0Y3Jvc3NUZXh0QmFzZWxpbmU6IFtcIm1pZGRsZVwiXSxcblx0XHRjcm9zc1RleHRBbGlnbjogW1wiY2VudGVyXCJdLFxuXHRcdGNyb3NzVGV4dFBvc1g6IFswXSxcblx0XHRjcm9zc1RleHRQb3NZOiBbMF0sXG5cdFx0Y3Jvc3NUZXh0QW5nbGU6IFswXSxcblx0XHRjcm9zc1RleHRGdW5jdGlvbjogbnVsbCxcblx0XHRjcm9zc1RleHRCb3JkZXJzIDogW2ZhbHNlXSxcblx0XHRjcm9zc1RleHRCb3JkZXJzQ29sb3IgOiBbXCJibGFja1wiXSxcbiAgICAgICAgICAgICAgICBjcm9zc1RleHRCb3JkZXJzUmFkaXVzIDogWzBdLFxuXHRcdGNyb3NzVGV4dEJvcmRlcnNYU3BhY2UgOiBbM10sXG5cdFx0Y3Jvc3NUZXh0Qm9yZGVyc1lTcGFjZSA6IFszXSxcblx0XHRjcm9zc1RleHRCb3JkZXJzV2lkdGggOiBbMV0sXG5cdFx0Y3Jvc3NUZXh0Qm9yZGVyc1N0eWxlIDogW1wic29saWRcIl0sXG5cdFx0Y3Jvc3NUZXh0QmFja2dyb3VuZENvbG9yIDogW1wibm9uZVwiXSxcblx0XHRjcm9zc0ltYWdlOiBbdW5kZWZpbmVkXSxcblx0XHRjcm9zc0ltYWdlSXRlcjogW1wiYWxsXCJdLFxuXHRcdGNyb3NzSW1hZ2VPdmVybGF5OiBbdHJ1ZV0sXG5cdFx0Y3Jvc3NJbWFnZVJlbGF0aXZlUG9zWDogWzJdLFxuXHRcdGNyb3NzSW1hZ2VSZWxhdGl2ZVBvc1k6IFsyXSxcblx0XHRjcm9zc0ltYWdlQmFzZWxpbmU6IFtcIm1pZGRsZVwiXSxcblx0XHRjcm9zc0ltYWdlQWxpZ246IFtcImNlbnRlclwiXSxcblx0XHRjcm9zc0ltYWdlUG9zWDogWzBdLFxuXHRcdGNyb3NzSW1hZ2VQb3NZOiBbMF0sXG5cdFx0Y3Jvc3NJbWFnZUFuZ2xlOiBbMF0sXG5cdFx0c3BhY2VUb3A6IDAsXG5cdFx0c3BhY2VCb3R0b206IDAsXG5cdFx0c3BhY2VSaWdodDogMCxcblx0XHRzcGFjZUxlZnQ6IDAsXG5cdFx0ZGVjaW1hbFNlcGFyYXRvcjogXCIuXCIsXG5cdFx0dGhvdXNhbmRTZXBhcmF0b3I6IFwiXCIsXG5cdFx0Y3VycmVuY3kgOiBcIlxcdTIwQUNcIiwgICAgLy8gMjBBQz0gRXVyb1xuXHRcdGN1cnJlbmN5UG9zaXRpb24gOiBcImFmdGVyXCIsXG5cdFx0cm91bmROdW1iZXI6IFwibm9uZVwiLFxuXHRcdHJvdW5kUGN0OiAtMSxcblx0XHR0ZW1wbGF0ZXNPcGVuVGFnIDogXCI8JT1cIixcblx0XHR0ZW1wbGF0ZXNDbG9zZVRhZyA6IFwiJT5cIixcblx0XHRmbXRWMTogXCJub25lXCIsXG5cdFx0Zm10VjI6IFwibm9uZVwiLFxuXHRcdGZtdFYzOiBcIm5vbmVcIixcblx0XHRmbXRWNDogXCJub25lXCIsXG5cdFx0Zm10VjU6IFwibm9uZVwiLFxuXHRcdGZtdFY2OiBcIm5vbmVcIixcblx0XHRmbXRWNlQ6IFwibm9uZVwiLFxuXHRcdGZtdFY3OiBcIm5vbmVcIixcblx0XHRmbXRWODogXCJub25lXCIsXG5cdFx0Zm10VjhUOiBcIm5vbmVcIixcblx0XHRmbXRWOTogXCJub25lXCIsXG5cdFx0Zm10VjEwOiBcIm5vbmVcIixcblx0XHRmbXRWMTE6IFwibm9uZVwiLFxuXHRcdGZtdFYxMjogXCJub25lXCIsXG5cdFx0Zm10VjEzOiBcIm5vbmVcIixcblx0XHRmbXRYTGFiZWw6IFwibm9uZVwiLFxuXHRcdGZtdFlMYWJlbDogXCJub25lXCIsXG5cdFx0Zm10WUxhYmVsMjogXCJub25lXCIsXG5cdFx0Zm10TGVnZW5kOiBcIm5vbmVcIixcblx0XHRhbmltYXRpb25TdGFydFZhbHVlOiAwLFxuXHRcdGFuaW1hdGlvblN0b3BWYWx1ZTogMSxcblx0XHRhbmltYXRpb25Db3VudDogMSxcblx0XHRhbmltYXRpb25QYXVzZVRpbWU6IDUsXG5cdFx0YW5pbWF0aW9uQmFja3dhcmQ6IGZhbHNlLFxuXHRcdGFuaW1hdGlvblN0YXJ0V2l0aERhdGFzZXQ6IDEsXG5cdFx0YW5pbWF0aW9uU3RhcnRXaXRoRGF0YTogMSxcblx0XHRhbmltYXRpb25MZWZ0VG9SaWdodDogZmFsc2UsXG5cdFx0YW5pbWF0aW9uQnlEYXRhc2V0OiBmYWxzZSxcblx0XHRkZWZhdWx0U3Ryb2tlQ29sb3I6IFwicmdiYSgyMjAsMjIwLDIyMCwxKVwiLFxuXHRcdGRlZmF1bHRGaWxsQ29sb3I6IFwicmdiYSgyMjAsMjIwLDIyMCwwLjUpXCIsXG5cdFx0ZGVmYXVsdExpbmVXaWR0aCA6IDIsXG5cdFx0Z3JhcGhNYXhpbWl6ZWQ6IGZhbHNlLFxuXHRcdGNvbnRleHRNZW51OiB0cnVlLFxuXHRcdG1vdXNlRG93blJpZ2h0OiBudWxsLFxuXHRcdG1vdXNlRG93bkxlZnQ6IG51bGwsXG5cdFx0bW91c2VEb3duTWlkZGxlOiBudWxsLFxuXHRcdG1vdXNlTW92ZTogbnVsbCxcblx0XHRtb3VzZU91dDogbnVsbCxcblx0XHRtb3VzZURibENsaWNrOiBudWxsLFxuXHRcdG1vdXNlV2hlZWwgOiBudWxsLFxuXHRcdGhpZ2hMaWdodCA6IGZhbHNlLFxuXHRcdGhpZ2hMaWdodE1vdXNlRnVuY3Rpb24gOiBcIm1vdXNlbW92ZVwiLFxuXHRcdGhpZ2hMaWdodEZ1bGxMaW5lIDogZmFsc2UsICAgLy8gdHJ1ZSwgZmFsc2Ugb3IgXCJncm91cFwiXG5cdFx0aGlnaExpZ2h0UmVydW5FbmRGdW5jdGlvbiA6IGZhbHNlLFxuXHRcdHNhdmVQbmdOYW1lOiBcImNhbnZhc1wiLFxuXHRcdHJlc3BvbnNpdmUgOiBmYWxzZSxcblx0XHRyZXNwb25zaXZlTWluV2lkdGggOiAwLFxuXHRcdHJlc3BvbnNpdmVNaW5IZWlnaHQgOiAwLFxuXHRcdHJlc3BvbnNpdmVNYXhXaWR0aCA6IDk5OTk5OTksXG5cdFx0cmVzcG9uc2l2ZU1heEhlaWdodCA6IDk5OTk5OTksXG5cdFx0bWFpbnRhaW5Bc3BlY3RSYXRpbzogdHJ1ZSxcblx0XHRyZXNwb25zaXZlU2NhbGVDb250ZW50IDogZmFsc2UsXG5cdFx0cmVzcG9uc2l2ZVdpbmRvd0luaXRpYWxXaWR0aCA6IGZhbHNlLFxuXHRcdHBvaW50TWFya2VyIDogXCJjaXJjbGVcIiwgICAgLy8gXCJjaXJjbGVcIixcImNyb3NzXCIsXCJwbHVzXCIsXCJkaWFtb25kXCIsXCJ0cmlhbmdsZVwiLFwic3F1YXJlXCJcblx0XHRpbml0RnVuY3Rpb24gOiBudWxsLFxuXHRcdGJlZm9yZURyYXdGdW5jdGlvbiA6IG51bGwsXG5cdFx0ZW5kRHJhd0RhdGFGdW5jdGlvbiA6IG51bGwsXG5cdFx0ZW5kRHJhd1NjYWxlRnVuY3Rpb24gOiBudWxsXG5cdH07XG5cblxuXHRjaGFydC5kZWZhdWx0cy5QaWVBbmREb3VnaG51dCA9IHtcblx0XHRcdGhpZ2hMaWdodFNldCA6IHsgZXhwYW5kT3V0UmFkaXVzIDogMC4xMCwgZXhwYW5kSW5SYWRpdXMgOiAtMC4xMCB9LFxuXHRcdFx0aW5HcmFwaERhdGFTaG93OiBmYWxzZSxcblx0XHRcdGluR3JhcGhEYXRhUGFkZGluZ1JhZGl1czogNSxcblx0XHRcdGluR3JhcGhEYXRhUGFkZGluZ0FuZ2xlOiAwLFxuXHRcdFx0aW5HcmFwaERhdGFUbXBsOiBcIjwlPSh2MSA9PSAnJz8gJycgOiB2MSsnOicpKyB2MiArICcgKCcgKyB2NiArICcgJSknJT5cIixcblx0XHRcdGluR3JhcGhEYXRhQWxpZ246IFwib2ZmLWNlbnRlclwiLCAvLyBcInJpZ2h0XCIsIFwiY2VudGVyXCIsIFwibGVmdFwiLCBcIm9mZi1jZW50ZXJcIiBvciBcInRvLWNlbnRlclwiXG5cdFx0XHRpbkdyYXBoRGF0YVZBbGlnbjogXCJvZmYtY2VudGVyXCIsIC8vIFwiYm90dG9tXCIsIFwibWlkZGxlXCIsIFwidG9wXCIsIFwib2ZmLWNlbnRlclwiIG9yIFwidG8tY2VudGVyXCJcblx0XHRcdGluR3JhcGhEYXRhUm90YXRlOiAwLCAvLyByb3RhdGVBbmdsZSB2YWx1ZSAoMC0+MzYwKSAsIFwiaW5SYWRpdXNBeGlzXCIgb3IgXCJpblJhZGl1c0F4aXNSb3RhdGVMYWJlbHNcIlxuXHRcdFx0aW5HcmFwaERhdGFGb250RmFtaWx5OiBcIidBcmlhbCdcIixcblx0XHRcdGluR3JhcGhEYXRhRm9udFNpemU6IDEyLFxuXHRcdFx0aW5HcmFwaERhdGFGb250U3R5bGU6IFwibm9ybWFsXCIsXG5cdFx0XHRpbkdyYXBoRGF0YUZvbnRDb2xvcjogXCIjNjY2XCIsXG5cdFx0XHRpbkdyYXBoRGF0YVJhZGl1c1Bvc2l0aW9uOiAzLFxuXHRcdFx0aW5HcmFwaERhdGFBbmdsZVBvc2l0aW9uOiAyLFxuXHRcdCAgICAgICAgaW5HcmFwaERhdGFNaW5pbXVtQW5nbGUgOiAwLFxuXHRcdFx0c2VnbWVudFNob3dTdHJva2U6IHRydWUsXG5cdFx0XHRzZWdtZW50U3Ryb2tlQ29sb3I6IFwiI2ZmZlwiLFxuXHRcdFx0c2VnbWVudFN0cm9rZVN0eWxlOiBcInNvbGlkXCIsXG5cdFx0XHRzZWdtZW50U3Ryb2tlV2lkdGg6IDIsXG5cdFx0XHRwZXJjZW50YWdlSW5uZXJDdXRvdXQ6IDUwLFxuXHRcdFx0YW5pbWF0aW9uOiB0cnVlLFxuXHRcdFx0YW5pbWF0aW9uQnlEYXRhIDogZmFsc2UsXG5cdFx0XHRhbmltYXRpb25TdGVwczogMTAwLFxuXHRcdFx0YW5pbWF0aW9uRWFzaW5nOiBcImVhc2VPdXRCb3VuY2VcIixcblx0XHRcdGFuaW1hdGVSb3RhdGU6IHRydWUsXG5cdFx0XHRhbmltYXRlU2NhbGU6IGZhbHNlLFxuXHRcdFx0b25BbmltYXRpb25Db21wbGV0ZTogbnVsbCxcblx0XHRcdGFubm90YXRlTGFiZWw6IFwiPCU9KHYxID09ICcnPyAnJyA6IHYxKyc6JykrIHYyICsgJyAoJyArIHY2ICsgJyAlKSclPlwiLFxuXHRcdFx0c3RhcnRBbmdsZTogOTAsXG5cdFx0XHR0b3RhbEFtcGxpdHVkZSA6IDM2MCxcblx0XHRcdHJhZGl1c1NjYWxlOiAxXG5cdH07XG5cblx0Y2hhcnQuZGVmYXVsdHMueHlBeGlzQ29tbW9uT3B0aW9ucyA9IHtcblx0XHRtYXhCYXJXaWR0aCA6IC0xLFxuXHRcdHlBeGlzTWluaW11bUludGVydmFsOiBcIm5vbmVcIixcblx0XHR5QXhpc01pbmltdW1JbnRlcnZhbDI6IFwibm9uZVwiLFxuXHRcdHlTY2FsZUxhYmVsc01pbmltdW1XaWR0aDogMCxcblx0XHR4U2NhbGVMYWJlbHNNaW5pbXVtV2lkdGg6IDAsXG5cdFx0eUF4aXNMZWZ0OiB0cnVlLFxuXHRcdHlBeGlzUmlnaHQ6IGZhbHNlLFxuXHRcdHhBeGlzQm90dG9tOiB0cnVlLFxuXHRcdHhBeGlzVG9wOiBmYWxzZSxcblx0XHR4QXhpc1NwYWNlQmV0d2VlbkxhYmVsczogNSxcblx0XHRmdWxsV2lkdGhHcmFwaDogZmFsc2UsXG5cdFx0eUF4aXNMYWJlbDogXCJcIixcblx0XHR5QXhpc0xhYmVsMjogXCJcIixcblx0XHR5QXhpc0ZvbnRGYW1pbHk6IFwiJ0FyaWFsJ1wiLFxuXHRcdHlBeGlzRm9udFNpemU6IDE2LFxuXHRcdHlBeGlzRm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuXHRcdHlBeGlzRm9udENvbG9yOiBcIiM2NjZcIixcblx0XHR5QXhpc0xhYmVsU3BhY2VSaWdodDogNSxcblx0XHR5QXhpc0xhYmVsU3BhY2VMZWZ0OiA1LFxuXHRcdHlBeGlzU3BhY2VSaWdodDogNSxcblx0XHR5QXhpc1NwYWNlTGVmdDogNSxcblx0XHR5QXhpc0xhYmVsQm9yZGVycyA6IGZhbHNlLFxuXHRcdHlBeGlzTGFiZWxCb3JkZXJzQ29sb3IgOiBcImJsYWNrXCIsXG4gICAgICAgICAgICAgICAgeUF4aXNMYWJlbEJvcmRlcnNSYWRpdXMgOiAwLFxuXHRcdHlBeGlzTGFiZWxCb3JkZXJzWFNwYWNlIDogMyxcblx0XHR5QXhpc0xhYmVsQm9yZGVyc1lTcGFjZSA6IDMsXG5cdFx0eUF4aXNMYWJlbEJvcmRlcnNXaWR0aCA6IDEsXG5cdFx0eUF4aXNMYWJlbEJvcmRlcnNTdHlsZSA6IFwic29saWRcIixcblx0XHR5QXhpc0xhYmVsQmFja2dyb3VuZENvbG9yIDogXCJub25lXCIsXG5cdFx0eEF4aXNMYWJlbDogXCJcIixcblx0XHR4QXhpc0ZvbnRGYW1pbHk6IFwiJ0FyaWFsJ1wiLFxuXHRcdHhBeGlzRm9udFNpemU6IDE2LFxuXHRcdHhBeGlzRm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuXHRcdHhBeGlzRm9udENvbG9yOiBcIiM2NjZcIixcblx0XHR4QXhpc0xhYmVsU3BhY2VCZWZvcmU6IDUsXG5cdFx0eEF4aXNMYWJlbFNwYWNlQWZ0ZXI6IDUsXG5cdFx0eEF4aXNTcGFjZUJlZm9yZTogNSxcblx0XHR4QXhpc1NwYWNlQWZ0ZXI6IDUsXG5cdFx0eEF4aXNMYWJlbEJvcmRlcnMgOiBmYWxzZSxcblx0XHR4QXhpc0xhYmVsQm9yZGVyc0NvbG9yIDogXCJibGFja1wiLFxuICAgICAgICAgICAgICAgIHhBeGlzTGFiZWxCb3JkZXJzUmFkaXVzIDogMCxcblx0XHR4QXhpc0xhYmVsQm9yZGVyc1hTcGFjZSA6IDMsXG5cdFx0eEF4aXNMYWJlbEJvcmRlcnNZU3BhY2UgOiAzLFxuXHRcdHhBeGlzTGFiZWxCb3JkZXJzV2lkdGggOiAxLFxuXHRcdHhBeGlzTGFiZWxCb3JkZXJzU3R5bGUgOiBcInNvbGlkXCIsXG5cdFx0eEF4aXNMYWJlbEJhY2tncm91bmRDb2xvciA6IFwibm9uZVwiLFxuXHRcdHNob3dYTGFiZWxzIDogMSxcblx0XHRmaXJzdExhYmVsVG9TaG93IDogMSxcblx0XHRzaG93WUxhYmVscyA6IDEsXG5cdFx0Zmlyc3RZTGFiZWxUb1Nob3cgOiAxLFxuXHRcdHlBeGlzVW5pdDogXCJcIixcblx0XHR5QXhpc1VuaXQyOiBcIlwiLFxuXHRcdHlBeGlzVW5pdEZvbnRGYW1pbHk6IFwiJ0FyaWFsJ1wiLFxuXHRcdHlBeGlzVW5pdEZvbnRTaXplOiA4LFxuXHRcdHlBeGlzVW5pdEZvbnRTdHlsZTogXCJub3JtYWxcIixcblx0XHR5QXhpc1VuaXRGb250Q29sb3I6IFwiIzY2NlwiLFxuXHRcdHlBeGlzVW5pdFNwYWNlQmVmb3JlOiA1LFxuXHRcdHlBeGlzVW5pdFNwYWNlQWZ0ZXI6IDUsXG5cdFx0eUF4aXNVbml0Qm9yZGVycyA6IGZhbHNlLFxuXHRcdHlBeGlzVW5pdEJvcmRlcnNDb2xvciA6IFwiYmxhY2tcIixcbiAgICAgICAgICAgICAgICB5QXhpc1VuaXRCb3JkZXJzcmFkaXVzIDogMCxcblx0XHR5QXhpc1VuaXRCb3JkZXJzWFNwYWNlIDogMyxcblx0XHR5QXhpc1VuaXRCb3JkZXJzWVNwYWNlIDogMyxcblx0XHR5QXhpc1VuaXRCb3JkZXJzV2lkdGggOiAxLFxuXHRcdHlBeGlzVW5pdEJvcmRlcnNTdHlsZSA6IFwic29saWRcIixcblx0XHR5QXhpc1VuaXRCYWNrZ3JvdW5kQ29sb3IgOiBcIm5vbmVcIlxuXHR9O1xuXHR2YXIgY2xlYXIgPSBmdW5jdGlvbihjKSB7XG5cdFx0Yy5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdH07XG5cdFxuXG5cblx0ZnVuY3Rpb24gaW5pdF9hbmRfc3RhcnQoY3R4LGRhdGEsY29uZmlnKSB7XG5cblx0XHR2YXIgaTtcblxuXHRcdGlmICh0eXBlb2YgY3R4LmluaXRpYWxXaWR0aCA9PSBcInVuZGVmaW5lZFwiKSBjdHguaW5pdGlhbFdpZHRoID1jdHguY2FudmFzLndpZHRoO1xuXHRcdGlmICh0eXBlb2YgY3R4LmNoYXJ0VGV4dFNjYWxlID09IFwidW5kZWZpbmVkXCIpIGN0eC5jaGFydFRleHRTY2FsZT1jb25maWcuY2hhcnRUZXh0U2NhbGU7XG5cdFx0aWYgKHR5cGVvZiBjdHguY2hhcnRMaW5lU2NhbGUgPT0gXCJ1bmRlZmluZWRcIikgY3R4LmNoYXJ0TGluZVNjYWxlPWNvbmZpZy5jaGFydExpbmVTY2FsZTtcblx0XHRpZiAodHlwZW9mIGN0eC5jaGFydFNwYWNlU2NhbGUgPT0gXCJ1bmRlZmluZWRcIikgXHRjdHguY2hhcnRTcGFjZVNjYWxlPWNvbmZpZy5jaGFydFNwYWNlU2NhbGU7XG5cdFxuXHRcdGlmKHR5cGVvZiBjdHguZmlyc3RQYXNzPT1cInVuZGVmaW5lZFwiKXtcblx0XHRcdGN0eC5maXJzdFBhc3M9MDtcbiAgICAgICAgXHRcdGlmKGNvbmZpZy5yZXNwb25zaXZlICYmICFjb25maWcubXVsdGlHcmFwaCkge1xuXHRcdFx0XHRhZGRSZXNwb25zaXZlQ2hhcnQoY3R4LkNoYXJ0TmV3SWQsY3R4LGRhdGEsY29uZmlnKTtcblx0XHRcdH1cblx0XHR9IFxuXG5cdFx0aWYgKHR5cGVvZiBjdHguQ2hhcnROZXdJZCA9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRjdHgucnVuYW5pbWF0aW9uY29tcGxldGVmdW5jdGlvbj10cnVlO1xuXHRcdFx0dmFyIGN2ZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHR2YXIgY3ZtaWxsc2VjID0gY3ZkYXRlLmdldFRpbWUoKTtcblx0XHRcdGN0eC5DaGFydE5ld0lkID0gY3R4LnRwY2hhcnQgKyAnXycgKyBjdm1pbGxzZWM7XG5cdFx0XHRjdHguX2V2ZW50TGlzdGVuZXJzID0ge307XG5cdFx0fVxuXG5cdFx0cmVzaXplQ3R4KGN0eCxjb25maWcpO1xuXG5cdFx0aWYgKCFkeW5hbWljRnVuY3Rpb24oZGF0YSwgY29uZmlnLCBjdHgpKSByZXR1cm4gZmFsc2U7ICAgLy8gaWYgY29uZmlnLmR5bmFtaWNEaXNwbGF5PXRydWUsIGNoYXJ0IGhhcyB0byBiZSBkaXNwbGF5ZWQgb25seSBpZiBpbiBjdXJyZW50IHNjcmVlbjsgIFxuXG5cdFx0aWYgKCFjb25maWcubXVsdGlHcmFwaCAmJiBjdHguZmlyc3RQYXNzIT0wKSB7XHRcblx0XHRcdGNsZWFyQW5ub3RhdGUoY3R4LkNoYXJ0TmV3SWQpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YganNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXSA9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdID0gbmV3IEFycmF5KCk7XG5cdFx0XHRqc1RleHRNb3VzZVBvc1tjdHguQ2hhcnROZXdJZF0gPSBuZXcgQXJyYXkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGNvbnZlcnQgbGFiZWwgdG8gdGl0bGUgLSBmb3IgY29tcGF0aWJpbGl0eSByZWFzb25zIHdpdGggQ2hhcnQuanM7XG5cdFx0c3dpdGNoKGN0eC50cGRhdGEpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0Zm9yKGk9MDtpPGRhdGEubGVuZ3RoO2krKyl7XG5cdFx0XHRcdFx0aWYodHlwZW9mIGRhdGFbaV0udGl0bGUgPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZGF0YVtpXS5sYWJlbCAhPSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0XHRkYXRhW2ldLnRpdGxlPWRhdGFbaV0ubGFiZWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAwOlxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Zm9yKGk9MDtpPGRhdGEuZGF0YXNldHMubGVuZ3RoO2krKyl7XG5cdFx0XHRcdFx0aWYodHlwZW9mIGRhdGEuZGF0YXNldHNbaV0udGl0bGUgPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZGF0YS5kYXRhc2V0c1tpXS5sYWJlbCAhPSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0XHRkYXRhLmRhdGFzZXRzW2ldLnRpdGxlPWRhdGEuZGF0YXNldHNbaV0ubGFiZWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGRlZk1vdXNlKGN0eCwgZGF0YSwgY29uZmlnKTtcblx0XHRcblx0XHRpZihjdHguZmlyc3RQYXNzPT0wKSB7XG5cdFx0XHRpZihjb25maWcuYW5pbWF0aW9uKWN0eC5maXJzdFBhc3M9MTtcblx0XHRcdGVsc2UgY3R4LmZpcnN0UGFzcz0yO1xuXHRcdH1cblxuXHRcdHNldFJlY3QoY3R4LCBjb25maWcpO1xuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9IDtcblxuXHR2YXIgUG9sYXJBcmVhID0gZnVuY3Rpb24oZGF0YSwgY29uZmlnLCBjdHgpIHtcblx0XHR2YXIgbWF4U2l6ZSwgc2NhbGVIb3AsIGNhbGN1bGF0ZWRTY2FsZSwgbGFiZWxIZWlnaHQsIHNjYWxlSGVpZ2h0LCB2YWx1ZUJvdW5kcywgbGFiZWxUZW1wbGF0ZVN0cmluZywgbXNyLCBtaWRQb3NYLCBtaWRQb3NZO1xuXG5cdFx0Y3R4LnRwY2hhcnQ9XCJQb2xhckFyZWFcIjtcblx0XHRjdHgudHBkYXRhPTE7XG5cdFx0XG5cdCAgICAgICAgaWYgKCFpbml0X2FuZF9zdGFydChjdHgsZGF0YSxjb25maWcpKSByZXR1cm47XG5cblx0XHR2YXIgcmVhbEN1bXVsYXRpdmVBbmdsZSA9ICgoKGNvbmZpZy5zdGFydEFuZ2xlICogKE1hdGguUEkgLyAxODApICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSkgKyAyKiBNYXRoLlBJKSAlICgyKiBNYXRoLlBJKSA7IFxuXHRcdHZhciByZWFsQW1wbGl0dWRlID0gKCgoY29uZmlnLnRvdGFsQW1wbGl0dWRlICogKE1hdGguUEkgLyAxODApICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSkgKyAyKiBNYXRoLlBJKSAlICgyKiBNYXRoLlBJKSA7IFxuXHRcdGlmKHJlYWxBbXBsaXR1ZGUgPD0gY29uZmlnLnplcm9WYWx1ZSlyZWFsQW1wbGl0dWRlPTIqTWF0aC5QSTtcblx0XHRcdFxuXHRcdHZhciBkZWJBbmdsZT0oKHJlYWxDdW11bGF0aXZlQW5nbGUtcmVhbEFtcGxpdHVkZSkrNCpNYXRoLlBJKSUoMipNYXRoLlBJKTtcblx0XHR2YXIgZmluQW5nbGU9ZGViQW5nbGUrcmVhbEFtcGxpdHVkZTtcblxuXHRcdHZhciBzdGF0RGF0YT1pbml0UGFzc1ZhcmlhYmxlRGF0YV9wYXJ0MShkYXRhLGNvbmZpZyxjdHgpO1xuXG5cdFx0dmFsdWVCb3VuZHMgPSBnZXRWYWx1ZUJvdW5kcygpO1xuXHRcdGNvbmZpZy5sb2dhcml0aG1pYyA9IGZhbHNlO1xuXHRcdGNvbmZpZy5sb2dhcml0aG1pYzIgPSBmYWxzZTtcblxuXHRcdC8vQ2hlY2sgYW5kIHNldCB0aGUgc2NhbGVcblx0XHRsYWJlbFRlbXBsYXRlU3RyaW5nID0gKGNvbmZpZy5zY2FsZVNob3dMYWJlbHMpID8gY29uZmlnLnNjYWxlTGFiZWwgOiBcIlwiO1xuXHRcdGlmICghY29uZmlnLnNjYWxlT3ZlcnJpZGUpIHtcblx0XHRcdGNhbGN1bGF0ZWRTY2FsZSA9IGNhbGN1bGF0ZVNjYWxlKDEsIGNvbmZpZywgdmFsdWVCb3VuZHMubWF4U3RlcHMsIHZhbHVlQm91bmRzLm1pblN0ZXBzLCB2YWx1ZUJvdW5kcy5tYXhWYWx1ZSwgdmFsdWVCb3VuZHMubWluVmFsdWUsIGxhYmVsVGVtcGxhdGVTdHJpbmcpO1xuXHRcdFx0bXNyID0gc2V0TWVhc3VyZXMoZGF0YSwgY29uZmlnLCBjdHgsIGN0eC5jYW52YXMuaGVpZ2h0LCBjdHguY2FudmFzLndpZHRoLCBjYWxjdWxhdGVkU2NhbGUubGFiZWxzLCBudWxsLCB0cnVlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCB0cnVlLCBcIlBvbGFyQXJlYVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHNjYWxlU3RhcnRWYWx1ZT0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEFSVFZBTFVFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5zY2FsZVN0YXJ0VmFsdWUsXCJzY2FsZVN0YXJ0VmFsdWVcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdHZhciBzY2FsZVN0ZXBzID1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJTQ0FMRVNURVBTXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5zY2FsZVN0ZXBzLFwic2NhbGVTdGVwc1wiLC0xLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0dmFyIHNjYWxlU3RlcFdpZHRoID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEVQV0lEVEhcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLnNjYWxlU3RlcFdpZHRoLFwic2NhbGVTdGVwV2lkdGhcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblxuXHRcdFx0Y2FsY3VsYXRlZFNjYWxlID0ge1xuXHRcdFx0XHRzdGVwczogc2NhbGVTdGVwcyxcblx0XHRcdFx0c3RlcFZhbHVlOiBzY2FsZVN0ZXBXaWR0aCxcblx0XHRcdFx0Z3JhcGhNaW46IHNjYWxlU3RhcnRWYWx1ZSxcblx0XHRcdFx0Z3JhcGhNYXg6IHNjYWxlU3RhcnRWYWx1ZSArIHNjYWxlU3RlcHMgKiBzY2FsZVN0ZXBXaWR0aCxcblx0XHRcdFx0bGFiZWxzOiBbXVxuXHRcdFx0fVxuXHRcdFx0cG9wdWxhdGVMYWJlbHMoMSwgY29uZmlnLCBsYWJlbFRlbXBsYXRlU3RyaW5nLCBjYWxjdWxhdGVkU2NhbGUubGFiZWxzLCBjYWxjdWxhdGVkU2NhbGUuc3RlcHMsIHNjYWxlU3RhcnRWYWx1ZSwgY2FsY3VsYXRlZFNjYWxlLmdyYXBoTWF4LCBzY2FsZVN0ZXBXaWR0aCk7XG5cdFx0XHRtc3IgPSBzZXRNZWFzdXJlcyhkYXRhLCBjb25maWcsIGN0eCwgY3R4LmNhbnZhcy5oZWlnaHQsIGN0eC5jYW52YXMud2lkdGgsIGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHMsIG51bGwsIHRydWUsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUsIFwiUG9sYXJBcmVhXCIpO1xuXHRcdH1cblxuXHRcdHZhciBvdXRlclZhbD1jYWxjdWxhdGVkU2NhbGUuZ3JhcGhNaW4rY2FsY3VsYXRlZFNjYWxlLnN0ZXBzKmNhbGN1bGF0ZWRTY2FsZS5zdGVwVmFsdWU7XG5cdFx0dmFyIGRyd1NpemU9Y2FsY3VsYXRlUGllRHJhd2luZ1NpemUoY3R4LG1zcixjb25maWcsZGF0YSxzdGF0RGF0YSk7XG5cdFx0bWlkUG9zWD1kcndTaXplLm1pZFBpZVg7XG5cdFx0bWlkUG9zWT1kcndTaXplLm1pZFBpZVk7XG5cblx0XHRzY2FsZUhvcCA9IE1hdGguZmxvb3IoZHJ3U2l6ZS5yYWRpdXMgLyBjYWxjdWxhdGVkU2NhbGUuc3RlcHMpO1xuXHRcdC8vV3JhcCBpbiBhbiBhbmltYXRpb24gbG9vcCB3cmFwcGVyXG4gXHRcdGlmKHNjYWxlSG9wID4gMCkge1xuXHRcdFx0aW5pdFBhc3NWYXJpYWJsZURhdGFfcGFydDIoc3RhdERhdGEsZGF0YSxjb25maWcsY3R4LHttaWRQb3NYIDogbWlkUG9zWCxtaWRQb3NZIDogbWlkUG9zWSxpbnRfcmFkaXVzIDogMCxleHRfcmFkaXVzIDogc2NhbGVIb3AqY2FsY3VsYXRlZFNjYWxlLnN0ZXBzLCBjYWxjdWxhdGVkU2NhbGUgOiBjYWxjdWxhdGVkU2NhbGUsIHNjYWxlSG9wIDogc2NhbGVIb3Asb3V0ZXJWYWwgOiBvdXRlclZhbH0pO1xuXHRcdFx0YW5pbWF0aW9uTG9vcChjb25maWcsIGRyYXdTY2FsZSwgZHJhd0FsbFNlZ21lbnRzLCBjdHgsIG1zci5jbHJ4LCBtc3IuY2xyeSwgbXNyLmNscndpZHRoLCBtc3IuY2xyaGVpZ2h0LCBtaWRQb3NYLCBtaWRQb3NZLCBtaWRQb3NYIC0gKChNaW4oW21zci5hdmFpbGFibGVIZWlnaHQsIG1zci5hdmFpbGFibGVXaWR0aF0pIC8gMikgLSA1KSwgbWlkUG9zWSArICgoTWluKFttc3IuYXZhaWxhYmxlSGVpZ2h0LCBtc3IuYXZhaWxhYmxlV2lkdGhdKSAvIDIpIC0gNSksIGRhdGEsIHN0YXREYXRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGVzdFJlZHJhdyhjdHgsZGF0YSxjb25maWcpO1xuXHRcdFx0Y3R4LmZpcnN0UGFzcz05O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRyYXdBbGxTZWdtZW50cyhhbmltYXRpb25EZWNpbWFsKSB7XG5cblx0XHRcdHZhciBwcmV2QW5nbGU9c3RhdERhdGFbMF0uZmlyc3RBbmdsZTtcblxuXHRcdFx0dmFyIGZpeEFuZ2xlPTA7XG5cdFx0XHR2YXIgZmlyc3RBbmdsZT1zdGF0RGF0YVswXS5maXJzdEFuZ2xlO1xuXHRcdFx0aWYoMSpjb25maWcuYW5pbWF0aW9uU3RhcnRXaXRoRGF0YT4xICYmIDEqY29uZmlnLmFuaW1hdGlvblN0YXJ0V2l0aERhdGEtMSA8IGRhdGEubGVuZ3RoKSB7XG5cdFx0XHRcdGZpeEFuZ2xlPShzdGF0RGF0YVtjb25maWcuYW5pbWF0aW9uU3RhcnRXaXRoRGF0YS0xXS5zdGFydEFuZ2xlLXN0YXREYXRhWzBdLmZpcnN0QW5nbGUpO1xuXHRcdFx0XHRmaXJzdEFuZ2xlPXN0YXREYXRhW2NvbmZpZy5hbmltYXRpb25TdGFydFdpdGhEYXRhLTFdLnN0YXJ0QW5nbGU7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXJcdHNjYWxlQW5pbWF0aW9uID0gMSxcblx0XHRcdFx0XHRyb3RhdGVBbmltYXRpb24gPSAxO1xuICAgICAgICAgICAgICAgIFx0XG5cdFx0XHRcdGlmIChjb25maWcuYW5pbWF0aW9uKSB7XG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5hbmltYXRlU2NhbGUpIHtcblx0XHRcdFx0XHRcdHNjYWxlQW5pbWF0aW9uID0gYW5pbWF0aW9uRGVjaW1hbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5hbmltYXRlUm90YXRlKSB7XG5cdFx0XHRcdFx0XHRyb3RhdGVBbmltYXRpb24gPSBhbmltYXRpb25EZWNpbWFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjb3JyZWN0ZWRSb3RhdGVBbmltYXRpb24gPSBhbmltYXRpb25Db3JyZWN0aW9uKHJvdGF0ZUFuaW1hdGlvbiwgZGF0YSwgY29uZmlnLCBpLCAtMSxmYWxzZSkubWFpblZhbDtcblx0XHRcdFx0aWYgKCEodHlwZW9mKGRhdGFbaV0udmFsdWUpID09ICd1bmRlZmluZWQnKSkge1xuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRpZihjb25maWcuYW5pbWF0aW9uQnlEYXRhID09IFwiQnlBcmNcIikge1xuXHRcdFx0XHRcdFx0ZW5kQW5nbGU9c3RhdERhdGFbaV0uc3RhcnRBbmdsZStjb3JyZWN0ZWRSb3RhdGVBbmltYXRpb24qc3RhdERhdGFbaV0uc2VnbWVudEFuZ2xlO1xuXHRcdFx0XHRcdFx0Y3R4LmFyYyhtaWRQb3NYLCBtaWRQb3NZLCBzY2FsZUFuaW1hdGlvbiAqIHN0YXREYXRhW2ldLnJhZGl1c09mZnNldCwgc3RhdERhdGFbaV0uc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGZhbHNlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYoY29uZmlnLmFuaW1hdGlvbkJ5RGF0YSkge1xuXHRcdFx0XHRcdCAgICAgICAgaWYgKGk8MSpjb25maWcuYW5pbWF0aW9uU3RhcnRXaXRoRGF0YS0xKSB7XG5cdFx0XHRcdFx0XHRcdGN0eC5hcmMobWlkUGllWCwgbWlkUGllWSwgc2NhbGVBbmltYXRpb24gKiBzdGF0RGF0YVtpXS5yYWRpdXNPZmZzZXQsIHN0YXREYXRhW2ldLnN0YXJ0QW5nbGUsIHN0YXREYXRhW2ldLmVuZEFuZ2xlLGZhbHNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZihzdGF0RGF0YVtpXS5zdGFydEFuZ2xlIDw9IGZpcnN0QW5nbGUrY29ycmVjdGVkUm90YXRlQW5pbWF0aW9uKigyKk1hdGguUEktZml4QW5nbGUpICkge1xuXHRcdFx0XHRcdFx0XHRlbmRBbmdsZT1zdGF0RGF0YVtpXS5lbmRBbmdsZTtcblx0XHRcdFx0XHRcdFx0aWYoc3RhdERhdGFbaV0uZW5kQW5nbGUgPiBmaXJzdEFuZ2xlK2NvcnJlY3RlZFJvdGF0ZUFuaW1hdGlvbiooMipNYXRoLlBJLWZpeEFuZ2xlKSkge1xuXHRcdFx0XHRcdFx0XHRcdGVuZEFuZ2xlPWZpcnN0QW5nbGUrY29ycmVjdGVkUm90YXRlQW5pbWF0aW9uKigyKk1hdGguUEktZml4QW5nbGUpO1xuXHRcdFx0XHRcdFx0XHR9IFxuXHRcdFx0XHRcdFx0XHRjdHguYXJjKG1pZFBpZVgsIG1pZFBpZVksIHNjYWxlQW5pbWF0aW9uICogc3RhdERhdGFbaV0ucmFkaXVzT2Zmc2V0LCBzdGF0RGF0YVtpXS5zdGFydEFuZ2xlLCBlbmRBbmdsZSxmYWxzZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTsgXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN0eC5hcmMobWlkUGllWCwgbWlkUGllWSwgc2NhbGVBbmltYXRpb24gKiBzdGF0RGF0YVtpXS5yYWRpdXNPZmZzZXQsIHByZXZBbmdsZSwgcHJldkFuZ2xlK2NvcnJlY3RlZFJvdGF0ZUFuaW1hdGlvbiAqIChzdGF0RGF0YVtpXS5lbmRBbmdsZS1zdGF0RGF0YVtpXS5zdGFydEFuZ2xlKSxmYWxzZSk7XG5cdFx0XHRcdFx0XHRwcmV2QW5nbGU9cHJldkFuZ2xlK2NvcnJlY3RlZFJvdGF0ZUFuaW1hdGlvbiAqIChzdGF0RGF0YVtpXS5lbmRBbmdsZS1zdGF0RGF0YVtpXS5zdGFydEFuZ2xlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhtaWRQb3NYLCBtaWRQb3NZKTtcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGFbaV0uY29sb3IsY29uZmlnLmRlZmF1bHRGaWxsQ29sb3IsXCJjb2xvclwiLGksLTEse2FuaW1hdGlvbkRlY2ltYWw6IGFuaW1hdGlvbkRlY2ltYWwsIHNjYWxlQW5pbWF0aW9uIDogc2NhbGVBbmltYXRpb259ICk7XG5cdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblxuXHRcdFx0XHRcdGlmKGNvbmZpZy5zZWdtZW50U2hvd1N0cm9rZT09XCJtZXJnZVwiKSB7IC8qIGF2b2lkIGJsYW5rIHN0cmlwZXMgYmV0d2VlbiBwaWVjZSBvZiBjaGFydCAqL1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9MDtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhW2ldLmNvbG9yLGNvbmZpZy5kZWZhdWx0RmlsbENvbG9yLFwiY29sb3JcIixpLC0xLHthbmltYXRpb25EZWNpbWFsOiBhbmltYXRpb25EZWNpbWFsLCBzY2FsZUFuaW1hdGlvbiA6IHNjYWxlQW5pbWF0aW9ufSApO1xuXHRcdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoY29uZmlnLnNlZ21lbnRTaG93U3Ryb2tlKSB7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuc2VnbWVudFN0cm9rZUNvbG9yO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNlZ21lbnRTdHJva2VXaWR0aCk7XG5cdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0VHTUVOVFNUUk9LRVNUWUxFXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YVtpXS5zZWdtZW50U3Ryb2tlU3R5bGUsY29uZmlnLnNlZ21lbnRTdHJva2VTdHlsZSxcInNlZ21lbnRTdHJva2VTdHlsZVwiLGksLTEse2FuaW1hdGlvbkRlY2ltYWw6IGFuaW1hdGlvbkRlY2ltYWwsIHNjYWxlQW5pbWF0aW9uIDogc2NhbGVBbmltYXRpb259ICkpKTtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKGFuaW1hdGlvbkRlY2ltYWwgPj0gY29uZmlnLmFuaW1hdGlvblN0b3BWYWx1ZSkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YoZGF0YVtpXS52YWx1ZSkgPT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1banNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXS5sZW5ndGhdID0gW1wiQVJDXCIsIGksIC0xLHN0YXREYXRhLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkFOTk9UQVRFRElTUExBWVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGFbaV0uYW5ub3RhdGVEaXNwbGF5LGNvbmZpZy5hbm5vdGF0ZURpc3BsYXksXCJhbm5vdGF0ZURpc3BsYXlcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSldO1xuXHRcdFx0XHRcdGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVNIT1dcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhW2ldLmluR3JhcGhEYXRhU2hvdyxjb25maWcuaW5HcmFwaERhdGFTaG93LFwiaW5HcmFwaERhdGFTaG93XCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0pKSB7XG5cdFx0XHRcdFx0XHRpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFBTkdMRVBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUFuZ2xlUG9zaXRpb24sXCJpbkdyYXBoRGF0YUFuZ2xlUG9zaXRpb25cIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDEpIHBvc0FuZ2xlID0gc3RhdERhdGFbaV0ucmVhbFN0YXJ0QW5nbGUgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVBBRERJTkFOR0xFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdBbmdsZSxcImluR3JhcGhEYXRhUGFkZGluZ0FuZ2xlXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlICB9KSAqIChNYXRoLlBJIC8gMTgwKTtcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQU5HTEVQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFBbmdsZVBvc2l0aW9uLFwiaW5HcmFwaERhdGFBbmdsZVBvc2l0aW9uXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAyKSBwb3NBbmdsZSA9ICgyKnN0YXREYXRhW2ldLnJlYWxTdGFydEFuZ2xlIC0gc3RhdERhdGFbaV0uc2VnbWVudEFuZ2xlKSAvIDIgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVBBRERJTkFOR0xFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdBbmdsZSxcImluR3JhcGhEYXRhUGFkZGluZ0FuZ2xlXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlICB9KSAqIChNYXRoLlBJIC8gMTgwKTtcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQU5HTEVQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFBbmdsZVBvc2l0aW9uLFwiaW5HcmFwaERhdGFBbmdsZVBvc2l0aW9uXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAzKSBwb3NBbmdsZSA9IHN0YXREYXRhW2ldLnJlYWxTdGFydEFuZ2xlIC0gc3RhdERhdGFbaV0uc2VnbWVudEFuZ2xlICsgc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFQQURESU5BTkdMRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nQW5nbGUsXCJpbkdyYXBoRGF0YVBhZGRpbmdBbmdsZVwiLGksLTEse251bGxWYWx1ZTogdHJ1ZSAgfSkgKiAoTWF0aC5QSSAvIDE4MCk7XG5cdFx0XHRcdFx0XHRpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFSQURJVVNQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSYWRpdXNQb3NpdGlvbixcImluR3JhcGhEYXRhUmFkaXVzUG9zaXRpb25cIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDEpIGxhYmVsUmFkaXVzID0gMCArIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUEFERElOR1JBRElVU1wiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzLFwiaW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFSQURJVVNQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSYWRpdXNQb3NpdGlvbixcImluR3JhcGhEYXRhUmFkaXVzUG9zaXRpb25cIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDIpIGxhYmVsUmFkaXVzID0gc3RhdERhdGFbaV0ucmFkaXVzT2Zmc2V0IC8gMiArIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUEFERElOR1JBRElVU1wiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzLFwiaW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFSQURJVVNQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSYWRpdXNQb3NpdGlvbixcImluR3JhcGhEYXRhUmFkaXVzUG9zaXRpb25cIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDMpIGxhYmVsUmFkaXVzID0gc3RhdERhdGFbaV0ucmFkaXVzT2Zmc2V0ICsgc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFQQURESU5HUkFESVVTXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdSYWRpdXMsXCJpbkdyYXBoRGF0YVBhZGRpbmdSYWRpdXNcIixpLC0xLHtudWxsVmFsdWU6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVJBRElVU1BPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVJhZGl1c1Bvc2l0aW9uLFwiaW5HcmFwaERhdGFSYWRpdXNQb3NpdGlvblwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICkgPT0gNCkgbGFiZWxSYWRpdXMgPSBzY2FsZUhvcCAqIGNhbGN1bGF0ZWRTY2FsZS5zdGVwcyArIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUEFERElOR1JBRElVU1wiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzLFwiaW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0Y3R4LnNhdmUoKVxuXHRcdFx0XHRcdFx0aWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQWxpZ24sXCJpbkdyYXBoRGF0YUFsaWduXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlICB9KSA9PSBcIm9mZi1jZW50ZXJcIikge1xuXHRcdFx0XHRcdFx0XHRpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFST1RBVEVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUm90YXRlLFwiaW5HcmFwaERhdGFSb3RhdGVcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IFwiaW5SYWRpdXNBeGlzXCIgfHwgKHBvc0FuZ2xlICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSA+PSAzICogTWF0aC5QSSAvIDIgfHwgKHBvc0FuZ2xlICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSA8PSBNYXRoLlBJIC8gMikgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXHRcdFx0XHRcdFx0XHRlbHNlIGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQWxpZ24sXCJpbkdyYXBoRGF0YUFsaWduXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlICB9KSA9PSBcInRvLWNlbnRlclwiKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVJPVEFURVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSb3RhdGUsXCJpbkdyYXBoRGF0YVJvdGF0ZVwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICkgPT0gXCJpblJhZGl1c0F4aXNcIiB8fCAocG9zQW5nbGUgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpID49IDMgKiBNYXRoLlBJIC8gMiB8fCAocG9zQW5nbGUgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpIDw9IE1hdGguUEkgLyAyKSBjdHgudGV4dEFsaWduID0gXCJyaWdodFwiO1xuXHRcdFx0XHRcdFx0XHRlbHNlIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XHRcdFx0XHRcdH0gZWxzZSBjdHgudGV4dEFsaWduID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFBTElHTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFBbGlnbixcImluR3JhcGhEYXRhQWxpZ25cIixpLC0xLHtudWxsVmFsdWU6IHRydWUgIH0pO1xuXHRcdFx0XHRcdFx0aWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBVkFMSUdOXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVZBbGlnbixcImluR3JhcGhEYXRhVkFsaWduXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSBcIm9mZi1jZW50ZXJcIikge1xuXHRcdFx0XHRcdFx0XHRpZiAoKHBvc0FuZ2xlICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSA+IE1hdGguUEkpIGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuXHRcdFx0XHRcdFx0XHRlbHNlIGN0eC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVZBTElHTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFWQWxpZ24sXCJpbkdyYXBoRGF0YVZBbGlnblwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICkgPT0gXCJ0by1jZW50ZXJcIikge1xuXHRcdFx0XHRcdFx0XHRpZiAoKHBvc0FuZ2xlICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSA+IE1hdGguUEkpIGN0eC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuXHRcdFx0XHRcdFx0XHRlbHNlIGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGN0eC50ZXh0QmFzZWxpbmUgPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVZBTElHTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFWQWxpZ24sXCJpbkdyYXBoRGF0YVZBbGlnblwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRjdHguZm9udCA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBRk9OVFNUWUxFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRTdHlsZSxcImluR3JhcGhEYXRhRm9udFN0eWxlXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSArICcgJyArIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0VGV4dFNjYWxlLFwiSU5HUkFQSERBVEFGT05UU0laRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U2l6ZSxcImluR3JhcGhEYXRhRm9udFNpemVcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApICsgJ3B4ICcgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUZPTlRGQU1JTFlcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udEZhbWlseSxcImluR3JhcGhEYXRhRm9udEZhbWlseVwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFGT05UQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udENvbG9yLFwiaW5HcmFwaERhdGFGb250Q29sb3JcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0dmFyIGRpc3BTdHJpbmcgPSB0bXBsYmlzKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBVE1QTFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFUbXBsLFwiaW5HcmFwaERhdGFUbXBsXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSwgc3RhdERhdGFbaV0sY29uZmlnKTtcblx0XHRcdFx0XHRcdGN0eC50cmFuc2xhdGUobWlkUG9zWCArIGxhYmVsUmFkaXVzICogTWF0aC5jb3MocG9zQW5nbGUpLCBtaWRQb3NZIC0gbGFiZWxSYWRpdXMgKiBNYXRoLnNpbihwb3NBbmdsZSkpO1xuXHRcdFx0XHRcdFx0dmFyIHJvdGF0ZVZhbD0wO1xuXHRcdFx0XHRcdFx0aWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUk9UQVRFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVJvdGF0ZSxcImluR3JhcGhEYXRhUm90YXRlXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSBcImluUmFkaXVzQXhpc1wiKSByb3RhdGVWYWw9MiAqIE1hdGguUEkgLSBwb3NBbmdsZTtcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUk9UQVRFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVJvdGF0ZSxcImluR3JhcGhEYXRhUm90YXRlXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSBcImluUmFkaXVzQXhpc1JvdGF0ZUxhYmVsc1wiKSB7XG5cdFx0XHRcdFx0XHRcdGlmICgocG9zQW5nbGUgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpID4gTWF0aC5QSSAvIDIgJiYgKHBvc0FuZ2xlICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSA8IDMgKiBNYXRoLlBJIC8gMikgcm90YXRlVmFsPTMgKiBNYXRoLlBJIC0gcG9zQW5nbGU7XG5cdFx0XHRcdFx0XHRcdGVsc2Ugcm90YXRlVmFsPTIgKiBNYXRoLlBJIC0gcG9zQW5nbGU7XG5cdFx0XHRcdFx0XHR9IGVsc2Ugcm90YXRlVmFsPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUk9UQVRFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVJvdGF0ZSxcImluR3JhcGhEYXRhUm90YXRlXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSAqIChNYXRoLlBJIC8gMTgwKTtcblx0XHRcdFx0XHRcdGN0eC5yb3RhdGUocm90YXRlVmFsKTtcblx0XHRcdFx0XHRcdHNldFRleHRCb3JkZXJzQW5kQmFja2dyb3VuZChjdHgsZGlzcFN0cmluZyxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFRleHRTY2FsZSxcIklOR1JBUEhEQVRBRk9OVFNJWkVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udFNpemUsXCJpbkdyYXBoRGF0YUZvbnRTaXplXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSwwLDAsc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFCT1JERVJTXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnMsXCJpbkdyYXBoRGF0YUJvcmRlcnNcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQk9SREVSU0NPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNDb2xvcixcImluR3JhcGhEYXRhQm9yZGVyc0NvbG9yXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydExpbmVTY2FsZSxcIklOR1JBUEhEQVRBQk9SREVSU1dJRFRIXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNXaWR0aCxcImluR3JhcGhEYXRhQm9yZGVyc1dpZHRoXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQUJPUkRFUlNYU1BBQ0VcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVyc1hTcGFjZSxcImluR3JhcGhEYXRhQm9yZGVyc1hTcGFjZVwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICksc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiSU5HUkFQSERBVEFCT1JERVJTWVNQQUNFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNZU3BhY2UsXCJpbkdyYXBoRGF0YUJvcmRlcnNZU3BhY2VcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQk9SREVSU1NUWUxFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNTdHlsZSxcImluR3JhcGhEYXRhQm9yZGVyc1N0eWxlXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJBQ0tHUk9VTkRDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCYWNrZ3JvdW5kQ29sb3IsXCJpbkdyYXBoRGF0YUJhY2tncm91bmRDb2xvclwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICksXCJJTkdSQVBIREFUQVwiLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNSYWRpdXMpO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGRpc3BTdHJpbmcsIDAsIDAsIGN0eC50ZXh0QmFzZWxpbmUsIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0VGV4dFNjYWxlLFwiSU5HUkFQSERBVEFGT05UU0laRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U2l6ZSxcImluR3JhcGhEYXRhRm9udFNpemVcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApLCB0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJJTkdSQVBIREFUQV9URVhUTU9VU0VcIixyb3RhdGVWYWwsbWlkUG9zWCArIGxhYmVsUmFkaXVzICogTWF0aC5jb3MocG9zQW5nbGUpLCBtaWRQb3NZIC0gbGFiZWxSYWRpdXMgKiBNYXRoLnNpbihwb3NBbmdsZSksaSwtMSk7XG5cdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYobXNyLmxlZ2VuZE1zci5kaXNwTGVnZW5kKWRyYXdMZWdlbmQobXNyLmxlZ2VuZE1zcixkYXRhLGNvbmZpZyxjdHgsXCJQb2xhckFyZWFcIik7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGRyYXdTY2FsZSgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FsY3VsYXRlZFNjYWxlLnN0ZXBzOyBpKyspIHtcblx0XHRcdFx0aWYgKGNvbmZpZy5zY2FsZVNob3dMaW5lICYmIChpKzEpICUgY29uZmlnLnNjYWxlR3JpZExpbmVzU3RlcD09MCkge1xuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRjdHguYXJjKG1pZFBvc1gsIG1pZFBvc1ksIHNjYWxlSG9wICogKGkgKyAxKSwgNCpNYXRoLlBJLWRlYkFuZ2xlLCA0Kk1hdGguUEktZmluQW5nbGUsIHRydWUpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5zY2FsZUxpbmVDb2xvcjtcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVMaW5lV2lkdGgpO1xuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihjb25maWcuc2NhbGVMaW5lU3R5bGUpKTtcblxuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjb25maWcuc2NhbGVTaG93TGFiZWxzKSB7XG5cblx0XHRcdFx0XHRpZihNYXRoLmFicyhjb25maWcudG90YWxBbXBsaXR1ZGUtMzYwKTxjb25maWcuemVyb1ZhbHVlKXNjYWxlQW5nbGU9TWF0aC5QSS8yO1xuXHRcdFx0XHRcdGVsc2Ugc2NhbGVBbmdsZT0oZGViQW5nbGUrZmluQW5nbGUpLzI7XG5cblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0XHRjdHguZm9udCA9IGNvbmZpZy5zY2FsZUZvbnRTdHlsZSArIFwiIFwiICsgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKS50b1N0cmluZygpICsgXCJweCBcIiArIGNvbmZpZy5zY2FsZUZvbnRGYW1pbHk7XG5cdFx0XHRcdFx0dmFyIGxhYmVsID0gY2FsY3VsYXRlZFNjYWxlLmxhYmVsc1tpICsgMV07XG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5zY2FsZVNob3dMYWJlbEJhY2tkcm9wKSB7XG5cdFx0XHRcdFx0XHR2YXIgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0TXVsdGlMaW5lKGxhYmVsLCBNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSk7XG5cdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gY29uZmlnLnNjYWxlQmFja2Ryb3BDb2xvcjtcblx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdGN0eC5yZWN0KFxuXHRcdFx0XHRcdFx0XHRNYXRoLnJvdW5kKG1pZFBvc1ggKyBNYXRoLmNvcyhzY2FsZUFuZ2xlKSooc2NhbGVIb3AqKGkrMSkpIC0gdGV4dFdpZHRoIC8gMiAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zY2FsZUJhY2tkcm9wUGFkZGluZ1gpKSwgLy9YXG5cdFx0XHRcdFx0XHRcdE1hdGgucm91bmQobWlkUG9zWSAtIE1hdGguc2luKHNjYWxlQW5nbGUpKihzY2FsZUhvcCAqIChpICsgMSkpIC0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSAqIDAuNSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zY2FsZUJhY2tkcm9wUGFkZGluZ1kpKSwgLy9ZXG5cdFx0XHRcdFx0XHRcdE1hdGgucm91bmQodGV4dFdpZHRoICsgKE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zY2FsZUJhY2tkcm9wUGFkZGluZ1gpICogMikpLCAvL1dpZHRoXG5cdFx0XHRcdFx0XHRcdE1hdGgucm91bmQoKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSArIChNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc2NhbGVCYWNrZHJvcFBhZGRpbmdZKSAqIDIpKSAvL0hlaWdodFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBjb25maWcuc2NhbGVGb250Q29sb3I7XG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGxhYmVsLCBtaWRQb3NYICsgTWF0aC5jb3Moc2NhbGVBbmdsZSkqKHNjYWxlSG9wKihpKzEpKSAsIG1pZFBvc1kgLSBNYXRoLnNpbihzY2FsZUFuZ2xlKSooc2NhbGVIb3AgKiAoaSArIDEpKSwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJTQ0FMRV9URVhUTU9VU0VcIiwwLDAsMCxpLC0xKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZUJvdW5kcygpIHtcblx0XHRcdHZhciB1cHBlclZhbHVlID0gLU51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHR2YXIgbG93ZXJWYWx1ZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYodHlwZW9mIGRhdGFbaV0udmFsdWUgPT0gXCJ1bmRlZmluZWRcIikgY29udGludWU7XG5cdFx0XHRcdGlmICgxICogZGF0YVtpXS52YWx1ZSA+IHVwcGVyVmFsdWUpIHtcblx0XHRcdFx0XHR1cHBlclZhbHVlID0gMSAqIGRhdGFbaV0udmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKDEgKiBkYXRhW2ldLnZhbHVlIDwgbG93ZXJWYWx1ZSkge1xuXHRcdFx0XHRcdGxvd2VyVmFsdWUgPSAxICogZGF0YVtpXS52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGlmKHVwcGVyVmFsdWU8bG93ZXJWYWx1ZSl7dXBwZXJWYWx1ZT0wO2xvd2VyVmFsdWU9MDt9XG5cdFx0XHRpZiAoTWF0aC5hYnModXBwZXJWYWx1ZSAtIGxvd2VyVmFsdWUpIDwgY29uZmlnLnplcm9WYWx1ZSkge1xuXHRcdFx0XHRpZihNYXRoLmFicyh1cHBlclZhbHVlKTwgY29uZmlnLnplcm9WYWx1ZSkgdXBwZXJWYWx1ZSA9IC45O1xuXHRcdFx0XHRpZih1cHBlclZhbHVlPjApIHtcblx0XHRcdFx0XHR1cHBlclZhbHVlPXVwcGVyVmFsdWUqMS4xO1xuXHRcdFx0XHRcdGxvd2VyVmFsdWU9bG93ZXJWYWx1ZSowLjk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dXBwZXJWYWx1ZT11cHBlclZhbHVlKjAuOTtcblx0XHRcdFx0XHRsb3dlclZhbHVlPWxvd2VyVmFsdWUqMS4xO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZih0eXBlb2YgY29uZmlnLmdyYXBoTWluPT1cImZ1bmN0aW9uXCIpIGxvd2VyVmFsdWU9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkdSQVBITUlOXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5ncmFwaE1pbixcImdyYXBoTWluXCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9KVxuXHRcdFx0ZWxzZSBpZiAoIWlzTmFOKGNvbmZpZy5ncmFwaE1pbikpIGxvd2VyVmFsdWUgPSBjb25maWcuZ3JhcGhNaW47XG5cdFx0XHRpZih0eXBlb2YgY29uZmlnLmdyYXBoTWF4PT1cImZ1bmN0aW9uXCIpIHVwcGVyVmFsdWU9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkdSQVBITUFYXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5ncmFwaE1heCxcImdyYXBoTWF4XCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9KVxuXHRcdFx0ZWxzZSBpZiAoIWlzTmFOKGNvbmZpZy5ncmFwaE1heCkpIHVwcGVyVmFsdWUgPSBjb25maWcuZ3JhcGhNYXg7XG5cdFx0XHR2YXIgbWF4U3RlcHMgPSBNYXRoLmZsb29yKChzY2FsZUhlaWdodCAvIChsYWJlbEhlaWdodCAqIDAuNjYpKSk7XG5cdFx0XHR2YXIgbWluU3RlcHMgPSBNYXRoLmZsb29yKChzY2FsZUhlaWdodCAvIGxhYmVsSGVpZ2h0ICogMC41KSk7XG5cdFx0XHRpZih1cHBlclZhbHVlPGxvd2VyVmFsdWUpe2xvd2VyVmFsdWU9dXBwZXJWYWx1ZS0xO31cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bWF4VmFsdWU6IHVwcGVyVmFsdWUsXG5cdFx0XHRcdG1pblZhbHVlOiBsb3dlclZhbHVlLFxuXHRcdFx0XHRtYXhTdGVwczogbWF4U3RlcHMsXG5cdFx0XHRcdG1pblN0ZXBzOiBtaW5TdGVwc1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGE6ZGF0YSxcblx0XHRcdGNvbmZpZzpjb25maWcsXG5cdFx0XHRjdHg6Y3R4XG5cdFx0fTtcblx0fTtcblx0dmFyIFJhZGFyID0gZnVuY3Rpb24oZGF0YSwgY29uZmlnLCBjdHgpIHtcblx0XHR2YXIgbWF4U2l6ZSwgc2NhbGVIb3AsIGNhbGN1bGF0ZWRTY2FsZSwgbGFiZWxIZWlnaHQsIHNjYWxlSGVpZ2h0LCB2YWx1ZUJvdW5kcywgbGFiZWxUZW1wbGF0ZVN0cmluZywgbXNyLCBtaWRQb3NYLCBtaWRQb3NZO1xuXG5cdFx0Y3R4LnRwY2hhcnQ9XCJSYWRhclwiO1xuXHRcdGN0eC50cGRhdGE9MDtcblxuXHQgICAgICAgIGlmICghaW5pdF9hbmRfc3RhcnQoY3R4LGRhdGEsY29uZmlnKSkgcmV0dXJuO1xuXHRcdHZhciBzdGF0RGF0YT1pbml0UGFzc1ZhcmlhYmxlRGF0YV9wYXJ0MShkYXRhLGNvbmZpZyxjdHgpO1xuXHRcdHZhbHVlQm91bmRzID0gZ2V0VmFsdWVCb3VuZHMoKTtcblxuXHRcdGNvbmZpZy5sb2dhcml0aG1pYyA9IGZhbHNlO1xuXHRcdGNvbmZpZy5sb2dhcml0aG1pYzIgPSBmYWxzZTtcblx0XHQvL0lmIG5vIGxhYmVscyBhcmUgZGVmaW5lZCBzZXQgdG8gYW4gZW1wdHkgYXJyYXksIHNvIHJlZmVyZW5jaW5nIGxlbmd0aCBmb3IgbG9vcGluZyBkb2Vzbid0IGJsb3cgdXAuXG5cdFx0aWYgKCFkYXRhLmxhYmVscykgZGF0YS5sYWJlbHMgPSBbXTtcblx0XHQvL0NoZWNrIGFuZCBzZXQgdGhlIHNjYWxlXG5cdFx0bGFiZWxUZW1wbGF0ZVN0cmluZyA9IChjb25maWcuc2NhbGVTaG93TGFiZWxzKSA/IGNvbmZpZy5zY2FsZUxhYmVsIDogXCJcIjtcblx0XHRpZiAoIWNvbmZpZy5zY2FsZU92ZXJyaWRlKSB7XG5cdFx0XHRjYWxjdWxhdGVkU2NhbGUgPSBjYWxjdWxhdGVTY2FsZSgxLCBjb25maWcsIHZhbHVlQm91bmRzLm1heFN0ZXBzLCB2YWx1ZUJvdW5kcy5taW5TdGVwcywgdmFsdWVCb3VuZHMubWF4VmFsdWUsIHZhbHVlQm91bmRzLm1pblZhbHVlLCBsYWJlbFRlbXBsYXRlU3RyaW5nKTtcblx0XHRcdG1zciA9IHNldE1lYXN1cmVzKGRhdGEsIGNvbmZpZywgY3R4LCBjdHguY2FudmFzLmhlaWdodCwgY3R4LmNhbnZhcy53aWR0aCwgY2FsY3VsYXRlZFNjYWxlLmxhYmVscywgbnVsbCwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCB0cnVlLCBjb25maWcuZGF0YXNldEZpbGwsIFwiUmFkYXJcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBzY2FsZVN0YXJ0VmFsdWU9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNDQUxFU1RBUlRWQUxVRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuc2NhbGVTdGFydFZhbHVlLFwic2NhbGVTdGFydFZhbHVlXCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHR2YXIgc2NhbGVTdGVwcyA9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEVQU1wiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuc2NhbGVTdGVwcyxcInNjYWxlU3RlcHNcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdHZhciBzY2FsZVN0ZXBXaWR0aCA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNDQUxFU1RFUFdJRFRIXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5zY2FsZVN0ZXBXaWR0aCxcInNjYWxlU3RlcFdpZHRoXCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRjYWxjdWxhdGVkU2NhbGUgPSB7XG5cdFx0XHRcdHN0ZXBzOiBzY2FsZVN0ZXBzLFxuXHRcdFx0XHRzdGVwVmFsdWU6IHNjYWxlU3RlcFdpZHRoLFxuXHRcdFx0XHRncmFwaE1pbjogc2NhbGVTdGFydFZhbHVlLFxuXHRcdFx0XHRncmFwaE1heDogc2NhbGVTdGFydFZhbHVlICsgc2NhbGVTdGVwcyAqIHNjYWxlU3RlcFdpZHRoLFxuXHRcdFx0XHRsYWJlbHM6IFtdXG5cdFx0XHR9XG5cdFx0XHRwb3B1bGF0ZUxhYmVscygxLCBjb25maWcsIGxhYmVsVGVtcGxhdGVTdHJpbmcsIGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHMsIGNhbGN1bGF0ZWRTY2FsZS5zdGVwcywgc2NhbGVTdGFydFZhbHVlLCBjYWxjdWxhdGVkU2NhbGUuZ3JhcGhNYXgsIHNjYWxlU3RlcFdpZHRoKTtcblx0XHRcdG1zciA9IHNldE1lYXN1cmVzKGRhdGEsIGNvbmZpZywgY3R4LCBjdHguY2FudmFzLmhlaWdodCwgY3R4LmNhbnZhcy53aWR0aCwgY2FsY3VsYXRlZFNjYWxlLmxhYmVscywgbnVsbCwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCB0cnVlLCBjb25maWcuZGF0YXNldEZpbGwsIFwiUmFkYXJcIik7XG5cdFx0fVxuXG5cdFx0Y2FsY3VsYXRlRHJhd2luZ1NpemVzKCk7XG5cdFx0bWlkUG9zWSA9IG1zci50b3BOb3RVc2FibGVTaXplICsgKG1zci5hdmFpbGFibGVIZWlnaHQgLyAyKTtcblx0XHRzY2FsZUhvcCA9IG1heFNpemUgLyAoY2FsY3VsYXRlZFNjYWxlLnN0ZXBzKTtcblx0XHQvL1dyYXAgaW4gYW4gYW5pbWF0aW9uIGxvb3Agd3JhcHBlclxuXHRcdGluaXRQYXNzVmFyaWFibGVEYXRhX3BhcnQyKHN0YXREYXRhLGRhdGEsY29uZmlnLGN0eCx7bWlkUG9zWCA6IG1pZFBvc1gsIG1pZFBvc1kgOiBtaWRQb3NZLCBjYWxjdWxhdGVkU2NhbGU6IGNhbGN1bGF0ZWRTY2FsZSwgc2NhbGVIb3A6IHNjYWxlSG9wLCBtYXhTaXplOm1heFNpemUsb3V0ZXJWYWwgOiAtMX0pO1xuXHRcdGFuaW1hdGlvbkxvb3AoY29uZmlnLCBkcmF3U2NhbGUsIGRyYXdBbGxEYXRhUG9pbnRzLCBjdHgsIG1zci5jbHJ4LCBtc3IuY2xyeSwgbXNyLmNscndpZHRoLCBtc3IuY2xyaGVpZ2h0LCBtaWRQb3NYLCBtaWRQb3NZLCBtaWRQb3NYIC0gbWF4U2l6ZSwgbWlkUG9zWSArIG1heFNpemUsIGRhdGEsIHN0YXREYXRhKTtcblx0XHQvL1JhZGFyIHNwZWNpZmljIGZ1bmN0aW9ucy5cblx0XHRmdW5jdGlvbiBkcmF3QWxsRGF0YVBvaW50cyhhbmltYXRpb25EZWNpbWFsKSB7XG5cdFx0XHR2YXIgcm90YXRpb25EZWdyZWUgPSAoMiAqIE1hdGguUEkpIC8gZGF0YS5kYXRhc2V0c1swXS5kYXRhLmxlbmd0aDtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHQvL1dlIGFjY2VwdCBtdWx0aXBsZSBkYXRhIHNldHMgZm9yIHJhZGFyIGNoYXJ0cywgc28gc2hvdyBsb29wIHRocm91Z2ggZWFjaCBzZXRcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgZlB0ID0gLTE7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0dmFyIGN1cnJlbnRBbmltUGMgPSBhbmltYXRpb25Db3JyZWN0aW9uKGFuaW1hdGlvbkRlY2ltYWwsIGRhdGEsIGNvbmZpZywgaSwgaiwgZmFsc2UpLmFuaW1WYWw7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRBbmltUGMgPiAxKSBjdXJyZW50QW5pbVBjID0gY3VycmVudEFuaW1QYyAtIDE7XG5cdFx0XHRcdFx0aWYgKCEodHlwZW9mKGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSkgPT0gJ3VuZGVmaW5lZCcpKSB7XG5cdFx0XHRcdFx0XHRpZiAoZlB0ID09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdFx0Y3R4Lm1vdmVUbyhtaWRQb3NYICsgY3VycmVudEFuaW1QYyAqIHN0YXREYXRhW2ldW2pdLm9mZnNldFgsIG1pZFBvc1kgLSBjdXJyZW50QW5pbVBjICogc3RhdERhdGFbaV1bal0ub2Zmc2V0WSk7XG5cdFx0XHRcdFx0XHRcdGZQdCA9IGo7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjdHgubGluZVRvKG1pZFBvc1ggKyBjdXJyZW50QW5pbVBjICogc3RhdERhdGFbaV1bal0ub2Zmc2V0WCwgbWlkUG9zWSAtIGN1cnJlbnRBbmltUGMgKiBzdGF0RGF0YVtpXVtqXS5vZmZzZXRZKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRpZiAoY29uZmlnLmRhdGFzZXRGaWxsKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uZmlsbENvbG9yLGNvbmZpZy5kZWZhdWx0RmlsbENvbG9yLFwiZmlsbENvbG9yXCIsaSwtMSx7YW5pbWF0aW9uVmFsdWUgOiBjdXJyZW50QW5pbVBjLCBtaWRQb3NYIDogc3RhdERhdGFbaV1bMF0ubWlkUG9zWCwgbWlkUG9zWSA6IHN0YXREYXRhW2ldWzBdLm1pZFBvc1ksIGV4dF9yYWRpdXMgOiAoY29uZmlnLmFuaW1hdGlvbkxlZnRUb1JpZ2h0ID8gMSA6IGN1cnJlbnRBbmltUGMpICogKHN0YXREYXRhW2ldWzBdLmNhbGN1bGF0ZWRfb2Zmc2V0X21heCl9ICk7XG5cdFx0XHRcdH0gZWxzZSBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsMCwwLDApXCI7XG5cblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNUUk9LRUNPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5zdHJva2VDb2xvcixjb25maWcuZGVmYXVsdFN0cm9rZUNvbG9yLFwic3Ryb2tlQ29sb3JcIixpLC0xLHtudWxsdmFsdWUgOiBudWxsfSApO1xuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJMSU5FV0lEVEhcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmRhdGFzZXRTdHJva2VXaWR0aCxjb25maWcuZGF0YXNldFN0cm9rZVdpZHRoLFwiZGF0YXNldFN0cm9rZVdpZHRoXCIsaSwtMSx7bnVsbHZhbHVlIDogbnVsbH0gKSk7XG5cdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJMSU5FREFTSFwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uZGF0YXNldFN0cm9rZVN0eWxlLGNvbmZpZy5kYXRhc2V0U3Ryb2tlU3R5bGUsXCJkYXRhc2V0U3Ryb2tlU3R5bGVcIixpLGose251bGx2YWx1ZSA6IG51bGx9ICkpKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0XHRpZiAoYW5pbWF0aW9uRGVjaW1hbCA+PSBjb25maWcuYW5pbWF0aW9uU3RvcFZhbHVlKSB7XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkYXRhLmRhdGFzZXRzW2ldLmRhdGEubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdGlmICghKHR5cGVvZihkYXRhLmRhdGFzZXRzW2ldLmRhdGFba10pID09ICd1bmRlZmluZWQnKSkge1xuXHRcdFx0XHRcdFx0XHRpZihzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJQT0lOVERPVFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcucG9pbnREb3QsXCJwb2ludERvdFwiLGksayx7bnVsbHZhbHVlIDogbnVsbH0gKSkge1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIk1BUktFUkZJTExDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0ucG9pbnRDb2xvcixjb25maWcuZGVmYXVsdFN0cm9rZUNvbG9yLFwicG9pbnRDb2xvclwiLGksayx7bnVsbHZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZT1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJNQVJLRVJTVFJPS0VTVFlMRVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0ucG9pbnRTdHJva2VDb2xvcixjb25maWcuZGVmYXVsdFN0cm9rZUNvbG9yLFwicG9pbnRTdHJva2VDb2xvclwiLGksayx7bnVsbHZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5saW5lV2lkdGg9c2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRMaW5lU2NhbGUsXCJNQVJLRVJMSU5FV0lEVEhcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLnBvaW50RG90U3Ryb2tlV2lkdGgsY29uZmlnLnBvaW50RG90U3Ryb2tlV2lkdGgsXCJwb2ludERvdFN0cm9rZVdpZHRoXCIsaSxrLHtudWxsdmFsdWU6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1hcmtlclNoYXBlPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIk1BUktFUlNIQVBFXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5tYXJrZXJTaGFwZSxjb25maWcubWFya2VyU2hhcGUsXCJtYXJrZXJTaGFwZVwiLGksayx7bnVsbHZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXJrZXJSYWRpdXM9c2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiTUFSS0VSUkFESVVTXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5wb2ludERvdFJhZGl1cyxjb25maWcucG9pbnREb3RSYWRpdXMsXCJwb2ludERvdFJhZGl1c1wiLGksayx7bnVsbHZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXJrZXJTdHJva2VTdHlsZT1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJNQVJLRVJTVFJPS0VTVFlMRVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0ucG9pbnREb3RTdHJva2VTdHlsZSxjb25maWcucG9pbnREb3RTdHJva2VTdHlsZSxcInBvaW50RG90U3Ryb2tlU3R5bGVcIixpLGsse251bGx2YWx1ZTogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0XHRkcmF3TWFya2VyKGN0eCxtaWRQb3NYICsgY3VycmVudEFuaW1QYyAqIHN0YXREYXRhW2ldW2tdLm9mZnNldFgsIG1pZFBvc1kgLSBjdXJyZW50QW5pbVBjICogc3RhdERhdGFbaV1ba10ub2Zmc2V0WSwgbWFya2VyU2hhcGUsbWFya2VyUmFkaXVzLG1hcmtlclN0cm9rZVN0eWxlKTtcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0aWYgKGFuaW1hdGlvbkRlY2ltYWwgPj0gY29uZmlnLmFuaW1hdGlvblN0b3BWYWx1ZSkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBkYXRhLmRhdGFzZXRzW2ldLmRhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKSA9PSAndW5kZWZpbmVkJykgY29udGludWU7XG5cdFx0XHRcdFx0XHRqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW2pzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF0ubGVuZ3RoXSA9IFtcIlBPSU5UXCIsIGksaixzdGF0RGF0YSxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJBTk5PVEFURURJU1BMQVlcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmFubm90YXRlRGlzcGxheSxjb25maWcuYW5ub3RhdGVEaXNwbGF5LFwiYW5ub3RhdGVEaXNwbGF5XCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSldO1xuXHRcdFx0XHRcdFx0aWYoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFTSE9XXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5pbkdyYXBoRGF0YVNob3csY29uZmlnLmluR3JhcGhEYXRhU2hvdyxcImluR3JhcGhEYXRhU2hvd1wiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0pKSB7XG5cdFx0XHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQWxpZ24sXCJpbkdyYXBoRGF0YUFsaWduXCIsaSxqLHtudWxsVmFsdWU6IHRydWUgIH0pO1xuXHRcdFx0XHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFWQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhVkFsaWduLFwiaW5HcmFwaERhdGFWQWxpZ25cIixpLGose251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUFMSUdOXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUFsaWduLFwiaW5HcmFwaERhdGFBbGlnblwiLGksaix7bnVsbFZhbHVlOiB0cnVlICB9KSA9PSBcIm9mZi1jZW50ZXJcIikge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVJPVEFURVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSb3RhdGUsXCJpbkdyYXBoRGF0YVJvdGF0ZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSBcImluUmFkaXVzQXhpc1wiIHx8IChjb25maWcuc3RhcnRBbmdsZSAqIE1hdGguUEkgLyAxODAgLSBqICogcm90YXRpb25EZWdyZWUgKyA0ICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpID4gMyAqIE1hdGguUEkgLyAyIHx8IChjb25maWcuc3RhcnRBbmdsZSAqIE1hdGguUEkgLyAxODAgLSBqICogcm90YXRpb25EZWdyZWUgKyA0ICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpIDw9IE1hdGguUEkgLyAyKSBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSBjdHgudGV4dEFsaWduID0gXCJyaWdodFwiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQWxpZ24sXCJpbkdyYXBoRGF0YUFsaWduXCIsaSxqLHtudWxsVmFsdWU6IHRydWUgIH0pID09IFwidG8tY2VudGVyXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFST1RBVEVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUm90YXRlLFwiaW5HcmFwaERhdGFSb3RhdGVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgPT0gXCJpblJhZGl1c0F4aXNcIiB8fCAoY29uZmlnLnN0YXJ0QW5nbGUgKiBNYXRoLlBJIC8gMTgwIC0gaiAqIHJvdGF0aW9uRGVncmVlICsgNCAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSA+IDMgKiBNYXRoLlBJIC8gMiB8fCAoY29uZmlnLnN0YXJ0QW5nbGUgKiBNYXRoLlBJIC8gMTgwIC0gaiAqIHJvdGF0aW9uRGVncmVlICsgNCAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSA8IE1hdGguUEkgLyAyKSBjdHgudGV4dEFsaWduID0gXCJyaWdodFwiO1xuXHRcdFx0XHRcdFx0XHRcdGVsc2UgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgY3R4LnRleHRBbGlnbiA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQWxpZ24sXCJpbkdyYXBoRGF0YUFsaWduXCIsaSxqLHtudWxsVmFsdWU6IHRydWUgIH0pO1xuXHRcdFx0XHRcdFx0XHRpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFWQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhVkFsaWduLFwiaW5HcmFwaERhdGFWQWxpZ25cIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgPT0gXCJvZmYtY2VudGVyXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoKGNvbmZpZy5zdGFydEFuZ2xlICogTWF0aC5QSSAvIDE4MCAtIGogKiByb3RhdGlvbkRlZ3JlZSArIDQgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkgPiBNYXRoLlBJKSBjdHgudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcblx0XHRcdFx0XHRcdFx0XHRlbHNlIGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBVkFMSUdOXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVZBbGlnbixcImluR3JhcGhEYXRhVkFsaWduXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IFwidG8tY2VudGVyXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoKGNvbmZpZy5zdGFydEFuZ2xlICogTWF0aC5QSSAvIDE4MCAtIGogKiByb3RhdGlvbkRlZ3JlZSArIDQgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkgPiBNYXRoLlBJKSBjdHgudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcblx0XHRcdFx0XHRcdFx0XHRlbHNlIGN0eC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgY3R4LnRleHRCYXNlbGluZSA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBVkFMSUdOXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVZBbGlnbixcImluR3JhcGhEYXRhVkFsaWduXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHRjdHguZm9udCA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBRk9OVFNUWUxFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRTdHlsZSxcImluR3JhcGhEYXRhRm9udFN0eWxlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApICsgJyAnICsgc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRUZXh0U2NhbGUsXCJJTkdSQVBIREFUQUZPTlRTSVpFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRTaXplLFwiaW5HcmFwaERhdGFGb250U2l6ZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSArICdweCAnICsgc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFGT05URkFNSUxZXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRGYW1pbHksXCJpbkdyYXBoRGF0YUZvbnRGYW1pbHlcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUZPTlRDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250Q29sb3IsXCJpbkdyYXBoRGF0YUZvbnRDb2xvclwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0dmFyIHJhZGl1c1BydDtcblx0XHRcdFx0XHRcdFx0aWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUkFESVVTUE9TSVRJT05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUmFkaXVzUG9zaXRpb24sXCJpbkdyYXBoRGF0YVJhZGl1c1Bvc2l0aW9uXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDEpIHJhZGl1c1BydCA9IDAgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVBBRERJTkdSQURJVVNcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ1JhZGl1cyxcImluR3JhcGhEYXRhUGFkZGluZ1JhZGl1c1wiLGksaix7bnVsbFZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHRlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVJBRElVU1BPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVJhZGl1c1Bvc2l0aW9uLFwiaW5HcmFwaERhdGFSYWRpdXNQb3NpdGlvblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAyKSByYWRpdXNQcnQgPSAoc3RhdERhdGFbaV1bal0uY2FsY3VsYXRlZF9vZmZzZXQpIC8gMiArIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUEFERElOR1JBRElVU1wiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzLFwiaW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzXCIsaSxqLHtudWxsVmFsdWU6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUkFESVVTUE9TSVRJT05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUmFkaXVzUG9zaXRpb24sXCJpbkdyYXBoRGF0YVJhZGl1c1Bvc2l0aW9uXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDMpIHJhZGl1c1BydCA9IChzdGF0RGF0YVtpXVtqXS5jYWxjdWxhdGVkX29mZnNldCkgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVBBRERJTkdSQURJVVNcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ1JhZGl1cyxcImluR3JhcGhEYXRhUGFkZGluZ1JhZGl1c1wiLGksaix7bnVsbFZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHR2YXIgeF9wb3MseV9wb3M7XG5cdFx0XHRcdFx0XHRcdGlmKHN0YXREYXRhW2ldW2pdLmNhbGN1bGF0ZWRfb2Zmc2V0PjApIHtcblx0XHRcdFx0XHRcdFx0ICAgICAgICB4X3Bvcz1taWRQb3NYICsgc3RhdERhdGFbaV1bal0ub2Zmc2V0WCAqIChyYWRpdXNQcnQvc3RhdERhdGFbaV1bal0uY2FsY3VsYXRlZF9vZmZzZXQpO1xuXHRcdFx0XHRcdFx0XHQgICAgICAgIHlfcG9zPW1pZFBvc1kgLSBzdGF0RGF0YVtpXVtqXS5vZmZzZXRZICogKHJhZGl1c1BydC9zdGF0RGF0YVtpXVtqXS5jYWxjdWxhdGVkX29mZnNldCk7XG4vL1x0XHRcdFx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKG1pZFBvc1ggKyBzdGF0RGF0YVtpXVtqXS5vZmZzZXRYICogKHJhZGl1c1BydC9zdGF0RGF0YVtpXVtqXS5jYWxjdWxhdGVkX29mZnNldCksIG1pZFBvc1kgLSBzdGF0RGF0YVtpXVtqXS5vZmZzZXRZICogKHJhZGl1c1BydC9zdGF0RGF0YVtpXVtqXS5jYWxjdWxhdGVkX29mZnNldCkpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHhfcG9zPW1pZFBvc1g7XG5cdFx0XHRcdFx0XHRcdFx0eV9wb3M9bWlkUG9zWTtcbi8vXHRcdFx0XHRcdFx0XHRcdGN0eC50cmFuc2xhdGUobWlkUG9zWCwgbWlkUG9zWSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh4X3Bvcyx5X3Bvcyk7XG5cdFx0XHRcdFx0XHRcdHZhciByb3RhdGVWYWw9MDtcblx0XHRcdFx0XHRcdFx0aWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUk9UQVRFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVJvdGF0ZSxcImluR3JhcGhEYXRhUm90YXRlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IFwiaW5SYWRpdXNBeGlzXCIpIHJvdGF0ZVZhbD0gaiAqIHJvdGF0aW9uRGVncmVlO1xuXHRcdFx0XHRcdFx0XHRlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVJPVEFURVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSb3RhdGUsXCJpbkdyYXBoRGF0YVJvdGF0ZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSBcImluUmFkaXVzQXhpc1JvdGF0ZUxhYmVsc1wiKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKChqICogcm90YXRpb25EZWdyZWUgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpID4gTWF0aC5QSSAvIDIgJiYgKGogKiByb3RhdGlvbkRlZ3JlZSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkgPCAzICogTWF0aC5QSSAvIDIpIHJvdGF0ZVZhbD0gMyAqIE1hdGguUEkgKyBqICogcm90YXRpb25EZWdyZWU7XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSByb3RhdGVWYWwgPSAyICogTWF0aC5QSSArIGogKiByb3RhdGlvbkRlZ3JlZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHJvdGF0ZVZhbD1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVJPVEFURVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSb3RhdGUsXCJpbkdyYXBoRGF0YVJvdGF0ZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSAqIChNYXRoLlBJIC8gMTgwKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZShyb3RhdGVWYWwpO1xuXHRcdFx0XHRcdFx0XHR2YXIgZGlzcFN0cmluZyA9IHRtcGxiaXMoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFUTVBMXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVRtcGwsXCJpbkdyYXBoRGF0YVRtcGxcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksIHN0YXREYXRhW2ldW2pdLGNvbmZpZyk7XG5cdFx0XHRcdFx0XHRcdHNldFRleHRCb3JkZXJzQW5kQmFja2dyb3VuZChjdHgsZGlzcFN0cmluZyxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFRleHRTY2FsZSxcIklOR1JBUEhEQVRBRk9OVFNJWkVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udFNpemUsXCJpbkdyYXBoRGF0YUZvbnRTaXplXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLDAsMCxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJPUkRFUlNcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVycyxcImluR3JhcGhEYXRhQm9yZGVyc1wiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJPUkRFUlNDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzQ29sb3IsXCJpbkdyYXBoRGF0YUJvcmRlcnNDb2xvclwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydExpbmVTY2FsZSxcIklOR1JBUEhEQVRBQk9SREVSU1dJRFRIXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNXaWR0aCxcImluR3JhcGhEYXRhQm9yZGVyc1dpZHRoXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBQk9SREVSU1hTUEFDRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzWFNwYWNlLFwiaW5HcmFwaERhdGFCb3JkZXJzWFNwYWNlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBQk9SREVSU1lTUEFDRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzWVNwYWNlLFwiaW5HcmFwaERhdGFCb3JkZXJzWVNwYWNlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQk9SREVSU1NUWUxFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNTdHlsZSxcImluR3JhcGhEYXRhQm9yZGVyc1N0eWxlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQkFDS0dST1VORENPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJhY2tncm91bmRDb2xvcixcImluR3JhcGhEYXRhQmFja2dyb3VuZENvbG9yXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLFwiSU5HUkFQSERBVEFcIixjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzUmFkaXVzKTtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGRpc3BTdHJpbmcsIDAsIDAsIGN0eC50ZXh0QmFzZWxpbmUsIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0VGV4dFNjYWxlLFwiSU5HUkFQSERBVEFGT05UU0laRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U2l6ZSxcImluR3JhcGhEYXRhRm9udFNpemVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksdHJ1ZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiSU5HUkFQSERBVEFfVEVYVE1PVVNFXCIscm90YXRlVmFsLHhfcG9zLHlfcG9zLGksaik7XG5cdFx0XHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihtc3IubGVnZW5kTXNyLmRpc3BMZWdlbmQpZHJhd0xlZ2VuZChtc3IubGVnZW5kTXNyLGRhdGEsY29uZmlnLGN0eCxcIlJhZGFyXCIpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBkcmF3U2NhbGUoKSB7XG5cdFx0XHR2YXIgcm90YXRpb25EZWdyZWUgPSAoMiAqIE1hdGguUEkpIC8gZGF0YS5kYXRhc2V0c1swXS5kYXRhLmxlbmd0aDtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHgudHJhbnNsYXRlKG1pZFBvc1gsIG1pZFBvc1kpO1xuXHRcdFx0Y3R4LnJvdGF0ZSgoOTAgLSBjb25maWcuc3RhcnRBbmdsZSkgKiBNYXRoLlBJIC8gMTgwKTtcblx0XHRcdGlmIChjb25maWcuYW5nbGVTaG93TGluZU91dCkge1xuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuYW5nbGVMaW5lQ29sb3I7XG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5hbmdsZUxpbmVXaWR0aCk7XG5cdFx0XHRcdGZvciAodmFyIGggPSAwOyBoIDwgZGF0YS5kYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgaCsrKSB7XG5cdFx0XHRcdFx0Y3R4LnJvdGF0ZShyb3RhdGlvbkRlZ3JlZSk7XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oMCwgMCk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbygwLCAtbWF4U2l6ZSk7XG4vL1x0XHRcdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oY29uZmlnLmFuZ2xlTGluZVN0eWxlKSk7XG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkFOR0xFTElORVNUWUxFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5hbmdsZUxpbmVTdHlsZSxcImFuZ2xlTGluZVN0eWxlXCIsaCwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSkpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGN1bGF0ZWRTY2FsZS5zdGVwczsgaSsrKSB7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0aWYgKGNvbmZpZy5zY2FsZVNob3dMaW5lICYmIChpKzEpICUgY29uZmlnLnNjYWxlR3JpZExpbmVzU3RlcCA9PSAwICkge1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5zY2FsZUxpbmVDb2xvcjtcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVMaW5lV2lkdGgpO1xuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oMCwgLXNjYWxlSG9wICogKGkgKyAxKSk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhLmRhdGFzZXRzWzBdLmRhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdGN0eC5yb3RhdGUocm90YXRpb25EZWdyZWUpO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbygwLCAtc2NhbGVIb3AgKiAoaSArIDEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihjb25maWcuc2NhbGVMaW5lU3R5bGUpKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y3R4LnJvdGF0ZSgtKDkwIC0gY29uZmlnLnN0YXJ0QW5nbGUpICogTWF0aC5QSSAvIDE4MCk7XG5cdFx0XHRpZiAoY29uZmlnLnNjYWxlU2hvd0xhYmVscykge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2FsY3VsYXRlZFNjYWxlLnN0ZXBzOyBpKyspIHtcblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRcdFx0Y3R4LmZvbnQgPSBjb25maWcuc2NhbGVGb250U3R5bGUgKyBcIiBcIiArIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSkudG9TdHJpbmcoKSArIFwicHggXCIgKyBjb25maWcuc2NhbGVGb250RmFtaWx5O1xuXHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuXHRcdFx0XHRcdGlmIChjb25maWcuc2NhbGVTaG93TGFiZWxCYWNrZHJvcCkge1xuXHRcdFx0XHRcdFx0dmFyIHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dE11bHRpTGluZShjYWxjdWxhdGVkU2NhbGUubGFiZWxzW2kgKyAxXSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSkudGV4dFdpZHRoO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5zY2FsZUJhY2tkcm9wQ29sb3I7XG5cdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHRjdHgucmVjdChcblx0XHRcdFx0XHRcdFx0TWF0aC5yb3VuZChNYXRoLmNvcyhjb25maWcuc3RhcnRBbmdsZSAqIE1hdGguUEkgLyAxODApICogKHNjYWxlSG9wICogKGkgKyAxKSkgLSB0ZXh0V2lkdGggLyAyIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNjYWxlQmFja2Ryb3BQYWRkaW5nWCkpLCAvL1hcblx0XHRcdFx0XHRcdFx0TWF0aC5yb3VuZCgoLU1hdGguc2luKGNvbmZpZy5zdGFydEFuZ2xlICogTWF0aC5QSSAvIDE4MCkgKiBzY2FsZUhvcCAqIChpICsgMSkpIC0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSAqIDAuNSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zY2FsZUJhY2tkcm9wUGFkZGluZ1kpKSwgLy9ZXG5cdFx0XHRcdFx0XHRcdE1hdGgucm91bmQodGV4dFdpZHRoICsgKE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zY2FsZUJhY2tkcm9wUGFkZGluZ1gpICogMikpLCAvL1dpZHRoXG5cdFx0XHRcdFx0XHRcdE1hdGgucm91bmQoKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSArIChNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc2NhbGVCYWNrZHJvcFBhZGRpbmdZKSAqIDIpKSAvL0hlaWdodFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBjb25maWcuc2NhbGVGb250Q29sb3I7XG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHNbaSArIDFdLCBNYXRoLmNvcyhjb25maWcuc3RhcnRBbmdsZSAqIE1hdGguUEkgLyAxODApICogKHNjYWxlSG9wICogKGkgKyAxKSksIC1NYXRoLnNpbihjb25maWcuc3RhcnRBbmdsZSAqIE1hdGguUEkgLyAxODApICogc2NhbGVIb3AgKiAoaSArIDEpLCBjdHgudGV4dEJhc2VsaW5lLCAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpLHRydWUsY29uZmlnLmRldGVjdE1vdXNlT25UZXh0LGN0eCxcIlNDQUxFX1RFWFRNT1VTRVwiLDAsbWlkUG9zWCwgbWlkUG9zWSxpLC0xKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkYXRhLmxhYmVscy5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRjdHguZm9udCA9IGNvbmZpZy5wb2ludExhYmVsRm9udFN0eWxlICsgXCIgXCIgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcucG9pbnRMYWJlbEZvbnRTaXplKSkudG9TdHJpbmcoKSArIFwicHggXCIgKyBjb25maWcucG9pbnRMYWJlbEZvbnRGYW1pbHk7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBjb25maWcucG9pbnRMYWJlbEZvbnRDb2xvcjtcblx0XHRcdFx0dmFyIG9wcG9zaXRlID0gTWF0aC5zaW4oKDkwIC0gY29uZmlnLnN0YXJ0QW5nbGUpICogTWF0aC5QSSAvIDE4MCArIHJvdGF0aW9uRGVncmVlICogaykgKiAobWF4U2l6ZSArIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5wb2ludExhYmVsRm9udFNpemUpKSk7XG5cdFx0XHRcdHZhciBhZGphY2VudCA9IE1hdGguY29zKCg5MCAtIGNvbmZpZy5zdGFydEFuZ2xlKSAqIE1hdGguUEkgLyAxODAgKyByb3RhdGlvbkRlZ3JlZSAqIGspICogKG1heFNpemUgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcucG9pbnRMYWJlbEZvbnRTaXplKSkpO1xuXHRcdFx0XHR2YXIgdmFuZ2xlID0gKDkwIC0gY29uZmlnLnN0YXJ0QW5nbGUpICogTWF0aC5QSSAvIDE4MCArIHJvdGF0aW9uRGVncmVlICogaztcblx0XHRcdFx0d2hpbGUgKHZhbmdsZSA8IDApIHZhbmdsZSA9IHZhbmdsZSArIDIgKiBNYXRoLlBJO1xuXHRcdFx0XHR3aGlsZSAodmFuZ2xlID4gMiAqIE1hdGguUEkpIHZhbmdsZSA9IHZhbmdsZSAtIDIgKiBNYXRoLlBJO1xuXHRcdFx0XHRpZiAodmFuZ2xlID09IE1hdGguUEkgfHwgdmFuZ2xlID09IDApIHtcblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0fSBlbHNlIGlmICh2YW5nbGUgPiBNYXRoLlBJKSB7XG5cdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwicmlnaHRcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG5cdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShkYXRhLmxhYmVsc1trXSwgb3Bwb3NpdGUsIC1hZGphY2VudCwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnBvaW50TGFiZWxGb250U2l6ZSkpLHRydWUsY29uZmlnLmRldGVjdE1vdXNlT25UZXh0LGN0eCxcIkxBQkVMX1RFWFRNT1VTRVwiLDAsbWlkUG9zWCwgbWlkUG9zWSxrLC0xKTtcblx0XHRcdH1cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNhbGN1bGF0ZURyYXdpbmdTaXplcygpIHtcblx0XHRcdHZhciBtaWRYLCBteGxiLCBtYXhMLCBtYXhSLCBpdGVyLCBuYml0ZXIsIHByZXZNYXhTaXplLCBwcmV2TWlkWCxpLHRleHRNZWFzdXJlbWVudDtcblx0XHRcdHZhciByb3RhdGlvbkRlZ3JlZSA9ICgyICogTWF0aC5QSSkgLyBkYXRhLmRhdGFzZXRzWzBdLmRhdGEubGVuZ3RoO1xuXHRcdFx0dmFyIHJvdGF0ZUFuZ2xlID0gY29uZmlnLnN0YXJ0QW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuXHRcdFx0Ly8gQ29tcHV0ZSByYW5nZSBmb3IgTWlkIFBvaW50IG9mIGdyYXBoXG5cdFx0XHRjdHguZm9udCA9IGNvbmZpZy5wb2ludExhYmVsRm9udFN0eWxlICsgXCIgXCIgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcucG9pbnRMYWJlbEZvbnRTaXplKSkudG9TdHJpbmcoKSArIFwicHggXCIgKyBjb25maWcucG9pbnRMYWJlbEZvbnRGYW1pbHk7XG5cdFx0XHRpZiAoIWNvbmZpZy5ncmFwaE1heGltaXplZCkge1xuXHRcdFx0XHRtYXhSID0gbXNyLmF2YWlsYWJsZVdpZHRoIC8gMjtcblx0XHRcdFx0bWF4TCA9IG1zci5hdmFpbGFibGVXaWR0aCAvIDI7XG5cdFx0XHRcdG5iaXRlciA9IDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXhSID0gbXNyLmF2YWlsYWJsZVdpZHRoIC8gMjtcblx0XHRcdFx0bWF4TCA9IG1zci5hdmFpbGFibGVXaWR0aCAvIDI7XG5cdFx0XHRcdG5iaXRlciA9IDQwO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5sYWJlbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR0ZXh0TWVhc3VyZW1lbnQgPSBjdHgubWVhc3VyZVRleHRNdWx0aUxpbmUoZGF0YS5sYWJlbHNbaV0sIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSkpLnRleHRXaWR0aCArIGN0eC5tZWFzdXJlVGV4dE11bHRpTGluZShkYXRhLmxhYmVsc1tpXSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSkudGV4dEhlaWdodDtcblx0XHRcdFx0XHRteGxiID0gKG1zci5hdmFpbGFibGVXaWR0aCAtIHRleHRNZWFzdXJlbWVudCkgLyAoMSArIE1hdGguYWJzKE1hdGguY29zKHJvdGF0ZUFuZ2xlKSkpO1xuXHRcdFx0XHRcdGlmICgocm90YXRlQW5nbGUgPCBNYXRoLlBJIC8gMiAmJiByb3RhdGVBbmdsZSA+IC1NYXRoLlBJIC8gMikgfHwgcm90YXRlQW5nbGUgPiAzICogTWF0aC5QSSAvIDIpIHtcblx0XHRcdFx0XHRcdGlmIChteGxiIDwgbWF4UikgbWF4UiA9IG14bGI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChNYXRoLmNvcyhyb3RhdGVBbmdsZSkgIT0gMCkge1xuXHRcdFx0XHRcdFx0aWYgKG14bGIgPCBtYXhMKSBtYXhMID0gbXhsYjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cm90YXRlQW5nbGUgLT0gcm90YXRpb25EZWdyZWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGNvbXB1dGUgbWF4IFJhZGl1cyBhbmQgbWlkUG9pbnQgaW4gdGhhdCByYW5nZVxuXHRcdFx0cHJldk1heFNpemUgPSAwO1xuXHRcdFx0cHJldk1pZFggPSAwO1xuXHRcdFx0bWlkUG9zWCA9IG1heFIgKyBtc3IubGVmdE5vdFVzYWJsZVNpemU7XG5cdFx0XHRmb3IgKG1pZFggPSBtYXhSLCBpdGVyID0gMDsgaXRlciA8IG5iaXRlcjsgKytpdGVyLCBtaWRYICs9IChtc3IuYXZhaWxhYmxlV2lkdGggLSBtYXhMIC0gbWF4UikgLyBuYml0ZXIpIHtcblx0XHRcdFx0bWF4U2l6ZSA9IE1heChbbWlkWCwgbXNyLmF2YWlsYWJsZVdpZHRoIC0gbWlkWF0pO1xuXHRcdFx0XHRyb3RhdGVBbmdsZSA9IGNvbmZpZy5zdGFydEFuZ2xlICogTWF0aC5QSSAvIDE4MDtcblx0XHRcdFx0bXhsYiA9IG1zci5hdmFpbGFibGU7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhLmxhYmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHRleHRNZWFzdXJlbWVudCA9IGN0eC5tZWFzdXJlVGV4dE11bHRpTGluZShkYXRhLmxhYmVsc1tpXSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSkudGV4dFdpZHRoICsgY3R4Lm1lYXN1cmVUZXh0TXVsdGlMaW5lKGRhdGEubGFiZWxzW2ldLCAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpKS50ZXh0SGVpZ2h0O1xuXHRcdFx0XHRcdGlmICgocm90YXRlQW5nbGUgPCBNYXRoLlBJIC8gMiAmJiByb3RhdGVBbmdsZSA+IC1NYXRoLlBJIC8gMikgfHwgcm90YXRlQW5nbGUgPiAzICogTWF0aC5QSSAvIDIpIHtcblx0XHRcdFx0XHRcdG14bGIgPSAoKG1zci5hdmFpbGFibGVXaWR0aCAtIG1pZFgpIC0gdGV4dE1lYXN1cmVtZW50KSAvIE1hdGguYWJzKE1hdGguY29zKHJvdGF0ZUFuZ2xlKSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChNYXRoLmNvcyhyb3RhdGVBbmdsZSAhPSAwKSkge1xuXHRcdFx0XHRcdFx0bXhsYiA9IChtaWRYIC0gdGV4dE1lYXN1cmVtZW50KSAvIE1hdGguYWJzKE1hdGguY29zKHJvdGF0ZUFuZ2xlKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChteGxiIDwgbWF4U2l6ZSkgbWF4U2l6ZSA9IG14bGI7XG5cdFx0XHRcdFx0aWYgKE1hdGguc2luKHJvdGF0ZUFuZ2xlKSAqIG1zci5hdmFpbGFibGVIZWlnaHQgLyAyID4gbXNyLmF2YWlsYWJsZUhlaWdodCAvIDIgLSAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpICogMikge1xuXHRcdFx0XHRcdFx0bXhsYiA9IE1hdGguc2luKHJvdGF0ZUFuZ2xlKSAqIG1zci5hdmFpbGFibGVIZWlnaHQgLyAyIC0gMS41ICogKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKTtcblx0XHRcdFx0XHRcdGlmIChteGxiIDwgbWF4U2l6ZSkgbWF4U2l6ZSA9IG14bGI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJvdGF0ZUFuZ2xlIC09IHJvdGF0aW9uRGVncmVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtYXhTaXplID4gcHJldk1heFNpemUpIHtcblx0XHRcdFx0XHRwcmV2TWF4U2l6ZSA9IG1heFNpemU7XG5cdFx0XHRcdFx0bWlkUG9zWCA9IG1pZFggKyBtc3IubGVmdE5vdFVzYWJsZVNpemU7ICAgIFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtYXhTaXplID0gcHJldk1heFNpemUgLSAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpIC8gMjtcblx0XHRcdC8vSWYgdGhlIGxhYmVsIGhlaWdodCBpcyBsZXNzIHRoYW4gNSwgc2V0IGl0IHRvIDUgc28gd2UgZG9uJ3QgaGF2ZSBsaW5lcyBvbiB0b3Agb2YgZWFjaCBvdGhlci5cblx0XHRcdGxhYmVsSGVpZ2h0ID0gRGVmYXVsdChsYWJlbEhlaWdodCwgNSk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFZhbHVlQm91bmRzKCkge1xuXHRcdFx0dmFyIHVwcGVyVmFsdWUgPSAtTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdHZhciBsb3dlclZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGEuZGF0YXNldHNbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal09PVwidW5kZWZpbmVkXCIpY29udGludWU7XG5cdFx0XHRcdFx0aWYgKDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gPiB1cHBlclZhbHVlKSB7XG5cdFx0XHRcdFx0XHR1cHBlclZhbHVlID0gMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA8IGxvd2VyVmFsdWUpIHtcblx0XHRcdFx0XHRcdGxvd2VyVmFsdWUgPSAxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZih1cHBlclZhbHVlPGxvd2VyVmFsdWUpe3VwcGVyVmFsdWU9MDtsb3dlclZhbHVlPTA7fVxuXHRcdFx0aWYgKE1hdGguYWJzKHVwcGVyVmFsdWUgLSBsb3dlclZhbHVlKSA8IGNvbmZpZy56ZXJvVmFsdWUpIHtcblx0XHRcdFx0aWYoTWF0aC5hYnModXBwZXJWYWx1ZSk8IGNvbmZpZy56ZXJvVmFsdWUpeyB1cHBlclZhbHVlID0gLjk7bG93ZXJWYWx1ZT0tLjk7fVxuXHRcdFx0XHRpZih1cHBlclZhbHVlPjApIHtcblx0XHRcdFx0XHR1cHBlclZhbHVlPXVwcGVyVmFsdWUqMS4xO1xuXHRcdFx0XHRcdGxvd2VyVmFsdWU9bG93ZXJWYWx1ZSowLjk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dXBwZXJWYWx1ZT11cHBlclZhbHVlKjAuOTtcblx0XHRcdFx0XHRsb3dlclZhbHVlPWxvd2VyVmFsdWUqMS4xO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZih0eXBlb2YgY29uZmlnLmdyYXBoTWluPT1cImZ1bmN0aW9uXCIpIGxvd2VyVmFsdWU9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkdSQVBITUlOXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5ncmFwaE1pbixcImdyYXBoTWluXCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9KVxuXHRcdFx0ZWxzZSBpZiAoIWlzTmFOKGNvbmZpZy5ncmFwaE1pbikpIGxvd2VyVmFsdWUgPSBjb25maWcuZ3JhcGhNaW47XG5cdFx0XHRpZih0eXBlb2YgY29uZmlnLmdyYXBoTWF4PT1cImZ1bmN0aW9uXCIpIHVwcGVyVmFsdWU9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkdSQVBITUFYXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5ncmFwaE1heCxcImdyYXBoTWF4XCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9KVxuXHRcdFx0ZWxzZSBpZiAoIWlzTmFOKGNvbmZpZy5ncmFwaE1heCkpIHVwcGVyVmFsdWUgPSBjb25maWcuZ3JhcGhNYXg7XG5cdFx0XHR2YXIgbWF4U3RlcHMgPSBNYXRoLmZsb29yKChzY2FsZUhlaWdodCAvIChsYWJlbEhlaWdodCAqIDAuNjYpKSk7XG5cdFx0XHR2YXIgbWluU3RlcHMgPSBNYXRoLmZsb29yKChzY2FsZUhlaWdodCAvIGxhYmVsSGVpZ2h0ICogMC41KSk7XG5cdFx0XHRpZih1cHBlclZhbHVlPGxvd2VyVmFsdWUpe2xvd2VyVmFsdWU9dXBwZXJWYWx1ZS0xO31cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1heFZhbHVlOiB1cHBlclZhbHVlLFxuXHRcdFx0XHRtaW5WYWx1ZTogbG93ZXJWYWx1ZSxcblx0XHRcdFx0bWF4U3RlcHM6IG1heFN0ZXBzLFxuXHRcdFx0XHRtaW5TdGVwczogbWluU3RlcHNcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRhOmRhdGEsXG5cdFx0XHRjb25maWc6Y29uZmlnLFxuXHRcdFx0Y3R4OmN0eFxuXHRcdH07XG5cdH07XG5cblxuXHR2YXIgUGllID0gZnVuY3Rpb24oZGF0YSwgY29uZmlnLCBjdHgpIHtcblx0XHR2YXIgbXNyLCBtaWRQaWVYLCBtaWRQaWVZLCBwaWVSYWRpdXM7XG5cdFx0Y3R4LnRwY2hhcnQ9XCJQaWVcIjtcblx0XHRyZXR1cm4oRG91Z2hudXQoZGF0YSxjb25maWcsY3R4KSk7XG5cdH07XG5cdFxuXHR2YXIgRG91Z2hudXQgPSBmdW5jdGlvbihkYXRhLCBjb25maWcsIGN0eCkge1xuXHRcdHZhciBtc3IsIG1pZFBpZVgsIG1pZFBpZVksIGRvdWdobnV0UmFkaXVzO1xuXG5cdFx0aWYodHlwZW9mIGN0eC50cGNoYXJ0ID09IFwidW5kZWZpbmVkXCIpY3R4LnRwY2hhcnQ9XCJEb3VnaG51dFwiO1xuXHRcdGN0eC50cGRhdGE9MTtcblxuXG5cdCAgICAgICAgaWYgKCFpbml0X2FuZF9zdGFydChjdHgsZGF0YSxjb25maWcpKSByZXR1cm47XG5cblx0XHR2YXIgc3RhdERhdGE9aW5pdFBhc3NWYXJpYWJsZURhdGFfcGFydDEoZGF0YSxjb25maWcsY3R4KTtcblxuXHRcdHZhciByZWFsQ3VtdWxhdGl2ZUFuZ2xlID0gKCgoY29uZmlnLnN0YXJ0QW5nbGUgKiAoTWF0aC5QSSAvIDE4MCkgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpKSArIDIqIE1hdGguUEkpICUgKDIqIE1hdGguUEkpIDsgXG5cdFx0Y29uZmlnLmxvZ2FyaXRobWljID0gZmFsc2U7XG5cdFx0Y29uZmlnLmxvZ2FyaXRobWljMiA9IGZhbHNlO1xuXHRcdG1zciA9IHNldE1lYXN1cmVzKGRhdGEsIGNvbmZpZywgY3R4LCBjdHguY2FudmFzLmhlaWdodCwgY3R4LmNhbnZhcy53aWR0aCwgXCJub25lXCIsIG51bGwsIHRydWUsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUsIFwiRG91Z2hudXRcIik7XG5cblx0XHR2YXIgZHJ3U2l6ZT1jYWxjdWxhdGVQaWVEcmF3aW5nU2l6ZShjdHgsbXNyLGNvbmZpZyxkYXRhLHN0YXREYXRhKTtcblxuXHRcdG1pZFBpZVg9ZHJ3U2l6ZS5taWRQaWVYO1xuXHRcdG1pZFBpZVk9ZHJ3U2l6ZS5taWRQaWVZO1xuXHRcdGRvdWdobnV0UmFkaXVzPWRyd1NpemUucmFkaXVzO1xuXHRcdFxuXHRcdHZhciBjdXRvdXRSYWRpdXM7XG4gICAgICAgICAgICAgICAgaWYoY3R4LnRwY2hhcnQgPT0gXCJQaWVcIiljdXRvdXRSYWRpdXM9MDtcblx0XHRlbHNlIGN1dG91dFJhZGl1cyA9IGRvdWdobnV0UmFkaXVzICogKGNvbmZpZy5wZXJjZW50YWdlSW5uZXJDdXRvdXQgLyAxMDApO1xuXHRcdGlmKGRvdWdobnV0UmFkaXVzID4gMCkge1xuXHRcdFx0aW5pdFBhc3NWYXJpYWJsZURhdGFfcGFydDIoc3RhdERhdGEsZGF0YSxjb25maWcsY3R4LHttaWRQb3NYIDogbWlkUGllWCxtaWRQb3NZIDogbWlkUGllWSAsaW50X3JhZGl1cyA6IGN1dG91dFJhZGl1cyAsZXh0X3JhZGl1cyA6IGRvdWdobnV0UmFkaXVzLG91dGVyVmFsIDogLTF9KTtcblx0XHRcdGFuaW1hdGlvbkxvb3AoY29uZmlnLCBudWxsLCBkcmF3UGllU2VnbWVudHMsIGN0eCwgbXNyLmNscngsIG1zci5jbHJ5LCBtc3IuY2xyd2lkdGgsIG1zci5jbHJoZWlnaHQsIG1pZFBpZVgsIG1pZFBpZVksIG1pZFBpZVggLSBkb3VnaG51dFJhZGl1cywgbWlkUGllWSArIGRvdWdobnV0UmFkaXVzLCBkYXRhLCBzdGF0RGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRlc3RSZWRyYXcoY3R4LGRhdGEsY29uZmlnKTtcblx0XHRcdGN0eC5maXJzdFBhc3M9OTtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIGRyYXdQaWVTZWdtZW50cyhhbmltYXRpb25EZWNpbWFsKSB7XG5cdFx0XHR2YXIgY3VtdWxhdGl2ZUFuZ2xlID0gKCgoLWNvbmZpZy5zdGFydEFuZ2xlICogKE1hdGguUEkgLyAxODApICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSkgKyAyKiBNYXRoLlBJKSAlICgyKiBNYXRoLlBJKSA7IFxuXG5cdFx0XHR2YXIgZGF0YUN1dG91dFJhZGl1cywgZGF0YURvdWdobnV0UmFkaXVzO1xuXG5cdFx0XHR2YXIgcHJldkFuZ2xlPXN0YXREYXRhWzBdLmZpcnN0QW5nbGU7XG5cblx0XHRcdHZhciBmaXhBbmdsZT0wO1xuXHRcdFx0dmFyIGZpcnN0QW5nbGU9c3RhdERhdGFbMF0uZmlyc3RBbmdsZTtcblx0XHRcdGlmKDEqY29uZmlnLmFuaW1hdGlvblN0YXJ0V2l0aERhdGE+MSAmJiAxKmNvbmZpZy5hbmltYXRpb25TdGFydFdpdGhEYXRhLTEgPCBkYXRhLmxlbmd0aCkge1xuXHRcdFx0XHRmaXhBbmdsZT0oc3RhdERhdGFbY29uZmlnLmFuaW1hdGlvblN0YXJ0V2l0aERhdGEtMV0uc3RhcnRBbmdsZS1zdGF0RGF0YVswXS5maXJzdEFuZ2xlKTtcblx0XHRcdFx0Zmlyc3RBbmdsZT1zdGF0RGF0YVtjb25maWcuYW5pbWF0aW9uU3RhcnRXaXRoRGF0YS0xXS5zdGFydEFuZ2xlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdFx0XHRcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXJcdHNjYWxlQW5pbWF0aW9uID0gMSxcblx0XHRcdFx0XHRyb3RhdGVBbmltYXRpb24gPSAxO1xuXHRcdFx0XHRpZiAoY3R4LnRwY2hhcnQ9PVwiUGllXCIpZGF0YUN1dG91dFJhZGl1cz1jdXRvdXRSYWRpdXM7XG5cdFx0XHRcdGVsc2UgZGF0YUN1dG91dFJhZGl1cz1jdXRvdXRSYWRpdXMtKGRvdWdobnV0UmFkaXVzLWN1dG91dFJhZGl1cykqc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiRVhQQU5ESU5SQURJVVNcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhW2ldLmV4cGFuZEluUmFkaXVzLDAsXCJleHBhbmRJblJhZGl1c1wiLGksLTEse2FuaW1hdGlvbkRlY2ltYWw6IGFuaW1hdGlvbkRlY2ltYWwsIHNjYWxlQW5pbWF0aW9uIDogc2NhbGVBbmltYXRpb259ICk7XG4gICAgICAgICAgICAgICAgXHQgICAgICAgIGRhdGFEb3VnaG51dFJhZGl1cz1kb3VnaG51dFJhZGl1cysoZG91Z2hudXRSYWRpdXMtY3V0b3V0UmFkaXVzKSpzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJFWFBBTkRPVVRSQURJVVNcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhW2ldLmV4cGFuZE91dFJhZGl1cywwLFwiZXhwYW5kT3V0UmFkaXVzXCIsaSwtMSx7YW5pbWF0aW9uRGVjaW1hbDogYW5pbWF0aW9uRGVjaW1hbCwgc2NhbGVBbmltYXRpb24gOiBzY2FsZUFuaW1hdGlvbn0gKTtcblx0XHRcdFx0aWYgKGNvbmZpZy5hbmltYXRpb24pIHtcblx0XHRcdFx0XHRpZiAoY29uZmlnLmFuaW1hdGVTY2FsZSkge1xuXHRcdFx0XHRcdFx0c2NhbGVBbmltYXRpb24gPSBhbmltYXRpb25EZWNpbWFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY29uZmlnLmFuaW1hdGVSb3RhdGUpIHtcblx0XHRcdFx0XHRcdHJvdGF0ZUFuaW1hdGlvbiA9IGFuaW1hdGlvbkRlY2ltYWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29ycmVjdGVkUm90YXRlQW5pbWF0aW9uID0gYW5pbWF0aW9uQ29ycmVjdGlvbihyb3RhdGVBbmltYXRpb24sIGRhdGEsIGNvbmZpZywgaSwgLTEsIGZhbHNlKS5tYWluVmFsO1xuXHRcdFx0XHRpZiAoISh0eXBlb2YoZGF0YVtpXS52YWx1ZSkgPT0gJ3VuZGVmaW5lZCcpICYmIDEqZGF0YVtpXS52YWx1ZSA+PTApIHtcblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNlZ21lbnRTdHJva2VXaWR0aCk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsMCwwLDApXCI7XG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5hbmltYXRpb25CeURhdGEgPT0gXCJCeUFyY1wiKSB7XG5cdFx0XHRcdFx0XHRlbmRBbmdsZT1zdGF0RGF0YVtpXS5zdGFydEFuZ2xlK2NvcnJlY3RlZFJvdGF0ZUFuaW1hdGlvbipzdGF0RGF0YVtpXS5zZWdtZW50QW5nbGU7XG5cdFx0XHRcdFx0XHRjdHguYXJjKG1pZFBpZVgsIG1pZFBpZVksIHNjYWxlQW5pbWF0aW9uICogZGF0YURvdWdobnV0UmFkaXVzLCBzdGF0RGF0YVtpXS5zdGFydEFuZ2xlLCBlbmRBbmdsZSxmYWxzZSk7XG5cdFx0XHRcdFx0XHRjdHguYXJjKG1pZFBpZVgsIG1pZFBpZVksIHNjYWxlQW5pbWF0aW9uICogZGF0YUN1dG91dFJhZGl1cywgZW5kQW5nbGUsc3RhdERhdGFbaV0uc3RhcnRBbmdsZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmKGNvbmZpZy5hbmltYXRpb25CeURhdGEpIHtcblx0XHRcdFx0XHQgICAgICAgIGlmIChpPDEqY29uZmlnLmFuaW1hdGlvblN0YXJ0V2l0aERhdGEtMSkge1xuXHRcdFx0XHRcdFx0XHRjdHguYXJjKG1pZFBpZVgsIG1pZFBpZVksIHNjYWxlQW5pbWF0aW9uICogZGF0YURvdWdobnV0UmFkaXVzLCBzdGF0RGF0YVtpXS5zdGFydEFuZ2xlLCBzdGF0RGF0YVtpXS5lbmRBbmdsZSxmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5hcmMobWlkUGllWCwgbWlkUGllWSwgc2NhbGVBbmltYXRpb24gKiBkYXRhQ3V0b3V0UmFkaXVzLCBzdGF0RGF0YVtpXS5lbmRBbmdsZSxzdGF0RGF0YVtpXS5zdGFydEFuZ2xlLCB0cnVlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZihzdGF0RGF0YVtpXS5zdGFydEFuZ2xlIDw9IGZpcnN0QW5nbGUrY29ycmVjdGVkUm90YXRlQW5pbWF0aW9uKigyKk1hdGguUEktZml4QW5nbGUpICkge1xuXHRcdFx0XHRcdFx0XHRlbmRBbmdsZT1zdGF0RGF0YVtpXS5lbmRBbmdsZTtcblx0XHRcdFx0XHRcdFx0aWYoc3RhdERhdGFbaV0uZW5kQW5nbGUgPiBmaXJzdEFuZ2xlK2NvcnJlY3RlZFJvdGF0ZUFuaW1hdGlvbiooMipNYXRoLlBJLWZpeEFuZ2xlKSkge1xuXHRcdFx0XHRcdFx0XHRcdGVuZEFuZ2xlPWZpcnN0QW5nbGUrY29ycmVjdGVkUm90YXRlQW5pbWF0aW9uKigyKk1hdGguUEktZml4QW5nbGUpO1xuXHRcdFx0XHRcdFx0XHR9IFxuXHRcdFx0XHRcdFx0XHRjdHguYXJjKG1pZFBpZVgsIG1pZFBpZVksIHNjYWxlQW5pbWF0aW9uICogZGF0YURvdWdobnV0UmFkaXVzLCBzdGF0RGF0YVtpXS5zdGFydEFuZ2xlLCBlbmRBbmdsZSxmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5hcmMobWlkUGllWCwgbWlkUGllWSwgc2NhbGVBbmltYXRpb24gKiBkYXRhQ3V0b3V0UmFkaXVzLCBlbmRBbmdsZSxzdGF0RGF0YVtpXS5zdGFydEFuZ2xlLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlOyBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3R4LmFyYyhtaWRQaWVYLCBtaWRQaWVZLCBzY2FsZUFuaW1hdGlvbiAqIGRhdGFEb3VnaG51dFJhZGl1cywgcHJldkFuZ2xlLCBwcmV2QW5nbGUrY29ycmVjdGVkUm90YXRlQW5pbWF0aW9uICogKHN0YXREYXRhW2ldLmVuZEFuZ2xlLXN0YXREYXRhW2ldLnN0YXJ0QW5nbGUpLGZhbHNlKTtcblx0XHRcdFx0XHRcdGN0eC5hcmMobWlkUGllWCwgbWlkUGllWSwgc2NhbGVBbmltYXRpb24gKiBkYXRhQ3V0b3V0UmFkaXVzLCBwcmV2QW5nbGUrY29ycmVjdGVkUm90YXRlQW5pbWF0aW9uICogKHN0YXREYXRhW2ldLmVuZEFuZ2xlLXN0YXREYXRhW2ldLnN0YXJ0QW5nbGUpLCBwcmV2QW5nbGUsIHRydWUpO1xuXHRcdFx0XHRcdFx0cHJldkFuZ2xlPXByZXZBbmdsZStjb3JyZWN0ZWRSb3RhdGVBbmltYXRpb24gKiAoc3RhdERhdGFbaV0uZW5kQW5nbGUtc3RhdERhdGFbaV0uc3RhcnRBbmdsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTsgIFxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGU9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhW2ldLmNvbG9yLGNvbmZpZy5kZWZhdWx0RmlsbENvbG9yLFwiY29sb3JcIixpLC0xLHthbmltYXRpb25EZWNpbWFsOiBhbmltYXRpb25EZWNpbWFsLCBzY2FsZUFuaW1hdGlvbiA6IHNjYWxlQW5pbWF0aW9ufSApO1xuXHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdFx0aWYoY29uZmlnLnNlZ21lbnRTaG93U3Ryb2tlPT1cIm1lcmdlXCIpIHsgLyogYXZvaWQgYmxhbmsgc3RyaXBlcyBiZXR3ZWVuIHBpZWNlIG9mIGNoYXJ0ICovXG5cdFx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0xLjU7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIkNPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YVtpXS5jb2xvcixjb25maWcuZGVmYXVsdEZpbGxDb2xvcixcImNvbG9yXCIsaSwtMSx7YW5pbWF0aW9uRGVjaW1hbDogYW5pbWF0aW9uRGVjaW1hbCwgc2NhbGVBbmltYXRpb24gOiBzY2FsZUFuaW1hdGlvbn0gKTtcblx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKGNvbmZpZy5zZWdtZW50U2hvd1N0cm9rZSkge1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNlZ21lbnRTdHJva2VXaWR0aCk7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuc2VnbWVudFN0cm9rZUNvbG9yO1xuXHRcdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNFR01FTlRTVFJPS0VTVFlMRVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGFbaV0uc2VnbWVudFN0cm9rZVN0eWxlLGNvbmZpZy5zZWdtZW50U3Ryb2tlU3R5bGUsXCJzZWdtZW50U3Ryb2tlU3R5bGVcIixpLC0xLHthbmltYXRpb25EZWNpbWFsOiBhbmltYXRpb25EZWNpbWFsLCBzY2FsZUFuaW1hdGlvbiA6IHNjYWxlQW5pbWF0aW9ufSApKSk7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XHRcdFx0XHRcdCBcblx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoYW5pbWF0aW9uRGVjaW1hbCA+PSBjb25maWcuYW5pbWF0aW9uU3RvcFZhbHVlKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGN0eC50cGNoYXJ0PT1cIlBpZVwiKWRhdGFDdXRPdXRSYWRpdXM9Y3V0b3V0UmFkaXVzO1xuXHRcdFx0XHRcdGVsc2UgZGF0YUN1dG91dFJhZGl1cz1jdXRvdXRSYWRpdXMtKGRvdWdobnV0UmFkaXVzLWN1dG91dFJhZGl1cykqc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiRVhQQU5ESU5SQURJVVNcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhW2ldLmV4cGFuZEluUmFkaXVzLDAsXCJleHBhbmRJblJhZGl1c1wiLGksLTEse2FuaW1hdGlvbkRlY2ltYWw6IGFuaW1hdGlvbkRlY2ltYWwsIHNjYWxlQW5pbWF0aW9uIDogc2NhbGVBbmltYXRpb259ICk7XG4gICAgICAgIFx0ICAgICAgICBcdCAgICAgICAgZGF0YURvdWdobnV0UmFkaXVzPWRvdWdobnV0UmFkaXVzKyhkb3VnaG51dFJhZGl1cy1jdXRvdXRSYWRpdXMpKnNldE9wdGlvblZhbHVlKHRydWUsMSxcIkVYUEFORE9VVFJBRElVU1wiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGFbaV0uZXhwYW5kT3V0UmFkaXVzLDAsXCJleHBhbmRPdXRSYWRpdXNcIixpLC0xLHthbmltYXRpb25EZWNpbWFsOiBhbmltYXRpb25EZWNpbWFsLCBzY2FsZUFuaW1hdGlvbiA6IHNjYWxlQW5pbWF0aW9ufSApO1xuXHRcdFx0XHRcdGlmICh0eXBlb2YoZGF0YVtpXS52YWx1ZSkgPT0gJ3VuZGVmaW5lZCcgfHwgMSpkYXRhW2ldLnZhbHVlPDApIGNvbnRpbnVlO1xuXHRcdFx0XHRcdGpzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF1banNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXS5sZW5ndGhdID0gW1wiQVJDXCIsIGksLTEsc3RhdERhdGEsc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiQU5OT1RBVEVESVNQTEFZXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YVtpXS5hbm5vdGF0ZURpc3BsYXksY29uZmlnLmFubm90YXRlRGlzcGxheSxcImFubm90YXRlRGlzcGxheVwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9KV07XG5cdFx0XHRcdFx0aWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBU0hPV1wiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGFbaV0uaW5HcmFwaERhdGFTaG93LGNvbmZpZy5pbkdyYXBoRGF0YVNob3csXCJpbkdyYXBoRGF0YVNob3dcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSkgJiYgc3RhdERhdGFbaV0uc2VnbWVudEFuZ2xlID49IChNYXRoLlBJLzE4MCkgKiBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQU1JTklNVU1BTkdMRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFNaW5pbXVtQW5nbGUsXCJpbkdyYXBoRGF0YU1pbmltdW1BbmdsZVwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICkpIHtcblx0XHRcdFx0XHRcdGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUFOR0xFUE9TSVRJT05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQW5nbGVQb3NpdGlvbixcImluR3JhcGhEYXRhQW5nbGVQb3NpdGlvblwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICkgPT0gMSkgcG9zQW5nbGUgPSBzdGF0RGF0YVtpXS5yZWFsU3RhcnRBbmdsZSArIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUEFERElOQU5HTEVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ0FuZ2xlLFwiaW5HcmFwaERhdGFQYWRkaW5nQW5nbGVcIixpLC0xLHtudWxsVmFsdWU6IHRydWUgIH0pICogKE1hdGguUEkgLyAxODApO1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFBTkdMRVBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUFuZ2xlUG9zaXRpb24sXCJpbkdyYXBoRGF0YUFuZ2xlUG9zaXRpb25cIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDIpIHBvc0FuZ2xlID0gc3RhdERhdGFbaV0ucmVhbFN0YXJ0QW5nbGUtIHN0YXREYXRhW2ldLnNlZ21lbnRBbmdsZSAvIDIgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVBBRERJTkFOR0xFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdBbmdsZSxcImluR3JhcGhEYXRhUGFkZGluZ0FuZ2xlXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlICB9KSAqIChNYXRoLlBJIC8gMTgwKTtcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQU5HTEVQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFBbmdsZVBvc2l0aW9uLFwiaW5HcmFwaERhdGFBbmdsZVBvc2l0aW9uXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAzKSBwb3NBbmdsZSA9IHN0YXREYXRhW2ldLnJlYWxTdGFydEFuZ2xlIC0gc3RhdERhdGFbaV0uc2VnbWVudEFuZ2xlICsgc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFQQURESU5BTkdMRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nQW5nbGUsXCJpbkdyYXBoRGF0YVBhZGRpbmdBbmdsZVwiLGksLTEse251bGxWYWx1ZTogdHJ1ZSAgfSkgKiAoTWF0aC5QSSAvIDE4MCk7XG5cdFx0XHRcdFx0XHRpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFSQURJVVNQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSYWRpdXNQb3NpdGlvbixcImluR3JhcGhEYXRhUmFkaXVzUG9zaXRpb25cIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDEpIGxhYmVsUmFkaXVzID0gZGF0YUN1dG91dFJhZGl1cyArIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUEFERElOR1JBRElVU1wiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzLFwiaW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFSQURJVVNQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSYWRpdXNQb3NpdGlvbixcImluR3JhcGhEYXRhUmFkaXVzUG9zaXRpb25cIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDIpIGxhYmVsUmFkaXVzID0gZGF0YUN1dG91dFJhZGl1cyArIChkYXRhRG91Z2hudXRSYWRpdXMgLSBkYXRhQ3V0b3V0UmFkaXVzKSAvIDIgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVBBRERJTkdSQURJVVNcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ1JhZGl1cyxcImluR3JhcGhEYXRhUGFkZGluZ1JhZGl1c1wiLGksLTEse251bGxWYWx1ZTogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUkFESVVTUE9TSVRJT05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUmFkaXVzUG9zaXRpb24sXCJpbkdyYXBoRGF0YVJhZGl1c1Bvc2l0aW9uXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAzKSBsYWJlbFJhZGl1cyA9IGRhdGFEb3VnaG51dFJhZGl1cyArIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUEFERElOR1JBRElVU1wiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzLFwiaW5HcmFwaERhdGFQYWRkaW5nUmFkaXVzXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRcdGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUFMSUdOXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUFsaWduLFwiaW5HcmFwaERhdGFBbGlnblwiLGksLTEse251bGxWYWx1ZTogdHJ1ZSAgfSkgPT0gXCJvZmYtY2VudGVyXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUk9UQVRFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVJvdGF0ZSxcImluR3JhcGhEYXRhUm90YXRlXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSBcImluUmFkaXVzQXhpc1wiIHx8IChwb3NBbmdsZSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkgPj0gMyAqIE1hdGguUEkgLyAyIHx8IChwb3NBbmdsZSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkgPD0gTWF0aC5QSSAvIDIpIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XHRcdFx0XHRcdFx0ZWxzZSBjdHgudGV4dEFsaWduID0gXCJyaWdodFwiO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUFMSUdOXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUFsaWduLFwiaW5HcmFwaERhdGFBbGlnblwiLGksLTEse251bGxWYWx1ZTogdHJ1ZSAgfSkgPT0gXCJ0by1jZW50ZXJcIikge1xuXHRcdFx0XHRcdFx0XHRpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFST1RBVEVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUm90YXRlLFwiaW5HcmFwaERhdGFSb3RhdGVcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IFwiaW5SYWRpdXNBeGlzXCIgfHwgKHBvc0FuZ2xlICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSA+PSAzICogTWF0aC5QSSAvIDIgfHwgKHBvc0FuZ2xlICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSA8PSBNYXRoLlBJIC8gMikgY3R4LnRleHRBbGlnbiA9IFwicmlnaHRcIjtcblx0XHRcdFx0XHRcdFx0ZWxzZSBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG5cdFx0XHRcdFx0XHR9IGVsc2UgY3R4LnRleHRBbGlnbiA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQWxpZ24sXCJpbkdyYXBoRGF0YUFsaWduXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlICB9KTtcblx0XHRcdFx0XHRcdGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVZBTElHTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFWQWxpZ24sXCJpbkdyYXBoRGF0YVZBbGlnblwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICkgPT0gXCJvZmYtY2VudGVyXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKChwb3NBbmdsZSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkgPiBNYXRoLlBJKSBjdHgudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcblx0XHRcdFx0XHRcdFx0ZWxzZSBjdHgudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFWQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhVkFsaWduLFwiaW5HcmFwaERhdGFWQWxpZ25cIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IFwidG8tY2VudGVyXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKChwb3NBbmdsZSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkgPiBNYXRoLlBJKSBjdHgudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcblx0XHRcdFx0XHRcdFx0ZWxzZSBjdHgudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcblx0XHRcdFx0XHRcdH0gZWxzZSBjdHgudGV4dEJhc2VsaW5lID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFWQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhVkFsaWduLFwiaW5HcmFwaERhdGFWQWxpZ25cIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0Y3R4LmZvbnQgPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUZPTlRTVFlMRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U3R5bGUsXCJpbkdyYXBoRGF0YUZvbnRTdHlsZVwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICkgKyAnICcgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFRleHRTY2FsZSxcIklOR1JBUEhEQVRBRk9OVFNJWkVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udFNpemUsXCJpbkdyYXBoRGF0YUZvbnRTaXplXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSArICdweCAnICsgc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFGT05URkFNSUxZXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRGYW1pbHksXCJpbkdyYXBoRGF0YUZvbnRGYW1pbHlcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBRk9OVENPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRDb2xvcixcImluR3JhcGhEYXRhRm9udENvbG9yXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdHZhciBkaXNwU3RyaW5nID0gdG1wbGJpcyhzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVRNUExcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhVG1wbCxcImluR3JhcGhEYXRhVG1wbFwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICksIHN0YXREYXRhW2ldLGNvbmZpZyk7XG5cdFx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKG1pZFBpZVggKyBsYWJlbFJhZGl1cyAqIE1hdGguY29zKHBvc0FuZ2xlKSwgbWlkUGllWSAtIGxhYmVsUmFkaXVzICogTWF0aC5zaW4ocG9zQW5nbGUpKTtcblx0XHRcdFx0XHRcdHZhciByb3RhdGVWYWw9MDtcblx0XHRcdFx0XHRcdGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVJPVEFURVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSb3RhdGUsXCJpbkdyYXBoRGF0YVJvdGF0ZVwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICkgPT0gXCJpblJhZGl1c0F4aXNcIikgcm90YXRlVmFsPTIgKiBNYXRoLlBJIC0gcG9zQW5nbGU7XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVJPVEFURVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSb3RhdGUsXCJpbkdyYXBoRGF0YVJvdGF0ZVwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICkgPT0gXCJpblJhZGl1c0F4aXNSb3RhdGVMYWJlbHNcIikge1xuXHRcdFx0XHRcdFx0XHRpZiAoKHBvc0FuZ2xlICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSA+IE1hdGguUEkgLyAyICYmIChwb3NBbmdsZSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkgPCAzICogTWF0aC5QSSAvIDIpIHJvdGF0ZVZhbD0zICogTWF0aC5QSSAtIHBvc0FuZ2xlO1xuXHRcdFx0XHRcdFx0XHRlbHNlIHJvdGF0ZVZhbD0yICogTWF0aC5QSSAtIHBvc0FuZ2xlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHJvdGF0ZVZhbD1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVJPVEFURVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSb3RhdGUsXCJpbkdyYXBoRGF0YVJvdGF0ZVwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICkgKiAoTWF0aC5QSSAvIDE4MCk7XG5cdFx0XHRcdFx0XHRjdHgucm90YXRlKHJvdGF0ZVZhbCk7XG5cdFx0XHRcdFx0XHRzZXRUZXh0Qm9yZGVyc0FuZEJhY2tncm91bmQoY3R4LGRpc3BTdHJpbmcsc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRUZXh0U2NhbGUsXCJJTkdSQVBIREFUQUZPTlRTSVpFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRTaXplLFwiaW5HcmFwaERhdGFGb250U2l6ZVwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICksMCwwLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQk9SREVSU1wiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzLFwiaW5HcmFwaERhdGFCb3JkZXJzXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJPUkRFUlNDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzQ29sb3IsXCJpbkdyYXBoRGF0YUJvcmRlcnNDb2xvclwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICksc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRMaW5lU2NhbGUsXCJJTkdSQVBIREFUQUJPUkRFUlNXSURUSFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzV2lkdGgsXCJpbkdyYXBoRGF0YUJvcmRlcnNXaWR0aFwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICksc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiSU5HUkFQSERBVEFCT1JERVJTWFNQQUNFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNYU3BhY2UsXCJpbkdyYXBoRGF0YUJvcmRlcnNYU3BhY2VcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBQk9SREVSU1lTUEFDRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzWVNwYWNlLFwiaW5HcmFwaERhdGFCb3JkZXJzWVNwYWNlXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJPUkRFUlNTVFlMRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzU3R5bGUsXCJpbkdyYXBoRGF0YUJvcmRlcnNTdHlsZVwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICksc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFCQUNLR1JPVU5EQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQmFja2dyb3VuZENvbG9yLFwiaW5HcmFwaERhdGFCYWNrZ3JvdW5kQ29sb3JcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApLFwiSU5HUkFQSERBVEFcIixjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzUmFkaXVzKTtcblx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShkaXNwU3RyaW5nLCAwLCAwLCBjdHgudGV4dEJhc2VsaW5lLCBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFRleHRTY2FsZSxcIklOR1JBUEhEQVRBRk9OVFNJWkVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udFNpemUsXCJpbkdyYXBoRGF0YUZvbnRTaXplXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJJTkdSQVBIREFUQV9URVhUTU9VU0VcIixyb3RhdGVWYWwsbWlkUGllWCArIGxhYmVsUmFkaXVzICogTWF0aC5jb3MocG9zQW5nbGUpLCBtaWRQaWVZIC0gbGFiZWxSYWRpdXMgKiBNYXRoLnNpbihwb3NBbmdsZSksaSwtMSk7XG5cdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYobXNyLmxlZ2VuZE1zci5kaXNwTGVnZW5kKWRyYXdMZWdlbmQobXNyLmxlZ2VuZE1zcixkYXRhLGNvbmZpZyxjdHgsXCJEb3VnaG51dFwiKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRhOmRhdGEsXG5cdFx0XHRjb25maWc6Y29uZmlnLFxuXHRcdFx0Y3R4OmN0eFxuXHRcdH07XG5cdH07XG5cdHZhciBMaW5lID0gZnVuY3Rpb24oZGF0YSwgY29uZmlnLCBjdHgpIHtcblx0XHR2YXIgbWF4U2l6ZSwgc2NhbGVIb3AsIHNjYWxlSG9wMiwgY2FsY3VsYXRlZFNjYWxlLCBjYWxjdWxhdGVkU2NhbGUyLCBsYWJlbEhlaWdodCwgc2NhbGVIZWlnaHQsIHZhbHVlQm91bmRzLCBsYWJlbFRlbXBsYXRlU3RyaW5nLCBsYWJlbFRlbXBsYXRlU3RyaW5nMjtcblx0XHR2YXIgdmFsdWVIb3AsIHdpZGVzdFhMYWJlbCwgeEF4aXNMZW5ndGgsIHlBeGlzUG9zWCwgeEF4aXNQb3NZLCByb3RhdGVMYWJlbHMgPSAwLFxuXHRcdFx0bXNyO1xuXHRcdHZhciB6ZXJvWSA9IDA7XG5cdFx0dmFyIHplcm9ZMiA9IDA7XG5cdFx0Y3R4LnRwY2hhcnQ9XCJMaW5lXCI7XG5cdFx0Y3R4LnRwZGF0YT0wO1xuXG5cdCAgICAgICAgaWYgKCFpbml0X2FuZF9zdGFydChjdHgsZGF0YSxjb25maWcpKSByZXR1cm47XG5cdFx0Ly8gYWRhcHQgZGF0YSB3aGVuIGxlbmd0aCBpcyAxO1xuXHRcdHZhciBteGxndCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSsrKSB7bXhsZ3QgPSBNYXgoW214bGd0LCBkYXRhLmRhdGFzZXRzW2ldLmRhdGEubGVuZ3RoXSk7fVxuXHRcdGlmIChteGxndCA9PSAxKSB7XG5cdFx0XHRpZiAodHlwZW9mKGRhdGEubGFiZWxzWzBdKSA9PSBcInN0cmluZ1wiKSBkYXRhLmxhYmVscyA9IFtcIlwiLCBkYXRhLmxhYmVsc1swXSwgXCJcIl07XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodHlwZW9mKGRhdGEuZGF0YXNldHNbaV0uZGF0YVswXSAhPSBcInVuZGVmaW5lZFwiKSkgZGF0YS5kYXRhc2V0c1tpXS5kYXRhID0gW3VuZGVmaW5lZCwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhWzBdLCB1bmRlZmluZWRdO1xuXHRcdFx0fVxuXHRcdFx0bXhsZ3Q9Mztcblx0XHR9XG5cdFx0dmFyIHN0YXREYXRhPWluaXRQYXNzVmFyaWFibGVEYXRhX3BhcnQxKGRhdGEsY29uZmlnLGN0eCk7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHN0YXREYXRhW2ldWzBdLnRwY2hhcnQ9XCJMaW5lXCI7XG5cdFx0bXNyID0gc2V0TWVhc3VyZXMoZGF0YSwgY29uZmlnLCBjdHgsIGN0eC5jYW52YXMuaGVpZ2h0LCBjdHguY2FudmFzLndpZHRoLCBcIm5paGlsXCIsIFtcIlwiXSwgZmFsc2UsIGZhbHNlLCB0cnVlLCB0cnVlLCBjb25maWcuZGF0YXNldEZpbGwsIFwiTGluZVwiKTtcblx0XHR2YWx1ZUJvdW5kcyA9IGdldFZhbHVlQm91bmRzKCk7XG5cdFx0Ly8gdHJ1ZSBvciBmdXp6eSAoZXJyb3IgZm9yIG5lZ2F0aXYgdmFsdWVzIChpbmNsdWRlZCAwKSlcblx0XHRpZiAoY29uZmlnLmxvZ2FyaXRobWljICE9PSBmYWxzZSkge1xuXHRcdFx0aWYgKHZhbHVlQm91bmRzLm1pblZhbHVlIDw9IDApIHtcblx0XHRcdFx0Y29uZmlnLmxvZ2FyaXRobWljID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjb25maWcubG9nYXJpdGhtaWMyICE9PSBmYWxzZSkge1xuXHRcdFx0aWYgKHZhbHVlQm91bmRzLm1pblZhbHVlMiA8PSAwKSB7XG5cdFx0XHRcdGNvbmZpZy5sb2dhcml0aG1pYzIgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gQ2hlY2sgaWYgbG9nYXJpdGhtaWMgaXMgbWVhbmlnZnVsXG5cdFx0dmFyIE9yZGVyT2ZNYWduaXR1ZGUgPSBjYWxjdWxhdGVPcmRlck9mTWFnbml0dWRlKE1hdGgucG93KDEwLCBjYWxjdWxhdGVPcmRlck9mTWFnbml0dWRlKHZhbHVlQm91bmRzLm1heFZhbHVlKSArIDEpKSAtIGNhbGN1bGF0ZU9yZGVyT2ZNYWduaXR1ZGUoTWF0aC5wb3coMTAsIGNhbGN1bGF0ZU9yZGVyT2ZNYWduaXR1ZGUodmFsdWVCb3VuZHMubWluVmFsdWUpKSk7XG5cdFx0aWYgKChjb25maWcubG9nYXJpdGhtaWMgPT0gJ2Z1enp5JyAmJiBPcmRlck9mTWFnbml0dWRlIDwgNCkgfHwgY29uZmlnLnNjYWxlT3ZlcnJpZGUpIHtcblx0XHRcdGNvbmZpZy5sb2dhcml0aG1pYyA9IGZhbHNlO1xuXHRcdH1cblx0XHQvLyBDaGVjayBpZiBsb2dhcml0aG1pYyBpcyBtZWFuaWdmdWxcblx0XHR2YXIgT3JkZXJPZk1hZ25pdHVkZTIgPSBjYWxjdWxhdGVPcmRlck9mTWFnbml0dWRlKE1hdGgucG93KDEwLCBjYWxjdWxhdGVPcmRlck9mTWFnbml0dWRlKHZhbHVlQm91bmRzLm1heFZhbHVlMikgKyAxKSkgLSBjYWxjdWxhdGVPcmRlck9mTWFnbml0dWRlKE1hdGgucG93KDEwLCBjYWxjdWxhdGVPcmRlck9mTWFnbml0dWRlKHZhbHVlQm91bmRzLm1pblZhbHVlMikpKTtcblx0XHRpZiAoKGNvbmZpZy5sb2dhcml0aG1pYzIgPT0gJ2Z1enp5JyAmJiBPcmRlck9mTWFnbml0dWRlMiA8IDQpIHx8IGNvbmZpZy5zY2FsZU92ZXJyaWRlMikge1xuXHRcdFx0Y29uZmlnLmxvZ2FyaXRobWljMiA9IGZhbHNlO1xuXHRcdH1cblx0XHQvL0NoZWNrIGFuZCBzZXQgdGhlIHNjYWxlXG5cdFx0bGFiZWxUZW1wbGF0ZVN0cmluZyA9IChjb25maWcuc2NhbGVTaG93TGFiZWxzKSA/IGNvbmZpZy5zY2FsZUxhYmVsIDogXCJcIjtcblx0XHRsYWJlbFRlbXBsYXRlU3RyaW5nMiA9IChjb25maWcuc2NhbGVTaG93TGFiZWxzMikgPyBjb25maWcuc2NhbGVMYWJlbDIgOiBcIlwiO1xuXHRcdGlmICghY29uZmlnLnNjYWxlT3ZlcnJpZGUpIHtcblx0XHRcdGlmKHZhbHVlQm91bmRzLm1heFN0ZXBzPjAgJiYgdmFsdWVCb3VuZHMubWluU3RlcHM+MCkge1xuXHRcdFx0XHRjYWxjdWxhdGVkU2NhbGUgPSBjYWxjdWxhdGVTY2FsZSgxLCBjb25maWcsIHZhbHVlQm91bmRzLm1heFN0ZXBzLCB2YWx1ZUJvdW5kcy5taW5TdGVwcywgdmFsdWVCb3VuZHMubWF4VmFsdWUsIHZhbHVlQm91bmRzLm1pblZhbHVlLCBsYWJlbFRlbXBsYXRlU3RyaW5nKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHNjYWxlU3RhcnRWYWx1ZT0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEFSVFZBTFVFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5zY2FsZVN0YXJ0VmFsdWUsXCJzY2FsZVN0YXJ0VmFsdWVcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdHZhciBzY2FsZVN0ZXBzID1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJTQ0FMRVNURVBTXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5zY2FsZVN0ZXBzLFwic2NhbGVTdGVwc1wiLC0xLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0dmFyIHNjYWxlU3RlcFdpZHRoID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEVQV0lEVEhcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLnNjYWxlU3RlcFdpZHRoLFwic2NhbGVTdGVwV2lkdGhcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdGNhbGN1bGF0ZWRTY2FsZSA9IHtcblx0XHRcdFx0c3RlcHM6IHNjYWxlU3RlcHMsXG5cdFx0XHRcdHN0ZXBWYWx1ZTogc2NhbGVTdGVwV2lkdGgsXG5cdFx0XHRcdGdyYXBoTWluOiBzY2FsZVN0YXJ0VmFsdWUsXG5cdFx0XHRcdGdyYXBoTWF4OiBzY2FsZVN0YXJ0VmFsdWUgKyBzY2FsZVN0ZXBzICogc2NhbGVTdGVwV2lkdGgsXG5cdFx0XHRcdGxhYmVsczogW11cblx0XHRcdH1cblx0XHRcdHBvcHVsYXRlTGFiZWxzKDEsIGNvbmZpZywgbGFiZWxUZW1wbGF0ZVN0cmluZywgY2FsY3VsYXRlZFNjYWxlLmxhYmVscywgY2FsY3VsYXRlZFNjYWxlLnN0ZXBzLCBzY2FsZVN0YXJ0VmFsdWUsIGNhbGN1bGF0ZWRTY2FsZS5ncmFwaE1heCwgc2NhbGVTdGVwV2lkdGgpO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZUJvdW5kcy5kYkF4aXMpIHtcblx0XHRcdGlmICghY29uZmlnLnNjYWxlT3ZlcnJpZGUyKSB7XG5cdFx0XHRcdGlmKHZhbHVlQm91bmRzLm1heFN0ZXBzPjAgJiYgdmFsdWVCb3VuZHMubWluU3RlcHM+MCkge1xuXHRcdFx0XHRcdGNhbGN1bGF0ZWRTY2FsZTIgPSBjYWxjdWxhdGVTY2FsZSgyLCBjb25maWcsIHZhbHVlQm91bmRzLm1heFN0ZXBzLCB2YWx1ZUJvdW5kcy5taW5TdGVwcywgdmFsdWVCb3VuZHMubWF4VmFsdWUyLCB2YWx1ZUJvdW5kcy5taW5WYWx1ZTIsIGxhYmVsVGVtcGxhdGVTdHJpbmcyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNjYWxlU3RhcnRWYWx1ZTI9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNDQUxFU1RBUlRWQUxVRTJcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLnNjYWxlU3RhcnRWYWx1ZTIsXCJzY2FsZVN0YXJ0VmFsdWUyXCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdHZhciBzY2FsZVN0ZXBzMiA9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEVQUzJcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLnNjYWxlU3RlcHMyLFwic2NhbGVTdGVwczJcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0dmFyIHNjYWxlU3RlcFdpZHRoMiA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNDQUxFU1RFUFdJRFRIMlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuc2NhbGVTdGVwV2lkdGgyLFwic2NhbGVTdGVwV2lkdGgyXCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9ICk7XG5cblx0XHRcdFx0Y2FsY3VsYXRlZFNjYWxlMiA9IHtcblx0XHRcdFx0XHRzdGVwczogc2NhbGVTdGVwczIsXG5cdFx0XHRcdFx0c3RlcFZhbHVlOiBzY2FsZVN0ZXBXaWR0aDIsXG5cdFx0XHRcdFx0Z3JhcGhNaW46IHNjYWxlU3RhcnRWYWx1ZTIsXG5cdFx0XHRcdFx0Z3JhcGhNYXg6IHNjYWxlU3RhcnRWYWx1ZTIgKyBzY2FsZVN0ZXBzMiAqIHNjYWxlU3RlcFdpZHRoMixcblx0XHRcdFx0XHRsYWJlbHM6IFtdXG5cdFx0XHRcdH1cblx0XHRcdFx0cG9wdWxhdGVMYWJlbHMoMiwgY29uZmlnLCBsYWJlbFRlbXBsYXRlU3RyaW5nMiwgY2FsY3VsYXRlZFNjYWxlMi5sYWJlbHMsIGNhbGN1bGF0ZWRTY2FsZTIuc3RlcHMsIHNjYWxlU3RhcnRWYWx1ZTIsIGNhbGN1bGF0ZWRTY2FsZTIuZ3JhcGhNYXgsIHNjYWxlU3RlcFdpZHRoMik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbGN1bGF0ZWRTY2FsZTIgPSB7XG5cdFx0XHRcdHN0ZXBzOiAwLFxuXHRcdFx0XHRzdGVwVmFsdWU6IDAsXG5cdFx0XHRcdGdyYXBoTWluOiAwLFxuXHRcdFx0XHRncmFwaE1heDogMCxcblx0XHRcdFx0bGFiZWxzOiBudWxsXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHZhbHVlQm91bmRzLm1heFN0ZXBzPjAgJiYgdmFsdWVCb3VuZHMubWluU3RlcHM+MCkge1xuXHRcdFx0bXNyID0gc2V0TWVhc3VyZXMoZGF0YSwgY29uZmlnLCBjdHgsIGN0eC5jYW52YXMuaGVpZ2h0LCBjdHguY2FudmFzLndpZHRoLCBjYWxjdWxhdGVkU2NhbGUubGFiZWxzLCBjYWxjdWxhdGVkU2NhbGUyLmxhYmVscywgZmFsc2UsIGZhbHNlLCB0cnVlLCB0cnVlLCBjb25maWcuZGF0YXNldEZpbGwsIFwiTGluZVwiKTtcblx0XHRcdHZhciBwcmV2SGVpZ2h0PW1zci5hdmFpbGFibGVIZWlnaHQ7XG5cdFx0XHRtc3IuYXZhaWxhYmxlSGVpZ2h0ID0gbXNyLmF2YWlsYWJsZUhlaWdodCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVCb3R0b20pIC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCk7XG5cdFx0XHRtc3IuYXZhaWxhYmxlV2lkdGggPSBtc3IuYXZhaWxhYmxlV2lkdGggLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplTGVmdCkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplUmlnaHQpO1xuXHRcdFx0c2NhbGVIb3AgPSBNYXRoLmZsb29yKG1zci5hdmFpbGFibGVIZWlnaHQgLyBjYWxjdWxhdGVkU2NhbGUuc3RlcHMpO1xuXHRcdFx0c2NhbGVIb3AyID0gTWF0aC5mbG9vcihtc3IuYXZhaWxhYmxlSGVpZ2h0IC8gY2FsY3VsYXRlZFNjYWxlMi5zdGVwcyk7XG5cdFx0XHR2YWx1ZUhvcCA9IE1hdGguZmxvb3IobXNyLmF2YWlsYWJsZVdpZHRoIC8gKGRhdGEubGFiZWxzLmxlbmd0aCAtIDEpKTtcblx0XHRcdGlmICh2YWx1ZUhvcCA9PSAwIHx8IGNvbmZpZy5mdWxsV2lkdGhHcmFwaCkgdmFsdWVIb3AgPSAobXNyLmF2YWlsYWJsZVdpZHRoIC8gKGRhdGEubGFiZWxzLmxlbmd0aCAtIDEpKTtcblx0XHRcdG1zci5jbHJ3aWR0aCA9IG1zci5jbHJ3aWR0aCAtIChtc3IuYXZhaWxhYmxlV2lkdGggLSAoZGF0YS5sYWJlbHMubGVuZ3RoIC0gMSkgKiB2YWx1ZUhvcCk7XG5cdFx0XHRtc3IuYXZhaWxhYmxlV2lkdGggPSAoZGF0YS5sYWJlbHMubGVuZ3RoIC0gMSkgKiB2YWx1ZUhvcDtcblx0XHRcdG1zci5hdmFpbGFibGVIZWlnaHQgPSAoY2FsY3VsYXRlZFNjYWxlLnN0ZXBzKSAqIHNjYWxlSG9wO1xuXHRcdFx0bXNyLnhMYWJlbFBvcys9KE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVCb3R0b20pICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCkgLSAocHJldkhlaWdodC1tc3IuYXZhaWxhYmxlSGVpZ2h0KSk7XG5cdFx0XHRtc3IuY2xyaGVpZ2h0Kz0oTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUJvdHRvbSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplVG9wKSAtIChwcmV2SGVpZ2h0LW1zci5hdmFpbGFibGVIZWlnaHQpKTtcbiAgXHRcdFx0eUF4aXNQb3NYID0gbXNyLmxlZnROb3RVc2FibGVTaXplICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUxlZnQpO1xuXHRcdFx0eEF4aXNQb3NZID0gbXNyLnRvcE5vdFVzYWJsZVNpemUgKyBtc3IuYXZhaWxhYmxlSGVpZ2h0ICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCk7XG5cdFx0XHRkcmF3TGFiZWxzKCk7XG5cblx0XHRcdHplcm9ZID0gY2FsY3VsYXRlT2Zmc2V0KGNvbmZpZy5sb2dhcml0aG1pYywgMCwgY2FsY3VsYXRlZFNjYWxlLCBzY2FsZUhvcCk7XG5cdFx0XHRpZih0eXBlb2YgY2FsY3VsYXRlZFNjYWxlMiA9PT1cIm9iamVjdFwiKXplcm9ZMiA9IGNhbGN1bGF0ZU9mZnNldChjb25maWcubG9nYXJpdGhtaWMyLCAwLCBjYWxjdWxhdGVkU2NhbGUyLCBzY2FsZUhvcDIpO1xuXHRcdFx0aW5pdFBhc3NWYXJpYWJsZURhdGFfcGFydDIoc3RhdERhdGEsZGF0YSxjb25maWcsY3R4LHtcblx0XHRcdFx0eEF4aXNQb3NZIDogeEF4aXNQb3NZLFxuXHRcdFx0XHR5QXhpc1Bvc1ggOiB5QXhpc1Bvc1gsXG5cdFx0XHRcdHZhbHVlSG9wIDogdmFsdWVIb3AsXG5cdFx0XHRcdG5iVmFsdWVIb3AgOiBkYXRhLmxhYmVscy5sZW5ndGggLSAxLFxuXHRcdFx0XHRzY2FsZUhvcCA6IHNjYWxlSG9wLFxuXHRcdFx0XHR6ZXJvWSA6IHplcm9ZLFxuXHRcdFx0XHRjYWxjdWxhdGVkU2NhbGUgOiBjYWxjdWxhdGVkU2NhbGUsXG5cdFx0XHRcdGxvZ2FyaXRobWljICA6IGNvbmZpZy5sb2dhcml0aG1pYyxcblx0XHRcdFx0c2NhbGVIb3AyOiBzY2FsZUhvcDIsXG5cdFx0XHRcdHplcm9ZMjogemVyb1kyLFxuXHRcdFx0XHRtc3IgOiBtc3IsXG5cdFx0XHRcdGNhbGN1bGF0ZWRTY2FsZTI6IGNhbGN1bGF0ZWRTY2FsZTIsXG5cdFx0XHRcdGxvZ2FyaXRobWljMjogY29uZmlnLmxvZ2FyaXRobWljMn0gKTtcblx0XHRcdGFuaW1hdGlvbkxvb3AoY29uZmlnLCBkcmF3U2NhbGUsIGRyYXdMaW5lcywgY3R4LCBtc3IuY2xyeCwgbXNyLmNscnksIG1zci5jbHJ3aWR0aCwgbXNyLmNscmhlaWdodCwgeUF4aXNQb3NYICsgbXNyLmF2YWlsYWJsZVdpZHRoIC8gMiwgeEF4aXNQb3NZIC0gbXNyLmF2YWlsYWJsZUhlaWdodCAvIDIsIHlBeGlzUG9zWCwgeEF4aXNQb3NZLCBkYXRhLCBzdGF0RGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRlc3RSZWRyYXcoY3R4LGRhdGEsY29uZmlnKTtcblx0XHRcdGN0eC5maXJzdFBhc3M9OTtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIGRyYXdMaW5lcyhhbmltUGMpIHtcblx0XHRcblx0XHRcdGRyYXdMaW5lc0RhdGFzZXQoYW5pbVBjLCBkYXRhLCBjb25maWcsIGN0eCwgc3RhdERhdGEse3hBeGlzUG9zWSA6IHhBeGlzUG9zWSx5QXhpc1Bvc1ggOiB5QXhpc1Bvc1gsIHZhbHVlSG9wIDogdmFsdWVIb3AsIG5iVmFsdWVIb3AgOiBkYXRhLmxhYmVscy5sZW5ndGggLSAxIH0pO1xuXHRcdFx0aWYgKGFuaW1QYyA+PSAxKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZHJhd01hdGggPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0ZHJhd01hdGgoY3R4LCBjb25maWcsIGRhdGEsIG1zciwge1xuXHRcdFx0XHRcdFx0eEF4aXNQb3NZOiB4QXhpc1Bvc1ksXG5cdFx0XHRcdFx0XHR5QXhpc1Bvc1g6IHlBeGlzUG9zWCxcblx0XHRcdFx0XHRcdHZhbHVlSG9wOiB2YWx1ZUhvcCxcblx0XHRcdFx0XHRcdHNjYWxlSG9wOiBzY2FsZUhvcCxcblx0XHRcdFx0XHRcdHplcm9ZOiB6ZXJvWSxcblx0XHRcdFx0XHRcdGNhbGN1bGF0ZWRTY2FsZTogY2FsY3VsYXRlZFNjYWxlLFxuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlT2Zmc2V0OiBjYWxjdWxhdGVPZmZzZXQsXG5cdFx0XHRcdFx0XHRzdGF0RGF0YSA6IHN0YXREYXRhXG5cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYobXNyLmxlZ2VuZE1zci5kaXNwTGVnZW5kKWRyYXdMZWdlbmQobXNyLmxlZ2VuZE1zcixkYXRhLGNvbmZpZyxjdHgsXCJMaW5lXCIpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBkcmF3U2NhbGUoKSB7XG5cdFx0XHQvL1ggYXhpcyBsaW5lXG5cdFx0XHQvLyBpZiB0aGUgeFNjYWxlIHNob3VsZCBiZSBkcmF3blxuXHRcdFx0aWYgKGNvbmZpZy5kcmF3WFNjYWxlTGluZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Zm9yICh2YXIgcyA9IDA7IHMgPCBjb25maWcuZHJhd1hTY2FsZUxpbmUubGVuZ3RoOyBzKyspIHtcblx0XHRcdFx0XHQvLyBnZXQgc3BlY2lhbCBsaW5lV2lkdGggYW5kIGxpbmVDb2xvciBmb3IgdGhpcyB4U2NhbGVMaW5lXG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGNvbmZpZy5kcmF3WFNjYWxlTGluZVtzXS5saW5lV2lkdGggPyBjb25maWcuZHJhd1hTY2FsZUxpbmVbc10ubGluZVdpZHRoIDogTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVMaW5lV2lkdGgpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5kcmF3WFNjYWxlTGluZVtzXS5saW5lQ29sb3IgPyBjb25maWcuZHJhd1hTY2FsZUxpbmVbc10ubGluZUNvbG9yIDogY29uZmlnLnNjYWxlTGluZUNvbG9yO1xuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHR2YXIgeVBvc1hTY2FsZTtcblx0XHRcdFx0XHRzd2l0Y2ggKGNvbmZpZy5kcmF3WFNjYWxlTGluZVtzXS5wb3NpdGlvbikge1xuXHRcdFx0XHRcdFx0Y2FzZSBcImJvdHRvbVwiOlxuXHRcdFx0XHRcdFx0XHR5UG9zWFNjYWxlID0geEF4aXNQb3NZO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJ0b3BcIjpcblx0XHRcdFx0XHRcdFx0eVBvc1hTY2FsZSA9IHhBeGlzUG9zWSAtIG1zci5hdmFpbGFibGVIZWlnaHQgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplVG9wKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiMFwiOlxuXHRcdFx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdFx0XHQvLyBjaGVjayBpZiB6ZXJvIGV4aXN0c1xuXHRcdFx0XHRcdFx0XHRpZiAoemVyb1kgIT0gMCkgeVBvc1hTY2FsZSA9IHhBeGlzUG9zWSAtIHplcm9ZO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZHJhdyB0aGUgc2NhbGUgbGluZVxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oeUF4aXNQb3NYIC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUxlZnQpLCB5UG9zWFNjYWxlKTtcblx0XHRcdFx0XHRjdHgubGluZVRvKHlBeGlzUG9zWCArIG1zci5hdmFpbGFibGVXaWR0aCArIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVSaWdodCksIHlQb3NYU2NhbGUpO1xuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihjb25maWcuc2NhbGVMaW5lU3R5bGUpKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcbiBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxhYmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5tb3ZlVG8oeUF4aXNQb3NYICsgaSAqIHZhbHVlSG9wLCB4QXhpc1Bvc1kgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplQm90dG9tKSk7XG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZUdyaWRMaW5lV2lkdGgpO1xuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuc2NhbGVHcmlkTGluZUNvbG9yO1xuXHRcdFx0XHQvL0NoZWNrIGkgaXNudCAwLCBzbyB3ZSBkb250IGdvIG92ZXIgdGhlIFkgYXhpcyB0d2ljZS5cblx0XHRcdFx0aWYgKGNvbmZpZy5zY2FsZVNob3dHcmlkTGluZXMgJiYgaSA+IDAgJiYgaSAlIGNvbmZpZy5zY2FsZVhHcmlkTGluZXNTdGVwID09IDApIHtcblx0XHRcdFx0XHRjdHgubGluZVRvKHlBeGlzUG9zWCArIGkgKiB2YWx1ZUhvcCwgeEF4aXNQb3NZIC0gbXNyLmF2YWlsYWJsZUhlaWdodCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVUb3ApKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHgubGluZVRvKHlBeGlzUG9zWCArIGkgKiB2YWx1ZUhvcCwgeEF4aXNQb3NZKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oY29uZmlnLnNjYWxlR3JpZExpbmVTdHlsZSkpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICBcdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgXHRcdFx0XG5cdFx0XHR9XG5cdFx0XHQvL1kgYXhpc1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlTGluZVdpZHRoKTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5zY2FsZUxpbmVDb2xvcjtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oeUF4aXNQb3NYLCB4QXhpc1Bvc1kgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplQm90dG9tKSk7XG5cdFx0XHRjdHgubGluZVRvKHlBeGlzUG9zWCwgeEF4aXNQb3NZIC0gbXNyLmF2YWlsYWJsZUhlaWdodCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVUb3ApKTtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihjb25maWcuc2NhbGVMaW5lU3R5bGUpKTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGNhbGN1bGF0ZWRTY2FsZS5zdGVwczsgaisrKSB7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4Lm1vdmVUbyh5QXhpc1Bvc1ggLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplTGVmdCksIHhBeGlzUG9zWSAtICgoaiArIDEpICogc2NhbGVIb3ApKTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlR3JpZExpbmVXaWR0aCk7XG5cdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5zY2FsZUdyaWRMaW5lQ29sb3I7XG5cdFx0XHRcdGlmIChjb25maWcuc2NhbGVTaG93R3JpZExpbmVzICYmIChqKzEpICUgY29uZmlnLnNjYWxlWUdyaWRMaW5lc1N0ZXAgPT0gMCkge1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeUF4aXNQb3NYICsgbXNyLmF2YWlsYWJsZVdpZHRoICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVJpZ2h0KSwgeEF4aXNQb3NZIC0gKChqICsgMSkgKiBzY2FsZUhvcCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeUF4aXNQb3NYLCB4QXhpc1Bvc1kgLSAoKGogKyAxKSAqIHNjYWxlSG9wKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGNvbmZpZy5zY2FsZUdyaWRMaW5lU3R5bGUpKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgXHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZHJhd0xhYmVscygpIHtcblx0XHRcdGN0eC5mb250ID0gY29uZmlnLnNjYWxlRm9udFN0eWxlICsgXCIgXCIgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgY29uZmlnLnNjYWxlRm9udEZhbWlseTtcblx0XHRcdC8vWCBMYWJlbHMgICAgIFxuXHRcdFx0aWYgKGNvbmZpZy54QXhpc1RvcCB8fCBjb25maWcueEF4aXNCb3R0b20pIHtcblx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG5cdFx0XHRcdGlmIChtc3Iucm90YXRlTGFiZWxzID4gOTApIHtcblx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XHRcdFx0fSBlbHNlIGlmIChtc3Iucm90YXRlTGFiZWxzID4gMCkge1xuXHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwicmlnaHRcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gY29uZmlnLnNjYWxlRm9udENvbG9yO1xuXHRcdFx0XHRpZiAoY29uZmlnLnhBeGlzQm90dG9tKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxhYmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYoc2hvd0xhYmVscyhjdHgsZGF0YSxjb25maWcsaSkpe1xuXHRcdFx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAobXNyLnJvdGF0ZUxhYmVscyA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHlBeGlzUG9zWCArIGkgKiB2YWx1ZUhvcCAtIG1zci5oaWdoZXN0WExhYmVsIC8gMiwgbXNyLnhMYWJlbFBvcyk7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZSgtKG1zci5yb3RhdGVMYWJlbHMgKiAoTWF0aC5QSSAvIDE4MCkpKTtcblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbFRleHRNdWx0aUxpbmUoZm10Q2hhcnRKUyhjb25maWcsIGRhdGEubGFiZWxzW2ldLCBjb25maWcuZm10WExhYmVsKSwgMCwgMCwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJYU0NBTEVfVEVYVE1PVVNFXCIsLShtc3Iucm90YXRlTGFiZWxzICogKE1hdGguUEkgLyAxODApKSx5QXhpc1Bvc1ggKyBpICogdmFsdWVIb3AgLSBtc3IuaGlnaGVzdFhMYWJlbCAvIDIsIG1zci54TGFiZWxQb3MsaSwtMSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGZtdENoYXJ0SlMoY29uZmlnLCBkYXRhLmxhYmVsc1tpXSwgY29uZmlnLmZtdFhMYWJlbCksIHlBeGlzUG9zWCArIGkgKiB2YWx1ZUhvcCwgbXNyLnhMYWJlbFBvcywgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJYU0NBTEVfVEVYVE1PVVNFXCIsMCwwLDAsaSwtMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vWSBMYWJlbHNcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcblx0XHRcdGZvciAodmFyIGogPSAoKGNvbmZpZy5zaG93WUF4aXNNaW4pID8gLTEgOiAwKTsgaiA8IGNhbGN1bGF0ZWRTY2FsZS5zdGVwczsgaisrKSB7XG5cdFx0XHRcdGlmIChjb25maWcuc2NhbGVTaG93TGFiZWxzKSB7XG5cdFx0XHRcdFx0aWYoc2hvd1lMYWJlbHMoY3R4LGRhdGEsY29uZmlnLGorMSxjYWxjdWxhdGVkU2NhbGUubGFiZWxzW2ogKyAxXSkpIHtcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGNvbmZpZy55QXhpc0xlZnQpIHtcblx0XHRcdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwicmlnaHRcIjtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHNbaiArIDFdLCB5QXhpc1Bvc1ggLSAoTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUxlZnQpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnlBeGlzU3BhY2VSaWdodCkpLCB4QXhpc1Bvc1kgLSAoKGogKyAxKSAqIHNjYWxlSG9wKSwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJZTEVGVEFYSVNfVEVYVE1PVVNFXCIsMCwwLDAsLTEsaik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoY29uZmlnLnlBeGlzUmlnaHQgJiYgIXZhbHVlQm91bmRzLmRiQXhpcykge1xuXHRcdFx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShjYWxjdWxhdGVkU2NhbGUubGFiZWxzW2ogKyAxXSwgeUF4aXNQb3NYICsgbXNyLmF2YWlsYWJsZVdpZHRoICsgKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVSaWdodCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNTcGFjZVJpZ2h0KSksIHhBeGlzUG9zWSAtICgoaiArIDEpICogc2NhbGVIb3ApLCBjdHgudGV4dEJhc2VsaW5lLCAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpLHRydWUsY29uZmlnLmRldGVjdE1vdXNlT25UZXh0LGN0eCxcIllSSUdIVEFYSVNfVEVYVE1PVVNFXCIsMCwwLDAsLTEsaik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uZmlnLnlBeGlzUmlnaHQgJiYgdmFsdWVCb3VuZHMuZGJBeGlzKSB7XG5cdFx0XHRcdGZvciAoaiA9ICgoY29uZmlnLnNob3dZQXhpc01pbikgPyAtMSA6IDApOyBqIDwgY2FsY3VsYXRlZFNjYWxlMi5zdGVwczsgaisrKSB7XG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5zY2FsZVNob3dMYWJlbHMpIHtcblx0XHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShjYWxjdWxhdGVkU2NhbGUyLmxhYmVsc1tqICsgMV0sIHlBeGlzUG9zWCArIG1zci5hdmFpbGFibGVXaWR0aCArIChNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplUmlnaHQpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnlBeGlzU3BhY2VSaWdodCkpLCB4QXhpc1Bvc1kgLSAoKGogKyAxKSAqIHNjYWxlSG9wMiksIGN0eC50ZXh0QmFzZWxpbmUsIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSksdHJ1ZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiWVJJR0hUQVhJU19URVhUTU9VU0VcIiwwLDAsMCwtMSxqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWVCb3VuZHMoKSB7XG5cdFx0XHR2YXIgdXBwZXJWYWx1ZSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdFx0dmFyIGxvd2VyVmFsdWUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdFx0dmFyIHVwcGVyVmFsdWUyID0gLU51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHR2YXIgbG93ZXJWYWx1ZTIgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdFx0dmFyIHNlY29uZEF4aXMgPSBmYWxzZTtcblx0XHRcdHZhciBmaXJzdEF4aXMgPSBmYWxzZTtcblx0XHRcdHZhciBtYXRoVmFsdWVIZWlnaHQ7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIG1hdGhGY3ROYW1lID0gZGF0YS5kYXRhc2V0c1tpXS5kcmF3TWF0aERldmlhdGlvbjtcblx0XHRcdFx0dmFyIG1hdGhWYWx1ZUhlaWdodCA9IDA7XG5cdFx0XHRcdGlmICh0eXBlb2YgZXZhbChtYXRoRmN0TmFtZSkgPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0dmFyIHBhcmFtZXRlciA9IHtcblx0XHRcdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdFx0XHRkYXRhc2V0TnI6IGlcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdG1hdGhWYWx1ZUhlaWdodFZhbCA9IHdpbmRvd1ttYXRoRmN0TmFtZV0ocGFyYW1ldGVyKTtcblx0XHRcdFx0fSBlbHNlIG1hdGhWYWx1ZUhlaWdodFZhbD0wO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGEuZGF0YXNldHNbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBtYXRoVmFsdWVIZWlnaHRWYWw9PVwib2JqZWN0XCIpIG1hdGhWYWx1ZUhlaWdodD1tYXRoVmFsdWVIZWlnaHRWYWxbTWF0aC5taW4obWF0aFZhbHVlSGVpZ2h0VmFsLmxlbmd0aCxqKV07XG5cdFx0XHRcdFx0ZWxzZSBtYXRoVmFsdWVIZWlnaHQ9bWF0aFZhbHVlSGVpZ2h0VmFsO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmKHR5cGVvZiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gPT0gXCJ1bmRlZmluZWRcIikgY29udGludWU7XG5cdFx0XHRcdFx0aWYgKGRhdGEuZGF0YXNldHNbaV0uYXhpcyA9PSAyKSB7XG5cdFx0XHRcdFx0XHRzZWNvbmRBeGlzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmICgxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdICsgbWF0aFZhbHVlSGVpZ2h0ID4gdXBwZXJWYWx1ZTIpIHtcblx0XHRcdFx0XHRcdFx0dXBwZXJWYWx1ZTIgPSAxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdICsgbWF0aFZhbHVlSGVpZ2h0XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0aWYgKDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gLSBtYXRoVmFsdWVIZWlnaHQgPCBsb3dlclZhbHVlMikge1xuXHRcdFx0XHRcdFx0XHRsb3dlclZhbHVlMiA9IDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gLSBtYXRoVmFsdWVIZWlnaHRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcnN0QXhpcyA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAoMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSArIG1hdGhWYWx1ZUhlaWdodCA+IHVwcGVyVmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0dXBwZXJWYWx1ZSA9IDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gKyBtYXRoVmFsdWVIZWlnaHRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRpZiAoMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSAtIG1hdGhWYWx1ZUhlaWdodCA8IGxvd2VyVmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0bG93ZXJWYWx1ZSA9IDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gLSBtYXRoVmFsdWVIZWlnaHRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0aWYodXBwZXJWYWx1ZTxsb3dlclZhbHVlKXt1cHBlclZhbHVlPTA7bG93ZXJWYWx1ZT0wO31cblx0XHRcdGlmIChNYXRoLmFicyh1cHBlclZhbHVlIC0gbG93ZXJWYWx1ZSkgPCBjb25maWcuemVyb1ZhbHVlKSB7XG5cdFx0XHRcdGlmKE1hdGguYWJzKHVwcGVyVmFsdWUpPCBjb25maWcuemVyb1ZhbHVlKSB1cHBlclZhbHVlID0gLjk7XG5cdFx0XHRcdGlmKHVwcGVyVmFsdWU+MCkge1xuXHRcdFx0XHRcdHVwcGVyVmFsdWU9dXBwZXJWYWx1ZSoxLjE7XG5cdFx0XHRcdFx0bG93ZXJWYWx1ZT1sb3dlclZhbHVlKjAuOTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR1cHBlclZhbHVlPXVwcGVyVmFsdWUqMC45O1xuXHRcdFx0XHRcdGxvd2VyVmFsdWU9bG93ZXJWYWx1ZSoxLjE7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRpZih0eXBlb2YgY29uZmlnLmdyYXBoTWluPT1cImZ1bmN0aW9uXCIpbG93ZXJWYWx1ZT0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiR1JBUEhNSU5cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmdyYXBoTWluLFwiZ3JhcGhNaW5cIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0pXG5cdFx0XHRlbHNlIGlmICghaXNOYU4oY29uZmlnLmdyYXBoTWluKSkgbG93ZXJWYWx1ZSA9IGNvbmZpZy5ncmFwaE1pbjtcblx0XHRcdGlmKHR5cGVvZiBjb25maWcuZ3JhcGhNYXg9PVwiZnVuY3Rpb25cIikgdXBwZXJWYWx1ZT0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiR1JBUEhNQVhcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmdyYXBoTWF4LFwiZ3JhcGhNYXhcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0pXG5cdFx0XHRlbHNlIGlmICghaXNOYU4oY29uZmlnLmdyYXBoTWF4KSkgdXBwZXJWYWx1ZSA9IGNvbmZpZy5ncmFwaE1heDtcblx0XHRcdGlmIChzZWNvbmRBeGlzKSB7XG5cdFx0XHRcdGlmKHVwcGVyVmFsdWUyPGxvd2VyVmFsdWUyKXt1cHBlclZhbHVlMj0wO2xvd2VyVmFsdWUyPTA7fVxuXHRcdFx0XHRpZiAoTWF0aC5hYnModXBwZXJWYWx1ZTIgLSBsb3dlclZhbHVlMikgPCBjb25maWcuemVyb1ZhbHVlKSB7XG5cdFx0XHRcdFx0aWYoTWF0aC5hYnModXBwZXJWYWx1ZTIpPCBjb25maWcuemVyb1ZhbHVlKSB1cHBlclZhbHVlMiA9IC45O1xuXHRcdFx0XHRcdGlmKHVwcGVyVmFsdWUyPjApIHtcblx0XHRcdFx0XHRcdHVwcGVyVmFsdWUyPXVwcGVyVmFsdWUyKjEuMTtcblx0XHRcdFx0XHRcdGxvd2VyVmFsdWUyPWxvd2VyVmFsdWUyKjAuOTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dXBwZXJWYWx1ZTI9dXBwZXJWYWx1ZTIqMC45O1xuXHRcdFx0XHRcdFx0bG93ZXJWYWx1ZTI9bG93ZXJWYWx1ZTIqMS4xO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0eXBlb2YgY29uZmlnLmdyYXBoTWluMj09XCJmdW5jdGlvblwiKWxvd2VyVmFsdWUyPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJHUkFQSE1JTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuZ3JhcGhNaW4yLFwiZ3JhcGhNaW4yXCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9KVxuXHRcdFx0XHRlbHNlIGlmICghaXNOYU4oY29uZmlnLmdyYXBoTWluMikpIGxvd2VyVmFsdWUyID0gY29uZmlnLmdyYXBoTWluMjtcblx0XHRcdFx0aWYodHlwZW9mIGNvbmZpZy5ncmFwaE1heDI9PVwiZnVuY3Rpb25cIikgdXBwZXJWYWx1ZTI9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkdSQVBITUFYXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5ncmFwaE1heDIsXCJncmFwaE1heDJcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0pXG5cdFx0XHRcdGVsc2UgaWYgKCFpc05hTihjb25maWcuZ3JhcGhNYXgyKSkgdXBwZXJWYWx1ZTIgPSBjb25maWcuZ3JhcGhNYXgyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFmaXJzdEF4aXMgJiYgc2Vjb25kQXhpcykge1xuXHRcdFx0XHR1cHBlclZhbHVlID0gdXBwZXJWYWx1ZTI7XG5cdFx0XHRcdGxvd2VyVmFsdWUgPSBsb3dlclZhbHVlMjtcblx0XHRcdH1cblx0XHRcdGxhYmVsSGVpZ2h0ID0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKTtcblx0XHRcdHNjYWxlSGVpZ2h0ID0gbXNyLmF2YWlsYWJsZUhlaWdodDtcblx0XHRcdHZhciBtYXhTdGVwcyA9IE1hdGguZmxvb3IoKHNjYWxlSGVpZ2h0IC8gKGxhYmVsSGVpZ2h0ICogMC42NikpKTtcblx0XHRcdHZhciBtaW5TdGVwcyA9IE1hdGguZmxvb3IoKHNjYWxlSGVpZ2h0IC8gbGFiZWxIZWlnaHQgKiAwLjUpKTtcblx0XHRcdGlmKHVwcGVyVmFsdWU8bG93ZXJWYWx1ZSl7bG93ZXJWYWx1ZT11cHBlclZhbHVlLTE7fVxuXHRcdFx0aWYodXBwZXJWYWx1ZTI8bG93ZXJWYWx1ZTIpe2xvd2VyVmFsdWUyPXVwcGVyVmFsdWUyLTE7fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bWF4VmFsdWU6IHVwcGVyVmFsdWUsXG5cdFx0XHRcdG1pblZhbHVlOiBsb3dlclZhbHVlLFxuXHRcdFx0XHRtYXhWYWx1ZTI6IHVwcGVyVmFsdWUyLFxuXHRcdFx0XHRtaW5WYWx1ZTI6IGxvd2VyVmFsdWUyLFxuXHRcdFx0XHRkYkF4aXM6IHNlY29uZEF4aXMsXG5cdFx0XHRcdG1heFN0ZXBzOiBtYXhTdGVwcyxcblx0XHRcdFx0bWluU3RlcHM6IG1pblN0ZXBzXG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGE6ZGF0YSxcblx0XHRcdGNvbmZpZzpjb25maWcsXG5cdFx0XHRjdHg6Y3R4XG5cdFx0fTtcblx0fTtcblx0dmFyIFN0YWNrZWRCYXIgPSBmdW5jdGlvbihkYXRhLCBjb25maWcsIGN0eCkge1xuXHRcdHZhciBtYXhTaXplLCBzY2FsZUhvcCwgY2FsY3VsYXRlZFNjYWxlLCBsYWJlbEhlaWdodCwgc2NhbGVIZWlnaHQsIHZhbHVlQm91bmRzLCBsYWJlbFRlbXBsYXRlU3RyaW5nLCB2YWx1ZUhvcCwgd2lkZXN0WExhYmVsLCB4QXhpc0xlbmd0aCwgeUF4aXNQb3NYLCB4QXhpc1Bvc1ksIGJhcldpZHRoLCByb3RhdGVMYWJlbHMgPSAwLFxuXHRcdFx0bXNyO1xuXG5cdFx0Y3R4LnRwY2hhcnQ9XCJTdGFja2VkQmFyXCI7XG5cdFx0Y3R4LnRwZGF0YT0wO1xuXG5cdCAgICAgICAgaWYgKCFpbml0X2FuZF9zdGFydChjdHgsZGF0YSxjb25maWcpKSByZXR1cm47XG5cdFx0dmFyIHN0YXREYXRhPWluaXRQYXNzVmFyaWFibGVEYXRhX3BhcnQxKGRhdGEsY29uZmlnLGN0eCk7XG5cblx0XHR2YXIgbnJPZkJhcnMgPSBkYXRhLmRhdGFzZXRzLmxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChkYXRhLmRhdGFzZXRzW2ldLnR5cGUgPT0gXCJMaW5lXCIpIHsgc3RhdERhdGFbaV1bMF0udHBjaGFydD1cIkxpbmVcIjtuck9mQmFycy0tO31cblx0XHRcdGVsc2Ugc3RhdERhdGFbaV1bMF0udHBjaGFydD1cIkJhclwiO1x0XG5cdFx0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblx0XHRjb25maWcubG9nYXJpdGhtaWMgPSBmYWxzZTtcblx0XHRtc3IgPSBzZXRNZWFzdXJlcyhkYXRhLCBjb25maWcsIGN0eCwgY3R4LmNhbnZhcy5oZWlnaHQsIGN0eC5jYW52YXMud2lkdGgsIFwibmloaWxcIiwgW1wiXCJdLCB0cnVlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgXCJTdGFja2VkQmFyXCIpO1xuXHRcdHZhbHVlQm91bmRzID0gZ2V0VmFsdWVCb3VuZHMoKTtcblx0XHRpZih2YWx1ZUJvdW5kcy5tYXhTdGVwcz4wICYmIHZhbHVlQm91bmRzLm1pblN0ZXBzPjApIHtcblx0XHRcdC8vQ2hlY2sgYW5kIHNldCB0aGUgc2NhbGVcblx0XHRcdGxhYmVsVGVtcGxhdGVTdHJpbmcgPSAoY29uZmlnLnNjYWxlU2hvd0xhYmVscykgPyBjb25maWcuc2NhbGVMYWJlbCA6IFwiXCI7XG5cdFx0XHRpZiAoIWNvbmZpZy5zY2FsZU92ZXJyaWRlKSB7XG5cdFx0XHRcdGNhbGN1bGF0ZWRTY2FsZSA9IGNhbGN1bGF0ZVNjYWxlKDEsIGNvbmZpZywgdmFsdWVCb3VuZHMubWF4U3RlcHMsIHZhbHVlQm91bmRzLm1pblN0ZXBzLCB2YWx1ZUJvdW5kcy5tYXhWYWx1ZSwgdmFsdWVCb3VuZHMubWluVmFsdWUsIGxhYmVsVGVtcGxhdGVTdHJpbmcpO1xuXHRcdFx0XHRtc3IgPSBzZXRNZWFzdXJlcyhkYXRhLCBjb25maWcsIGN0eCwgY3R4LmNhbnZhcy5oZWlnaHQsIGN0eC5jYW52YXMud2lkdGgsIGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHMsIG51bGwsIHRydWUsIGZhbHNlLCB0cnVlLCB0cnVlLCB0cnVlLCBcIlN0YWNrZWRCYXJcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc2NhbGVTdGFydFZhbHVlPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJTQ0FMRVNUQVJUVkFMVUVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLnNjYWxlU3RhcnRWYWx1ZSxcInNjYWxlU3RhcnRWYWx1ZVwiLC0xLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHR2YXIgc2NhbGVTdGVwcyA9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEVQU1wiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuc2NhbGVTdGVwcyxcInNjYWxlU3RlcHNcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0dmFyIHNjYWxlU3RlcFdpZHRoID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEVQV0lEVEhcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLnNjYWxlU3RlcFdpZHRoLFwic2NhbGVTdGVwV2lkdGhcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblxuXHRcdFx0XHRjYWxjdWxhdGVkU2NhbGUgPSB7XG5cdFx0XHRcdFx0c3RlcHM6IHNjYWxlU3RlcHMsXG5cdFx0XHRcdFx0c3RlcFZhbHVlOiBzY2FsZVN0ZXBXaWR0aCxcblx0XHRcdFx0XHRncmFwaE1pbjogc2NhbGVTdGFydFZhbHVlLFxuXHRcdFx0XHRcdGxhYmVsczogW11cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNhbGN1bGF0ZWRTY2FsZS5zdGVwczsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGxhYmVsVGVtcGxhdGVTdHJpbmcpIHtcblx0XHRcdFx0XHRcdGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHMucHVzaCh0bXBsKGxhYmVsVGVtcGxhdGVTdHJpbmcsIHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IGZtdENoYXJ0SlMoY29uZmlnLCAxICogKChzY2FsZVN0YXJ0VmFsdWUgKyAoc2NhbGVTdGVwV2lkdGggKiBpKSkudG9GaXhlZChnZXREZWNpbWFsUGxhY2VzKHNjYWxlU3RlcFdpZHRoKSkpLCBjb25maWcuZm10WUxhYmVsKVxuXHRcdFx0XHRcdFx0fSxjb25maWcpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bXNyID0gc2V0TWVhc3VyZXMoZGF0YSwgY29uZmlnLCBjdHgsIGN0eC5jYW52YXMuaGVpZ2h0LCBjdHguY2FudmFzLndpZHRoLCBjYWxjdWxhdGVkU2NhbGUubGFiZWxzLCBudWxsLCB0cnVlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgXCJTdGFja2VkQmFyXCIpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHByZXZIZWlnaHQ9bXNyLmF2YWlsYWJsZUhlaWdodDtcbiAgICAgICBcdFxuXHRcdFx0bXNyLmF2YWlsYWJsZUhlaWdodCA9IG1zci5hdmFpbGFibGVIZWlnaHQgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplQm90dG9tKSAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVUb3ApO1xuXHRcdFx0bXNyLmF2YWlsYWJsZVdpZHRoID0gbXNyLmF2YWlsYWJsZVdpZHRoIC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUxlZnQpIC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVJpZ2h0KTtcblx0XHRcdHNjYWxlSG9wID0gTWF0aC5mbG9vcihtc3IuYXZhaWxhYmxlSGVpZ2h0IC8gY2FsY3VsYXRlZFNjYWxlLnN0ZXBzKTtcblx0XHRcdHZhbHVlSG9wID0gTWF0aC5mbG9vcihtc3IuYXZhaWxhYmxlV2lkdGggLyAoZGF0YS5sYWJlbHMubGVuZ3RoKSk7XG5cdFx0XHRpZiAodmFsdWVIb3AgPT0gMCB8fCBjb25maWcuZnVsbFdpZHRoR3JhcGgpIHZhbHVlSG9wID0gKG1zci5hdmFpbGFibGVXaWR0aCAvIGRhdGEubGFiZWxzLmxlbmd0aCk7XG5cdFx0XHRtc3IuY2xyd2lkdGggPSBtc3IuY2xyd2lkdGggLSAobXNyLmF2YWlsYWJsZVdpZHRoIC0gKChkYXRhLmxhYmVscy5sZW5ndGgpICogdmFsdWVIb3ApKTtcblx0XHRcdG1zci5hdmFpbGFibGVXaWR0aCA9IChkYXRhLmxhYmVscy5sZW5ndGgpICogdmFsdWVIb3A7XG5cblx0XHRcdG1zci5hdmFpbGFibGVIZWlnaHQgPSAoY2FsY3VsYXRlZFNjYWxlLnN0ZXBzKSAqIHNjYWxlSG9wO1xuXHRcdFx0bXNyLnhMYWJlbFBvcys9KE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVCb3R0b20pICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCkgLSAocHJldkhlaWdodC1tc3IuYXZhaWxhYmxlSGVpZ2h0KSk7XG5cdFx0XHRtc3IuY2xyaGVpZ2h0Kz0oTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUJvdHRvbSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplVG9wKSAtIChwcmV2SGVpZ2h0LW1zci5hdmFpbGFibGVIZWlnaHQpKTtcbiAgICAgICBcdFxuXHRcdFx0eUF4aXNQb3NYID0gbXNyLmxlZnROb3RVc2FibGVTaXplICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUxlZnQpO1xuXHRcdFx0eEF4aXNQb3NZID0gbXNyLnRvcE5vdFVzYWJsZVNpemUgKyBtc3IuYXZhaWxhYmxlSGVpZ2h0ICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCk7XG5cdFx0XHRiYXJXaWR0aCA9ICh2YWx1ZUhvcCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlR3JpZExpbmVXaWR0aCkgKiAyIC0gKE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5iYXJWYWx1ZVNwYWNpbmcpICogMikgLSAoTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmJhckRhdGFzZXRTcGFjaW5nKSAqIDEgLSAxKSAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5iYXJTdHJva2VXaWR0aCkgLyAyKSAtIDEpO1xuXHRcdFx0aWYoYmFyV2lkdGg+PTAgJiYgYmFyV2lkdGg8PTEpYmFyV2lkdGg9MTtcblx0XHRcdGlmKGJhcldpZHRoPDAgJiYgYmFyV2lkdGg+PS0xKWJhcldpZHRoPS0xO1xuXHRcdFx0dmFyIGFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzO1xuXHRcdFx0aWYoMSpjb25maWcubWF4QmFyV2lkdGggPjAgJiYgYmFyV2lkdGggPiAxKmNvbmZpZy5tYXhCYXJXaWR0aCkge1xuXHRcdFx0XHRhZGRpdGlvbmFsU3BhY2VCZXR3ZWVuQmFycz0oYmFyV2lkdGgtMSpjb25maWcubWF4QmFyV2lkdGgpLzI7XG5cdFx0XHRcdGJhcldpZHRoPTEqY29uZmlnLm1heEJhcldpZHRoO1xuXHRcdFx0fSBlbHNlIGFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzPTA7XG5cblx0XHRcdHZhciB6ZXJvWSA9IDA7XG5cdFx0XHR2YXIgemVyb1kyID0gMDtcblxuXHRcdFx0emVyb1kgPSBjYWxjdWxhdGVPZmZzZXQoZmFsc2UsIDAsIGNhbGN1bGF0ZWRTY2FsZSwgc2NhbGVIb3ApO1xuXHRcdFx0aWYodHlwZW9mIGNhbGN1bGF0ZWRTY2FsZTIgPT09XCJvYmplY3RcIikgemVyb1kyID0gY2FsY3VsYXRlT2Zmc2V0KGNvbmZpZy5sb2dhcml0aG1pYzIsIDAsIGNhbGN1bGF0ZWRTY2FsZTIsIHNjYWxlSG9wMik7ICAgICAgIFx0XG5cdFx0XHRkcmF3TGFiZWxzKCk7XG5cdFx0XHRpbml0UGFzc1ZhcmlhYmxlRGF0YV9wYXJ0MihzdGF0RGF0YSxkYXRhLGNvbmZpZyxjdHgseyBcblx0XHRcdFx0bXNyOiBtc3IsXG5cdFx0XHRcdHplcm9ZIDogemVyb1ksXG5cdFx0XHRcdHplcm9ZMiA6IHplcm9ZMixcblx0XHRcdFx0bG9nYXJpdGhtaWMgIDogZmFsc2UsXG5cdFx0XHRcdGxvZ2FyaXRobWljMiA6IGZhbHNlLFxuXHRcdFx0XHRjYWxjdWxhdGVkU2NhbGUgOiBjYWxjdWxhdGVkU2NhbGUsXG5cdFx0XHRcdGFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzIDogYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnMsXG5cdFx0XHRcdHNjYWxlSG9wIDogc2NhbGVIb3AsXG5cdFx0XHRcdHZhbHVlSG9wIDogdmFsdWVIb3AsXG5cdFx0XHRcdHlBeGlzUG9zWCA6IHlBeGlzUG9zWCxcblx0XHRcdFx0eEF4aXNQb3NZIDogeEF4aXNQb3NZLFxuXHRcdFx0XHRiYXJXaWR0aCA6IGJhcldpZHRoXG5cdFx0XHQgfSk7XG5cdFx0XHRhbmltYXRpb25Mb29wKGNvbmZpZywgZHJhd1NjYWxlLCBkcmF3QmFycywgY3R4LCBtc3IuY2xyeCwgbXNyLmNscnksIG1zci5jbHJ3aWR0aCwgbXNyLmNscmhlaWdodCwgeUF4aXNQb3NYICsgbXNyLmF2YWlsYWJsZVdpZHRoIC8gMiwgeEF4aXNQb3NZIC0gbXNyLmF2YWlsYWJsZUhlaWdodCAvIDIsIHlBeGlzUG9zWCwgeEF4aXNQb3NZLCBkYXRhLCBzdGF0RGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRlc3RSZWRyYXcoY3R4LGRhdGEsY29uZmlnKTtcblx0XHRcdGN0eC5maXJzdFBhc3M9OTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZHJhd0JhcnMoYW5pbVBjKSB7XG5cdFx0XHR2YXIgcHJldlRvcFBvcyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dmFyIHByZXZUb3BOZWcgPSBuZXcgQXJyYXkoKTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmKGRhdGEuZGF0YXNldHNbaV0udHlwZT09XCJMaW5lXCIpIGNvbnRpbnVlO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGEuZGF0YXNldHNbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aD1NYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKnNldE9wdGlvblZhbHVlKHRydWUsMSxcIkJBUlNUUk9LRVdJRFRIXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5iYXJTdHJva2VXaWR0aCxjb25maWcuYmFyU3Ryb2tlV2lkdGgsXCJiYXJTdHJva2VXaWR0aFwiLGksaix7YW5pbWF0aW9uVmFsdWU6IGN1cnJlbnRBbmltUGMsIHhQb3NMZWZ0IDogc3RhdERhdGFbaV1bal0ueFBvc0xlZnQsIHlQb3NCb3R0b20gOiBib3RCYXIsIHhQb3NSaWdodCA6IHN0YXREYXRhW2ldW2pdLnhQb3NSaWdodCwgeVBvc1RvcCA6IHRvcEJhcn0gKSk7XHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBjdXJyZW50QW5pbVBjID0gYW5pbWF0aW9uQ29ycmVjdGlvbihhbmltUGMsIGRhdGEsIGNvbmZpZywgaSwgaiwgZmFsc2UpLmFuaW1WYWw7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRBbmltUGMgPiAxKSBjdXJyZW50QW5pbVBjID0gY3VycmVudEFuaW1QYyAtIDE7XG5cdFx0XHRcdFx0aWYgKCh0eXBlb2YgZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdID09ICd1bmRlZmluZWQnKSB8fCAxKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA9PSAwICkgY29udGludWU7XG5cdFx0XHRcdFx0aWYodHlwZW9mIHByZXZUb3BQb3Nbal09PVwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdFx0cHJldlRvcFBvc1tqXT1zdGF0RGF0YVtzdGF0RGF0YVtpXVtqXS5maXJzdE5vdE1pc3NpbmddW2pdLnlQb3NCb3R0b207XG5cdFx0XHRcdFx0XHRwcmV2VG9wTmVnW2pdPXN0YXREYXRhW3N0YXREYXRhW2ldW2pdLmZpcnN0Tm90TWlzc2luZ11bal0ueVBvc0JvdHRvbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGJvdEJhciwgdG9wQmFyO1xuXHRcdFx0XHRcdGlmKDEqZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdID4gMCkgYm90QmFyPXByZXZUb3BQb3Nbal07XG5cdFx0XHRcdFx0ZWxzZSBib3RCYXI9cHJldlRvcE5lZ1tqXTtcblx0XHRcdFx0XHR0b3BCYXI9Ym90QmFyK2N1cnJlbnRBbmltUGMqKHN0YXREYXRhW2ldW2pdLnlQb3NUb3Atc3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbSk7XG5cdFx0XHRcdFx0aWYoMSpkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gPiAwKSBwcmV2VG9wUG9zW2pdPXRvcEJhcjtcblx0XHRcdFx0XHRlbHNlIHByZXZUb3BOZWdbal09dG9wQmFyO1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGU9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmZpbGxDb2xvcixjb25maWcuZGVmYXVsdEZpbGxDb2xvcixcImZpbGxDb2xvclwiLGksaix7YW5pbWF0aW9uVmFsdWU6IGN1cnJlbnRBbmltUGMsIHhQb3NMZWZ0IDogc3RhdERhdGFbaV1bal0ueFBvc0xlZnQsIHlQb3NCb3R0b20gOiBib3RCYXIsIHhQb3NSaWdodCA6IHN0YXREYXRhW2ldW2pdLnhQb3NSaWdodCwgeVBvc1RvcCA6IHRvcEJhcn0gKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGU9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU1RST0tFQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLnN0cm9rZUNvbG9yLGNvbmZpZy5kZWZhdWx0U3Ryb2tlQ29sb3IsXCJzdHJva2VDb2xvclwiLGksaix7bnVsbHZhbHVlIDogbnVsbH0gKTtcblxuXHRcdFx0XHRcdGlmKGN1cnJlbnRBbmltUGMgIT0wICYmIGJvdEJhciE9dG9wQmFyKSB7XG5cdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHRjdHgubW92ZVRvKHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0LCBib3RCYXIrKHRvcEJhci1ib3RCYXIpLzIpO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhzdGF0RGF0YVtpXVtqXS54UG9zTGVmdCwgdG9wQmFyKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oc3RhdERhdGFbaV1bal0ueFBvc1JpZ2h0LCB0b3BCYXIpO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhzdGF0RGF0YVtpXVtqXS54UG9zUmlnaHQsIGJvdEJhcik7XG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0LCBib3RCYXIpO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhzdGF0RGF0YVtpXVtqXS54UG9zTGVmdCwgYm90QmFyKyh0b3BCYXItYm90QmFyKS8yKTtcblx0XHRcdFx0XHRcdGlmIChjb25maWcuYmFyU2hvd1N0cm9rZSkgeyBcblx0XHRcdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNUUk9LRVNUWUxFXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5kYXRhc2V0U3Ryb2tlU3R5bGUsY29uZmlnLmRhdGFzZXRTdHJva2VTdHlsZSxcImRhdGFzZXRTdHJva2VTdHlsZVwiLGksaix7bnVsbHZhbHVlIDogbnVsbH0gKSkpO1xuXHRcdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZHJhd0xpbmVzRGF0YXNldChhbmltUGMsIGRhdGEsIGNvbmZpZywgY3R4LCBzdGF0RGF0YSx7eEF4aXNQb3NZIDogeEF4aXNQb3NZLHlBeGlzUG9zWCA6IHlBeGlzUG9zWCwgdmFsdWVIb3AgOiB2YWx1ZUhvcCwgbmJWYWx1ZUhvcCA6IGRhdGEubGFiZWxzLmxlbmd0aCB9KTtcblxuXHRcdFx0aWYgKGFuaW1QYyA+PSBjb25maWcuYW5pbWF0aW9uU3RvcFZhbHVlKSB7XG5cdFx0XHRcdHZhciBcdHlQb3MgPSAwLFxuXHRcdFx0XHRcdHhQb3MgPSAwO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBkYXRhLmRhdGFzZXRzW2ldLmRhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKSA9PSAndW5kZWZpbmVkJykgY29udGludWU7XG5cdFx0XHRcdFx0XHRqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW2pzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF0ubGVuZ3RoXSA9IFtcIlJFQ1RcIiwgaSwgaiwgc3RhdERhdGEsc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiQU5OT1RBVEVESVNQTEFZXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5hbm5vdGF0ZURpc3BsYXksY29uZmlnLmFubm90YXRlRGlzcGxheSxcImFubm90YXRlRGlzcGxheVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0pXTtcblx0XHRcdFx0XHRcdGlmKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBU0hPV1wiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uaW5HcmFwaERhdGFTaG93LGNvbmZpZy5pbkdyYXBoRGF0YVNob3csXCJpbkdyYXBoRGF0YVNob3dcIixpLGose251bGxWYWx1ZSA6IHRydWV9KSkge1xuXHRcdFx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFBTElHTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFBbGlnbixcImluR3JhcGhEYXRhQWxpZ25cIixpLGose251bGxWYWx1ZTogdHJ1ZSAgfSk7XG5cdFx0XHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVZBTElHTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFWQWxpZ24sXCJpbkdyYXBoRGF0YVZBbGlnblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0Y3R4LmZvbnQgPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUZPTlRTVFlMRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U3R5bGUsXCJpbkdyYXBoRGF0YUZvbnRTdHlsZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSArICcgJyArIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0VGV4dFNjYWxlLFwiSU5HUkFQSERBVEFGT05UU0laRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U2l6ZSxcImluR3JhcGhEYXRhRm9udFNpemVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgKyAncHggJyArIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBRk9OVEZBTUlMWVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250RmFtaWx5LFwiaW5HcmFwaERhdGFGb250RmFtaWx5XCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFGT05UQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udENvbG9yLFwiaW5HcmFwaERhdGFGb250Q29sb3JcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdHZhciBkaXNwU3RyaW5nID0gdG1wbGJpcyhzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVRNUExcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhVG1wbCxcImluR3JhcGhEYXRhVG1wbFwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSwgc3RhdERhdGFbaV1bal0sY29uZmlnKTtcblx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHRcdHlQb3MgPSAwO1xuXHRcdFx0XHRcdFx0XHR4UG9zID0gMDtcblx0XHRcdFx0XHRcdFx0aWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBWFBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVhQb3NpdGlvbixcImluR3JhcGhEYXRhWFBvc2l0aW9uXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDEpIHtcblx0XHRcdFx0XHRcdFx0XHR4UG9zID0gc3RhdERhdGFbaV1bal0ueFBvc0xlZnQgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQVBBRERJTkdYXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdYLFwiaW5HcmFwaERhdGFQYWRkaW5nWFwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVhQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFYUG9zaXRpb24sXCJpbkdyYXBoRGF0YVhQb3NpdGlvblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0eFBvcyA9IHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0ICsgYmFyV2lkdGggLyAyICsgc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiSU5HUkFQSERBVEFQQURESU5HWFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nWCxcImluR3JhcGhEYXRhUGFkZGluZ1hcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFYUE9TSVRJT05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhWFBvc2l0aW9uLFwiaW5HcmFwaERhdGFYUG9zaXRpb25cIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgPT0gMykge1xuXHRcdFx0XHRcdFx0XHRcdHhQb3MgPSBzdGF0RGF0YVtpXVtqXS54UG9zTGVmdCsgYmFyV2lkdGggKyBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQVBBRERJTkdYXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdYLFwiaW5HcmFwaERhdGFQYWRkaW5nWFwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFZUE9TSVRJT05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhWVBvc2l0aW9uLFwiaW5HcmFwaERhdGFZUG9zaXRpb25cIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgPT0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdHlQb3MgPSBzdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tIC0gc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiSU5HUkFQSERBVEFQQURESU5HWVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nWSxcImluR3JhcGhEYXRhUGFkZGluZ1lcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFZUE9TSVRJT05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhWVBvc2l0aW9uLFwiaW5HcmFwaERhdGFZUG9zaXRpb25cIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgPT0gMikge1xuXHRcdFx0XHRcdFx0XHRcdHlQb3MgPSAoc3RhdERhdGFbaV1bal0ueVBvc1RvcCArIHN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b20pLzIgLSBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQVBBRERJTkdZXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdZLFwiaW5HcmFwaERhdGFQYWRkaW5nWVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVlQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFZUG9zaXRpb24sXCJpbkdyYXBoRGF0YVlQb3NpdGlvblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAzKSB7XG5cdFx0XHRcdFx0XHRcdFx0eVBvcyA9IHN0YXREYXRhW2ldW2pdLnlQb3NUb3AgLSBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQVBBRERJTkdZXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdZLFwiaW5HcmFwaERhdGFQYWRkaW5nWVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZih5UG9zPm1zci50b3BOb3RVc2FibGVTaXplKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh4UG9zLCB5UG9zKTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcm90YXRlVmFsPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUk9UQVRFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVJvdGF0ZSxcImluR3JhcGhEYXRhUm90YXRlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApICogKE1hdGguUEkgLyAxODApO1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5yb3RhdGUocm90YXRlVmFsKTtcblx0XHRcdFx0XHRcdFx0XHRzZXRUZXh0Qm9yZGVyc0FuZEJhY2tncm91bmQoY3R4LGRpc3BTdHJpbmcsc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRUZXh0U2NhbGUsXCJJTkdSQVBIREFUQUZPTlRTSVpFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRTaXplLFwiaW5HcmFwaERhdGFGb250U2l6ZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSwwLDAsc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFCT1JERVJTXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnMsXCJpbkdyYXBoRGF0YUJvcmRlcnNcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFCT1JERVJTQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVyc0NvbG9yLFwiaW5HcmFwaERhdGFCb3JkZXJzQ29sb3JcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRMaW5lU2NhbGUsXCJJTkdSQVBIREFUQUJPUkRFUlNXSURUSFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzV2lkdGgsXCJpbkdyYXBoRGF0YUJvcmRlcnNXaWR0aFwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQUJPUkRFUlNYU1BBQ0VcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVyc1hTcGFjZSxcImluR3JhcGhEYXRhQm9yZGVyc1hTcGFjZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQUJPUkRFUlNZU1BBQ0VcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVyc1lTcGFjZSxcImluR3JhcGhEYXRhQm9yZGVyc1lTcGFjZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJPUkRFUlNTVFlMRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzU3R5bGUsXCJpbkdyYXBoRGF0YUJvcmRlcnNTdHlsZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJBQ0tHUk9VTkRDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCYWNrZ3JvdW5kQ29sb3IsXCJpbkdyYXBoRGF0YUJhY2tncm91bmRDb2xvclwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxcIklOR1JBUEhEQVRBXCIsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVyc1JhZGl1cyk7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGRpc3BTdHJpbmcsIDAsIDAsIGN0eC50ZXh0QmFzZWxpbmUsIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0VGV4dFNjYWxlLFwiSU5HUkFQSERBVEFGT05UU0laRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U2l6ZSxcImluR3JhcGhEYXRhRm9udFNpemVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksdHJ1ZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiSU5HUkFQSERBVEFfVEVYVE1PVVNFXCIscm90YXRlVmFsLHhQb3MsIHlQb3MsaSxqKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYobXNyLmxlZ2VuZE1zci5kaXNwTGVnZW5kKWRyYXdMZWdlbmQobXNyLmxlZ2VuZE1zcixkYXRhLGNvbmZpZyxjdHgsXCJTdGFja2VkQmFyXCIpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBkcmF3U2NhbGUoKSB7XG5cdFx0XHQvL1ggYXhpcyBsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlTGluZVdpZHRoKTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5zY2FsZUxpbmVDb2xvcjtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihjb25maWcuc2NhbGVMaW5lU3R5bGUpKTtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oeUF4aXNQb3NYIC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUxlZnQpLCB4QXhpc1Bvc1kpO1xuXHRcdFx0Y3R4LmxpbmVUbyh5QXhpc1Bvc1ggKyBtc3IuYXZhaWxhYmxlV2lkdGggKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplUmlnaHQpLCB4QXhpc1Bvc1kpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihjb25maWcuc2NhbGVHcmlkTGluZVN0eWxlKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4Lm1vdmVUbyh5QXhpc1Bvc1ggKyBpICogdmFsdWVIb3AsIHhBeGlzUG9zWSArIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVCb3R0b20pKTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlR3JpZExpbmVXaWR0aCk7XG5cdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5zY2FsZUdyaWRMaW5lQ29sb3I7XG5cdFx0XHRcdC8vQ2hlY2sgaSBpc250IDAsIHNvIHdlIGRvbnQgZ28gb3ZlciB0aGUgWSBheGlzIHR3aWNlLlxuXHRcdFx0XHRpZiAoY29uZmlnLnNjYWxlU2hvd0dyaWRMaW5lcyAmJiBpID4gMCAmJiBpICUgY29uZmlnLnNjYWxlWEdyaWRMaW5lc1N0ZXAgPT0gMCkge1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeUF4aXNQb3NYICsgaSAqIHZhbHVlSG9wLCB4QXhpc1Bvc1kgLSBtc3IuYXZhaWxhYmxlSGVpZ2h0IC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeUF4aXNQb3NYICsgaSAqIHZhbHVlSG9wLCB4QXhpc1Bvc1kpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdH1cblx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcblx0XHRcdC8vWSBheGlzXG5cdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVMaW5lV2lkdGgpO1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY29uZmlnLnNjYWxlTGluZUNvbG9yO1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGNvbmZpZy5zY2FsZUxpbmVTdHlsZSkpO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh5QXhpc1Bvc1gsIHhBeGlzUG9zWSArIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVCb3R0b20pKTtcblx0XHRcdGN0eC5saW5lVG8oeUF4aXNQb3NYLCB4QXhpc1Bvc1kgLSBtc3IuYXZhaWxhYmxlSGVpZ2h0IC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCkpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFxuXHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGNvbmZpZy5zY2FsZUdyaWRMaW5lU3R5bGUpKTtcblx0XHRcdGZvciAodmFyIGogPSAoKGNvbmZpZy5zaG93WUF4aXNNaW4pID8gLTEgOiAwKTsgaiA8IGNhbGN1bGF0ZWRTY2FsZS5zdGVwczsgaisrKSB7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4Lm1vdmVUbyh5QXhpc1Bvc1ggLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplTGVmdCksIHhBeGlzUG9zWSAtICgoaiArIDEpICogc2NhbGVIb3ApKTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlR3JpZExpbmVXaWR0aCk7XG5cdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5zY2FsZUdyaWRMaW5lQ29sb3I7XG5cdFx0XHRcdGlmIChjb25maWcuc2NhbGVTaG93R3JpZExpbmVzICYmIChqKzEpICUgY29uZmlnLnNjYWxlWUdyaWRMaW5lc1N0ZXAgPT0gMCkge1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeUF4aXNQb3NYICsgbXNyLmF2YWlsYWJsZVdpZHRoICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVJpZ2h0KSwgeEF4aXNQb3NZIC0gKChqICsgMSkgKiBzY2FsZUhvcCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeUF4aXNQb3NYLCB4QXhpc1Bvc1kgLSAoKGogKyAxKSAqIHNjYWxlSG9wKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZHJhd0xhYmVscygpIHtcblx0XHRcdGN0eC5mb250ID0gY29uZmlnLnNjYWxlRm9udFN0eWxlICsgXCIgXCIgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgY29uZmlnLnNjYWxlRm9udEZhbWlseTtcblx0XHRcdC8vWCBheGlzIGxhYmVscyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblx0XHRcdGlmIChjb25maWcueEF4aXNUb3AgfHwgY29uZmlnLnhBeGlzQm90dG9tKSB7XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuXHRcdFx0XHRpZiAobXNyLnJvdGF0ZUxhYmVscyA+IDkwKSB7XG5cdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAobXNyLnJvdGF0ZUxhYmVscyA+IDApIHtcblx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5zY2FsZUZvbnRDb2xvcjtcblx0XHRcdFx0aWYgKGNvbmZpZy54QXhpc0JvdHRvbSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sYWJlbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmKHNob3dMYWJlbHMoY3R4LGRhdGEsY29uZmlnLGkpKXtcblx0XHRcdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRcdFx0aWYgKG1zci5yb3RhdGVMYWJlbHMgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh5QXhpc1Bvc1ggKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuYmFyVmFsdWVTcGFjaW5nKSArIGkgKiB2YWx1ZUhvcCArIGFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzKyAoYmFyV2lkdGggLyAyKSAtIG1zci5oaWdoZXN0WExhYmVsIC8gMiwgbXNyLnhMYWJlbFBvcyk7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZSgtKG1zci5yb3RhdGVMYWJlbHMgKiAoTWF0aC5QSSAvIDE4MCkpKTtcblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbFRleHRNdWx0aUxpbmUoZm10Q2hhcnRKUyhjb25maWcsIGRhdGEubGFiZWxzW2ldLCBjb25maWcuZm10WExhYmVsKSwgMCwgMCwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJYQVhJU19URVhUTU9VU0VcIiwtKG1zci5yb3RhdGVMYWJlbHMgKiAoTWF0aC5QSSAvIDE4MCkpLHlBeGlzUG9zWCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5iYXJWYWx1ZVNwYWNpbmcpICsgaSAqIHZhbHVlSG9wICsgYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnMrKGJhcldpZHRoIC8gMikgLSBtc3IuaGlnaGVzdFhMYWJlbCAvIDIsIG1zci54TGFiZWxQb3MsaSwtMSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGZtdENoYXJ0SlMoY29uZmlnLCBkYXRhLmxhYmVsc1tpXSwgY29uZmlnLmZtdFhMYWJlbCksIHlBeGlzUG9zWCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5iYXJWYWx1ZVNwYWNpbmcpICsgaSAqIHZhbHVlSG9wICsgYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnMrKGJhcldpZHRoIC8gMiksIG1zci54TGFiZWxQb3MsIGN0eC50ZXh0QmFzZWxpbmUsIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSksdHJ1ZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiWEFYSVNfVEVYVE1PVVNFXCIsMCwwLDAsaSwtMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vWSBheGlzXG5cdFx0XHRjdHgudGV4dEFsaWduID0gXCJyaWdodFwiO1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG5cdFx0XHRmb3IgKHZhciBqID0gKChjb25maWcuc2hvd1lBeGlzTWluKSA/IC0xIDogMCk7IGogPCBjYWxjdWxhdGVkU2NhbGUuc3RlcHM7IGorKykge1xuXHRcdFx0XHRpZiAoY29uZmlnLnNjYWxlU2hvd0xhYmVscykge1xuXHRcdFx0XHRcdGlmKHNob3dZTGFiZWxzKGN0eCxkYXRhLGNvbmZpZyxqKzEsY2FsY3VsYXRlZFNjYWxlLmxhYmVsc1tqICsgMV0pKSB7XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChjb25maWcueUF4aXNMZWZ0KSB7XG5cdFx0XHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShjYWxjdWxhdGVkU2NhbGUubGFiZWxzW2ogKyAxXSwgeUF4aXNQb3NYIC0gKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVMZWZ0KSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc1NwYWNlUmlnaHQpKSwgeEF4aXNQb3NZIC0gKChqICsgMSkgKiBzY2FsZUhvcCksIGN0eC50ZXh0QmFzZWxpbmUsIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSksdHJ1ZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiWUxFRlRBWElTX1RFWFRNT1VTRVwiLDAsMCwwLC0xLGopO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGNvbmZpZy55QXhpc1JpZ2h0KSB7XG5cdFx0XHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHNbaiArIDFdLCB5QXhpc1Bvc1ggKyBtc3IuYXZhaWxhYmxlV2lkdGggKyAoTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVJpZ2h0KSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc1NwYWNlUmlnaHQpKSwgeEF4aXNQb3NZIC0gKChqICsgMSkgKiBzY2FsZUhvcCksIGN0eC50ZXh0QmFzZWxpbmUsIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSksdHJ1ZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiWVJJR0hUQVhJU19URVhUTU9VU0VcIiwwLDAsMCwtMSxqKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWVCb3VuZHMoKSB7XG5cdFx0XHR2YXIgbWF4VmFscCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdFx0dmFyIG1pblZhbHAgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdFx0dmFyIG1heFZhbG4gPSAtTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdHZhciBtaW5WYWxuID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuXHRcdFx0dmFyIHRlbXBwPVtdO1xuXHRcdFx0dmFyIHRlbXBuPVtdO1xuXHRcdFx0dmFyIGlucD0wO1xuXHRcdFx0dmFyIGlubj0wO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhLmRhdGFzZXRzW2ldLmRhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRpZigxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdID4gMCkge1xuXHRcdFx0XHRcdFx0aWYoc3RhdERhdGFbaV1bMF0udHBjaGFydD09XCJCYXJcIikge1xuXHRcdFx0XHRcdFx0XHRpZih0eXBlb2YgdGVtcHBbal0gPT0gXCJ1bmRlZmluZWRcIikgdGVtcHBbal09MDtcblx0XHRcdFx0XHRcdFx0dGVtcHBbal0gKz0gMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXTtcblx0XHRcdFx0XHRcdFx0bWF4VmFscD1NYXRoLm1heChtYXhWYWxwLHRlbXBwW2pdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBtYXhWYWxwPU1hdGgubWF4KG1heFZhbHAsMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSk7XG5cdFx0XHRcdFx0XHRtaW5WYWxwPU1hdGgubWluKG1pblZhbHAsMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSk7XG5cdFx0XHRcdFx0XHRpbnA9MTtcblx0XHRcdFx0XHR9IGVsc2UgaWYodHlwZW9mICgxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKT09PVwibnVtYmVyXCIgJiYgdHlwZW9mIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSE9XCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRcdFx0aWYoc3RhdERhdGFbaV1bMF0udHBjaGFydD09XCJCYXJcIikge1xuXHRcdFx0XHRcdFx0XHRpZih0eXBlb2YgdGVtcG5bal0gPT0gXCJ1bmRlZmluZWRcIikgdGVtcG5bal09MDtcblx0XHRcdFx0XHRcdFx0dGVtcG5bal0gKz0gKDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0pO1xuXHRcdFx0XHRcdFx0XHRtaW5WYWxuPU1hdGgubWluKG1pblZhbG4sdGVtcG5bal0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIG1pblZhbG49TWF0aC5taW4obWluVmFsbiwxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKTtcblx0XHRcdFx0XHRcdG1heFZhbG49TWF0aC5tYXgobWF4VmFsbiwxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKTtcblx0XHRcdFx0XHRcdGlubj0xO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHZhciB1cHBlclZhbHVlLCBsb3dlclZhbHVlO1xuXHRcdFx0aWYgKGlucD09MCl7dXBwZXJWYWx1ZT1tYXhWYWxuO2xvd2VyVmFsdWU9bWluVmFsbjt9XG5cdFx0XHRlbHNlIGlmKGlubj09MCkgeyB1cHBlclZhbHVlPW1heFZhbHA7bG93ZXJWYWx1ZT1taW5WYWxwO31cblx0XHRcdGVsc2UgeyB1cHBlclZhbHVlPW1heFZhbHA7bG93ZXJWYWx1ZT1taW5WYWxuOyB9XG5cblx0XHRcdGlmKHR5cGVvZiBjb25maWcuZ3JhcGhNaW49PVwiZnVuY3Rpb25cIilsb3dlclZhbHVlPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJHUkFQSE1JTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuZ3JhcGhNaW4sXCJncmFwaE1pblwiLC0xLC0xLHtudWxsVmFsdWUgOiB0cnVlfSlcblx0XHRcdGVsc2UgaWYgKCFpc05hTihjb25maWcuZ3JhcGhNaW4pKSBsb3dlclZhbHVlID0gY29uZmlnLmdyYXBoTWluO1xuXHRcdFx0aWYodHlwZW9mIGNvbmZpZy5ncmFwaE1heD09XCJmdW5jdGlvblwiKSB1cHBlclZhbHVlPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJHUkFQSE1BWFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuZ3JhcGhNYXgsXCJncmFwaE1heFwiLC0xLC0xLHtudWxsVmFsdWUgOiB0cnVlfSlcblx0XHRcdGVsc2UgaWYgKCFpc05hTihjb25maWcuZ3JhcGhNYXgpKSB1cHBlclZhbHVlID0gY29uZmlnLmdyYXBoTWF4O1xuXG5cdFx0XHRpZih1cHBlclZhbHVlPGxvd2VyVmFsdWUpe3VwcGVyVmFsdWU9MDtsb3dlclZhbHVlPTA7fVxuXHRcdFx0aWYgKE1hdGguYWJzKHVwcGVyVmFsdWUgLSBsb3dlclZhbHVlKSA8IGNvbmZpZy56ZXJvVmFsdWUpIHtcblx0XHRcdFx0aWYoTWF0aC5hYnModXBwZXJWYWx1ZSk8IGNvbmZpZy56ZXJvVmFsdWUpIHVwcGVyVmFsdWUgPSAuOTtcblx0XHRcdFx0aWYodXBwZXJWYWx1ZT4wKSB7XG5cdFx0XHRcdFx0dXBwZXJWYWx1ZT11cHBlclZhbHVlKjEuMTtcblx0XHRcdFx0XHRsb3dlclZhbHVlPWxvd2VyVmFsdWUqMC45O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHVwcGVyVmFsdWU9dXBwZXJWYWx1ZSowLjk7XG5cdFx0XHRcdFx0bG93ZXJWYWx1ZT1sb3dlclZhbHVlKjEuMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsYWJlbEhlaWdodCA9IChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSk7XG5cdFx0XHRzY2FsZUhlaWdodCA9IG1zci5hdmFpbGFibGVIZWlnaHQ7XG5cdFx0XHR2YXIgbWF4U3RlcHMgPSBNYXRoLmZsb29yKChzY2FsZUhlaWdodCAvIChsYWJlbEhlaWdodCAqIDAuNjYpKSk7XG5cdFx0XHR2YXIgbWluU3RlcHMgPSBNYXRoLmZsb29yKChzY2FsZUhlaWdodCAvIGxhYmVsSGVpZ2h0ICogMC41KSk7XG5cdFx0XHRpZih1cHBlclZhbHVlPGxvd2VyVmFsdWUpe2xvd2VyVmFsdWU9dXBwZXJWYWx1ZS0xO31cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bWF4VmFsdWU6IHVwcGVyVmFsdWUsXG5cdFx0XHRcdG1pblZhbHVlOiBsb3dlclZhbHVlLFxuXHRcdFx0XHRtYXhTdGVwczogbWF4U3RlcHMsXG5cdFx0XHRcdG1pblN0ZXBzOiBtaW5TdGVwc1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRhOmRhdGEsXG5cdFx0XHRjb25maWc6Y29uZmlnLFxuXHRcdFx0Y3R4OmN0eFxuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBSZXZlcnNlIHRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgaG9yaXpvbnRhbCBjaGFydHNcblx0ICogLSByZXZlcnNlIGxhYmVscyBhbmQgZXZlcnkgYXJyYXkgaW5zaWRlIGRhdGFzZXRzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGRhdGFzZXRzIGFuZCBsYWJlbHMgZm9yIHRoZSBjaGFydFxuXHQgKiBAcmV0dXJuIHJldHVybiB0aGUgcmV2ZXJzZWQgZGF0YVxuXHQgKi9cblx0ZnVuY3Rpb24gcmV2ZXJzZURhdGEoZGF0YSkge1xuXHRcdGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMucmV2ZXJzZSgpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGRhdGEuZGF0YXNldHNbaV0pIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YS5kYXRhc2V0c1tpXVtrZXldKSkge1xuXHRcdFx0XHRcdGRhdGEuZGF0YXNldHNbaV1ba2V5XSA9IGRhdGEuZGF0YXNldHNbaV1ba2V5XS5yZXZlcnNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH07XG5cdHZhciBIb3Jpem9udGFsU3RhY2tlZEJhciA9IGZ1bmN0aW9uKGRhdGEsIGNvbmZpZywgY3R4KSB7XG5cdFx0dmFyIG1heFNpemUsIHNjYWxlSG9wLCBjYWxjdWxhdGVkU2NhbGUsIGxhYmVsSGVpZ2h0LCBzY2FsZUhlaWdodCwgdmFsdWVCb3VuZHMsIGxhYmVsVGVtcGxhdGVTdHJpbmcsIHZhbHVlSG9wLCB3aWRlc3RYTGFiZWwsIHhBeGlzTGVuZ3RoLCB5QXhpc1Bvc1gsIHhBeGlzUG9zWSwgYmFyV2lkdGgsIHJvdGF0ZUxhYmVscyA9IDAsXG5cdFx0XHRtc3I7XG5cblx0XHRpZiAoY29uZmlnLnJldmVyc2VPcmRlciAmJiB0eXBlb2YgY3R4LnJldmVyc2VkID09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGN0eC5yZXZlcnNlZD10cnVlO1xuXHRcdFx0ZGF0YSA9IHJldmVyc2VEYXRhKGRhdGEpO1xuXHRcdH1cblxuXHRcdGN0eC50cGNoYXJ0PVwiSG9yaXpvbnRhbFN0YWNrZWRCYXJcIjtcblx0XHRjdHgudHBkYXRhPTA7XG5cdCAgICAgICAgaWYgKCFpbml0X2FuZF9zdGFydChjdHgsZGF0YSxjb25maWcpKSByZXR1cm47XG5cdFx0dmFyIHN0YXREYXRhPWluaXRQYXNzVmFyaWFibGVEYXRhX3BhcnQxKGRhdGEsY29uZmlnLGN0eCk7XG5cblx0XHRjb25maWcubG9nYXJpdGhtaWMgPSBmYWxzZTtcblx0XHRtc3IgPSBzZXRNZWFzdXJlcyhkYXRhLCBjb25maWcsIGN0eCwgY3R4LmNhbnZhcy5oZWlnaHQsIGN0eC5jYW52YXMud2lkdGgsIFwibmloaWxcIiwgW1wiXCJdLCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlLCBcIkhvcml6b250YWxTdGFja2VkQmFyXCIpO1xuIFx0XHR2YWx1ZUJvdW5kcyA9IGdldFZhbHVlQm91bmRzKCk7XG5cdFx0XG5cdFx0aWYodmFsdWVCb3VuZHMubWF4U3RlcHM+MCAmJiB2YWx1ZUJvdW5kcy5taW5TdGVwcz4wKSB7XG5cdFx0XHQvL0NoZWNrIGFuZCBzZXQgdGhlIHNjYWxlXG5cdFx0XHRsYWJlbFRlbXBsYXRlU3RyaW5nID0gKGNvbmZpZy5zY2FsZVNob3dMYWJlbHMpID8gY29uZmlnLnNjYWxlTGFiZWwgOiBcIlwiO1xuXHRcdFx0aWYgKCFjb25maWcuc2NhbGVPdmVycmlkZSkge1xuXHRcdFx0XHRjYWxjdWxhdGVkU2NhbGUgPSBjYWxjdWxhdGVTY2FsZSgxLCBjb25maWcsIHZhbHVlQm91bmRzLm1heFN0ZXBzLCB2YWx1ZUJvdW5kcy5taW5TdGVwcywgdmFsdWVCb3VuZHMubWF4VmFsdWUsIHZhbHVlQm91bmRzLm1pblZhbHVlLCBsYWJlbFRlbXBsYXRlU3RyaW5nKTtcblx0XHRcdFx0bXNyID0gc2V0TWVhc3VyZXMoZGF0YSwgY29uZmlnLCBjdHgsIGN0eC5jYW52YXMuaGVpZ2h0LCBjdHguY2FudmFzLndpZHRoLCBjYWxjdWxhdGVkU2NhbGUubGFiZWxzLCBudWxsLCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlLCBcIkhvcml6b250YWxTdGFja2VkQmFyXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNjYWxlU3RhcnRWYWx1ZT0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEFSVFZBTFVFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5zY2FsZVN0YXJ0VmFsdWUsXCJzY2FsZVN0YXJ0VmFsdWVcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0dmFyIHNjYWxlU3RlcHMgPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNDQUxFU1RFUFNcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLnNjYWxlU3RlcHMsXCJzY2FsZVN0ZXBzXCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdHZhciBzY2FsZVN0ZXBXaWR0aCA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNDQUxFU1RFUFdJRFRIXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5zY2FsZVN0ZXBXaWR0aCxcInNjYWxlU3RlcFdpZHRoXCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9ICk7XG5cblx0XHRcdFx0Y2FsY3VsYXRlZFNjYWxlID0ge1xuXHRcdFx0XHRcdHN0ZXBzOiBzY2FsZVN0ZXBzLFxuXHRcdFx0XHRcdHN0ZXBWYWx1ZTogc2NhbGVTdGVwV2lkdGgsXG5cdFx0XHRcdFx0Z3JhcGhNaW46IHNjYWxlU3RhcnRWYWx1ZSxcblx0XHRcdFx0XHRsYWJlbHM6IFtdXG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gY2FsY3VsYXRlZFNjYWxlLnN0ZXBzOyBpKyspIHtcblx0XHRcdFx0XHRpZiAobGFiZWxUZW1wbGF0ZVN0cmluZykge1xuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlZFNjYWxlLmxhYmVscy5wdXNoKHRtcGwobGFiZWxUZW1wbGF0ZVN0cmluZywge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZTogZm10Q2hhcnRKUyhjb25maWcsIDEgKiAoKHNjYWxlU3RhcnRWYWx1ZSArIChzY2FsZVN0ZXBXaWR0aCAqIGkpKS50b0ZpeGVkKGdldERlY2ltYWxQbGFjZXMoc2NhbGVTdGVwV2lkdGgpKSksIGNvbmZpZy5mbXRZTGFiZWwpXG5cdFx0XHRcdFx0XHR9LGNvbmZpZykpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRtc3IgPSBzZXRNZWFzdXJlcyhkYXRhLCBjb25maWcsIGN0eCwgY3R4LmNhbnZhcy5oZWlnaHQsIGN0eC5jYW52YXMud2lkdGgsIGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHMsIG51bGwsIHRydWUsIHRydWUsIHRydWUsIHRydWUsIHRydWUsIFwiSG9yaXpvbnRhbFN0YWNrZWRCYXJcIik7XG5cdFx0XHR9XG5cdFx0XHRtc3IuYXZhaWxhYmxlSGVpZ2h0ID0gbXNyLmF2YWlsYWJsZUhlaWdodCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVCb3R0b20pIC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCk7XG5cdFx0XHRtc3IuYXZhaWxhYmxlV2lkdGggPSBtc3IuYXZhaWxhYmxlV2lkdGggLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplTGVmdCkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplUmlnaHQpO1xuXHRcdFx0c2NhbGVIb3AgPSBNYXRoLmZsb29yKG1zci5hdmFpbGFibGVIZWlnaHQgLyBkYXRhLmxhYmVscy5sZW5ndGgpO1xuXHRcdFx0dmFsdWVIb3AgPSBNYXRoLmZsb29yKG1zci5hdmFpbGFibGVXaWR0aCAvIChjYWxjdWxhdGVkU2NhbGUuc3RlcHMpKTtcblx0XHRcdGlmICh2YWx1ZUhvcCA9PSAwIHx8IGNvbmZpZy5mdWxsV2lkdGhHcmFwaCkgdmFsdWVIb3AgPSAobXNyLmF2YWlsYWJsZVdpZHRoIC8gKGNhbGN1bGF0ZWRTY2FsZS5zdGVwcykpO1xuXHRcdFx0bXNyLmNscndpZHRoID0gbXNyLmNscndpZHRoIC0gKG1zci5hdmFpbGFibGVXaWR0aCAtIChjYWxjdWxhdGVkU2NhbGUuc3RlcHMgKiB2YWx1ZUhvcCkpO1xuXHRcdFx0bXNyLmF2YWlsYWJsZVdpZHRoID0gKGNhbGN1bGF0ZWRTY2FsZS5zdGVwcykgKiB2YWx1ZUhvcDtcblx0XHRcdG1zci5hdmFpbGFibGVIZWlnaHQgPSAoZGF0YS5sYWJlbHMubGVuZ3RoKSAqIHNjYWxlSG9wO1xuXHRcdFx0eUF4aXNQb3NYID0gbXNyLmxlZnROb3RVc2FibGVTaXplICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUxlZnQpO1xuXHRcdFx0eEF4aXNQb3NZID0gbXNyLnRvcE5vdFVzYWJsZVNpemUgKyBtc3IuYXZhaWxhYmxlSGVpZ2h0ICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCk7XG5cdFx0XHRiYXJXaWR0aCA9IChzY2FsZUhvcCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlR3JpZExpbmVXaWR0aCkgKiAyIC0gKE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5iYXJWYWx1ZVNwYWNpbmcpICogMikgLSAoTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmJhckRhdGFzZXRTcGFjaW5nKSAqIDEgLSAxKSAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5iYXJTdHJva2VXaWR0aCkgLyAyKSAtIDEpO1xuXHRcdFx0aWYoYmFyV2lkdGg+PTAgJiYgYmFyV2lkdGg8PTEpYmFyV2lkdGg9MTtcblx0XHRcdGlmKGJhcldpZHRoPDAgJiYgYmFyV2lkdGg+PS0xKWJhcldpZHRoPS0xO1xuXHRcdFx0dmFyIGFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzO1xuXHRcdFx0aWYoMSpjb25maWcubWF4QmFyV2lkdGggPjAgJiYgYmFyV2lkdGggPiAxKmNvbmZpZy5tYXhCYXJXaWR0aCkge1xuXHRcdFx0XHRhZGRpdGlvbmFsU3BhY2VCZXR3ZWVuQmFycz0gKGJhcldpZHRoLTEqY29uZmlnLm1heEJhcldpZHRoKS8yO1xuXHRcdFx0XHRiYXJXaWR0aD0xKmNvbmZpZy5tYXhCYXJXaWR0aDtcblx0XHRcdH0gZWxzZSBhZGRpdGlvbmFsU3BhY2VCZXR3ZWVuQmFycz0wO1xuXG5cdFx0XHRkcmF3TGFiZWxzKCk7XG5cdFx0XHR2YXIgemVyb1k9ICBIb3Jpem9udGFsQ2FsY3VsYXRlT2Zmc2V0KDAgLCBjYWxjdWxhdGVkU2NhbGUsIHNjYWxlSG9wKTtcblx0XHRcdGluaXRQYXNzVmFyaWFibGVEYXRhX3BhcnQyKHN0YXREYXRhLGRhdGEsY29uZmlnLGN0eCx7IFxuXHRcdFx0XHR5QXhpc1Bvc1ggOiB5QXhpc1Bvc1gsXG5cdFx0XHRcdGFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzIDogYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnMsXG5cdFx0XHRcdHhBeGlzUG9zWSA6IHhBeGlzUG9zWSxcblx0XHRcdFx0YmFyV2lkdGggOiBiYXJXaWR0aCxcblx0XHRcdFx0emVyb1kgOiB6ZXJvWSxcblx0XHRcdFx0c2NhbGVIb3AgOiBzY2FsZUhvcCxcblx0XHRcdFx0dmFsdWVIb3AgOiB2YWx1ZUhvcCxcblx0XHRcdFx0Y2FsY3VsYXRlZFNjYWxlIDogY2FsY3VsYXRlZFNjYWxlXG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0YW5pbWF0aW9uTG9vcChjb25maWcsIGRyYXdTY2FsZSwgZHJhd0JhcnMsIGN0eCwgbXNyLmNscngsIG1zci5jbHJ5LCBtc3IuY2xyd2lkdGgsIG1zci5jbHJoZWlnaHQsIHlBeGlzUG9zWCArIG1zci5hdmFpbGFibGVXaWR0aCAvIDIsIHhBeGlzUG9zWSAtIG1zci5hdmFpbGFibGVIZWlnaHQgLyAyLCB5QXhpc1Bvc1gsIHhBeGlzUG9zWSwgZGF0YSwgc3RhdERhdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ZXN0UmVkcmF3KGN0eCxkYXRhLGNvbmZpZyk7XG5cdFx0XHRjdHguZmlyc3RQYXNzPTk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIEhvcml6b250YWxDYWxjdWxhdGVPZmZzZXQodmFsLCBjYWxjdWxhdGVkU2NhbGUsIHNjYWxlSG9wKSB7XG5cdFx0XHR2YXIgb3V0ZXJWYWx1ZSA9IGNhbGN1bGF0ZWRTY2FsZS5zdGVwcyAqIGNhbGN1bGF0ZWRTY2FsZS5zdGVwVmFsdWU7XG5cdFx0XHR2YXIgYWRqdXN0ZWRWYWx1ZSA9IHZhbCAtIGNhbGN1bGF0ZWRTY2FsZS5ncmFwaE1pbjtcblx0XHRcdHZhciBzY2FsaW5nRmFjdG9yID0gQ2FwVmFsdWUoYWRqdXN0ZWRWYWx1ZSAvIG91dGVyVmFsdWUsIDEsIDApO1xuXHRcdFx0cmV0dXJuIChzY2FsZUhvcCAqIGNhbGN1bGF0ZWRTY2FsZS5zdGVwcykgKiBzY2FsaW5nRmFjdG9yO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBkcmF3QmFycyhhbmltUGMpIHtcblx0XHRcdHZhciBwcmV2TGVmdFBvcyA9IG5ldyBBcnJheSgpO1xuXHRcdFx0dmFyIHByZXZMZWZ0TmVnID0gbmV3IEFycmF5KCk7XG5cbi8vXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmJhclN0cm9rZVdpZHRoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGEuZGF0YXNldHNbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGg9TWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJCQVJTVFJPS0VXSURUSFwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uYmFyU3Ryb2tlV2lkdGgsY29uZmlnLmJhclN0cm9rZVdpZHRoLFwiYmFyU3Ryb2tlV2lkdGhcIixpLGose2FuaW1hdGlvblZhbHVlOiBjdXJyZW50QW5pbVBjLCB4UG9zTGVmdCA6IGxlZnRCYXIsIHlQb3NCb3R0b20gOiBzdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tLCB4UG9zUmlnaHQgOiByaWdodEJhciwgeVBvc1RvcCA6IHN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b219ICkpO1xuXHRcdFx0XHRcdHZhciBjdXJyZW50QW5pbVBjID0gYW5pbWF0aW9uQ29ycmVjdGlvbihhbmltUGMsIGRhdGEsIGNvbmZpZywgaSwgaiwgZmFsc2UpLmFuaW1WYWw7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRBbmltUGMgPiAxKSBjdXJyZW50QW5pbVBjID0gY3VycmVudEFuaW1QYyAtIDE7XG5cdFx0XHRcdFx0aWYgKCh0eXBlb2YoZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKSA9PSAndW5kZWZpbmVkJykgfHwgMSpkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gPT0gMCApIGNvbnRpbnVlO1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBwcmV2TGVmdFBvc1tqXT09XCJ1bmRlZmluZWRcIil7XG5cdFx0XHRcdFx0XHRwcmV2TGVmdFBvc1tqXT1zdGF0RGF0YVtzdGF0RGF0YVtpXVtqXS5maXJzdE5vdE1pc3NpbmddW2pdLnhQb3NMZWZ0O1xuXHRcdFx0XHRcdFx0cHJldkxlZnROZWdbal09c3RhdERhdGFbc3RhdERhdGFbaV1bal0uZmlyc3ROb3RNaXNzaW5nXVtqXS54UG9zTGVmdDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgbGVmdEJhciwgcmlnaHRCYXI7XG4vLy8vXHRcdFx0XHRcdGlmKGNvbmZpZy5hbmltYXRpb25CeURhdGFzZXQpIHtcbi8vLy9cdFx0XHRcdFx0XHRsZWZ0QmFyPSBzdGF0RGF0YVtpXVtqXS54UG9zTGVmdDtcbi8vLy9cdFx0XHRcdFx0XHRyaWdodEJhcj0gc3RhdERhdGFbaV1bal0ueFBvc1JpZ2h0O1xuLy8vL1x0XHRcdFx0XHRcdHJpZ2h0QmFyPWxlZnRCYXIrY3VycmVudEFuaW1QYyoocmlnaHRCYXItbGVmdEJhcik7XG4vLy8vXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZigxKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA+IDApIGxlZnRCYXI9cHJldkxlZnRQb3Nbal07XG5cdFx0XHRcdFx0XHRlbHNlIGxlZnRCYXI9cHJldkxlZnROZWdbal07XG4vL1x0XHRcdFx0XHRcdGxlZnRCYXI9c3RhdERhdGFbc3RhdERhdGFbaV1bal0uZmlyc3ROb3RNaXNzaW5nXVtqXS54UG9zTGVmdCArIGN1cnJlbnRBbmltUGMqKHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0LXN0YXREYXRhW3N0YXREYXRhW2ldW2pdLmZpcnN0Tm90TWlzc2luZ11bal0ueFBvc0xlZnQpO1xuLy9cdFx0XHRcdFx0XHRyaWdodEJhcj1zdGF0RGF0YVtzdGF0RGF0YVtpXVtqXS5maXJzdE5vdE1pc3NpbmddW2pdLnhQb3NMZWZ0ICsgY3VycmVudEFuaW1QYyooc3RhdERhdGFbaV1bal0ueFBvc1JpZ2h0LXN0YXREYXRhW3N0YXREYXRhW2ldW2pdLmZpcnN0Tm90TWlzc2luZ11bal0ueFBvc0xlZnQpO1xuXHRcdFx0XHRcdFx0cmlnaHRCYXI9bGVmdEJhcitjdXJyZW50QW5pbVBjKihzdGF0RGF0YVtpXVtqXS54UG9zUmlnaHQtc3RhdERhdGFbaV1bal0ueFBvc0xlZnQpO1xuXG5cdFx0XHRcdFx0XHRpZigxKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA+IDApIHByZXZMZWZ0UG9zW2pdPXJpZ2h0QmFyO1xuXHRcdFx0XHRcdFx0ZWxzZSBwcmV2TGVmdE5lZ1tqXT1yaWdodEJhcjtcbi8vLy9cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGU9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmZpbGxDb2xvcixjb25maWcuZGVmYXVsdEZpbGxDb2xvcixcImZpbGxDb2xvclwiLGksaix7YW5pbWF0aW9uVmFsdWU6IGN1cnJlbnRBbmltUGMsIHhQb3NMZWZ0IDogbGVmdEJhciwgeVBvc0JvdHRvbSA6IHN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b20sIHhQb3NSaWdodCA6IHJpZ2h0QmFyLCB5UG9zVG9wIDogc3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbX0gKTtcblxuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZT1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJTVFJPS0VDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uc3Ryb2tlQ29sb3IsY29uZmlnLmRlZmF1bHRTdHJva2VDb2xvcixcInN0cm9rZUNvbG9yXCIsaSxqLHtudWxsdmFsdWUgOiBudWxsfSApO1xuXG5cdFx0XHRcdFx0aWYoY3VycmVudEFuaW1QYyAhPTAgJiYgc3RhdERhdGFbaV1bal0ueFBvc0xlZnQhPXN0YXREYXRhW2ldW2pdLnhQb3NSaWdodCApIHtcblx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8obGVmdEJhcisocmlnaHRCYXItbGVmdEJhcikvMiwgc3RhdERhdGFbaV1bal0ueVBvc1RvcCk7XG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKHJpZ2h0QmFyLCBzdGF0RGF0YVtpXVtqXS55UG9zVG9wKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8ocmlnaHRCYXIsIHN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b20pO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhsZWZ0QmFyLCBzdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8obGVmdEJhciwgc3RhdERhdGFbaV1bal0ueVBvc1RvcCk7XG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGxlZnRCYXIrKHJpZ2h0QmFyLWxlZnRCYXIpLzIsIHN0YXREYXRhW2ldW2pdLnlQb3NUb3ApO1xuXHRcdFx0XHRcdFx0aWYgKGNvbmZpZy5iYXJTaG93U3Ryb2tlKXsgIFxuXHRcdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU1RST0tFU1RZTEVcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmRhdGFzZXRTdHJva2VTdHlsZSxjb25maWcuZGF0YXNldFN0cm9rZVN0eWxlLFwiZGF0YXNldFN0cm9rZVN0eWxlXCIsaSxqLHtudWxsdmFsdWUgOiBudWxsfSApKSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5zdHJva2UoKTsgXG5cdFx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFuaW1QYyA+PSBjb25maWcuYW5pbWF0aW9uU3RvcFZhbHVlKSB7XG5cdFx0XHRcdHZhciB5UG9zID0gMCxcblx0XHRcdFx0XHR4UG9zID0gMDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRpZiAoKHR5cGVvZihkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0pID09ICd1bmRlZmluZWQnKSkgY29udGludWU7XG5cdFx0XHRcdFx0XHRqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW2pzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF0ubGVuZ3RoXSA9IFtcIlJFQ1RcIiwgaSAsaiwgc3RhdERhdGEsc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiQU5OT1RBVEVESVNQTEFZXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5hbm5vdGF0ZURpc3BsYXksY29uZmlnLmFubm90YXRlRGlzcGxheSxcImFubm90YXRlRGlzcGxheVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0pXTtcblx0XHRcdFx0XHRcdGlmKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBU0hPV1wiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uaW5HcmFwaERhdGFTaG93LGNvbmZpZy5pbkdyYXBoRGF0YVNob3csXCJpbkdyYXBoRGF0YVNob3dcIixpLGose251bGxWYWx1ZSA6IHRydWV9KSkge1xuXHRcdFx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFBTElHTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFBbGlnbixcImluR3JhcGhEYXRhQWxpZ25cIixpLGose251bGxWYWx1ZTogdHJ1ZSAgfSk7XG5cdFx0XHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVZBTElHTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFWQWxpZ24sXCJpbkdyYXBoRGF0YVZBbGlnblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0Y3R4LmZvbnQgPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUZPTlRTVFlMRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U3R5bGUsXCJpbkdyYXBoRGF0YUZvbnRTdHlsZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSArICcgJyArIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0VGV4dFNjYWxlLFwiSU5HUkFQSERBVEFGT05UU0laRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U2l6ZSxcImluR3JhcGhEYXRhRm9udFNpemVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgKyAncHggJyArIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBRk9OVEZBTUlMWVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250RmFtaWx5LFwiaW5HcmFwaERhdGFGb250RmFtaWx5XCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFGT05UQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udENvbG9yLFwiaW5HcmFwaERhdGFGb250Q29sb3JcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdHZhciBkaXNwU3RyaW5nID0gdG1wbGJpcyhzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVRNUExcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhVG1wbCxcImluR3JhcGhEYXRhVG1wbFwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzdGF0RGF0YVtpXVtqXSxjb25maWcpO1xuXHRcdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHRcdHlQb3MgPSAwO1xuXHRcdFx0XHRcdFx0XHR4UG9zID0gMDtcblx0XHRcdFx0XHRcdFx0aWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBWFBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVhQb3NpdGlvbixcImluR3JhcGhEYXRhWFBvc2l0aW9uXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDEpIHtcblx0XHRcdFx0XHRcdFx0XHR4UG9zID0gc3RhdERhdGFbaV1bal0ueFBvc0xlZnQgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQVBBRERJTkdYXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdYLFwiaW5HcmFwaERhdGFQYWRkaW5nWFwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVhQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFYUG9zaXRpb24sXCJpbkdyYXBoRGF0YVhQb3NpdGlvblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0eFBvcyA9IHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0ICsgKHN0YXREYXRhW2ldW2pdLnhQb3NSaWdodC1zdGF0RGF0YVtpXVtqXS54UG9zTGVmdCkvMiArIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBUEFERElOR1hcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ1gsXCJpbkdyYXBoRGF0YVBhZGRpbmdYXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBWFBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVhQb3NpdGlvbixcImluR3JhcGhEYXRhWFBvc2l0aW9uXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDMpIHtcblx0XHRcdFx0XHRcdFx0XHR4UG9zID0gc3RhdERhdGFbaV1bal0ueFBvc1JpZ2h0ICsgc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiSU5HUkFQSERBVEFQQURESU5HWFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nWCxcImluR3JhcGhEYXRhUGFkZGluZ1hcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBWVBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVlQb3NpdGlvbixcImluR3JhcGhEYXRhWVBvc2l0aW9uXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDEpIHtcblx0XHRcdFx0XHRcdFx0XHR5UG9zID0gc3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbSAtIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBUEFERElOR1lcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ1ksXCJpbkdyYXBoRGF0YVBhZGRpbmdZXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBWVBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVlQb3NpdGlvbixcImluR3JhcGhEYXRhWVBvc2l0aW9uXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDIpIHtcblx0XHRcdFx0XHRcdFx0XHR5UG9zID0gc3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbSAtIGJhcldpZHRoIC8gMiAtIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBUEFERElOR1lcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ1ksXCJpbkdyYXBoRGF0YVBhZGRpbmdZXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBWVBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVlQb3NpdGlvbixcImluR3JhcGhEYXRhWVBvc2l0aW9uXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDMpIHtcblx0XHRcdFx0XHRcdFx0XHR5UG9zID0gc3RhdERhdGFbaV1bal0ueVBvc1RvcCAtIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBUEFERElOR1lcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ1ksXCJpbkdyYXBoRGF0YVBhZGRpbmdZXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHR9XG4vL1x0XHRcdFx0XHRcdFx0XHRpZih4UG9zPD1tc3IuYXZhaWxhYmxlV2lkdGgrbXNyLmxlZnROb3RVc2FibGVTaXplKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh4UG9zLCB5UG9zKTtcblx0XHRcdFx0XHRcdFx0XHRyb3RhdGVWYWw9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFST1RBVEVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUm90YXRlLFwiaW5HcmFwaERhdGFSb3RhdGVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgKiAoTWF0aC5QSSAvIDE4MCk7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZShyb3RhdGVWYWwpO1xuXHRcdFx0XHRcdFx0XHRcdHNldFRleHRCb3JkZXJzQW5kQmFja2dyb3VuZChjdHgsZGlzcFN0cmluZyxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFRleHRTY2FsZSxcIklOR1JBUEhEQVRBRk9OVFNJWkVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udFNpemUsXCJpbkdyYXBoRGF0YUZvbnRTaXplXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLDAsMCxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJPUkRFUlNcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVycyxcImluR3JhcGhEYXRhQm9yZGVyc1wiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJPUkRFUlNDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzQ29sb3IsXCJpbkdyYXBoRGF0YUJvcmRlcnNDb2xvclwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydExpbmVTY2FsZSxcIklOR1JBUEhEQVRBQk9SREVSU1dJRFRIXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNXaWR0aCxcImluR3JhcGhEYXRhQm9yZGVyc1dpZHRoXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBQk9SREVSU1hTUEFDRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzWFNwYWNlLFwiaW5HcmFwaERhdGFCb3JkZXJzWFNwYWNlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBQk9SREVSU1lTUEFDRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzWVNwYWNlLFwiaW5HcmFwaERhdGFCb3JkZXJzWVNwYWNlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQk9SREVSU1NUWUxFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNTdHlsZSxcImluR3JhcGhEYXRhQm9yZGVyc1N0eWxlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQkFDS0dST1VORENPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJhY2tncm91bmRDb2xvcixcImluR3JhcGhEYXRhQmFja2dyb3VuZENvbG9yXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLFwiSU5HUkFQSERBVEFcIixjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzUmFkaXVzKTtcblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbFRleHRNdWx0aUxpbmUoZGlzcFN0cmluZywgMCwgMCwgY3R4LnRleHRCYXNlbGluZSwgc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRUZXh0U2NhbGUsXCJJTkdSQVBIREFUQUZPTlRTSVpFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRTaXplLFwiaW5HcmFwaERhdGFGb250U2l6ZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJJTkdSQVBIREFUQV9URVhUTU9VU0VcIixyb3RhdGVWYWwseFBvcywgeVBvcyxpLGopO1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG4vL1x0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYobXNyLmxlZ2VuZE1zci5kaXNwTGVnZW5kKWRyYXdMZWdlbmQobXNyLmxlZ2VuZE1zcixkYXRhLGNvbmZpZyxjdHgsXCJIb3Jpem9udGFsU3RhY2tlZEJhclwiKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZHJhd1NjYWxlKCkge1xuXHRcdFx0Ly9YIGF4aXMgbGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblx0XHRcdGN0eC5saW5lV2lkdGggPSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZUxpbmVXaWR0aCk7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuc2NhbGVMaW5lQ29sb3I7XG5cdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oY29uZmlnLnNjYWxlTGluZVN0eWxlKSk7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHlBeGlzUG9zWCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVMZWZ0KSwgeEF4aXNQb3NZKTtcblx0XHRcdGN0eC5saW5lVG8oeUF4aXNQb3NYICsgbXNyLmF2YWlsYWJsZVdpZHRoLCB4QXhpc1Bvc1kpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFxuXHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGNvbmZpZy5zY2FsZUdyaWRMaW5lU3R5bGUpKTtcblx0XHRcdGZvciAodmFyIGkgPSAoKGNvbmZpZy5zaG93WUF4aXNNaW4pID8gLTEgOiAwKTsgaSA8IGNhbGN1bGF0ZWRTY2FsZS5zdGVwczsgaSsrKSB7XG5cdFx0XHRcdGlmIChpID49IDApIHtcblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh5QXhpc1Bvc1ggKyBpICogdmFsdWVIb3AsIHhBeGlzUG9zWSArIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVCb3R0b20pKTtcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVHcmlkTGluZVdpZHRoKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuc2NhbGVHcmlkTGluZUNvbG9yO1xuXHRcdFx0XHRcdC8vQ2hlY2sgaSBpc250IDAsIHNvIHdlIGRvbnQgZ28gb3ZlciB0aGUgWSBheGlzIHR3aWNlLlxuXHRcdFx0XHRcdGlmIChjb25maWcuc2NhbGVTaG93R3JpZExpbmVzICYmIGkgPiAwICYmIGkgJSBjb25maWcuc2NhbGVYR3JpZExpbmVzU3RlcCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKHlBeGlzUG9zWCArIGkgKiB2YWx1ZUhvcCwgeEF4aXNQb3NZIC0gbXNyLmF2YWlsYWJsZUhlaWdodCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVUb3ApKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyh5QXhpc1Bvc1ggKyBpICogdmFsdWVIb3AsIHhBeGlzUG9zWSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0fVxuXHRcdFx0Ly9ZIGF4aXNcblx0XHRcdGN0eC5saW5lV2lkdGggPSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZUxpbmVXaWR0aCk7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuc2NhbGVMaW5lQ29sb3I7XG5cdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oY29uZmlnLnNjYWxlTGluZVN0eWxlKSk7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHlBeGlzUG9zWCwgeEF4aXNQb3NZICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUJvdHRvbSkpO1xuXHRcdFx0Y3R4LmxpbmVUbyh5QXhpc1Bvc1gsIHhBeGlzUG9zWSAtIG1zci5hdmFpbGFibGVIZWlnaHQgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplVG9wKSk7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGNvbmZpZy5zY2FsZUdyaWRMaW5lU3R5bGUpKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5sYWJlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHlBeGlzUG9zWCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVMZWZ0KSwgeEF4aXNQb3NZIC0gKChqICsgMSkgKiBzY2FsZUhvcCkpO1xuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVHcmlkTGluZVdpZHRoKTtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY29uZmlnLnNjYWxlR3JpZExpbmVDb2xvcjtcblx0XHRcdFx0aWYgKGNvbmZpZy5zY2FsZVNob3dHcmlkTGluZXMgJiYgKGorMSkgJSBjb25maWcuc2NhbGVZR3JpZExpbmVzU3RlcCA9PSAwKSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh5QXhpc1Bvc1ggKyBtc3IuYXZhaWxhYmxlV2lkdGgsIHhBeGlzUG9zWSAtICgoaiArIDEpICogc2NhbGVIb3ApKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHgubGluZVRvKHlBeGlzUG9zWCwgeEF4aXNQb3NZIC0gKChqICsgMSkgKiBzY2FsZUhvcCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdH1cblx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGRyYXdMYWJlbHMoKSB7XG5cdFx0XHRjdHguZm9udCA9IGNvbmZpZy5zY2FsZUZvbnRTdHlsZSArIFwiIFwiICsgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKS50b1N0cmluZygpICsgXCJweCBcIiArIGNvbmZpZy5zY2FsZUZvbnRGYW1pbHk7XG5cdFx0XHQvL1ggYXhpcyBsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXHRcdFx0aWYgKGNvbmZpZy5zY2FsZVNob3dMYWJlbHMgJiYgKGNvbmZpZy54QXhpc1RvcCB8fCBjb25maWcueEF4aXNCb3R0b20pKSB7XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuXHRcdFx0XHRpZiAobXNyLnJvdGF0ZUxhYmVscyA+IDkwKSB7XG5cdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAobXNyLnJvdGF0ZUxhYmVscyA+IDApIHtcblx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5zY2FsZUZvbnRDb2xvcjtcblx0XHRcdFx0aWYgKGNvbmZpZy54QXhpc0JvdHRvbSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAoKGNvbmZpZy5zaG93WUF4aXNNaW4pID8gLTEgOiAwKTsgaSA8IGNhbGN1bGF0ZWRTY2FsZS5zdGVwczsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZihzaG93WUxhYmVscyhjdHgsZGF0YSxjb25maWcsaSsxLGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHNbaSsgMV0pKSB7XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRcdFx0aWYgKG1zci5yb3RhdGVMYWJlbHMgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh5QXhpc1Bvc1ggKyAoaSArIDEpICogdmFsdWVIb3AgLSBtc3IuaGlnaGVzdFhMYWJlbCAvIDIsIG1zci54TGFiZWxQb3MpO1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5yb3RhdGUoLShtc3Iucm90YXRlTGFiZWxzICogKE1hdGguUEkgLyAxODApKSk7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHNbaSArIDFdLCAwLCAwLCBjdHgudGV4dEJhc2VsaW5lLCAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpLHRydWUsY29uZmlnLmRldGVjdE1vdXNlT25UZXh0LGN0eCxcIlhBWElTX1RFWFRNT1VTRVwiLC0obXNyLnJvdGF0ZUxhYmVscyAqIChNYXRoLlBJIC8gMTgwKSkseUF4aXNQb3NYICsgKGkgKyAxKSAqIHZhbHVlSG9wIC0gbXNyLmhpZ2hlc3RYTGFiZWwgLyAyLCBtc3IueExhYmVsUG9zLGksLTEpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShjYWxjdWxhdGVkU2NhbGUubGFiZWxzW2kgKyAxXSwgeUF4aXNQb3NYICsgKChpICsgMSkgKiB2YWx1ZUhvcCksIG1zci54TGFiZWxQb3MsIGN0eC50ZXh0QmFzZWxpbmUsIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSksdHJ1ZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiWEFYSVNfVEVYVE1PVVNFXCIsMCwwLDAsaSwtMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vWSBheGlzXG5cdFx0XHRjdHgudGV4dEFsaWduID0gXCJyaWdodFwiO1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGEubGFiZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmKHNob3dMYWJlbHMoY3R4LGRhdGEsY29uZmlnLGopKXtcblx0XHRcdFx0XHRpZiAoY29uZmlnLnlBeGlzTGVmdCkge1xuXHRcdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwicmlnaHRcIjtcblx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShmbXRDaGFydEpTKGNvbmZpZywgZGF0YS5sYWJlbHNbal0sIGNvbmZpZy5mbXRYTGFiZWwpLCB5QXhpc1Bvc1ggLSAoTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUxlZnQpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnlBeGlzU3BhY2VSaWdodCkpLCB4QXhpc1Bvc1kgLSAoKGogKyAxKSAqIHNjYWxlSG9wKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5iYXJWYWx1ZVNwYWNpbmcpICsgYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnMgKyAoYmFyV2lkdGggLyAyKSwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJZTEVGVEFYSVNfVEVYVE1PVVNFXCIsMCwwLDAsLTEsaik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjb25maWcueUF4aXNSaWdodCkge1xuXHRcdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGZtdENoYXJ0SlMoY29uZmlnLCBkYXRhLmxhYmVsc1tqXSwgY29uZmlnLmZtdFhMYWJlbCksIHlBeGlzUG9zWCArIG1zci5hdmFpbGFibGVXaWR0aCArIChNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplUmlnaHQpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnlBeGlzU3BhY2VSaWdodCkpLCB4QXhpc1Bvc1kgLSAoKGogKyAxKSAqIHNjYWxlSG9wKSArIGFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzKyAoYmFyV2lkdGggLyAyKSwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJZUklHSFRBWElTX1RFWFRNT1VTRVwiLDAsMCwwLC0xLGopO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZUJvdW5kcygpIHtcblx0XHRcdHZhciB1cHBlclZhbHVlID0gLU51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHR2YXIgbG93ZXJWYWx1ZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHR2YXIgbWludmwgPSBuZXcgQXJyYXkoZGF0YS5kYXRhc2V0cy5sZW5ndGgpO1xuXHRcdFx0dmFyIG1heHZsID0gbmV3IEFycmF5KGRhdGEuZGF0YXNldHMubGVuZ3RoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGEuZGF0YXNldHNbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdHZhciBrID0gaTtcblx0XHRcdFx0XHR2YXIgdGVtcHAgPSAwO1xuXHRcdFx0XHRcdHZhciB0ZW1wbiA9IDA7XG5cdFx0XHRcdFx0aWYgKCEodHlwZW9mKGRhdGEuZGF0YXNldHNbMF0uZGF0YVtqXSkgPT0gJ3VuZGVmaW5lZCcpKSB7XG5cdFx0XHRcdFx0XHRpZigxICogZGF0YS5kYXRhc2V0c1swXS5kYXRhW2pdID4gMCkge1xuXHRcdFx0XHRcdFx0XHR0ZW1wcCArPSAxICogZGF0YS5kYXRhc2V0c1swXS5kYXRhW2pdO1xuXHRcdFx0XHRcdFx0XHRpZiAodGVtcHAgPiB1cHBlclZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dXBwZXJWYWx1ZSA9IHRlbXBwO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRpZiAodGVtcHAgPCBsb3dlclZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0bG93ZXJWYWx1ZSA9IHRlbXBwO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGVtcG4gKz0gMSAqIGRhdGEuZGF0YXNldHNbMF0uZGF0YVtqXTtcblx0XHRcdFx0XHRcdFx0aWYgKHRlbXBuID4gdXBwZXJWYWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdHVwcGVyVmFsdWUgPSB0ZW1wbjtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0aWYgKHRlbXBuIDwgbG93ZXJWYWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdGxvd2VyVmFsdWUgPSB0ZW1wbjtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKGsgPiAwKSB7IC8vZ2V0IG1heCBvZiBzdGFja2VkIGRhdGFcblx0XHRcdFx0XHRcdGlmICghKHR5cGVvZihkYXRhLmRhdGFzZXRzW2tdLmRhdGFbal0pID09ICd1bmRlZmluZWQnKSkge1xuXHRcdFx0XHRcdFx0XHRpZigxICogZGF0YS5kYXRhc2V0c1trXS5kYXRhW2pdID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHRlbXBwICs9IDEgKiBkYXRhLmRhdGFzZXRzW2tdLmRhdGFbal07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRlbXBwID4gdXBwZXJWYWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dXBwZXJWYWx1ZSA9IHRlbXBwO1xuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRlbXBwIDwgbG93ZXJWYWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bG93ZXJWYWx1ZSA9IHRlbXBwO1xuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGVtcG4gKz0gMSAqIGRhdGEuZGF0YXNldHNba10uZGF0YVtqXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGVtcG4gPiB1cHBlclZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1cHBlclZhbHVlID0gdGVtcG47XG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGVtcG4gPCBsb3dlclZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsb3dlclZhbHVlID0gdGVtcG47XG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ay0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGlmKHR5cGVvZiBjb25maWcuZ3JhcGhNaW49PVwiZnVuY3Rpb25cIilsb3dlclZhbHVlPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJHUkFQSE1JTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuZ3JhcGhNaW4sXCJncmFwaE1pblwiLC0xLC0xLHtudWxsVmFsdWUgOiB0cnVlfSlcblx0XHRcdGVsc2UgaWYgKCFpc05hTihjb25maWcuZ3JhcGhNaW4pKSBsb3dlclZhbHVlID0gY29uZmlnLmdyYXBoTWluO1xuXHRcdFx0aWYodHlwZW9mIGNvbmZpZy5ncmFwaE1heD09XCJmdW5jdGlvblwiKSB1cHBlclZhbHVlPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJHUkFQSE1BWFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuZ3JhcGhNYXgsXCJncmFwaE1heFwiLC0xLC0xLHtudWxsVmFsdWUgOiB0cnVlfSlcblx0XHRcdGVsc2UgaWYgKCFpc05hTihjb25maWcuZ3JhcGhNYXgpKSB1cHBlclZhbHVlID0gY29uZmlnLmdyYXBoTWF4O1xuXHRcdFx0aWYodXBwZXJWYWx1ZTxsb3dlclZhbHVlKXt1cHBlclZhbHVlPTA7bG93ZXJWYWx1ZT0wO31cblx0XHRcdGlmIChNYXRoLmFicyh1cHBlclZhbHVlIC0gbG93ZXJWYWx1ZSkgPCBjb25maWcuemVyb1ZhbHVlKSB7XG5cdFx0XHRcdGlmKE1hdGguYWJzKHVwcGVyVmFsdWUpPCBjb25maWcuemVyb1ZhbHVlKSB1cHBlclZhbHVlID0gLjk7XG5cdFx0XHRcdGlmKHVwcGVyVmFsdWU+MCkge1xuXHRcdFx0XHRcdHVwcGVyVmFsdWU9dXBwZXJWYWx1ZSoxLjE7XG5cdFx0XHRcdFx0bG93ZXJWYWx1ZT1sb3dlclZhbHVlKjAuOTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR1cHBlclZhbHVlPXVwcGVyVmFsdWUqMC45O1xuXHRcdFx0XHRcdGxvd2VyVmFsdWU9bG93ZXJWYWx1ZSoxLjE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxhYmVsSGVpZ2h0ID0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKTtcblx0XHRcdHNjYWxlSGVpZ2h0ID0gbXNyLmF2YWlsYWJsZUhlaWdodDtcblx0XHRcdHZhciBtYXhTdGVwcyA9IE1hdGguZmxvb3IoKHNjYWxlSGVpZ2h0IC8gKGxhYmVsSGVpZ2h0ICogMC42NikpKTtcblx0XHRcdHZhciBtaW5TdGVwcyA9IE1hdGguZmxvb3IoKHNjYWxlSGVpZ2h0IC8gbGFiZWxIZWlnaHQgKiAwLjUpKTtcblx0XHRcdGlmKHVwcGVyVmFsdWU8bG93ZXJWYWx1ZSl7bG93ZXJWYWx1ZT11cHBlclZhbHVlLTE7fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bWF4VmFsdWU6IHVwcGVyVmFsdWUsXG5cdFx0XHRcdG1pblZhbHVlOiBsb3dlclZhbHVlLFxuXHRcdFx0XHRtYXhTdGVwczogbWF4U3RlcHMsXG5cdFx0XHRcdG1pblN0ZXBzOiBtaW5TdGVwc1xuXHRcdFx0fTtcblxuXG5cdFx0fTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGF0YTpkYXRhLFxuXHRcdFx0Y29uZmlnOmNvbmZpZyxcblx0XHRcdGN0eDpjdHhcblx0XHR9O1xuXHR9O1xuXHR2YXIgQmFyID0gZnVuY3Rpb24oZGF0YSwgY29uZmlnLCBjdHgpIHtcblxuXHRcdHZhciBtYXhTaXplLCBzY2FsZUhvcCwgc2NhbGVIb3AyLCBjYWxjdWxhdGVkU2NhbGUsIGNhbGN1bGF0ZWRTY2FsZTIsIGxhYmVsSGVpZ2h0LCBzY2FsZUhlaWdodCwgdmFsdWVCb3VuZHMsIGxhYmVsVGVtcGxhdGVTdHJpbmcsIGxhYmVsVGVtcGxhdGVTdHJpbmcyLCB2YWx1ZUhvcCwgd2lkZXN0WExhYmVsLCB4QXhpc0xlbmd0aCwgeUF4aXNQb3NYLCB4QXhpc1Bvc1ksIGJhcldpZHRoLCByb3RhdGVMYWJlbHMgPSAwLFxuXHRcdFx0bXNyO1xuXHRcblx0XHRjdHgudHBjaGFydD1cIkJhclwiO1xuXHRcdGN0eC50cGRhdGE9MDtcblxuXHQgICAgICAgIGlmICghaW5pdF9hbmRfc3RhcnQoY3R4LGRhdGEsY29uZmlnKSkgcmV0dXJuO1xuXG5cdFx0dmFyIHN0YXREYXRhPWluaXRQYXNzVmFyaWFibGVEYXRhX3BhcnQxKGRhdGEsY29uZmlnLGN0eCk7XG5cblx0XHR2YXIgbnJPZkJhcnMgPSBkYXRhLmRhdGFzZXRzLmxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChkYXRhLmRhdGFzZXRzW2ldLnR5cGUgPT0gXCJMaW5lXCIpIHsgc3RhdERhdGFbaV1bMF0udHBjaGFydD1cIkxpbmVcIjtuck9mQmFycy0tO31cblx0XHRcdGVsc2Ugc3RhdERhdGFbaV1bMF0udHBjaGFydD1cIkJhclwiO1x0XG5cdFx0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuXG5cdFx0Ly8gY2hhbmdlIHRoZSBvcmRlciAoYXQgZmlyc3QgYWxsIGJhcnMgdGhlbiB0aGUgbGluZXMpIChmb3JtIG9mIEJ1YmJsZVNvcnQpXG5cdFx0dmFyIGJ1ZmZlckRhdGFzZXQsIGwgPSAwO1xuXHRcdFxuXHRcdG1zciA9IHNldE1lYXN1cmVzKGRhdGEsIGNvbmZpZywgY3R4LCBjdHguY2FudmFzLmhlaWdodCwgY3R4LmNhbnZhcy53aWR0aCwgXCJuaWhpbFwiLCBbXCJcIl0sIHRydWUsIGZhbHNlLCB0cnVlLCB0cnVlLCB0cnVlLCBcIkJhclwiKTtcblx0XHR2YWx1ZUJvdW5kcyA9IGdldFZhbHVlQm91bmRzKCk7XG5cdFx0aWYodmFsdWVCb3VuZHMubWluVmFsdWU8PTApY29uZmlnLmxvZ2FyaXRobWljPWZhbHNlO1xuXHRcdGlmKHZhbHVlQm91bmRzLm1heFN0ZXBzPjAgJiYgdmFsdWVCb3VuZHMubWluU3RlcHM+MCkge1xuXHRcdFx0Ly8gdHJ1ZSBvciBmdXp6eSAoZXJyb3IgZm9yIG5lZ2F0aXYgdmFsdWVzIChpbmNsdWRlZCAwKSlcblx0XHRcdGlmIChjb25maWcubG9nYXJpdGhtaWMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmICh2YWx1ZUJvdW5kcy5taW5WYWx1ZSA8PSAwKSB7XG5cdFx0XHRcdFx0Y29uZmlnLmxvZ2FyaXRobWljID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcubG9nYXJpdGhtaWMyICE9PSBmYWxzZSkge1xuXHRcdFx0XHRpZiAodmFsdWVCb3VuZHMubWluVmFsdWUyIDw9IDApIHtcblx0XHRcdFx0XHRjb25maWcubG9nYXJpdGhtaWMyID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIENoZWNrIGlmIGxvZ2FyaXRobWljIGlzIG1lYW5pZ2Z1bFxuXHRcdFx0dmFyIE9yZGVyT2ZNYWduaXR1ZGUgPSBjYWxjdWxhdGVPcmRlck9mTWFnbml0dWRlKE1hdGgucG93KDEwLCBjYWxjdWxhdGVPcmRlck9mTWFnbml0dWRlKHZhbHVlQm91bmRzLm1heFZhbHVlKSArIDEpKSAtIGNhbGN1bGF0ZU9yZGVyT2ZNYWduaXR1ZGUoTWF0aC5wb3coMTAsIGNhbGN1bGF0ZU9yZGVyT2ZNYWduaXR1ZGUodmFsdWVCb3VuZHMubWluVmFsdWUpKSk7XG5cdFx0XHRpZiAoKGNvbmZpZy5sb2dhcml0aG1pYyA9PSAnZnV6enknICYmIE9yZGVyT2ZNYWduaXR1ZGUgPCA0KSB8fCBjb25maWcuc2NhbGVPdmVycmlkZSkge1xuXHRcdFx0XHRjb25maWcubG9nYXJpdGhtaWMgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIENoZWNrIGlmIGxvZ2FyaXRobWljIGlzIG1lYW5pZ2Z1bFxuXHRcdFx0dmFyIE9yZGVyT2ZNYWduaXR1ZGUyID0gY2FsY3VsYXRlT3JkZXJPZk1hZ25pdHVkZShNYXRoLnBvdygxMCwgY2FsY3VsYXRlT3JkZXJPZk1hZ25pdHVkZSh2YWx1ZUJvdW5kcy5tYXhWYWx1ZTIpICsgMSkpIC0gY2FsY3VsYXRlT3JkZXJPZk1hZ25pdHVkZShNYXRoLnBvdygxMCwgY2FsY3VsYXRlT3JkZXJPZk1hZ25pdHVkZSh2YWx1ZUJvdW5kcy5taW5WYWx1ZTIpKSk7XG5cdFx0XHRpZiAoKGNvbmZpZy5sb2dhcml0aG1pYzIgPT0gJ2Z1enp5JyAmJiBPcmRlck9mTWFnbml0dWRlMiA8IDQpIHx8IGNvbmZpZy5zY2FsZU92ZXJyaWRlMikge1xuXHRcdFx0XHRjb25maWcubG9nYXJpdGhtaWMyID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vQ2hlY2sgYW5kIHNldCB0aGUgc2NhbGVcblx0XHRcdGxhYmVsVGVtcGxhdGVTdHJpbmcgPSAoY29uZmlnLnNjYWxlU2hvd0xhYmVscykgPyBjb25maWcuc2NhbGVMYWJlbCA6IFwiXCI7XG5cdFx0XHRsYWJlbFRlbXBsYXRlU3RyaW5nMiA9IChjb25maWcuc2NhbGVTaG93TGFiZWxzMikgPyBjb25maWcuc2NhbGVMYWJlbDIgOiBcIlwiO1xuXHRcdFx0aWYgKCFjb25maWcuc2NhbGVPdmVycmlkZSkge1xuXHRcdFx0XHRjYWxjdWxhdGVkU2NhbGUgPSBjYWxjdWxhdGVTY2FsZSgxLCBjb25maWcsIHZhbHVlQm91bmRzLm1heFN0ZXBzLCB2YWx1ZUJvdW5kcy5taW5TdGVwcywgdmFsdWVCb3VuZHMubWF4VmFsdWUsIHZhbHVlQm91bmRzLm1pblZhbHVlLCBsYWJlbFRlbXBsYXRlU3RyaW5nKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBzY2FsZVN0YXJ0VmFsdWU9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNDQUxFU1RBUlRWQUxVRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuc2NhbGVTdGFydFZhbHVlLFwic2NhbGVTdGFydFZhbHVlXCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdHZhciBzY2FsZVN0ZXBzID1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJTQ0FMRVNURVBTXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5zY2FsZVN0ZXBzLFwic2NhbGVTdGVwc1wiLC0xLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHR2YXIgc2NhbGVTdGVwV2lkdGggPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJTQ0FMRVNURVBXSURUSFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuc2NhbGVTdGVwV2lkdGgsXCJzY2FsZVN0ZXBXaWR0aFwiLC0xLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXG5cdFx0XHRcdGNhbGN1bGF0ZWRTY2FsZSA9IHtcblx0XHRcdFx0XHRzdGVwczogc2NhbGVTdGVwcyxcblx0XHRcdFx0XHRzdGVwVmFsdWU6IHNjYWxlU3RlcFdpZHRoLFxuXHRcdFx0XHRcdGdyYXBoTWluOiBzY2FsZVN0YXJ0VmFsdWUsXG5cdFx0XHRcdFx0Z3JhcGhNYXg6IHNjYWxlU3RhcnRWYWx1ZSArIHNjYWxlU3RlcHMgKiBzY2FsZVN0ZXBXaWR0aCxcblx0XHRcdFx0XHRsYWJlbHM6IFtdXG5cdFx0XHRcdH1cblx0XHRcdFx0cG9wdWxhdGVMYWJlbHMoMSwgY29uZmlnLCBsYWJlbFRlbXBsYXRlU3RyaW5nLCBjYWxjdWxhdGVkU2NhbGUubGFiZWxzLCBjYWxjdWxhdGVkU2NhbGUuc3RlcHMsIHNjYWxlU3RhcnRWYWx1ZSwgY2FsY3VsYXRlZFNjYWxlLmdyYXBoTWF4LCBzY2FsZVN0ZXBXaWR0aCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWVCb3VuZHMuZGJBeGlzKSB7XG5cdFx0XHRcdGlmICghY29uZmlnLnNjYWxlT3ZlcnJpZGUyKSB7XG5cdFx0XHRcdFx0Y2FsY3VsYXRlZFNjYWxlMiA9IGNhbGN1bGF0ZVNjYWxlKDIsIGNvbmZpZywgdmFsdWVCb3VuZHMubWF4U3RlcHMsIHZhbHVlQm91bmRzLm1pblN0ZXBzLCB2YWx1ZUJvdW5kcy5tYXhWYWx1ZTIsIHZhbHVlQm91bmRzLm1pblZhbHVlMiwgbGFiZWxUZW1wbGF0ZVN0cmluZzIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBzY2FsZVN0YXJ0VmFsdWUyPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJTQ0FMRVNUQVJUVkFMVUUyXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5zY2FsZVN0YXJ0VmFsdWUyLFwic2NhbGVTdGFydFZhbHVlMlwiLC0xLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdHZhciBzY2FsZVN0ZXBzMiA9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEVQUzJcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLnNjYWxlU3RlcHMyLFwic2NhbGVTdGVwczJcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHR2YXIgc2NhbGVTdGVwV2lkdGgyID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEVQV0lEVEgyXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5zY2FsZVN0ZXBXaWR0aDIsXCJzY2FsZVN0ZXBXaWR0aDJcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblxuXHRcdFx0XHRcdGNhbGN1bGF0ZWRTY2FsZTIgPSB7XG5cdFx0XHRcdFx0XHRzdGVwczogc2NhbGVTdGVwczIsXG5cdFx0XHRcdFx0XHRzdGVwVmFsdWU6IHNjYWxlU3RlcFdpZHRoMixcblx0XHRcdFx0XHRcdGdyYXBoTWluOiBzY2FsZVN0YXJ0VmFsdWUyLFxuXHRcdFx0XHRcdFx0Z3JhcGhNYXg6IHNjYWxlU3RhcnRWYWx1ZTIgKyBzY2FsZVN0ZXBzMiAqIHNjYWxlU3RlcFdpZHRoMixcblx0XHRcdFx0XHRcdGxhYmVsczogW11cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9wdWxhdGVMYWJlbHMoMiwgY29uZmlnLCBsYWJlbFRlbXBsYXRlU3RyaW5nMiwgY2FsY3VsYXRlZFNjYWxlMi5sYWJlbHMsIGNhbGN1bGF0ZWRTY2FsZTIuc3RlcHMsIHNjYWxlU3RhcnRWYWx1ZTIsIGNhbGN1bGF0ZWRTY2FsZTIuZ3JhcGhNYXgsIHNjYWxlU3RlcFdpZHRoMik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbGN1bGF0ZWRTY2FsZTIgPSB7XG5cdFx0XHRcdFx0c3RlcHM6IDAsXG5cdFx0XHRcdFx0c3RlcFZhbHVlOiAwLFxuXHRcdFx0XHRcdGdyYXBoTWluOiAwLFxuXHRcdFx0XHRcdGdyYXBoTWF4OiAwLFxuXHRcdFx0XHRcdGxhYmVsczogbnVsbFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtc3IgPSBzZXRNZWFzdXJlcyhkYXRhLCBjb25maWcsIGN0eCwgY3R4LmNhbnZhcy5oZWlnaHQsIGN0eC5jYW52YXMud2lkdGgsIGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHMsIGNhbGN1bGF0ZWRTY2FsZTIubGFiZWxzLCB0cnVlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgXCJCYXJcIik7XG5cblx0XHRcdHZhciBwcmV2SGVpZ2h0PW1zci5hdmFpbGFibGVIZWlnaHQ7XG5cblx0XHRcdG1zci5hdmFpbGFibGVIZWlnaHQgPSBtc3IuYXZhaWxhYmxlSGVpZ2h0IC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUJvdHRvbSkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplVG9wKTtcblx0XHRcdG1zci5hdmFpbGFibGVXaWR0aCA9IG1zci5hdmFpbGFibGVXaWR0aCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVMZWZ0KSAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVSaWdodCk7XG5cdFx0XHRzY2FsZUhvcCA9IE1hdGguZmxvb3IobXNyLmF2YWlsYWJsZUhlaWdodCAvIGNhbGN1bGF0ZWRTY2FsZS5zdGVwcyk7XG5cdFx0XHRzY2FsZUhvcDIgPSBNYXRoLmZsb29yKG1zci5hdmFpbGFibGVIZWlnaHQgLyBjYWxjdWxhdGVkU2NhbGUyLnN0ZXBzKTtcblx0XHRcdHZhbHVlSG9wID0gTWF0aC5mbG9vcihtc3IuYXZhaWxhYmxlV2lkdGggLyAoZGF0YS5sYWJlbHMubGVuZ3RoKSk7XG5cdFx0XHRpZiAodmFsdWVIb3AgPT0gMCB8fCBjb25maWcuZnVsbFdpZHRoR3JhcGgpIHZhbHVlSG9wID0gKG1zci5hdmFpbGFibGVXaWR0aCAvIGRhdGEubGFiZWxzLmxlbmd0aCk7XG5cdFx0XHRtc3IuY2xyd2lkdGggPSBtc3IuY2xyd2lkdGggLSAobXNyLmF2YWlsYWJsZVdpZHRoIC0gKChkYXRhLmxhYmVscy5sZW5ndGgpICogdmFsdWVIb3ApKTtcblx0XHRcdG1zci5hdmFpbGFibGVXaWR0aCA9IChkYXRhLmxhYmVscy5sZW5ndGgpICogdmFsdWVIb3A7XG5cdFx0XHRtc3IuYXZhaWxhYmxlSGVpZ2h0ID0gKGNhbGN1bGF0ZWRTY2FsZS5zdGVwcykgKiBzY2FsZUhvcDtcblx0XHRcdG1zci54TGFiZWxQb3MrPShNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplQm90dG9tKSArIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVUb3ApIC0gKHByZXZIZWlnaHQtbXNyLmF2YWlsYWJsZUhlaWdodCkpO1xuXHRcdFx0bXNyLmNscmhlaWdodCs9KE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVCb3R0b20pICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCkgLSAocHJldkhlaWdodC1tc3IuYXZhaWxhYmxlSGVpZ2h0KSk7XG5cblx0XHRcdHlBeGlzUG9zWCA9IG1zci5sZWZ0Tm90VXNhYmxlU2l6ZSArIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVMZWZ0KTtcblx0XHRcdHhBeGlzUG9zWSA9IG1zci50b3BOb3RVc2FibGVTaXplICsgbXNyLmF2YWlsYWJsZUhlaWdodCArIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVUb3ApO1xuXHRcdFx0YmFyV2lkdGggPSAodmFsdWVIb3AgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZUdyaWRMaW5lV2lkdGgpICogMiAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuYmFyVmFsdWVTcGFjaW5nKSAqIDIpIC0gKE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5iYXJEYXRhc2V0U3BhY2luZykgKiBuck9mQmFycyAtIDEpIC0gKChNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5iYXJTdHJva2VXaWR0aCkgLyAyKSAqIG5yT2ZCYXJzIC0gMSkpIC8gbnJPZkJhcnM7XG5cdFx0XHRpZihiYXJXaWR0aD49MCAmJiBiYXJXaWR0aDw9MSliYXJXaWR0aD0xO1xuXHRcdFx0aWYoYmFyV2lkdGg8MCAmJiBiYXJXaWR0aD49LTEpYmFyV2lkdGg9LTE7XG5cdFx0XHR2YXIgYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnM7XG5cdFx0XHRpZigxKmNvbmZpZy5tYXhCYXJXaWR0aCA+MCAmJiBiYXJXaWR0aCA+IDEqY29uZmlnLm1heEJhcldpZHRoKSB7XG5cdFx0XHRcdGFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzPW5yT2ZCYXJzKihiYXJXaWR0aC0xKmNvbmZpZy5tYXhCYXJXaWR0aCkvMjtcblx0XHRcdFx0YmFyV2lkdGg9MSpjb25maWcubWF4QmFyV2lkdGg7XG5cdFx0XHR9IGVsc2UgYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnM9MDtcblxuXHRcdFx0dmFyIHplcm9ZMiA9IDA7XG5cdFx0XHR2YXIgemVyb1kgPSBjYWxjdWxhdGVPZmZzZXQoY29uZmlnLmxvZ2FyaXRobWljLCAwLCBjYWxjdWxhdGVkU2NhbGUsIHNjYWxlSG9wKTtcblx0XHRcdGlmKHR5cGVvZiBjYWxjdWxhdGVkU2NhbGUyID09PVwib2JqZWN0XCIpIHplcm9ZMiA9IGNhbGN1bGF0ZU9mZnNldChjb25maWcubG9nYXJpdGhtaWMyLCAwLCBjYWxjdWxhdGVkU2NhbGUyLCBzY2FsZUhvcDIpO1xuXHRcdFx0aW5pdFBhc3NWYXJpYWJsZURhdGFfcGFydDIoc3RhdERhdGEsZGF0YSxjb25maWcsY3R4LHsgXG5cdFx0XHRcdG1zcjogbXNyLFxuXHRcdFx0XHR5QXhpc1Bvc1ggOiB5QXhpc1Bvc1gsXG5cdFx0XHRcdHhBeGlzUG9zWSA6IHhBeGlzUG9zWSxcblx0XHRcdFx0dmFsdWVIb3AgOiB2YWx1ZUhvcCxcblx0XHRcdFx0bmJWYWx1ZUhvcCA6IGRhdGEubGFiZWxzLmxlbmd0aCAtIDEsXG5cdFx0XHRcdGJhcldpZHRoIDogYmFyV2lkdGgsXG5cdFx0XHRcdGFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzIDogYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnMsXG5cdFx0XHRcdHplcm9ZIDogemVyb1ksXG5cdFx0XHRcdHplcm9ZMiA6IHplcm9ZMixcblx0XHRcdFx0Y2FsY3VsYXRlZFNjYWxlIDogY2FsY3VsYXRlZFNjYWxlLFxuXHRcdFx0XHRjYWxjdWxhdGVkU2NhbGUyIDogY2FsY3VsYXRlZFNjYWxlMixcblx0XHRcdFx0c2NhbGVIb3AgOiBzY2FsZUhvcCxcdFxuXHRcdFx0XHRzY2FsZUhvcDIgOiBzY2FsZUhvcDJcdFxuXHRcdFx0fSk7XG5cdFx0XHRkcmF3TGFiZWxzKCk7XG5cdFx0XHRhbmltYXRpb25Mb29wKGNvbmZpZywgZHJhd1NjYWxlLCBkcmF3QmFycywgY3R4LCBtc3IuY2xyeCwgbXNyLmNscnksIG1zci5jbHJ3aWR0aCwgbXNyLmNscmhlaWdodCwgeUF4aXNQb3NYICsgbXNyLmF2YWlsYWJsZVdpZHRoIC8gMiwgeEF4aXNQb3NZIC0gbXNyLmF2YWlsYWJsZUhlaWdodCAvIDIsIHlBeGlzUG9zWCwgeEF4aXNQb3NZLCBkYXRhLCBzdGF0RGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRlc3RSZWRyYXcoY3R4LGRhdGEsY29uZmlnKTtcblx0XHRcdGN0eC5maXJzdFBhc3M9OTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkcmF3QmFycyhhbmltUGMpIHtcblx0XHRcdHZhciB0MSwgdDIsIHQzO1xuXG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZihkYXRhLmRhdGFzZXRzW2ldLnR5cGU9PVwiTGluZVwiKSBjb250aW51ZTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhLmRhdGFzZXRzW2ldLmRhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGg9TWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJCQVJTVFJPS0VXSURUSFwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uYmFyU3Ryb2tlV2lkdGgsY29uZmlnLmJhclN0cm9rZVdpZHRoLFwiYmFyU3Ryb2tlV2lkdGhcIixpLGose2FuaW1hdGlvblZhbHVlOiBjdXJyZW50QW5pbVBjLCB4UG9zTGVmdCA6IHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0LCB5UG9zQm90dG9tIDogc3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbSwgeFBvc1JpZ2h0IDogc3RhdERhdGFbaV1bal0ueFBvc0xlZnQrYmFyV2lkdGgsIHlQb3NUb3AgOiBzdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tLWJhckhlaWdodH0gKSk7XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoISh0eXBlb2YoZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKSA9PSAndW5kZWZpbmVkJykpIHtcblx0XHRcdFx0XHRcdHZhciBjdXJyZW50QW5pbVBjID0gYW5pbWF0aW9uQ29ycmVjdGlvbihhbmltUGMsIGRhdGEsIGNvbmZpZywgaSwgaiwgZmFsc2UpLmFuaW1WYWw7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudEFuaW1QYyA+IDEpIGN1cnJlbnRBbmltUGMgPSBjdXJyZW50QW5pbVBjIC0gMTtcblx0XHRcdFx0XHRcdHZhciBiYXJIZWlnaHQgPSBjdXJyZW50QW5pbVBjICogKHN0YXREYXRhW2ldW2pdLmJhckhlaWdodCkgKyAoTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuYmFyU3Ryb2tlV2lkdGgpIC8gMik7XG5cdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIkNPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5maWxsQ29sb3IsY29uZmlnLmRlZmF1bHRGaWxsQ29sb3IsXCJmaWxsQ29sb3JcIixpLGose2FuaW1hdGlvblZhbHVlOiBjdXJyZW50QW5pbVBjLCB4UG9zTGVmdCA6IHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0LCB5UG9zQm90dG9tIDogc3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbSwgeFBvc1JpZ2h0IDogc3RhdERhdGFbaV1bal0ueFBvc0xlZnQrYmFyV2lkdGgsIHlQb3NUb3AgOiBzdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tLWJhckhlaWdodH0gKTtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZT1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJTVFJPS0VDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uc3Ryb2tlQ29sb3IsY29uZmlnLmRlZmF1bHRTdHJva2VDb2xvcixcInN0cm9rZUNvbG9yXCIsaSxqLHtudWxsdmFsdWUgOiBudWxsfSApO1xuXHRcdFx0XHRcdFx0cm91bmRSZWN0KGN0eCwgc3RhdERhdGFbaV1bal0ueFBvc0xlZnQsIHN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b20sIGJhcldpZHRoLCBiYXJIZWlnaHQsIGNvbmZpZy5iYXJTaG93U3Ryb2tlLCBjb25maWcuYmFyQm9yZGVyUmFkaXVzLGksaiwoZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdIDwgMCA/IC0xICA6IDEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZHJhd0xpbmVzRGF0YXNldChhbmltUGMsIGRhdGEsIGNvbmZpZywgY3R4LCBzdGF0RGF0YSx7eEF4aXNQb3NZIDogeEF4aXNQb3NZLHlBeGlzUG9zWCA6IHlBeGlzUG9zWCwgdmFsdWVIb3AgOiB2YWx1ZUhvcCwgbmJWYWx1ZUhvcCA6IGRhdGEubGFiZWxzLmxlbmd0aCB9KTtcblxuXHRcdFx0aWYgKGFuaW1QYyA+PSBjb25maWcuYW5pbWF0aW9uU3RvcFZhbHVlKSB7XG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSkgPT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aWYgKGRhdGEuZGF0YXNldHNbaV0udHlwZSA9PSBcIkxpbmVcIikgY29udGludWU7XG5cdFx0XHRcdFx0XHRqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdW2pzR3JhcGhBbm5vdGF0ZVtjdHguQ2hhcnROZXdJZF0ubGVuZ3RoXSA9IFtcIlJFQ1RcIiwgaSAsIGosIHN0YXREYXRhLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkFOTk9UQVRFRElTUExBWVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uYW5ub3RhdGVEaXNwbGF5LGNvbmZpZy5hbm5vdGF0ZURpc3BsYXksXCJhbm5vdGF0ZURpc3BsYXlcIixpLGose251bGxWYWx1ZSA6IHRydWV9KV07XG5cdFx0XHRcdFx0XHRpZihzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVNIT1dcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmluR3JhcGhEYXRhU2hvdyxjb25maWcuaW5HcmFwaERhdGFTaG93LFwiaW5HcmFwaERhdGFTaG93XCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSkpIHtcblx0XHRcdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQWxpZ24sXCJpbkdyYXBoRGF0YUFsaWduXCIsaSxqLHtudWxsVmFsdWU6IHRydWUgIH0pO1xuXHRcdFx0XHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFWQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhVkFsaWduLFwiaW5HcmFwaERhdGFWQWxpZ25cIixpLGose251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdGN0eC5mb250ID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFGT05UU1RZTEVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udFN0eWxlLFwiaW5HcmFwaERhdGFGb250U3R5bGVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgKyAnICcgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFRleHRTY2FsZSxcIklOR1JBUEhEQVRBRk9OVFNJWkVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udFNpemUsXCJpbkdyYXBoRGF0YUZvbnRTaXplXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApICsgJ3B4ICcgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUZPTlRGQU1JTFlcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udEZhbWlseSxcImluR3JhcGhEYXRhRm9udEZhbWlseVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBRk9OVENPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRDb2xvcixcImluR3JhcGhEYXRhRm9udENvbG9yXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHR0MSA9IHN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b207XG5cdFx0XHRcdFx0XHRcdHQyID0gc3RhdERhdGFbaV1bal0ueVBvc1RvcDtcblx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0XHR2YXIgeVBvcyA9IDAsXG5cdFx0XHRcdFx0XHRcdFx0eFBvcyA9IDA7XG5cdFx0XHRcdFx0XHRcdGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVhQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFYUG9zaXRpb24sXCJpbkdyYXBoRGF0YVhQb3NpdGlvblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0eFBvcyA9IHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0ICsgc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiSU5HUkFQSERBVEFQQURESU5HWFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nWCxcImluR3JhcGhEYXRhUGFkZGluZ1hcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFYUE9TSVRJT05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhWFBvc2l0aW9uLFwiaW5HcmFwaERhdGFYUG9zaXRpb25cIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgPT0gMikge1xuXHRcdFx0XHRcdFx0XHRcdHhQb3MgPSBzdGF0RGF0YVtpXVtqXS54UG9zTGVmdCArIGJhcldpZHRoIC8gMiArIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBUEFERElOR1hcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ1gsXCJpbkdyYXBoRGF0YVBhZGRpbmdYXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBWFBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVhQb3NpdGlvbixcImluR3JhcGhEYXRhWFBvc2l0aW9uXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDMpIHtcblx0XHRcdFx0XHRcdFx0XHR4UG9zID0gc3RhdERhdGFbaV1bal0ueFBvc0xlZnQgKyBiYXJXaWR0aCArIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBUEFERElOR1hcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ1gsXCJpbkdyYXBoRGF0YVBhZGRpbmdYXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVlQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFZUG9zaXRpb24sXCJpbkdyYXBoRGF0YVlQb3NpdGlvblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0eVBvcyA9IHN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b20gLSBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQVBBRERJTkdZXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdZLFwiaW5HcmFwaERhdGFQYWRkaW5nWVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVlQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFZUG9zaXRpb24sXCJpbkdyYXBoRGF0YVlQb3NpdGlvblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0eVBvcyA9IChzdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tK3N0YXREYXRhW2ldW2pdLnlQb3NUb3ApLzIgLSBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQVBBRERJTkdZXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdZLFwiaW5HcmFwaERhdGFQYWRkaW5nWVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVlQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFZUG9zaXRpb24sXCJpbkdyYXBoRGF0YVlQb3NpdGlvblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAzKSB7XG5cdFx0XHRcdFx0XHRcdFx0eVBvcyA9IHN0YXREYXRhW2ldW2pdLnlQb3NUb3AgLSBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQVBBRERJTkdZXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdZLFwiaW5HcmFwaERhdGFQYWRkaW5nWVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHhQb3MsIHlQb3MpO1xuXHRcdFx0XHRcdFx0XHR2YXIgZGlzcFN0cmluZyA9IHRtcGxiaXMoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFUTVBMXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVRtcGwsXCJpbkdyYXBoRGF0YVRtcGxcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksIHN0YXREYXRhW2ldW2pdLGNvbmZpZyk7XG5cdFx0XHRcdFx0XHRcdHJvdGF0ZVZhbD1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVJPVEFURVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSb3RhdGUsXCJpbkdyYXBoRGF0YVJvdGF0ZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSAqIChNYXRoLlBJIC8gMTgwKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZShyb3RhdGVWYWwpO1xuXHRcdFx0XHRcdFx0XHRzZXRUZXh0Qm9yZGVyc0FuZEJhY2tncm91bmQoY3R4LGRpc3BTdHJpbmcsc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRUZXh0U2NhbGUsXCJJTkdSQVBIREFUQUZPTlRTSVpFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRTaXplLFwiaW5HcmFwaERhdGFGb250U2l6ZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSwwLDAsc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFCT1JERVJTXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnMsXCJpbkdyYXBoRGF0YUJvcmRlcnNcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFCT1JERVJTQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVyc0NvbG9yLFwiaW5HcmFwaERhdGFCb3JkZXJzQ29sb3JcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRMaW5lU2NhbGUsXCJJTkdSQVBIREFUQUJPUkRFUlNXSURUSFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzV2lkdGgsXCJpbkdyYXBoRGF0YUJvcmRlcnNXaWR0aFwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQUJPUkRFUlNYU1BBQ0VcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVyc1hTcGFjZSxcImluR3JhcGhEYXRhQm9yZGVyc1hTcGFjZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQUJPUkRFUlNZU1BBQ0VcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVyc1lTcGFjZSxcImluR3JhcGhEYXRhQm9yZGVyc1lTcGFjZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJPUkRFUlNTVFlMRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzU3R5bGUsXCJpbkdyYXBoRGF0YUJvcmRlcnNTdHlsZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJBQ0tHUk9VTkRDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCYWNrZ3JvdW5kQ29sb3IsXCJpbkdyYXBoRGF0YUJhY2tncm91bmRDb2xvclwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxcIklOR1JBUEhEQVRBXCIsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVyc1JhZGl1cyk7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShkaXNwU3RyaW5nLCAwLCAwLCBjdHgudGV4dEJhc2VsaW5lLCBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFRleHRTY2FsZSxcIklOR1JBUEhEQVRBRk9OVFNJWkVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udFNpemUsXCJpbkdyYXBoRGF0YUZvbnRTaXplXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHRydWUsY29uZmlnLmRldGVjdE1vdXNlT25UZXh0LGN0eCxcIklOR1JBUEhEQVRBX1RFWFRNT1VTRVwiLHJvdGF0ZVZhbCx4UG9zLCB5UG9zLGksaik7XG5cdFx0XHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoYW5pbVBjID49IDEgJiYgdHlwZW9mIGRyYXdNYXRoID09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRkcmF3TWF0aChjdHgsIGNvbmZpZywgZGF0YSwgbXNyLCB7XG5cdFx0XHRcdFx0eEF4aXNQb3NZOiB4QXhpc1Bvc1ksXG5cdFx0XHRcdFx0eUF4aXNQb3NYOiB5QXhpc1Bvc1gsXG5cdFx0XHRcdFx0dmFsdWVIb3A6IHZhbHVlSG9wLFxuXHRcdFx0XHRcdHNjYWxlSG9wOiBzY2FsZUhvcCxcblx0XHRcdFx0XHR6ZXJvWTogemVyb1ksXG5cdFx0XHRcdFx0Y2FsY3VsYXRlZFNjYWxlOiBjYWxjdWxhdGVkU2NhbGUsXG5cdFx0XHRcdFx0Y2FsY3VsYXRlT2Zmc2V0OiBjYWxjdWxhdGVPZmZzZXQsXG5cdFx0XHRcdFx0YWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnMgOiBhZGRpdGlvbmFsU3BhY2VCZXR3ZWVuQmFycyxcblx0XHRcdFx0XHRiYXJXaWR0aDogYmFyV2lkdGhcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRpZihtc3IubGVnZW5kTXNyLmRpc3BMZWdlbmQpZHJhd0xlZ2VuZChtc3IubGVnZW5kTXNyLGRhdGEsY29uZmlnLGN0eCxcIkJhclwiKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcm91bmRSZWN0KGN0eCwgeCwgeSwgdywgaCwgc3Ryb2tlLCByYWRpdXMsaSxqLGZhY3QpIHtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJTVFJPS0VTVFlMRVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uZGF0YXNldFN0cm9rZVN0eWxlLGNvbmZpZy5kYXRhc2V0U3Ryb2tlU3R5bGUsXCJkYXRhc2V0U3Ryb2tlU3R5bGVcIixpLGose251bGx2YWx1ZSA6IG51bGx9ICkpKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCArICh3LzIpLCB5KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHcgLCB5KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHcsIHkgLSBoICsgZmFjdCpyYWRpdXMpO1xuXHRcdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHcsIHkgLSBoLCB4ICsgdyAtIHJhZGl1cywgeSAtIGgpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5IC0gaCk7XG5cdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5IC0gaCwgeCwgeSAtIGggKyBmYWN0KnJhZGl1cyk7XG5cdFx0XHRjdHgubGluZVRvKHgsIHkpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgKHcvMiksIHkpO1xuXHRcdFx0aWYgKHN0cm9rZSkgY3R4LnN0cm9rZSgpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGRyYXdTY2FsZSgpIHtcblx0XHRcdC8vWCBheGlzIGxpbmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVMaW5lV2lkdGgpO1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY29uZmlnLnNjYWxlTGluZUNvbG9yO1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGNvbmZpZy5zY2FsZUxpbmVTdHlsZSkpO1xuXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHlBeGlzUG9zWCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVMZWZ0KSwgeEF4aXNQb3NZKTtcblx0XHRcdGN0eC5saW5lVG8oeUF4aXNQb3NYICsgbXNyLmF2YWlsYWJsZVdpZHRoICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVJpZ2h0KSwgeEF4aXNQb3NZKTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihjb25maWcuc2NhbGVHcmlkTGluZVN0eWxlKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4Lm1vdmVUbyh5QXhpc1Bvc1ggKyBpICogdmFsdWVIb3AsIHhBeGlzUG9zWSArIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVCb3R0b20pKTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlR3JpZExpbmVXaWR0aCk7XG5cdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5zY2FsZUdyaWRMaW5lQ29sb3I7XG5cdFx0XHRcdC8vQ2hlY2sgaSBpc250IDAsIHNvIHdlIGRvbnQgZ28gb3ZlciB0aGUgWSBheGlzIHR3aWNlLlxuXHRcdFx0XHRpZiAoY29uZmlnLnNjYWxlU2hvd0dyaWRMaW5lcyAmJiBpID4gMCAmJiBpICUgY29uZmlnLnNjYWxlWEdyaWRMaW5lc1N0ZXAgPT0gMCkge1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeUF4aXNQb3NYICsgaSAqIHZhbHVlSG9wLCB4QXhpc1Bvc1kgLSBtc3IuYXZhaWxhYmxlSGVpZ2h0IC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeUF4aXNQb3NYICsgaSAqIHZhbHVlSG9wLCB4QXhpc1Bvc1kpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdH1cblx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcblx0XHRcdC8vWSBheGlzXG5cdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVMaW5lV2lkdGgpO1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY29uZmlnLnNjYWxlTGluZUNvbG9yO1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGNvbmZpZy5zY2FsZUxpbmVTdHlsZSkpO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh5QXhpc1Bvc1gsIHhBeGlzUG9zWSArIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVCb3R0b20pKTtcblx0XHRcdGN0eC5saW5lVG8oeUF4aXNQb3NYLCB4QXhpc1Bvc1kgLSBtc3IuYXZhaWxhYmxlSGVpZ2h0IC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCkpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFxuXHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGNvbmZpZy5zY2FsZUdyaWRMaW5lU3R5bGUpKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgY2FsY3VsYXRlZFNjYWxlLnN0ZXBzOyBqKyspIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHlBeGlzUG9zWCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVMZWZ0KSwgeEF4aXNQb3NZIC0gKChqICsgMSkgKiBzY2FsZUhvcCkpO1xuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVHcmlkTGluZVdpZHRoKTtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY29uZmlnLnNjYWxlR3JpZExpbmVDb2xvcjtcblx0XHRcdFx0aWYgKGNvbmZpZy5zY2FsZVNob3dHcmlkTGluZXMgJiYgKGorMSkgJSBjb25maWcuc2NhbGVZR3JpZExpbmVzU3RlcCA9PSAwKSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh5QXhpc1Bvc1ggKyBtc3IuYXZhaWxhYmxlV2lkdGggKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplUmlnaHQpLCB4QXhpc1Bvc1kgLSAoKGogKyAxKSAqIHNjYWxlSG9wKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh5QXhpc1Bvc1gsIHhBeGlzUG9zWSAtICgoaiArIDEpICogc2NhbGVIb3ApKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHR9XG5cdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBkcmF3TGFiZWxzKCkge1xuXHRcdFx0Y3R4LmZvbnQgPSBjb25maWcuc2NhbGVGb250U3R5bGUgKyBcIiBcIiArIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSkudG9TdHJpbmcoKSArIFwicHggXCIgKyBjb25maWcuc2NhbGVGb250RmFtaWx5O1xuXHRcdFx0Ly9YIGF4aXMgbGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblx0XHRcdGlmIChjb25maWcueEF4aXNUb3AgfHwgY29uZmlnLnhBeGlzQm90dG9tKSB7XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuXHRcdFx0XHRpZiAobXNyLnJvdGF0ZUxhYmVscyA+IDkwKSB7XG5cdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAobXNyLnJvdGF0ZUxhYmVscyA+IDApIHtcblx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5zY2FsZUZvbnRDb2xvcjtcblx0XHRcdFx0aWYgKGNvbmZpZy54QXhpc0JvdHRvbSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sYWJlbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmKHNob3dMYWJlbHMoY3R4LGRhdGEsY29uZmlnLGkpKXtcblx0XHRcdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRcdFx0aWYgKG1zci5yb3RhdGVMYWJlbHMgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh5QXhpc1Bvc1ggKyBpICogdmFsdWVIb3AgKyAodmFsdWVIb3AgLyAyKSAtIG1zci5oaWdoZXN0WExhYmVsIC8gMiwgbXNyLnhMYWJlbFBvcyk7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZSgtKG1zci5yb3RhdGVMYWJlbHMgKiAoTWF0aC5QSSAvIDE4MCkpKTtcblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbFRleHRNdWx0aUxpbmUoZm10Q2hhcnRKUyhjb25maWcsIGRhdGEubGFiZWxzW2ldLCBjb25maWcuZm10WExhYmVsKSwgMCwgMCwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJYQVhJU19URVhUTU9VU0VcIiwtKG1zci5yb3RhdGVMYWJlbHMgKiAoTWF0aC5QSSAvIDE4MCkpLHlBeGlzUG9zWCArIGkgKiB2YWx1ZUhvcCArICh2YWx1ZUhvcCAvIDIpIC0gbXNyLmhpZ2hlc3RYTGFiZWwgLyAyLCBtc3IueExhYmVsUG9zLGksLTEpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShmbXRDaGFydEpTKGNvbmZpZywgZGF0YS5sYWJlbHNbaV0sIGNvbmZpZy5mbXRYTGFiZWwpLCB5QXhpc1Bvc1ggKyBpICogdmFsdWVIb3AgKyAodmFsdWVIb3AgLyAyKSwgbXNyLnhMYWJlbFBvcywgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJYQVhJU19URVhUTU9VU0VcIiwwLDAsMCxpLC0xKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly9ZIGF4aXNcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcblx0XHRcdGZvciAodmFyIGogPSAoKGNvbmZpZy5zaG93WUF4aXNNaW4pID8gLTEgOiAwKTsgaiA8IGNhbGN1bGF0ZWRTY2FsZS5zdGVwczsgaisrKSB7XG5cdFx0XHRcdGlmIChjb25maWcuc2NhbGVTaG93TGFiZWxzKSB7XG5cdFx0XHRcdFx0aWYoc2hvd1lMYWJlbHMoY3R4LGRhdGEsY29uZmlnLGorMSxjYWxjdWxhdGVkU2NhbGUubGFiZWxzW2orIDFdKSkge1x0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoY29uZmlnLnlBeGlzTGVmdCkge1xuXHRcdFx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJyaWdodFwiO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFRleHRNdWx0aUxpbmUoY2FsY3VsYXRlZFNjYWxlLmxhYmVsc1tqICsgMV0sIHlBeGlzUG9zWCAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplTGVmdCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNTcGFjZVJpZ2h0KSksIHhBeGlzUG9zWSAtICgoaiArIDEpICogc2NhbGVIb3ApLCBjdHgudGV4dEJhc2VsaW5lLCAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpLHRydWUsY29uZmlnLmRldGVjdE1vdXNlT25UZXh0LGN0eCxcIllMRUZUQVhJU19URVhUTU9VU0VcIiwwLDAsMCwtMSxqKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChjb25maWcueUF4aXNSaWdodCAmJiAhdmFsdWVCb3VuZHMuZGJBeGlzKSB7XG5cdFx0XHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHNbaiArIDFdLCB5QXhpc1Bvc1ggKyBtc3IuYXZhaWxhYmxlV2lkdGggKyAoTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVJpZ2h0KSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc1NwYWNlUmlnaHQpKSwgeEF4aXNQb3NZIC0gKChqICsgMSkgKiBzY2FsZUhvcCksIGN0eC50ZXh0QmFzZWxpbmUsIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSksdHJ1ZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiWVJJR0hUQVhJU19URVhUTU9VU0VcIiwwLDAsMCwtMSxqKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcueUF4aXNSaWdodCAmJiB2YWx1ZUJvdW5kcy5kYkF4aXMpIHtcblx0XHRcdFx0Zm9yIChqID0gKChjb25maWcuc2hvd1lBeGlzTWluKSA/IC0xIDogMCk7IGogPCBjYWxjdWxhdGVkU2NhbGUyLnN0ZXBzOyBqKyspIHtcblx0XHRcdFx0XHRpZiAoY29uZmlnLnNjYWxlU2hvd0xhYmVscykge1xuXHRcdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGNhbGN1bGF0ZWRTY2FsZTIubGFiZWxzW2ogKyAxXSwgeUF4aXNQb3NYICsgbXNyLmF2YWlsYWJsZVdpZHRoICsgKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVSaWdodCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNTcGFjZVJpZ2h0KSksIHhBeGlzUG9zWSAtICgoaiArIDEpICogc2NhbGVIb3AyKSwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJZUklHSFRBWElTX1RFWFRNT1VTRVwiLDAsMCwwLC0xLGopO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZUJvdW5kcygpIHtcblx0XHRcdHZhciB1cHBlclZhbHVlID0gLU51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHR2YXIgbG93ZXJWYWx1ZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHR2YXIgdXBwZXJWYWx1ZTIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdHZhciBsb3dlclZhbHVlMiA9IE51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHR2YXIgc2Vjb25kQXhpcyA9IGZhbHNlO1xuXHRcdFx0dmFyIGZpcnN0QXhpcyA9IGZhbHNlO1xuXHRcdFx0dmFyIG1hdGhWYWx1ZUhlaWdodDtcdFx0XHRcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgbWF0aEZjdE5hbWUgPSBkYXRhLmRhdGFzZXRzW2ldLmRyYXdNYXRoRGV2aWF0aW9uO1xuXHRcdFx0XHR2YXIgbWF0aFZhbHVlSGVpZ2h0ID0gMDtcblx0XHRcdFx0aWYgKHR5cGVvZiBldmFsKG1hdGhGY3ROYW1lKSA9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR2YXIgcGFyYW1ldGVyID0ge1xuXHRcdFx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0XHRcdGRhdGFzZXROcjogaVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0bWF0aFZhbHVlSGVpZ2h0VmFsID0gd2luZG93W21hdGhGY3ROYW1lXShwYXJhbWV0ZXIpO1xuXHRcdFx0XHR9IGVsc2UgbWF0aFZhbHVlSGVpZ2h0VmFsPTA7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0aWYodHlwZW9mIG1hdGhWYWx1ZUhlaWdodFZhbD09XCJvYmplY3RcIikgbWF0aFZhbHVlSGVpZ2h0PW1hdGhWYWx1ZUhlaWdodFZhbFtNYXRoLm1pbihtYXRoVmFsdWVIZWlnaHRWYWwubGVuZ3RoLGopXTtcblx0XHRcdFx0XHRlbHNlIG1hdGhWYWx1ZUhlaWdodD1tYXRoVmFsdWVIZWlnaHRWYWw7XG5cdFx0XHRcdFx0aWYodHlwZW9mIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXT09XCJ1bmRlZmluZWRcIiljb250aW51ZTtcblx0XHRcdFx0XHRpZiAoZGF0YS5kYXRhc2V0c1tpXS5heGlzID09IDIpIHtcblx0XHRcdFx0XHRcdHNlY29uZEF4aXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gKyBtYXRoVmFsdWVIZWlnaHQgPiB1cHBlclZhbHVlMikge1xuXHRcdFx0XHRcdFx0XHR1cHBlclZhbHVlMiA9IDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gKyBtYXRoVmFsdWVIZWlnaHQ7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0aWYgKDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gLSBtYXRoVmFsdWVIZWlnaHQgPCBsb3dlclZhbHVlMikge1xuXHRcdFx0XHRcdFx0XHRsb3dlclZhbHVlMiA9IDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gLSBtYXRoVmFsdWVIZWlnaHQ7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaXJzdEF4aXM9dHJ1ZTtcblx0XHRcdFx0XHRcdGlmICgxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdICsgbWF0aFZhbHVlSGVpZ2h0ID4gdXBwZXJWYWx1ZSkge1xuXHRcdFx0XHRcdFx0XHR1cHBlclZhbHVlID0gMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSArIG1hdGhWYWx1ZUhlaWdodDtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRpZiAoMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSAtIG1hdGhWYWx1ZUhlaWdodCA8IGxvd2VyVmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0bG93ZXJWYWx1ZSA9IDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gLSBtYXRoVmFsdWVIZWlnaHQ7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGlmKHVwcGVyVmFsdWU8bG93ZXJWYWx1ZSl7dXBwZXJWYWx1ZT0wO2xvd2VyVmFsdWU9MDt9XG5cdFx0XHRpZiAoTWF0aC5hYnModXBwZXJWYWx1ZSAtIGxvd2VyVmFsdWUpIDwgY29uZmlnLnplcm9WYWx1ZSkge1xuXHRcdFx0XHRpZihNYXRoLmFicyh1cHBlclZhbHVlKTwgY29uZmlnLnplcm9WYWx1ZSkgdXBwZXJWYWx1ZSA9IC45O1xuXHRcdFx0XHRpZih1cHBlclZhbHVlPjApIHtcblx0XHRcdFx0XHR1cHBlclZhbHVlPXVwcGVyVmFsdWUqMS4xO1xuXHRcdFx0XHRcdGxvd2VyVmFsdWU9bG93ZXJWYWx1ZSowLjk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dXBwZXJWYWx1ZT11cHBlclZhbHVlKjAuOTtcblx0XHRcdFx0XHRsb3dlclZhbHVlPWxvd2VyVmFsdWUqMS4xO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZih0eXBlb2YgY29uZmlnLmdyYXBoTWluPT1cImZ1bmN0aW9uXCIpbG93ZXJWYWx1ZT0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiR1JBUEhNSU5cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmdyYXBoTWluLFwiZ3JhcGhNaW5cIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0pXG5cdFx0XHRlbHNlIGlmICghaXNOYU4oY29uZmlnLmdyYXBoTWluKSkgbG93ZXJWYWx1ZSA9IGNvbmZpZy5ncmFwaE1pbjtcblx0XHRcdGlmKHR5cGVvZiBjb25maWcuZ3JhcGhNYXg9PVwiZnVuY3Rpb25cIikgdXBwZXJWYWx1ZT0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiR1JBUEhNQVhcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmdyYXBoTWF4LFwiZ3JhcGhNYXhcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0pXG5cdFx0XHRlbHNlIGlmICghaXNOYU4oY29uZmlnLmdyYXBoTWF4KSkgdXBwZXJWYWx1ZSA9IGNvbmZpZy5ncmFwaE1heDtcblxuXHRcdFx0aWYgKHNlY29uZEF4aXMpIHtcblx0XHRcdFx0aWYodXBwZXJWYWx1ZTI8bG93ZXJWYWx1ZTIpe3VwcGVyVmFsdWUyPTA7bG93ZXJWYWx1ZTI9MDt9XG5cdFx0XHRcdGlmIChNYXRoLmFicyh1cHBlclZhbHVlMiAtIGxvd2VyVmFsdWUyKSA8IGNvbmZpZy56ZXJvVmFsdWUpIHtcblx0XHRcdFx0XHRpZihNYXRoLmFicyh1cHBlclZhbHVlMik8IGNvbmZpZy56ZXJvVmFsdWUpIHVwcGVyVmFsdWUyID0gLjk7XG5cdFx0XHRcdFx0aWYodXBwZXJWYWx1ZTI+MCkge1xuXHRcdFx0XHRcdFx0dXBwZXJWYWx1ZTI9dXBwZXJWYWx1ZTIqMS4xO1xuXHRcdFx0XHRcdFx0bG93ZXJWYWx1ZTI9bG93ZXJWYWx1ZTIqMC45O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR1cHBlclZhbHVlMj11cHBlclZhbHVlMiowLjk7XG5cdFx0XHRcdFx0XHRsb3dlclZhbHVlMj1sb3dlclZhbHVlMioxLjE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHR5cGVvZiBjb25maWcuZ3JhcGhNaW4yPT1cImZ1bmN0aW9uXCIpbG93ZXJWYWx1ZTI9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkdSQVBITUlOXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5ncmFwaE1pbjIsXCJncmFwaE1pbjJcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0pXG5cdFx0XHRcdGVsc2UgaWYgKCFpc05hTihjb25maWcuZ3JhcGhNaW4yKSkgbG93ZXJWYWx1ZTIgPSBjb25maWcuZ3JhcGhNaW4yO1xuXHRcdFx0XHRpZih0eXBlb2YgY29uZmlnLmdyYXBoTWF4Mj09XCJmdW5jdGlvblwiKSB1cHBlclZhbHVlMj0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiR1JBUEhNQVhcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmdyYXBoTWF4MixcImdyYXBoTWF4MlwiLC0xLC0xLHtudWxsVmFsdWUgOiB0cnVlfSlcblx0XHRcdFx0ZWxzZSBpZiAoIWlzTmFOKGNvbmZpZy5ncmFwaE1heDIpKSB1cHBlclZhbHVlMiA9IGNvbmZpZy5ncmFwaE1heDI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWZpcnN0QXhpcyAmJiBzZWNvbmRBeGlzKSB7XG5cdFx0XHRcdHVwcGVyVmFsdWUgPSB1cHBlclZhbHVlMjtcblx0XHRcdFx0bG93ZXJWYWx1ZSA9IGxvd2VyVmFsdWUyO1xuXHRcdFx0fVxuXG5cdFx0XHRsYWJlbEhlaWdodCA9IChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSk7XG5cdFx0XHRzY2FsZUhlaWdodCA9IG1zci5hdmFpbGFibGVIZWlnaHQ7XG5cdFx0XHR2YXIgbWF4U3RlcHMgPSBNYXRoLmZsb29yKChzY2FsZUhlaWdodCAvIChsYWJlbEhlaWdodCAqIDAuNjYpKSk7XG5cdFx0XHR2YXIgbWluU3RlcHMgPSBNYXRoLmZsb29yKChzY2FsZUhlaWdodCAvIGxhYmVsSGVpZ2h0ICogMC41KSk7XG5cdFx0XHRpZih1cHBlclZhbHVlPGxvd2VyVmFsdWUpe2xvd2VyVmFsdWU9dXBwZXJWYWx1ZS0xO31cblx0XHRcdGlmKHVwcGVyVmFsdWUyPGxvd2VyVmFsdWUyKXtsb3dlclZhbHVlMj11cHBlclZhbHVlMi0xO31cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1heFZhbHVlOiB1cHBlclZhbHVlLFxuXHRcdFx0XHRtaW5WYWx1ZTogbG93ZXJWYWx1ZSxcblx0XHRcdFx0bWF4VmFsdWUyOiB1cHBlclZhbHVlMixcblx0XHRcdFx0bWluVmFsdWUyOiBsb3dlclZhbHVlMixcblx0XHRcdFx0ZGJBeGlzOiBzZWNvbmRBeGlzLFxuXHRcdFx0XHRtYXhTdGVwczogbWF4U3RlcHMsXG5cdFx0XHRcdG1pblN0ZXBzOiBtaW5TdGVwc1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGE6ZGF0YSxcblx0XHRcdGNvbmZpZzpjb25maWcsXG5cdFx0XHRjdHg6Y3R4XG5cdFx0fTtcblx0fTtcblxuXHR2YXIgSG9yaXpvbnRhbEJhciA9IGZ1bmN0aW9uKGRhdGEsIGNvbmZpZywgY3R4KSB7XG5cdFx0dmFyIG1heFNpemUsIHNjYWxlSG9wLCBjYWxjdWxhdGVkU2NhbGUsIGxhYmVsSGVpZ2h0LCBzY2FsZUhlaWdodCwgdmFsdWVCb3VuZHMsIGxhYmVsVGVtcGxhdGVTdHJpbmcsIHZhbHVlSG9wLCB3aWRlc3RYTGFiZWwsIHhBeGlzTGVuZ3RoLCB5QXhpc1Bvc1gsIHhBeGlzUG9zWSwgYmFyV2lkdGgsIHJvdGF0ZUxhYmVscyA9IDAsXG5cdFx0XHRtc3I7XG5cdFx0Y3R4LnRwY2hhcnQ9XCJIb3Jpem9udGFsQmFyXCI7XG5cdFx0Y3R4LnRwZGF0YT0wO1xuXG5cdCAgICAgICAgaWYgKCFpbml0X2FuZF9zdGFydChjdHgsZGF0YSxjb25maWcpKSByZXR1cm47XG5cblx0XHRpZiAoY29uZmlnLnJldmVyc2VPcmRlciAmJiB0eXBlb2YgY3R4LnJldmVyc2VkID09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGN0eC5yZXZlcnNlZD10cnVlO1xuXHRcdFx0ZGF0YSA9IHJldmVyc2VEYXRhKGRhdGEpO1xuXHRcdH1cblxuXHRcdHZhciBzdGF0RGF0YT1pbml0UGFzc1ZhcmlhYmxlRGF0YV9wYXJ0MShkYXRhLGNvbmZpZyxjdHgpO1xuXG5cdFx0bXNyID0gc2V0TWVhc3VyZXMoZGF0YSwgY29uZmlnLCBjdHgsIGN0eC5jYW52YXMuaGVpZ2h0LCBjdHguY2FudmFzLndpZHRoLCBcIm5paGlsXCIsIFtcIlwiXSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgXCJTdGFja2VkQmFyXCIpO1xuXHRcdHZhbHVlQm91bmRzID0gZ2V0VmFsdWVCb3VuZHMoKTtcblx0XHRpZih2YWx1ZUJvdW5kcy5taW5WYWx1ZTw9MCljb25maWcubG9nYXJpdGhtaWM9ZmFsc2U7XG5cdFx0aWYodmFsdWVCb3VuZHMubWF4U3RlcHM+MCAmJiB2YWx1ZUJvdW5kcy5taW5TdGVwcz4wKSB7XG5cdFx0XHRpZiAoY29uZmlnLmxvZ2FyaXRobWljICE9PSBmYWxzZSkge1xuXHRcdFx0XHRpZiAodmFsdWVCb3VuZHMubWluVmFsdWUgPD0gMCkge1xuXHRcdFx0XHRcdGNvbmZpZy5sb2dhcml0aG1pYyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvL0NoZWNrIGFuZCBzZXQgdGhlIHNjYWxlXG5cdFx0XHRsYWJlbFRlbXBsYXRlU3RyaW5nID0gKGNvbmZpZy5zY2FsZVNob3dMYWJlbHMpID8gY29uZmlnLnNjYWxlTGFiZWwgOiBcIlwiO1xuXHRcdFx0aWYgKCFjb25maWcuc2NhbGVPdmVycmlkZSkge1xuXHRcdFx0XHRjYWxjdWxhdGVkU2NhbGUgPSBjYWxjdWxhdGVTY2FsZSgxLCBjb25maWcsIHZhbHVlQm91bmRzLm1heFN0ZXBzLCB2YWx1ZUJvdW5kcy5taW5TdGVwcywgdmFsdWVCb3VuZHMubWF4VmFsdWUsIHZhbHVlQm91bmRzLm1pblZhbHVlLCBsYWJlbFRlbXBsYXRlU3RyaW5nKTtcblx0XHRcdFx0bXNyID0gc2V0TWVhc3VyZXMoZGF0YSwgY29uZmlnLCBjdHgsIGN0eC5jYW52YXMuaGVpZ2h0LCBjdHguY2FudmFzLndpZHRoLCBjYWxjdWxhdGVkU2NhbGUubGFiZWxzLCBudWxsLCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlLCBcIkhvcml6b250YWxCYXJcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc2NhbGVTdGFydFZhbHVlPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJTQ0FMRVNUQVJUVkFMVUVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLnNjYWxlU3RhcnRWYWx1ZSxcInNjYWxlU3RhcnRWYWx1ZVwiLC0xLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHR2YXIgc2NhbGVTdGVwcyA9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEVQU1wiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuc2NhbGVTdGVwcyxcInNjYWxlU3RlcHNcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0dmFyIHNjYWxlU3RlcFdpZHRoID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0NBTEVTVEVQV0lEVEhcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLnNjYWxlU3RlcFdpZHRoLFwic2NhbGVTdGVwV2lkdGhcIiwtMSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblxuXHRcdFx0XHRjYWxjdWxhdGVkU2NhbGUgPSB7XG5cdFx0XHRcdFx0c3RlcHM6IHNjYWxlU3RlcHMsXG5cdFx0XHRcdFx0c3RlcFZhbHVlOiBzY2FsZVN0ZXBXaWR0aCxcblx0XHRcdFx0XHRncmFwaE1pbjogc2NhbGVTdGFydFZhbHVlLFxuXHRcdFx0XHRcdGdyYXBoTWF4OiBzY2FsZVN0YXJ0VmFsdWUgKyBzY2FsZVN0ZXBzICogc2NhbGVTdGVwV2lkdGgsXG5cdFx0XHRcdFx0bGFiZWxzOiBbXVxuXHRcdFx0XHR9XG5cdFx0XHRcdHBvcHVsYXRlTGFiZWxzKDEsIGNvbmZpZywgbGFiZWxUZW1wbGF0ZVN0cmluZywgY2FsY3VsYXRlZFNjYWxlLmxhYmVscywgY2FsY3VsYXRlZFNjYWxlLnN0ZXBzLCBzY2FsZVN0YXJ0VmFsdWUsIGNhbGN1bGF0ZWRTY2FsZS5ncmFwaE1heCwgc2NhbGVTdGVwV2lkdGgpO1xuXHRcdFx0XHRtc3IgPSBzZXRNZWFzdXJlcyhkYXRhLCBjb25maWcsIGN0eCwgY3R4LmNhbnZhcy5oZWlnaHQsIGN0eC5jYW52YXMud2lkdGgsIGNhbGN1bGF0ZWRTY2FsZS5sYWJlbHMsIG51bGwsIHRydWUsIHRydWUsIHRydWUsIHRydWUsIHRydWUsIFwiSG9yaXpvbnRhbEJhclwiKTtcblx0XHRcdH1cblx0XHRcdG1zci5hdmFpbGFibGVIZWlnaHQgPSBtc3IuYXZhaWxhYmxlSGVpZ2h0IC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUJvdHRvbSkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplVG9wKTtcblx0XHRcdG1zci5hdmFpbGFibGVXaWR0aCA9IG1zci5hdmFpbGFibGVXaWR0aCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVMZWZ0KSAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVSaWdodCk7XG5cdFx0XHRzY2FsZUhvcCA9IE1hdGguZmxvb3IobXNyLmF2YWlsYWJsZUhlaWdodCAvIGRhdGEubGFiZWxzLmxlbmd0aCk7XG5cdFx0XHR2YWx1ZUhvcCA9IE1hdGguZmxvb3IobXNyLmF2YWlsYWJsZVdpZHRoIC8gKGNhbGN1bGF0ZWRTY2FsZS5zdGVwcykpO1xuXHRcdFx0aWYgKHZhbHVlSG9wID09IDAgfHwgY29uZmlnLmZ1bGxXaWR0aEdyYXBoKSB2YWx1ZUhvcCA9IChtc3IuYXZhaWxhYmxlV2lkdGggLyBjYWxjdWxhdGVkU2NhbGUuc3RlcHMpO1xuXHRcdFx0bXNyLmNscndpZHRoID0gbXNyLmNscndpZHRoIC0gKG1zci5hdmFpbGFibGVXaWR0aCAtIChjYWxjdWxhdGVkU2NhbGUuc3RlcHMgKiB2YWx1ZUhvcCkpO1xuXHRcdFx0bXNyLmF2YWlsYWJsZVdpZHRoID0gKGNhbGN1bGF0ZWRTY2FsZS5zdGVwcykgKiB2YWx1ZUhvcDtcblx0XHRcdG1zci5hdmFpbGFibGVIZWlnaHQgPSAoZGF0YS5sYWJlbHMubGVuZ3RoKSAqIHNjYWxlSG9wO1xuXHRcdFx0eUF4aXNQb3NYID0gbXNyLmxlZnROb3RVc2FibGVTaXplICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUxlZnQpO1xuXHRcdFx0eEF4aXNQb3NZID0gbXNyLnRvcE5vdFVzYWJsZVNpemUgKyBtc3IuYXZhaWxhYmxlSGVpZ2h0ICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZVRvcCk7XG5cdFx0XHRiYXJXaWR0aCA9IChzY2FsZUhvcCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlR3JpZExpbmVXaWR0aCkgKiAyIC0gKE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5iYXJWYWx1ZVNwYWNpbmcpICogMikgLSAoTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmJhckRhdGFzZXRTcGFjaW5nKSAqIGRhdGEuZGF0YXNldHMubGVuZ3RoIC0gMSkgLSAoKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmJhclN0cm9rZVdpZHRoKSAvIDIpICogZGF0YS5kYXRhc2V0cy5sZW5ndGggLSAxKSkgLyBkYXRhLmRhdGFzZXRzLmxlbmd0aDtcblx0XHRcdGlmKGJhcldpZHRoPj0wICYmIGJhcldpZHRoPD0xKWJhcldpZHRoPTE7XG5cdFx0XHRpZihiYXJXaWR0aDwwICYmIGJhcldpZHRoPj0tMSliYXJXaWR0aD0tMTtcblx0XHRcdHZhciBhZGRpdGlvbmFsU3BhY2VCZXR3ZWVuQmFycztcblx0XHRcdGlmKDEqY29uZmlnLm1heEJhcldpZHRoID4wICYmIGJhcldpZHRoID4gMSpjb25maWcubWF4QmFyV2lkdGgpIHtcblx0XHRcdFx0YWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnM9ZGF0YS5kYXRhc2V0cy5sZW5ndGgqKGJhcldpZHRoLTEqY29uZmlnLm1heEJhcldpZHRoKS8yO1xuXHRcdFx0XHRiYXJXaWR0aD0xKmNvbmZpZy5tYXhCYXJXaWR0aDtcblx0XHRcdH0gZWxzZSBhZGRpdGlvbmFsU3BhY2VCZXR3ZWVuQmFycz0wO1xuXG5cdFx0XHR2YXIgemVyb1kgPSAwO1xuXHRcdFx0emVyb1kgPSBjYWxjdWxhdGVPZmZzZXQoY29uZmlnLmxvZ2FyaXRobWljLCAwLCBjYWxjdWxhdGVkU2NhbGUsIHZhbHVlSG9wKTtcblx0XHRcdGRyYXdMYWJlbHMoKTtcblx0XHRcdGluaXRQYXNzVmFyaWFibGVEYXRhX3BhcnQyKHN0YXREYXRhLGRhdGEsY29uZmlnLGN0eCx7IFxuXHRcdFx0XHR5QXhpc1Bvc1ggOiB5QXhpc1Bvc1gsXG5cdFx0XHRcdHhBeGlzUG9zWSA6IHhBeGlzUG9zWSxcblx0XHRcdFx0YmFyV2lkdGggOiBiYXJXaWR0aCxcblx0XHRcdFx0YWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnMgOiBhZGRpdGlvbmFsU3BhY2VCZXR3ZWVuQmFycyxcblx0XHRcdFx0emVyb1kgOiB6ZXJvWSxcblx0XHRcdFx0c2NhbGVIb3AgOiBzY2FsZUhvcCxcblx0XHRcdFx0dmFsdWVIb3AgOiB2YWx1ZUhvcCxcblx0XHRcdFx0Y2FsY3VsYXRlZFNjYWxlIDogY2FsY3VsYXRlZFNjYWxlXG5cdFx0XHR9KTtcblx0XHRcdGFuaW1hdGlvbkxvb3AoY29uZmlnLCBkcmF3U2NhbGUsIGRyYXdCYXJzLCBjdHgsIG1zci5jbHJ4LCBtc3IuY2xyeSwgbXNyLmNscndpZHRoLCBtc3IuY2xyaGVpZ2h0LCB5QXhpc1Bvc1ggKyBtc3IuYXZhaWxhYmxlV2lkdGggLyAyLCB4QXhpc1Bvc1kgLSBtc3IuYXZhaWxhYmxlSGVpZ2h0IC8gMiwgeUF4aXNQb3NYLCB4QXhpc1Bvc1ksIGRhdGEsIHN0YXREYXRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGVzdFJlZHJhdyhjdHgsZGF0YSxjb25maWcpO1xuXHRcdFx0Y3R4LmZpcnN0UGFzcz05O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRyYXdCYXJzKGFuaW1QYykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG4vL1x0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuYmFyU3Ryb2tlV2lkdGgpO1xuY3R4LmxpbmVXaWR0aD1NYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKnNldE9wdGlvblZhbHVlKHRydWUsMSxcIkJBUlNUUk9LRVdJRFRIXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5iYXJTdHJva2VXaWR0aCxjb25maWcuYmFyU3Ryb2tlV2lkdGgsXCJiYXJTdHJva2VXaWR0aFwiLGksaix7YW5pbWF0aW9uVmFsdWU6IGN1cnJlbnRBbmltUGMsIHhQb3NMZWZ0IDogc3RhdERhdGFbaV1bal0ueFBvc0xlZnQsIHlQb3NCb3R0b20gOiBzdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tLCB4UG9zUmlnaHQgOiBzdGF0RGF0YVtpXVtqXS54UG9zTGVmdCtiYXJXaWR0aCwgeVBvc1RvcCA6IHN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b20tYmFySGVpZ2h0fSApKTtcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBjdXJyZW50QW5pbVBjID0gYW5pbWF0aW9uQ29ycmVjdGlvbihhbmltUGMsIGRhdGEsIGNvbmZpZywgaSwgaiwgZmFsc2UpLmFuaW1WYWw7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRBbmltUGMgPiAxKSBjdXJyZW50QW5pbVBjID0gY3VycmVudEFuaW1QYyAtIDE7XG5cdFx0XHRcdFx0dmFyIGJhckhlaWdodCA9IGN1cnJlbnRBbmltUGMgKiBzdGF0RGF0YVtpXVtqXS5iYXJXaWR0aCArIChNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5iYXJTdHJva2VXaWR0aCkgLyAyKTtcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIkNPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5maWxsQ29sb3IsY29uZmlnLmRlZmF1bHRGaWxsQ29sb3IsXCJmaWxsQ29sb3JcIixpLGose2FuaW1hdGlvblZhbHVlOiBjdXJyZW50QW5pbVBjLCB4UG9zTGVmdCA6IHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0LCB5UG9zQm90dG9tIDogc3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbSwgeFBvc1JpZ2h0IDogc3RhdERhdGFbaV1bal0ueFBvc0xlZnQrYmFySGVpZ2h0LCB5UG9zVG9wIDogc3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbX0gKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGU9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU1RST0tFQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLnN0cm9rZUNvbG9yLGNvbmZpZy5kZWZhdWx0U3Ryb2tlQ29sb3IsXCJzdHJva2VDb2xvclwiLGksaix7bnVsbHZhbHVlIDogbnVsbH0gKTtcblxuXHRcdFx0XHRcdGlmICghKHR5cGVvZihkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0pID09ICd1bmRlZmluZWQnKSkge1xuXHRcdFx0XHRcdFx0cm91bmRSZWN0KGN0eCwgc3RhdERhdGFbaV1bal0ueVBvc1RvcCwgc3RhdERhdGFbaV1bal0ueFBvc0xlZnQgLCBiYXJXaWR0aCwgYmFySGVpZ2h0LCBjb25maWcuYmFyU2hvd1N0cm9rZSwgY29uZmlnLmJhckJvcmRlclJhZGl1cywgMCxpLGosKGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA8IDAgPyAtMSAgOiAxKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoYW5pbVBjID49IGNvbmZpZy5hbmltYXRpb25TdG9wVmFsdWUpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSkgPT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0anNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdLmxlbmd0aF0gPSBbXCJSRUNUXCIsIGkgLGogLHN0YXREYXRhLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkFOTk9UQVRFRElTUExBWVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uYW5ub3RhdGVEaXNwbGF5LGNvbmZpZy5hbm5vdGF0ZURpc3BsYXksXCJhbm5vdGF0ZURpc3BsYXlcIixpLGose251bGxWYWx1ZSA6IHRydWV9KV07XG4gICAgICAgICAgICAgICAgICAgICAgIFx0XHRcdFx0aWYoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFTSE9XXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5pbkdyYXBoRGF0YVNob3csY29uZmlnLmluR3JhcGhEYXRhU2hvdyxcImluR3JhcGhEYXRhU2hvd1wiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0pKSAge1xuXHRcdFx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFBTElHTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFBbGlnbixcImluR3JhcGhEYXRhQWxpZ25cIixpLGose251bGxWYWx1ZTogdHJ1ZSAgfSk7XG5cdFx0XHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVZBTElHTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFWQWxpZ24sXCJpbkdyYXBoRGF0YVZBbGlnblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0Y3R4LmZvbnQgPSBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUZPTlRTVFlMRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U3R5bGUsXCJpbkdyYXBoRGF0YUZvbnRTdHlsZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSArICcgJyArIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0VGV4dFNjYWxlLFwiSU5HUkFQSERBVEFGT05UU0laRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U2l6ZSxcImluR3JhcGhEYXRhRm9udFNpemVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgKyAncHggJyArIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBRk9OVEZBTUlMWVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250RmFtaWx5LFwiaW5HcmFwaERhdGFGb250RmFtaWx5XCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFGT05UQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udENvbG9yLFwiaW5HcmFwaERhdGFGb250Q29sb3JcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdFx0dmFyIHlQb3MgPSAwLFxuXHRcdFx0XHRcdFx0XHRcdHhQb3MgPSAwO1xuXHRcdFx0XHRcdFx0XHRpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFZUE9TSVRJT05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhWVBvc2l0aW9uLFwiaW5HcmFwaERhdGFZUG9zaXRpb25cIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgPT0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdHlQb3MgPSBzdGF0RGF0YVtpXVtqXS55UG9zVG9wIC0gc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiSU5HUkFQSERBVEFQQURESU5HWVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nWSxcImluR3JhcGhEYXRhUGFkZGluZ1lcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgKyBiYXJXaWR0aDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVlQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFZUG9zaXRpb24sXCJpbkdyYXBoRGF0YVlQb3NpdGlvblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0eVBvcyA9IHN0YXREYXRhW2ldW2pdLnlQb3NUb3AgKyBiYXJXaWR0aCAvIDIgLSBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQVBBRERJTkdZXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdZLFwiaW5HcmFwaERhdGFQYWRkaW5nWVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVlQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFZUG9zaXRpb24sXCJpbkdyYXBoRGF0YVlQb3NpdGlvblwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAzKSB7XG5cdFx0XHRcdFx0XHRcdFx0eVBvcyA9IHN0YXREYXRhW2ldW2pdLnlQb3NUb3AgLSBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQVBBRERJTkdZXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdZLFwiaW5HcmFwaERhdGFQYWRkaW5nWVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFYUE9TSVRJT05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhWFBvc2l0aW9uLFwiaW5HcmFwaERhdGFYUG9zaXRpb25cIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgPT0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdHhQb3MgPSBzdGF0RGF0YVtpXVtqXS54UG9zTGVmdCArIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBUEFERElOR1hcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ1gsXCJpbkdyYXBoRGF0YVBhZGRpbmdYXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBWFBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVhQb3NpdGlvbixcImluR3JhcGhEYXRhWFBvc2l0aW9uXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDIpIHtcblx0XHRcdFx0XHRcdFx0XHR4UG9zID0gKHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0K3N0YXREYXRhW2ldW2pdLnhQb3NSaWdodCkvMiArIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBUEFERElOR1hcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ1gsXCJpbkdyYXBoRGF0YVBhZGRpbmdYXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBWFBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVhQb3NpdGlvbixcImluR3JhcGhEYXRhWFBvc2l0aW9uXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDMpIHtcblx0XHRcdFx0XHRcdFx0XHR4UG9zID0gc3RhdERhdGFbaV1bal0ueFBvc1JpZ2h0ICsgc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiSU5HUkFQSERBVEFQQURESU5HWFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nWCxcImluR3JhcGhEYXRhUGFkZGluZ1hcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh4UG9zLCB5UG9zKTtcblx0XHRcdFx0XHRcdFx0dmFyIGRpc3BTdHJpbmcgPSB0bXBsYmlzKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBVE1QTFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFUbXBsLFwiaW5HcmFwaERhdGFUbXBsXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLCBzdGF0RGF0YVtpXVtqXSxjb25maWcpO1xuXHRcdFx0XHRcdFx0XHR2YXIgcm90YXRlVmFsPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUk9UQVRFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVJvdGF0ZSxcImluR3JhcGhEYXRhUm90YXRlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApICogKE1hdGguUEkgLyAxODApO1xuXHRcdFx0XHRcdFx0XHRjdHgucm90YXRlKHJvdGF0ZVZhbCk7XG5cdFx0XHRcdFx0XHRcdHNldFRleHRCb3JkZXJzQW5kQmFja2dyb3VuZChjdHgsZGlzcFN0cmluZyxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFRleHRTY2FsZSxcIklOR1JBUEhEQVRBRk9OVFNJWkVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udFNpemUsXCJpbkdyYXBoRGF0YUZvbnRTaXplXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLDAsMCxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJPUkRFUlNcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVycyxcImluR3JhcGhEYXRhQm9yZGVyc1wiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUJPUkRFUlNDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzQ29sb3IsXCJpbkdyYXBoRGF0YUJvcmRlcnNDb2xvclwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSxzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydExpbmVTY2FsZSxcIklOR1JBUEhEQVRBQk9SREVSU1dJRFRIXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNXaWR0aCxcImluR3JhcGhEYXRhQm9yZGVyc1dpZHRoXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBQk9SREVSU1hTUEFDRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzWFNwYWNlLFwiaW5HcmFwaERhdGFCb3JkZXJzWFNwYWNlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0U3BhY2VTY2FsZSxcIklOR1JBUEhEQVRBQk9SREVSU1lTUEFDRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzWVNwYWNlLFwiaW5HcmFwaERhdGFCb3JkZXJzWVNwYWNlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQk9SREVSU1NUWUxFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNTdHlsZSxcImluR3JhcGhEYXRhQm9yZGVyc1N0eWxlXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQkFDS0dST1VORENPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJhY2tncm91bmRDb2xvcixcImluR3JhcGhEYXRhQmFja2dyb3VuZENvbG9yXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLFwiSU5HUkFQSERBVEFcIixjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzUmFkaXVzKTtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGRpc3BTdHJpbmcsIDAsIDAsIGN0eC50ZXh0QmFzZWxpbmUsIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0VGV4dFNjYWxlLFwiSU5HUkFQSERBVEFGT05UU0laRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U2l6ZSxcImluR3JhcGhEYXRhRm9udFNpemVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksdHJ1ZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiSU5HUkFQSERBVEFfVEVYVE1PVVNFXCIscm90YXRlVmFsLHhQb3MsIHlQb3MsaSxqKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKG1zci5sZWdlbmRNc3IuZGlzcExlZ2VuZClkcmF3TGVnZW5kKG1zci5sZWdlbmRNc3IsZGF0YSxjb25maWcsY3R4LFwiSG9yaXpvbnRhbEJhclwiKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcm91bmRSZWN0KGN0eCwgeCwgeSwgdywgaCwgc3Ryb2tlLCByYWRpdXMsIHplcm9ZLGksaixmYWN0KSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHkgKyB6ZXJvWSwgeCApO1xuXHRcdFx0Y3R4LmxpbmVUbyh5ICsgemVyb1ksIHggKyB3KTtcblx0XHRcdGN0eC5saW5lVG8oeSArIGggLSBmYWN0KnJhZGl1cywgeCArIHcpO1xuXHRcdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeSArIGgsIHggKyB3LCB5ICsgaCwgeCArIHcgLSByYWRpdXMpO1xuXHRcdFx0Y3R4LmxpbmVUbyh5ICsgaCwgeCArIHJhZGl1cyk7XG5cdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh5ICsgaCwgeCwgeSArIGggLSBmYWN0KnJhZGl1cywgeCk7XG5cdFx0XHRjdHgubGluZVRvKHkgKyB6ZXJvWSwgeCk7XG5cdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh5ICsgemVyb1ksIHgsIHkgKyB6ZXJvWSwgeCArIHcpO1xuXG5cdFx0XHRpZiAoc3Ryb2tlKSB7IFxuXHRcdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU1RST0tFU1RZTEVcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmRhdGFzZXRTdHJva2VTdHlsZSxjb25maWcuZGF0YXNldFN0cm9rZVN0eWxlLFwiZGF0YXNldFN0cm9rZVN0eWxlXCIsaSxqLHtudWxsdmFsdWUgOiBudWxsfSApKSk7XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdH07XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHguZmlsbCgpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBkcmF3U2NhbGUoKSB7XG5cdFx0XHQvL1ggYXhpcyBsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlTGluZVdpZHRoKTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5zY2FsZUxpbmVDb2xvcjtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihjb25maWcuc2NhbGVMaW5lU3R5bGUpKTtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oeUF4aXNQb3NYIC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUxlZnQpLCB4QXhpc1Bvc1kpO1xuXHRcdFx0Y3R4LmxpbmVUbyh5QXhpc1Bvc1ggKyBtc3IuYXZhaWxhYmxlV2lkdGggKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplUmlnaHQpLCB4QXhpc1Bvc1kpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFxuXHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGNvbmZpZy5zY2FsZUdyaWRMaW5lU3R5bGUpKTtcblx0XHRcdGZvciAodmFyIGkgPSAoKGNvbmZpZy5zaG93WUF4aXNNaW4pID8gLTEgOiAwKTsgaSA8IGNhbGN1bGF0ZWRTY2FsZS5zdGVwczsgaSsrKSB7XG5cdFx0XHRcdGlmIChpID49IDApIHtcblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh5QXhpc1Bvc1ggKyBpICogdmFsdWVIb3AsIHhBeGlzUG9zWSArIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVCb3R0b20pKTtcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVHcmlkTGluZVdpZHRoKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuc2NhbGVHcmlkTGluZUNvbG9yO1xuXHRcdFx0XHRcdC8vQ2hlY2sgaSBpc250IDAsIHNvIHdlIGRvbnQgZ28gb3ZlciB0aGUgWSBheGlzIHR3aWNlLlxuXHRcdFx0XHRcdGlmIChjb25maWcuc2NhbGVTaG93R3JpZExpbmVzICYmIGkgPiAwICYmIGkgJSBjb25maWcuc2NhbGVYR3JpZExpbmVzU3RlcCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKHlBeGlzUG9zWCArIGkgKiB2YWx1ZUhvcCwgeEF4aXNQb3NZIC0gbXNyLmF2YWlsYWJsZUhlaWdodCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVUb3ApKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyh5QXhpc1Bvc1ggKyBpICogdmFsdWVIb3AsIHhBeGlzUG9zWSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0Ly9ZIGF4aXNcblx0XHRcdGN0eC5saW5lV2lkdGggPSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZUxpbmVXaWR0aCk7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuc2NhbGVMaW5lQ29sb3I7XG5cdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oY29uZmlnLnNjYWxlTGluZVN0eWxlKSk7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHlBeGlzUG9zWCwgeEF4aXNQb3NZICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVUaWNrU2l6ZUJvdHRvbSkpO1xuXHRcdFx0Y3R4LmxpbmVUbyh5QXhpc1Bvc1gsIHhBeGlzUG9zWSAtIG1zci5hdmFpbGFibGVIZWlnaHQgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplVG9wKSk7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGNvbmZpZy5zY2FsZUdyaWRMaW5lU3R5bGUpKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5sYWJlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHlBeGlzUG9zWCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVMZWZ0KSwgeEF4aXNQb3NZIC0gKChqICsgMSkgKiBzY2FsZUhvcCkpO1xuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuc2NhbGVHcmlkTGluZVdpZHRoKTtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY29uZmlnLnNjYWxlR3JpZExpbmVDb2xvcjtcblx0XHRcdFx0aWYgKGNvbmZpZy5zY2FsZVNob3dHcmlkTGluZXMgJiYgKGorMSkgJSBjb25maWcuc2NhbGVZR3JpZExpbmVzU3RlcCA9PSAwKSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh5QXhpc1Bvc1ggKyBtc3IuYXZhaWxhYmxlV2lkdGggKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplUmlnaHQpLCB4QXhpc1Bvc1kgLSAoKGogKyAxKSAqIHNjYWxlSG9wKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh5QXhpc1Bvc1gsIHhBeGlzUG9zWSAtICgoaiArIDEpICogc2NhbGVIb3ApKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHR9XG5cdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBkcmF3TGFiZWxzKCkge1xuXHRcdFx0Y3R4LmZvbnQgPSBjb25maWcuc2NhbGVGb250U3R5bGUgKyBcIiBcIiArIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSkudG9TdHJpbmcoKSArIFwicHggXCIgKyBjb25maWcuc2NhbGVGb250RmFtaWx5O1xuXHRcdFx0Ly9YIGF4aXMgbGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblx0XHRcdGlmIChjb25maWcuc2NhbGVTaG93TGFiZWxzICYmIChjb25maWcueEF4aXNUb3AgfHwgY29uZmlnLnhBeGlzQm90dG9tKSkge1xuXHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcblx0XHRcdFx0aWYgKG1zci5yb3RhdGVMYWJlbHMgPiA5MCkge1xuXHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1zci5yb3RhdGVMYWJlbHMgPiAwKSB7XG5cdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJyaWdodFwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBjb25maWcuc2NhbGVGb250Q29sb3I7XG5cdFx0XHRcdGlmIChjb25maWcueEF4aXNCb3R0b20pIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gKChjb25maWcuc2hvd1lBeGlzTWluKSA/IC0xIDogMCk7IGkgPCBjYWxjdWxhdGVkU2NhbGUuc3RlcHM7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYoc2hvd1lMYWJlbHMoY3R4LGRhdGEsY29uZmlnLGkrMSxjYWxjdWxhdGVkU2NhbGUubGFiZWxzW2krIDFdKSkge1x0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0XHRcdGlmIChtc3Iucm90YXRlTGFiZWxzID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoeUF4aXNQb3NYICsgKGkgKyAxKSAqIHZhbHVlSG9wIC0gbXNyLmhpZ2hlc3RYTGFiZWwgLyAyLCBtc3IueExhYmVsUG9zKTtcblx0XHRcdFx0XHRcdFx0XHRjdHgucm90YXRlKC0obXNyLnJvdGF0ZUxhYmVscyAqIChNYXRoLlBJIC8gMTgwKSkpO1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShjYWxjdWxhdGVkU2NhbGUubGFiZWxzW2kgKyAxXSwgMCwgMCwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJYQVhJU19URVhUTU9VU0VcIiwtKG1zci5yb3RhdGVMYWJlbHMgKiAoTWF0aC5QSSAvIDE4MCkpLHlBeGlzUG9zWCArIChpICsgMSkgKiB2YWx1ZUhvcCAtIG1zci5oaWdoZXN0WExhYmVsIC8gMiwgbXNyLnhMYWJlbFBvcyxpLC0xKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbFRleHRNdWx0aUxpbmUoY2FsY3VsYXRlZFNjYWxlLmxhYmVsc1tpICsgMV0sIHlBeGlzUG9zWCArIChpICsgMSkgKiB2YWx1ZUhvcCwgbXNyLnhMYWJlbFBvcywgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJYQVhJU19URVhUTU9VU0VcIiwwLDAsMCxpLC0xKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly9ZIGF4aXNcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5sYWJlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYoc2hvd0xhYmVscyhjdHgsZGF0YSxjb25maWcsaikpe1xuXHRcdFx0XHRcdGlmIChjb25maWcueUF4aXNMZWZ0KSB7XG5cdFx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJyaWdodFwiO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGZtdENoYXJ0SlMoY29uZmlnLCBkYXRhLmxhYmVsc1tqXSwgY29uZmlnLmZtdFhMYWJlbCksIHlBeGlzUG9zWCAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5zY2FsZVRpY2tTaXplTGVmdCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNTcGFjZVJpZ2h0KSksIHhBeGlzUG9zWSAtIChqICogc2NhbGVIb3ApIC0gc2NhbGVIb3AgLyAyLCBjdHgudGV4dEJhc2VsaW5lLCAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpLHRydWUsY29uZmlnLmRldGVjdE1vdXNlT25UZXh0LGN0eCxcIllMRUZUQVhJU19URVhUTU9VU0VcIiwwLDAsMCwtMSxqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGNvbmZpZy55QXhpc1JpZ2h0KSB7XG5cdFx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG5cdFx0XHRcdFx0XHRjdHguZmlsbFRleHRNdWx0aUxpbmUoZm10Q2hhcnRKUyhjb25maWcsIGRhdGEubGFiZWxzW2pdLCBjb25maWcuZm10WExhYmVsKSwgeUF4aXNQb3NYICsgbXNyLmF2YWlsYWJsZVdpZHRoICsgKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnNjYWxlVGlja1NpemVSaWdodCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNTcGFjZVJpZ2h0KSksIHhBeGlzUG9zWSAtIChqICogc2NhbGVIb3ApIC0gc2NhbGVIb3AgLyAyLCBjdHgudGV4dEJhc2VsaW5lLCAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpLHRydWUsY29uZmlnLmRldGVjdE1vdXNlT25UZXh0LGN0eCxcIllSSUdIVEFYSVNfVEVYVE1PVVNFXCIsMCwwLDAsLTEsaik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFZhbHVlQm91bmRzKCkge1xuXHRcdFx0dmFyIHVwcGVyVmFsdWUgPSAtTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdHZhciBsb3dlclZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGEuZGF0YXNldHNbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal09PVwidW5kZWZpbmVkXCIpY29udGludWU7XG5cdFx0XHRcdFx0aWYgKDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gPiB1cHBlclZhbHVlKSB7XG5cdFx0XHRcdFx0XHR1cHBlclZhbHVlID0gMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gPCBsb3dlclZhbHVlKSB7XG5cdFx0XHRcdFx0XHRsb3dlclZhbHVlID0gMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRpZih1cHBlclZhbHVlPGxvd2VyVmFsdWUpe3VwcGVyVmFsdWU9MDtsb3dlclZhbHVlPTA7fVxuXHRcdFx0aWYgKE1hdGguYWJzKHVwcGVyVmFsdWUgLSBsb3dlclZhbHVlKSA8IGNvbmZpZy56ZXJvVmFsdWUpIHtcblx0XHRcdFx0aWYoTWF0aC5hYnModXBwZXJWYWx1ZSk8IGNvbmZpZy56ZXJvVmFsdWUpIHVwcGVyVmFsdWUgPSAuOTtcblx0XHRcdFx0aWYodXBwZXJWYWx1ZT4wKSB7XG5cdFx0XHRcdFx0dXBwZXJWYWx1ZT11cHBlclZhbHVlKjEuMTtcblx0XHRcdFx0XHRsb3dlclZhbHVlPWxvd2VyVmFsdWUqMC45O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHVwcGVyVmFsdWU9dXBwZXJWYWx1ZSowLjk7XG5cdFx0XHRcdFx0bG93ZXJWYWx1ZT1sb3dlclZhbHVlKjEuMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gQUpPVVQgQ0hBTkdFTUVOVFxuXHRcdFx0aWYodHlwZW9mIGNvbmZpZy5ncmFwaE1pbj09XCJmdW5jdGlvblwiKWxvd2VyVmFsdWU9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkdSQVBITUlOXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5ncmFwaE1pbixcImdyYXBoTWluXCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9KVxuXHRcdFx0ZWxzZSBpZiAoIWlzTmFOKGNvbmZpZy5ncmFwaE1pbikpIGxvd2VyVmFsdWUgPSBjb25maWcuZ3JhcGhNaW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cdFx0XHRpZih0eXBlb2YgY29uZmlnLmdyYXBoTWF4PT1cImZ1bmN0aW9uXCIpIHVwcGVyVmFsdWU9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkdSQVBITUFYXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5ncmFwaE1heCxcImdyYXBoTWF4XCIsLTEsLTEse251bGxWYWx1ZSA6IHRydWV9KVxuXHRcdFx0ZWxzZSBpZiAoIWlzTmFOKGNvbmZpZy5ncmFwaE1heCkpIHVwcGVyVmFsdWUgPSBjb25maWcuZ3JhcGhNYXg7XG5cblx0XHRcdGxhYmVsSGVpZ2h0ID0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKTtcblx0XHRcdHNjYWxlSGVpZ2h0ID0gbXNyLmF2YWlsYWJsZUhlaWdodDtcblxuXHRcdFx0dmFyIG1heFN0ZXBzID0gTWF0aC5mbG9vcigoc2NhbGVIZWlnaHQgLyAobGFiZWxIZWlnaHQgKiAwLjY2KSkpO1xuXHRcdFx0dmFyIG1pblN0ZXBzID0gTWF0aC5mbG9vcigoc2NhbGVIZWlnaHQgLyBsYWJlbEhlaWdodCAqIDAuNSkpO1xuXHRcdFx0aWYodXBwZXJWYWx1ZTxsb3dlclZhbHVlKXtsb3dlclZhbHVlPXVwcGVyVmFsdWUtMTt9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRtYXhWYWx1ZTogdXBwZXJWYWx1ZSxcblx0XHRcdFx0bWluVmFsdWU6IGxvd2VyVmFsdWUsXG5cdFx0XHRcdG1heFN0ZXBzOiBtYXhTdGVwcyxcblx0XHRcdFx0bWluU3RlcHM6IG1pblN0ZXBzXG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGF0YTpkYXRhLFxuXHRcdFx0Y29uZmlnOmNvbmZpZyxcblx0XHRcdGN0eDpjdHhcblx0XHR9O1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChsb2dhcml0aG1pYywgdmFsLCBjYWxjdWxhdGVkU2NhbGUsIHNjYWxlSG9wKSB7XG5cdFx0aWYgKCFsb2dhcml0aG1pYykgeyAvLyBubyBsb2dhcml0aG1pYyBzY2FsZVxuXHRcdFx0dmFyIG91dGVyVmFsdWUgPSBjYWxjdWxhdGVkU2NhbGUuc3RlcHMgKiBjYWxjdWxhdGVkU2NhbGUuc3RlcFZhbHVlO1xuXHRcdFx0dmFyIGFkanVzdGVkVmFsdWUgPSB2YWwgLSBjYWxjdWxhdGVkU2NhbGUuZ3JhcGhNaW47XG5cdFx0XHR2YXIgc2NhbGluZ0ZhY3RvciA9IENhcFZhbHVlKGFkanVzdGVkVmFsdWUgLyBvdXRlclZhbHVlLCAxLCAwKTtcblx0XHRcdHJldHVybiAoc2NhbGVIb3AgKiBjYWxjdWxhdGVkU2NhbGUuc3RlcHMpICogc2NhbGluZ0ZhY3Rvcjtcblx0XHR9IGVsc2UgeyAvLyBsb2dhcml0aG1pYyBzY2FsZVxuLy9cdFx0XHRyZXR1cm4gQ2FwVmFsdWUobG9nMTAodmFsKSAqIHNjYWxlSG9wIC0gY2FsY3VsYXRlT3JkZXJPZk1hZ25pdHVkZShjYWxjdWxhdGVkU2NhbGUuZ3JhcGhNaW4pICogc2NhbGVIb3AsIHVuZGVmaW5lZCwgMCk7XG5cdFx0XHRyZXR1cm4gQ2FwVmFsdWUobG9nMTAodmFsKSAqIHNjYWxlSG9wIC0gbG9nMTAoY2FsY3VsYXRlZFNjYWxlLmdyYXBoTWluKSAqIHNjYWxlSG9wLCB1bmRlZmluZWQsIDApO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBhbmltYXRpb25Mb29wKGNvbmZpZywgZHJhd1NjYWxlLCBkcmF3RGF0YSwgY3R4LCBjbHJ4LCBjbHJ5LCBjbHJ3aWR0aCwgY2xyaGVpZ2h0LCBtaWRQb3NYLCBtaWRQb3NZLCBib3JkZXJYLCBib3JkZXJZLCBkYXRhLCBzdGF0RGF0YSkge1xuXHRcdHZhciBjbnRpdGVyID0gMDtcblx0XHR2YXIgYW5pbWF0aW9uQ291bnQgPSAxO1xuXHRcdHZhciBtdWx0QW5pbSA9IDE7XG5cdFx0aWYgKGNvbmZpZy5hbmltYXRpb25TdGFydFZhbHVlIDwgMCB8fCBjb25maWcuYW5pbWF0aW9uU3RhcnRWYWx1ZSA+IDEpIGNvbmZpZy5hbmltYXRpb24uU3RhcnRWYWx1ZSA9IDA7XG5cdFx0aWYgKGNvbmZpZy5hbmltYXRpb25TdG9wVmFsdWUgPCAwIHx8IGNvbmZpZy5hbmltYXRpb25TdG9wVmFsdWUgPiAxKSBjb25maWcuYW5pbWF0aW9uLlN0b3BWYWx1ZSA9IDE7XG5cdFx0aWYgKGNvbmZpZy5hbmltYXRpb25TdG9wVmFsdWUgPCBjb25maWcuYW5pbWF0aW9uU3RhcnRWYWx1ZSkgY29uZmlnLmFuaW1hdGlvblN0b3BWYWx1ZSA9IGNvbmZpZy5hbmltYXRpb25TdGFydFZhbHVlO1xuXHRcdGlmIChpc0lFKCkgPCA5ICYmIGlzSUUoKSAhPSBmYWxzZSkgY29uZmlnLmFuaW1hdGlvbiA9IGZhbHNlO1xuXHRcdHZhciBhbmltRnJhbWVBbW91bnQgPSAoY29uZmlnLmFuaW1hdGlvbikgPyAxIC8gQ2FwVmFsdWUoY29uZmlnLmFuaW1hdGlvblN0ZXBzLCBOdW1iZXIuTUFYX1ZBTFVFLCAxKSA6IDEsXG5cdFx0XHRlYXNpbmdGdW5jdGlvbiA9IGFuaW1hdGlvbk9wdGlvbnNbY29uZmlnLmFuaW1hdGlvbkVhc2luZ10sXG5cdFx0XHRwZXJjZW50QW5pbUNvbXBsZXRlID0gKGNvbmZpZy5hbmltYXRpb24pID8gMCA6IDE7XG5cdFx0aWYgKGNvbmZpZy5hbmltYXRpb24gJiYgY29uZmlnLmFuaW1hdGlvblN0YXJ0VmFsdWUgPiAwICYmIGNvbmZpZy5hbmltYXRpb25TdGFydFZhbHVlIDw9IDEpIHtcblx0XHRcdHdoaWxlIChwZXJjZW50QW5pbUNvbXBsZXRlIDwgY29uZmlnLmFuaW1hdGlvblN0YXJ0VmFsdWUpIHtcblx0XHRcdFx0Y250aXRlcisrO1xuXHRcdFx0XHRwZXJjZW50QW5pbUNvbXBsZXRlICs9IGFuaW1GcmFtZUFtb3VudDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGJlZ2luQW5pbSA9IGNudGl0ZXI7XG5cdFx0dmFyIGJlZ2luQW5pbVBjdCA9IHBlcmNlbnRBbmltQ29tcGxldGU7XG5cdFx0aWYgKHR5cGVvZiBkcmF3U2NhbGUgIT09IFwiZnVuY3Rpb25cIikgZHJhd1NjYWxlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRpZiAoY29uZmlnLmNsZWFyUmVjdCkge1xuXHRcdFx0aWYoY29uZmlnLmFuaW1hdGlvbkZvcmNlU2V0VGltZU91dClyZXF1ZXN0QW5pbUZyYW1lU2V0VGltZU91dChhbmltTG9vcCk7XG5cdFx0XHRlbHNlIHJlcXVlc3RBbmltRnJhbWUoYW5pbUxvb3ApO1xuXHRcdH0gZWxzZSBhbmltTG9vcCgpO1xuXG5cdFx0ZnVuY3Rpb24gYW5pbWF0ZUZyYW1lKCkge1xuXHRcdFx0dmFyIGVhc2VBZGp1c3RlZEFuaW1hdGlvblBlcmNlbnQgPSAoY29uZmlnLmFuaW1hdGlvbikgPyBDYXBWYWx1ZShlYXNpbmdGdW5jdGlvbihwZXJjZW50QW5pbUNvbXBsZXRlKSwgbnVsbCwgMCkgOiAxO1xuXHRcdFx0aWYgKDEgKiBjbnRpdGVyID49IDEgKiBDYXBWYWx1ZShjb25maWcuYW5pbWF0aW9uU3RlcHMsIE51bWJlci5NQVhfVkFMVUUsIDEpIHx8IGNvbmZpZy5hbmltYXRpb24gPT0gZmFsc2UgfHwgY3R4LmZpcnN0UGFzcyUxMCE9MSkgZWFzZUFkanVzdGVkQW5pbWF0aW9uUGVyY2VudCA9IDE7XG5cdFx0XHRlbHNlIGlmIChlYXNlQWRqdXN0ZWRBbmltYXRpb25QZXJjZW50ID49IDEpIGVhc2VBZGp1c3RlZEFuaW1hdGlvblBlcmNlbnQgPSAwLjk5OTk7XG5cdFx0XHRpZiAoY29uZmlnLmFuaW1hdGlvbiAmJiAhKGlzSUUoKSA8IDkgJiYgaXNJRSgpICE9IGZhbHNlKSAmJiBjb25maWcuY2xlYXJSZWN0KSB7XG5cdFx0XHRcdGN0eC5jbGVhclJlY3QoY2xyeCwgY2xyeSwgY2xyd2lkdGgsIGNscmhlaWdodCk7XG5cdFx0XHR9XG5cdFx0XHRkaXNwQ3Jvc3NJbWFnZShjdHgsIGNvbmZpZywgbWlkUG9zWCwgbWlkUG9zWSwgYm9yZGVyWCwgYm9yZGVyWSwgZmFsc2UsIGRhdGEsIGVhc2VBZGp1c3RlZEFuaW1hdGlvblBlcmNlbnQsIGNudGl0ZXIpO1xuXHRcdFx0ZGlzcENyb3NzVGV4dChjdHgsIGNvbmZpZywgbWlkUG9zWCwgbWlkUG9zWSwgYm9yZGVyWCwgYm9yZGVyWSwgZmFsc2UsIGRhdGEsIGVhc2VBZGp1c3RlZEFuaW1hdGlvblBlcmNlbnQsIGNudGl0ZXIpO1xuXHRcdFx0aWYodHlwZW9mIGNvbmZpZy5iZWZvcmVEcmF3RnVuY3Rpb24gPT0gXCJmdW5jdGlvblwiKSBjb25maWcuYmVmb3JlRHJhd0Z1bmN0aW9uKFwiQkVGT1JFRFJBV0ZVTkNUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsLTEsLTEse2FuaW1hdGlvblZhbHVlIDogZWFzZUFkanVzdGVkQW5pbWF0aW9uUGVyY2VudCwgY250aXRlcjogY250aXRlciwgY29uZmlnIDogY29uZmlnLCBib3JkZXJYIDogYm9yZGVyWCwgYm9yZGVyWSA6IGJvcmRlclksIG1pZFBvc1ggOiBtaWRQb3NYLCBtaWRQb3NZIDogbWlkUG9zWX0pO1xuXHRcdFx0aWYgKGNvbmZpZy5zY2FsZU92ZXJsYXkpIHtcblx0XHRcdFx0ZHJhd0RhdGEoZWFzZUFkanVzdGVkQW5pbWF0aW9uUGVyY2VudCk7XG5cdFx0XHRcdGlmKHR5cGVvZiBjb25maWcuZW5kRHJhd0RhdGFGdW5jdGlvbiA9PSBcImZ1bmN0aW9uXCIpY29uZmlnLmVuZERyYXdEYXRhRnVuY3Rpb24oXCJFTkREQVRBRlVOQ1RJT05cIixjdHgsZGF0YSxzdGF0RGF0YSwtMSwtMSx7YW5pbWF0aW9uVmFsdWUgOiBlYXNlQWRqdXN0ZWRBbmltYXRpb25QZXJjZW50LCBjbnRpdGVyOiBjbnRpdGVyLCBjb25maWcgOiBjb25maWcsIGJvcmRlclggOiBib3JkZXJYLCBib3JkZXJZIDogYm9yZGVyWSwgbWlkUG9zWCA6IG1pZFBvc1gsIG1pZFBvc1kgOiBtaWRQb3NZfSk7XG5cdFx0XHRcdGRyYXdTY2FsZSgpO1xuXHRcdFx0XHRpZih0eXBlb2YgY29uZmlnLmVuZERyYXdTY2FsZUZ1bmN0aW9uID09IFwiZnVuY3Rpb25cIiljb25maWcuZW5kRHJhd1NjYWxlRnVuY3Rpb24oXCJFTkRTQ0FMRUZVTkNUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsLTEsLTEse2FuaW1hdGlvblZhbHVlIDogZWFzZUFkanVzdGVkQW5pbWF0aW9uUGVyY2VudCwgY250aXRlcjogY250aXRlciwgY29uZmlnIDogY29uZmlnLCBib3JkZXJYIDogYm9yZGVyWCwgYm9yZGVyWSA6IGJvcmRlclksIG1pZFBvc1ggOiBtaWRQb3NYLCBtaWRQb3NZIDogbWlkUG9zWX0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZHJhd1NjYWxlKCk7XG5cdFx0XHRcdGlmKHR5cGVvZiBjb25maWcuZW5kRHJhd1NjYWxlRnVuY3Rpb24gPT0gXCJmdW5jdGlvblwiKWNvbmZpZy5lbmREcmF3U2NhbGVGdW5jdGlvbihcIkVORFNDQUxFRlVOQ1RJT05cIixjdHgsZGF0YSxzdGF0RGF0YSwtMSwtMSx7YW5pbWF0aW9uVmFsdWUgOiBlYXNlQWRqdXN0ZWRBbmltYXRpb25QZXJjZW50LCBjbnRpdGVyOiBjbnRpdGVyLCBjb25maWcgOiBjb25maWcsIGJvcmRlclggOiBib3JkZXJYLCBib3JkZXJZIDogYm9yZGVyWSwgbWlkUG9zWCA6IG1pZFBvc1gsIG1pZFBvc1kgOiBtaWRQb3NZfSk7XG5cdFx0XHRcdGRyYXdEYXRhKGVhc2VBZGp1c3RlZEFuaW1hdGlvblBlcmNlbnQpO1xuXHRcdFx0XHRpZih0eXBlb2YgY29uZmlnLmVuZERyYXdEYXRhRnVuY3Rpb24gPT0gXCJmdW5jdGlvblwiKWNvbmZpZy5lbmREcmF3RGF0YUZ1bmN0aW9uKFwiRU5EREFUQUZVTkNUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsLTEsLTEse2FuaW1hdGlvblZhbHVlIDogZWFzZUFkanVzdGVkQW5pbWF0aW9uUGVyY2VudCwgY250aXRlcjogY250aXRlciwgY29uZmlnIDogY29uZmlnLCBib3JkZXJYIDogYm9yZGVyWCwgYm9yZGVyWSA6IGJvcmRlclksIG1pZFBvc1ggOiBtaWRQb3NYLCBtaWRQb3NZIDogbWlkUG9zWX0pO1xuXHRcdFx0fVxuXHRcdFx0ZGlzcENyb3NzSW1hZ2UoY3R4LCBjb25maWcsIG1pZFBvc1gsIG1pZFBvc1ksIGJvcmRlclgsIGJvcmRlclksIHRydWUsIGRhdGEsIGVhc2VBZGp1c3RlZEFuaW1hdGlvblBlcmNlbnQsIGNudGl0ZXIpO1xuXHRcdFx0ZGlzcENyb3NzVGV4dChjdHgsIGNvbmZpZywgbWlkUG9zWCwgbWlkUG9zWSwgYm9yZGVyWCwgYm9yZGVyWSwgdHJ1ZSwgZGF0YSwgZWFzZUFkanVzdGVkQW5pbWF0aW9uUGVyY2VudCwgY250aXRlcik7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGFuaW1Mb29wKCkge1xuXHRcdFx0Ly9XZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBhbmltYXRpb24gaXMgaW5jb21wbGV0ZSAobGVzcyB0aGFuIDEpLCBvciBjb21wbGV0ZSAoMSkuXG5cdFx0XHRjbnRpdGVyICs9IG11bHRBbmltO1xuXHRcdFx0cGVyY2VudEFuaW1Db21wbGV0ZSArPSBtdWx0QW5pbSAqIGFuaW1GcmFtZUFtb3VudDtcblx0XHRcdGlmIChjbnRpdGVyID09IGNvbmZpZy5hbmltYXRpb25TdGVwcyB8fCBjb25maWcuYW5pbWF0aW9uID09IGZhbHNlIHx8IGN0eC5maXJzdFBhc3MlMTAhPTEpIHBlcmNlbnRBbmltQ29tcGxldGUgPSAxO1xuXHRcdFx0ZWxzZSBpZiAocGVyY2VudEFuaW1Db21wbGV0ZSA+PSAxKSBwZXJjZW50QW5pbUNvbXBsZXRlID0gMC45OTk7XG5cdFx0XHRhbmltYXRlRnJhbWUoKTtcblx0XHRcdC8vU3RvcCB0aGUgbG9vcCBjb250aW51aW5nIGZvcmV2ZXJcblx0XHRcdGlmIChtdWx0QW5pbSA9PSAtMSAmJiBjbnRpdGVyIDw9IGJlZ2luQW5pbSkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGNvbmZpZy5vbkFuaW1hdGlvbkNvbXBsZXRlID09IFwiZnVuY3Rpb25cIiAmJiBjdHgucnVuYW5pbWF0aW9uY29tcGxldGVmdW5jdGlvbj09dHJ1ZSkgY29uZmlnLm9uQW5pbWF0aW9uQ29tcGxldGUoY3R4LCBjb25maWcsIGRhdGEsIDAsIGFuaW1hdGlvbkNvdW50ICsgMSxzdGF0RGF0YSk7XG5cdFx0XHRcdG11bHRBbmltID0gMTtcblx0XHRcdFx0aWYoY29uZmlnLmFuaW1hdGlvbkZvcmNlU2V0VGltZU91dClyZXF1ZXN0QW5pbUZyYW1lU2V0VGltZU91dChhbmltTG9vcCk7XG5cdFx0XHRcdGVsc2UgcmVxdWVzdEFuaW1GcmFtZShhbmltTG9vcCk7XG5cdFx0XHR9IGVsc2UgaWYgKHBlcmNlbnRBbmltQ29tcGxldGUgPCBjb25maWcuYW5pbWF0aW9uU3RvcFZhbHVlKSB7XG5cdFx0XHRcdGlmKGNvbmZpZy5hbmltYXRpb25Gb3JjZVNldFRpbWVPdXQpcmVxdWVzdEFuaW1GcmFtZVNldFRpbWVPdXQoYW5pbUxvb3ApO1xuXHRcdFx0XHRlbHNlIHJlcXVlc3RBbmltRnJhbWUoYW5pbUxvb3ApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKChhbmltYXRpb25Db3VudCA8IGNvbmZpZy5hbmltYXRpb25Db3VudCB8fCBjb25maWcuYW5pbWF0aW9uQ291bnQgPT0gMCkgJiYgKGN0eC5maXJzdFBhc3MlMTA9PTEpKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uQ291bnQrKztcblx0XHRcdFx0XHRpZiAoY29uZmlnLmFuaW1hdGlvbkJhY2t3YXJkICYmIG11bHRBbmltID09IDEpIHtcblx0XHRcdFx0XHRcdHBlcmNlbnRBbmltQ29tcGxldGUgLT0gYW5pbUZyYW1lQW1vdW50O1xuXHRcdFx0XHRcdFx0bXVsdEFuaW0gPSAtMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bXVsdEFuaW0gPSAxO1xuXHRcdFx0XHRcdFx0Y250aXRlciA9IGJlZ2luQW5pbSAtIDE7XG5cdFx0XHRcdFx0XHRwZXJjZW50QW5pbUNvbXBsZXRlID0gYmVnaW5BbmltUGN0IC0gYW5pbUZyYW1lQW1vdW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dChhbmltTG9vcCwgY29uZmlnLmFuaW1hdGlvblBhdXNlVGltZSoxMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZighdGVzdFJlZHJhdyhjdHgsZGF0YSxjb25maWcpKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIGNvbmZpZy5vbkFuaW1hdGlvbkNvbXBsZXRlID09IFwiZnVuY3Rpb25cIiAmJiBjdHgucnVuYW5pbWF0aW9uY29tcGxldGVmdW5jdGlvbj09dHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRjb25maWcub25BbmltYXRpb25Db21wbGV0ZShjdHgsIGNvbmZpZywgZGF0YSwgMSwgYW5pbWF0aW9uQ291bnQgKyAxLHN0YXREYXRhKTtcblxuXHRcdFx0XHRcdFx0XHRjdHgucnVuYW5pbWF0aW9uY29tcGxldGVmdW5jdGlvbj1mYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LmZpcnN0UGFzcz05O1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cdC8vRGVjbGFyZSBnbG9iYWwgZnVuY3Rpb25zIHRvIGJlIGNhbGxlZCB3aXRoaW4gdGhpcyBuYW1lc3BhY2UgaGVyZS5cblx0Ly8gc2hpbSBsYXllciB3aXRoIHNldFRpbWVvdXQgZmFsbGJhY2tcblx0dmFyIHJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuXHRcdFx0fTtcblx0fSkoKTtcblx0dmFyIHJlcXVlc3RBbmltRnJhbWVTZXRUaW1lT3V0ID0gKGZ1bmN0aW9uKCkge1xuXHRcdHJldHVyblx0ZnVuY3Rpb24oY2FsbGJhY2spIHsgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7IH07XG5cdH0pKCk7XG5cblxuXHRmdW5jdGlvbiBjYWxjdWxhdGVTY2FsZShheGlzLCBjb25maWcsIG1heFN0ZXBzLCBtaW5TdGVwcywgbWF4VmFsdWUsIG1pblZhbHVlLCBsYWJlbFRlbXBsYXRlU3RyaW5nKSB7XG5cdFx0dmFyIGdyYXBoTWluLCBncmFwaE1heCwgZ3JhcGhSYW5nZSwgc3RlcFZhbHVlLCBudW1iZXJPZlN0ZXBzLCB2YWx1ZVJhbmdlLCByYW5nZU9yZGVyT2ZNYWduaXR1ZGUsIGRlY2ltYWxOdW07XG5cdFx0dmFyIGxvZ2FyaXRobWljLCB5QXhpc01pbmltdW1JbnRlcnZhbDtcblx0XHRpZiAoYXhpcyA9PSAyKSB7XG5cdFx0XHRsb2dhcml0aG1pYyA9IGNvbmZpZy5sb2dhcml0aG1pYzI7XG5cdFx0XHR5QXhpc01pbmltdW1JbnRlcnZhbCA9IGNvbmZpZy55QXhpc01pbmltdW1JbnRlcnZhbDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZ2FyaXRobWljID0gY29uZmlnLmxvZ2FyaXRobWljO1xuXHRcdFx0eUF4aXNNaW5pbXVtSW50ZXJ2YWwgPSBjb25maWcueUF4aXNNaW5pbXVtSW50ZXJ2YWw7XG5cdFx0fVxuXG5cdFx0aWYgKCFsb2dhcml0aG1pYykgeyAvLyBubyBsb2dhcml0aG1pYyBzY2FsZVxuXHRcdFx0dmFsdWVSYW5nZSA9IG1heFZhbHVlIC0gbWluVmFsdWU7XG5cdFx0XHRyYW5nZU9yZGVyT2ZNYWduaXR1ZGUgPSBjYWxjdWxhdGVPcmRlck9mTWFnbml0dWRlKHZhbHVlUmFuZ2UpO1xuXHRcdFx0aWYoTWF0aC5hYnMobWluVmFsdWUpPmNvbmZpZy56ZXJvVmFsdWUpZ3JhcGhNaW4gPSBNYXRoLmZsb29yKG1pblZhbHVlIC8gKDEgKiBNYXRoLnBvdygxMCwgcmFuZ2VPcmRlck9mTWFnbml0dWRlKSkpICogTWF0aC5wb3coMTAsIHJhbmdlT3JkZXJPZk1hZ25pdHVkZSk7XG5cdFx0XHRlbHNlIGdyYXBoTWluPTA7XG5cdFx0XHRpZihNYXRoLmFicyhtYXhWYWx1ZSk+Y29uZmlnLnplcm9WYWx1ZSlncmFwaE1heCA9IE1hdGguY2VpbChtYXhWYWx1ZSAvICgxICogTWF0aC5wb3coMTAsIHJhbmdlT3JkZXJPZk1hZ25pdHVkZSkpKSAqIE1hdGgucG93KDEwLCByYW5nZU9yZGVyT2ZNYWduaXR1ZGUpO1xuXHRcdFx0ZWxzZSBncmFwaE1heD0wO1xuXHRcdFx0aWYgKHR5cGVvZiB5QXhpc01pbmltdW1JbnRlcnZhbCA9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdGlmKGdyYXBoTWF4Pj0wKSB7XG5cdFx0XHRcdFx0Z3JhcGhNaW4gPSBncmFwaE1pbiAtIChncmFwaE1pbiAlIHlBeGlzTWluaW11bUludGVydmFsKTtcblx0XHRcdFx0XHR3aGlsZSAoZ3JhcGhNaW4gPiBtaW5WYWx1ZSkgZ3JhcGhNaW4gPSBncmFwaE1pbiAtIHlBeGlzTWluaW11bUludGVydmFsO1xuXHRcdFx0XHRcdGlmIChncmFwaE1heCAlIHlBeGlzTWluaW11bUludGVydmFsID4gY29uZmlnLnplcm9WYWx1ZSAmJiBncmFwaE1heCAlIHlBeGlzTWluaW11bUludGVydmFsIDwgeUF4aXNNaW5pbXVtSW50ZXJ2YWwgLSBjb25maWcuemVyb1ZhbHVlKSB7XG5cdFx0XHRcdFx0XHRncmFwaE1heCA9IHJvdW5kU2NhbGUoY29uZmlnLCAoMSArIE1hdGguZmxvb3IoZ3JhcGhNYXggLyB5QXhpc01pbmltdW1JbnRlcnZhbCkpICogeUF4aXNNaW5pbXVtSW50ZXJ2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoZ3JhcGhNYXggPCBtYXhWYWx1ZSkgZ3JhcGhNYXggPSBncmFwaE1heCArIHlBeGlzTWluaW11bUludGVydmFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgLy8gbG9nYXJpdGhtaWMgc2NhbGVcblx0XHRcdGlmKG1pblZhbHVlPT1tYXhWYWx1ZSltYXhWYWx1ZT1tYXhWYWx1ZSsxO1xuXHRcdFx0aWYobWluVmFsdWU9PTApbWluVmFsdWU9MC4wMTtcblx0XHRcdHZhciBtaW5NYWcgPSBjYWxjdWxhdGVPcmRlck9mTWFnbml0dWRlKG1pblZhbHVlKTtcblx0XHRcdHZhciBtYXhNYWcgPSBjYWxjdWxhdGVPcmRlck9mTWFnbml0dWRlKG1heFZhbHVlKSArIDE7XG5cdFx0XHRncmFwaE1pbiA9IE1hdGgucG93KDEwLCBtaW5NYWcpO1xuXHRcdFx0Z3JhcGhNYXggPSBNYXRoLnBvdygxMCwgbWF4TWFnKTtcblx0XHRcdHJhbmdlT3JkZXJPZk1hZ25pdHVkZSA9IG1heE1hZyAtIG1pbk1hZztcblx0XHR9XG5cdFx0Z3JhcGhSYW5nZSA9IGdyYXBoTWF4IC0gZ3JhcGhNaW47XG5cdFx0c3RlcFZhbHVlID0gTWF0aC5wb3coMTAsIHJhbmdlT3JkZXJPZk1hZ25pdHVkZSk7XG5cdFx0bnVtYmVyT2ZTdGVwcyA9IE1hdGgucm91bmQoZ3JhcGhSYW5nZSAvIHN0ZXBWYWx1ZSk7XG5cdFx0aWYgKCFsb2dhcml0aG1pYykgeyAvLyBubyBsb2dhcml0aG1pYyBzY2FsZVxuXHRcdFx0Ly9Db21wYXJlIG51bWJlciBvZiBzdGVwcyB0byB0aGUgbWF4IGFuZCBtaW4gZm9yIHRoYXQgc2l6ZSBncmFwaCwgYW5kIGFkZCBpbiBoYWxmIHN0ZXBzIGlmIG5lZWQgYmUuXG5cdFx0XHR2YXIgc3RvcExvb3AgPSBmYWxzZTtcblx0XHRcdHdoaWxlICghc3RvcExvb3AgJiYgKG51bWJlck9mU3RlcHMgPCBtaW5TdGVwcyB8fCBudW1iZXJPZlN0ZXBzID4gbWF4U3RlcHMpKSB7XG5cdFx0XHRcdGlmIChudW1iZXJPZlN0ZXBzIDwgbWluU3RlcHMpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIHlBeGlzTWluaW11bUludGVydmFsID09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRcdGlmIChzdGVwVmFsdWUgLyAyIDwgeUF4aXNNaW5pbXVtSW50ZXJ2YWwpIHtcblx0XHRcdFx0XHRcdFx0c3RvcExvb3AgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRzdGVwVmFsdWU9eUF4aXNNaW5pbXVtSW50ZXJ2YWw7XG5cdFx0XHRcdFx0XHRcdG51bWJlck9mU3RlcHM9TWF0aC5jZWlsKGdyYXBoUmFuZ2UgLyBzdGVwVmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXN0b3BMb29wKSB7XG5cdFx0XHRcdFx0XHRzdGVwVmFsdWUgLz0yO1xuXHRcdFx0XHRcdFx0bnVtYmVyT2ZTdGVwcyA9IE1hdGgucm91bmQoZ3JhcGhSYW5nZSAvIHN0ZXBWYWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0ZXBWYWx1ZSAqPSAyO1xuXHRcdFx0XHRcdG51bWJlck9mU3RlcHMgPSBNYXRoLnJvdW5kKGdyYXBoUmFuZ2UgLyBzdGVwVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIHlBeGlzTWluaW11bUludGVydmFsID09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0aWYgKHN0ZXBWYWx1ZSA8IHlBeGlzTWluaW11bUludGVydmFsKSB7XG5cdFx0XHRcdFx0c3RlcFZhbHVlID0geUF4aXNNaW5pbXVtSW50ZXJ2YWw7XG5cdFx0XHRcdFx0bnVtYmVyT2ZTdGVwcyA9IE1hdGguY2VpbChncmFwaFJhbmdlIC8gc3RlcFZhbHVlKTtcblx0XHRcdFx0fSBcblx0XHRcdFx0aWYgKHN0ZXBWYWx1ZSAlIHlBeGlzTWluaW11bUludGVydmFsID4gY29uZmlnLnplcm9WYWx1ZSAmJiBzdGVwVmFsdWUgJSB5QXhpc01pbmltdW1JbnRlcnZhbCA8IHlBeGlzTWluaW11bUludGVydmFsIC0gY29uZmlnLnplcm9WYWx1ZSkge1xuXHRcdFx0XHRcdGlmICgoMiAqIHN0ZXBWYWx1ZSkgJSB5QXhpc01pbmltdW1JbnRlcnZhbCA8IGNvbmZpZy56ZXJvVmFsdWUgfHwgKDIgKiBzdGVwVmFsdWUpICUgeUF4aXNNaW5pbXVtSW50ZXJ2YWwgPiB5QXhpc01pbmltdW1JbnRlcnZhbCAtIGNvbmZpZy56ZXJvVmFsdWUpIHtcblx0XHRcdFx0XHRcdHN0ZXBWYWx1ZSA9IDIgKiBzdGVwVmFsdWU7XG5cdFx0XHRcdFx0XHRudW1iZXJPZlN0ZXBzID0gTWF0aC5jZWlsKGdyYXBoUmFuZ2UgLyBzdGVwVmFsdWUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGVwVmFsdWUgPSByb3VuZFNjYWxlKGNvbmZpZywgKDEgKyBNYXRoLmZsb29yKHN0ZXBWYWx1ZSAvIHlBeGlzTWluaW11bUludGVydmFsKSkgKiB5QXhpc01pbmltdW1JbnRlcnZhbCk7XG5cdFx0XHRcdFx0XHRudW1iZXJPZlN0ZXBzID0gTWF0aC5jZWlsKGdyYXBoUmFuZ2UgLyBzdGVwVmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoY29uZmlnLmdyYXBoTWF4aW1pemVkPT10cnVlIHx8IGNvbmZpZy5ncmFwaE1heGltaXplZD09XCJib3R0b21cIiB8fCB0eXBlb2YgY29uZmlnLmdyYXBoTWluIT09XCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHR3aGlsZSAoZ3JhcGhNaW4rc3RlcFZhbHVlIDwgbWluVmFsdWUgJiYgbnVtYmVyT2ZTdGVwcz49Myl7Z3JhcGhNaW4rPXN0ZXBWYWx1ZTtudW1iZXJPZlN0ZXBzLS19O1xuXHRcdFx0fVxuXHRcdFx0aWYoY29uZmlnLmdyYXBoTWF4aW1pemVkPT10cnVlIHx8IGNvbmZpZy5ncmFwaE1heGltaXplZD09XCJ0b3BcIiB8fCB0eXBlb2YgY29uZmlnLmdyYXBoTWF4IT09XCJ1bmRlZmluZWRcIikge1xuXG5cdFx0XHRcdHdoaWxlIChncmFwaE1pbisobnVtYmVyT2ZTdGVwcy0xKSpzdGVwVmFsdWUgPj0gbWF4VmFsdWUgJiYgbnVtYmVyT2ZTdGVwcz49MykgbnVtYmVyT2ZTdGVwcy0tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7IC8vIGxvZ2FyaXRobWljIHNjYWxlXG5cdFx0XHRudW1iZXJPZlN0ZXBzID0gcmFuZ2VPcmRlck9mTWFnbml0dWRlOyAvLyBzbyBzY2FsZSBpcyAxMCwxMDAsMTAwMCwuLi5cblx0XHR9XG5cdFx0dmFyIGxhYmVscyA9IFtdO1xuXHRcdHBvcHVsYXRlTGFiZWxzKDEsIGNvbmZpZywgbGFiZWxUZW1wbGF0ZVN0cmluZywgbGFiZWxzLCBudW1iZXJPZlN0ZXBzLCBncmFwaE1pbiwgZ3JhcGhNYXgsIHN0ZXBWYWx1ZSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0ZXBzOiBudW1iZXJPZlN0ZXBzLFxuXHRcdFx0c3RlcFZhbHVlOiBzdGVwVmFsdWUsXG5cdFx0XHRncmFwaE1pbjogZ3JhcGhNaW4sXG5cdFx0XHRsYWJlbHM6IGxhYmVscyxcblx0XHRcdG1heFZhbHVlOiBtYXhWYWx1ZVxuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiByb3VuZFNjYWxlKGNvbmZpZywgdmFsdWUpIHtcblx0XHR2YXIgc2NsZGVjID0gMDtcblx0XHR2YXIgc3NjbCA9IFwiXCIgKyBjb25maWcueUF4aXNNaW5pbXVtSW50ZXJ2YWw7XG5cdFx0aWYgKHNzY2wuaW5kZXhPZihcIi5cIikgPiAwKSB7XG5cdFx0XHRzY2xkZWMgPSBzc2NsLnN1YnN0cihzc2NsLmluZGV4T2YoXCIuXCIpKS5sZW5ndGg7XG5cdFx0fVxuXHRcdHJldHVybiAoTWF0aC5yb3VuZCh2YWx1ZSAqIE1hdGgucG93KDEwLCBzY2xkZWMpKSAvIE1hdGgucG93KDEwLCBzY2xkZWMpKTtcblx0fSA7XG5cblx0ZnVuY3Rpb24gY2FsY3VsYXRlT3JkZXJPZk1hZ25pdHVkZSh2YWwpIHtcblx0XHRpZiAodmFsPT0wKXJldHVybiAwO1xuXHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMTApO1xuXHR9O1xuXHQvL1BvcHVsYXRlIGFuIGFycmF5IG9mIGFsbCB0aGUgbGFiZWxzIGJ5IGludGVycG9sYXRpbmcgdGhlIHN0cmluZy5cblx0ZnVuY3Rpb24gcG9wdWxhdGVMYWJlbHMoYXhpcywgY29uZmlnLCBsYWJlbFRlbXBsYXRlU3RyaW5nLCBsYWJlbHMsIG51bWJlck9mU3RlcHMsIGdyYXBoTWluLCBncmFwaE1heCwgc3RlcFZhbHVlKSB7XG5cdFx0dmFyIGxvZ2FyaXRobWljO1xuXHRcdGlmIChheGlzID09IDIpIHtcblx0XHRcdGxvZ2FyaXRobWljID0gY29uZmlnLmxvZ2FyaXRobWljMjtcblx0XHRcdGZtdFlMYWJlbCA9IGNvbmZpZy5mbXRZTGFiZWwyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2dhcml0aG1pYyA9IGNvbmZpZy5sb2dhcml0aG1pYztcblx0XHRcdGZtdFlMYWJlbCA9IGNvbmZpZy5mbXRZTGFiZWw7XG5cdFx0fVxuXHRcdGlmIChsYWJlbFRlbXBsYXRlU3RyaW5nKSB7XG5cdFx0XHQvL0ZpeCBmbG9hdGluZyBwb2ludCBlcnJvcnMgYnkgc2V0dGluZyB0byBmaXhlZCB0aGUgb24gdGhlIHNhbWUgZGVjaW1hbCBhcyB0aGUgc3RlcFZhbHVlLlxuXHRcdFx0dmFyIGk7XG5cdFx0XHRpZiAoIWxvZ2FyaXRobWljKSB7IC8vIG5vIGxvZ2FyaXRobWljIHNjYWxlXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBudW1iZXJPZlN0ZXBzICsgMTsgaSsrKSB7XG5cdFx0XHRcdFx0bGFiZWxzLnB1c2godG1wbChsYWJlbFRlbXBsYXRlU3RyaW5nLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogZm10Q2hhcnRKUyhjb25maWcsIDEgKiAoKGdyYXBoTWluICsgKHN0ZXBWYWx1ZSAqIGkpKS50b0ZpeGVkKGdldERlY2ltYWxQbGFjZXMoc3RlcFZhbHVlKSkpLCBmbXRZTGFiZWwpXG5cdFx0XHRcdFx0fSxjb25maWcpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHsgLy8gbG9nYXJpdGhtaWMgc2NhbGUgMTAsMTAwLDEwMDAsLi4uXG5cdFx0XHRcdHZhciB2YWx1ZSA9IGdyYXBoTWluO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbnVtYmVyT2ZTdGVwcyArIDE7IGkrKykge1xuXHRcdFx0XHRcdGxhYmVscy5wdXNoKHRtcGwobGFiZWxUZW1wbGF0ZVN0cmluZywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IGZtdENoYXJ0SlMoY29uZmlnLCAxICogdmFsdWUudG9GaXhlZChnZXREZWNpbWFsUGxhY2VzKHZhbHVlKSksIGZtdFlMYWJlbClcblx0XHRcdFx0XHR9LGNvbmZpZykpO1xuXHRcdFx0XHRcdHZhbHVlICo9IDEwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHQvL01heCB2YWx1ZSBmcm9tIGFycmF5XG5cdGZ1bmN0aW9uIE1heChhcnJheSkge1xuXHRcdHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBhcnJheSk7XG5cdH07XG5cdC8vTWluIHZhbHVlIGZyb20gYXJyYXlcblx0ZnVuY3Rpb24gTWluKGFycmF5KSB7XG5cdFx0cmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIGFycmF5KTtcblx0fTtcblx0Ly9EZWZhdWx0IGlmIHVuZGVmaW5lZFxuXHRmdW5jdGlvbiBEZWZhdWx0KHVzZXJEZWNsYXJlZCwgdmFsdWVJZkZhbHNlKSB7XG5cdFx0aWYgKCF1c2VyRGVjbGFyZWQpIHtcblx0XHRcdHJldHVybiB2YWx1ZUlmRmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB1c2VyRGVjbGFyZWQ7XG5cdFx0fVxuXHR9O1xuXHQvL0FwcGx5IGNhcCBhIHZhbHVlIGF0IGEgaGlnaCBvciBsb3cgbnVtYmVyXG5cdGZ1bmN0aW9uIENhcFZhbHVlKHZhbHVlVG9DYXAsIG1heFZhbHVlLCBtaW5WYWx1ZSkge1xuXHRcdGlmIChpc051bWJlcihtYXhWYWx1ZSkpIHtcblx0XHRcdGlmICh2YWx1ZVRvQ2FwID4gbWF4VmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIG1heFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaXNOdW1iZXIobWluVmFsdWUpKSB7XG5cdFx0XHRpZiAodmFsdWVUb0NhcCA8IG1pblZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiBtaW5WYWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlVG9DYXA7XG5cdH07XG5cblx0ZnVuY3Rpb24gZ2V0RGVjaW1hbFBsYWNlcyhudW0pIHtcblx0XHR2YXIgbWF0Y2ggPSAoJycrbnVtKS5tYXRjaCgvKD86XFwuKFxcZCspKT8oPzpbZUVdKFsrLV0/XFxkKykpPyQvKTtcblx0XHRpZiAoIW1hdGNoKSB7IFxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdDAsXG5cdFx0XHQobWF0Y2hbMV0gPyBtYXRjaFsxXS5sZW5ndGggOiAwKSAtIChtYXRjaFsyXSA/ICttYXRjaFsyXSA6IDApXG5cdFx0KTtcblx0fTtcblxuXHRmdW5jdGlvbiBtZXJnZUNoYXJ0Q29uZmlnKGRlZmF1bHRzLCB1c2VyRGVmaW5lZCkge1xuXHRcdHZhciByZXR1cm5PYmogPSB7fTtcblx0XHRmb3IgKHZhciBhdHRybmFtZSBpbiBkZWZhdWx0cykge1xuXHRcdFx0cmV0dXJuT2JqW2F0dHJuYW1lXSA9IGRlZmF1bHRzW2F0dHJuYW1lXTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgYXR0cm5hbWVCaXMgaW4gdXNlckRlZmluZWQpIHtcblx0XHRcdHJldHVybk9ialthdHRybmFtZUJpc10gPSB1c2VyRGVmaW5lZFthdHRybmFtZUJpc107XG5cdFx0fVxuXHRcdHJldHVybiByZXR1cm5PYmo7XG5cdH07XG5cdC8vSmF2YXNjcmlwdCBtaWNybyB0ZW1wbGF0aW5nIGJ5IEpvaG4gUmVzaWcgLSBzb3VyY2UgYXQgaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy9cblx0dmFyIGNhY2hlID0ge307XG5cdFxuXHRmdW5jdGlvbiB0bXBsKHN0ciwgZGF0YSxjb25maWcpIHtcblx0XHRuZXdzdHI9c3RyO1xuXHRcdGlmKG5ld3N0ci5zdWJzdHIoMCxjb25maWcudGVtcGxhdGVzT3BlblRhZy5sZW5ndGgpPT1jb25maWcudGVtcGxhdGVzT3BlblRhZyluZXdzdHI9XCI8JT1cIituZXdzdHIuc3Vic3RyKGNvbmZpZy50ZW1wbGF0ZXNPcGVuVGFnLmxlbmd0aCxuZXdzdHIubGVuZ3RoLWNvbmZpZy50ZW1wbGF0ZXNPcGVuVGFnLmxlbmd0aCk7XG5cdFx0aWYobmV3c3RyLnN1YnN0cihuZXdzdHIubGVuZ3RoLWNvbmZpZy50ZW1wbGF0ZXNDbG9zZVRhZy5sZW5ndGgsY29uZmlnLnRlbXBsYXRlc0Nsb3NlVGFnLmxlbmd0aCk9PWNvbmZpZy50ZW1wbGF0ZXNDbG9zZVRhZyluZXdzdHI9bmV3c3RyLnN1YnN0cigwLG5ld3N0ci5sZW5ndGgtY29uZmlnLnRlbXBsYXRlc0Nsb3NlVGFnLmxlbmd0aCkrXCIlPlwiO1xuXHRcdHJldHVybiB0bXBscGFydDIobmV3c3RyLGRhdGEpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdG1wbHBhcnQyKHN0ciwgZGF0YSkge1xuXHRcdC8vIEZpZ3VyZSBvdXQgaWYgd2UncmUgZ2V0dGluZyBhIHRlbXBsYXRlLCBvciBpZiB3ZSBuZWVkIHRvXG5cdFx0Ly8gbG9hZCB0aGUgdGVtcGxhdGUgLSBhbmQgYmUgc3VyZSB0byBjYWNoZSB0aGUgcmVzdWx0LlxuXHRcdHZhciBmbiA9ICEvXFxXLy50ZXN0KHN0cikgP1xuXHRcdFx0Y2FjaGVbc3RyXSA9IGNhY2hlW3N0cl0gfHxcblx0XHRcdHRtcGxwYXJ0Mihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHIpLmlubmVySFRNTCkgOlxuXHRcdFx0Ly8gR2VuZXJhdGUgYSByZXVzYWJsZSBmdW5jdGlvbiB0aGF0IHdpbGwgc2VydmUgYXMgYSB0ZW1wbGF0ZVxuXHRcdFx0Ly8gZ2VuZXJhdG9yIChhbmQgd2hpY2ggd2lsbCBiZSBjYWNoZWQpLlxuXHRcdFx0bmV3IEZ1bmN0aW9uKFwib2JqXCIsXG5cdFx0XHRcdFwidmFyIHA9W10scHJpbnQ9ZnVuY3Rpb24oKXtwLnB1c2guYXBwbHkocCxhcmd1bWVudHMpO307XCIgK1xuXHRcdFx0XHQvLyBJbnRyb2R1Y2UgdGhlIGRhdGEgYXMgbG9jYWwgdmFyaWFibGVzIHVzaW5nIHdpdGgoKXt9XG5cdFx0XHRcdFwid2l0aChvYmope3AucHVzaCgnXCIgK1xuXHRcdFx0XHQvLyBDb252ZXJ0IHRoZSB0ZW1wbGF0ZSBpbnRvIHB1cmUgSmF2YVNjcmlwdFxuXHRcdFx0XHRzdHJcblx0XHRcdFx0LnJlcGxhY2UoL1tcXHJcXHRcXG5dL2csIFwiIFwiKVxuXHRcdFx0XHQuc3BsaXQoXCI8JVwiKS5qb2luKFwiXFx0XCIpXG5cdFx0XHRcdC5yZXBsYWNlKC8oKF58JT4pW15cXHRdKiknL2csIFwiJDFcXHJcIilcblx0XHRcdFx0LnJlcGxhY2UoL1xcdD0oLio/KSU+L2csIFwiJywkMSwnXCIpXG5cdFx0XHRcdC5zcGxpdChcIlxcdFwiKS5qb2luKFwiJyk7XCIpXG5cdFx0XHRcdC5zcGxpdChcIiU+XCIpLmpvaW4oXCJwLnB1c2goJ1wiKVxuXHRcdFx0XHQuc3BsaXQoXCJcXHJcIikuam9pbihcIlxcXFwnXCIpICsgXCInKTt9cmV0dXJuIHAuam9pbignJyk7XCIpO1xuXHRcdC8vIFByb3ZpZGUgc29tZSBiYXNpYyBjdXJyeWluZyB0byB0aGUgdXNlclxuXHRcdHJldHVybiBkYXRhID8gZm4oZGF0YSkgOiBmbjtcblx0fTtcblxuXHRmdW5jdGlvbiBkaXNwQ3Jvc3NUZXh0KGN0eCwgY29uZmlnLCBwb3NYLCBwb3NZLCBib3JkZXJYLCBib3JkZXJZLCBvdmVybGF5LCBkYXRhLCBhbmltUEMsIGNudGl0ZXIpIHtcblx0XHR2YXIgaSwgZGlzcHR4dCwgdHh0cG9zeCwgdHh0cG9zeSwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmU7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGNvbmZpZy5jcm9zc1RleHQubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChjb25maWcuY3Jvc3NUZXh0W2ldICE9IFwiXCIgJiYgY29uZmlnLmNyb3NzVGV4dE92ZXJsYXlbTWluKFtpLCBjb25maWcuY3Jvc3NUZXh0T3ZlcmxheS5sZW5ndGggLSAxXSldID09IG92ZXJsYXkgJiYgKChjbnRpdGVyID09IDEgJiYgY29uZmlnLmNyb3NzVGV4dEl0ZXJbTWluKFtpLCBjb25maWcuY3Jvc3NUZXh0SXRlci5sZW5ndGggLSAxXSldID09IFwiZmlyc3RcIikgfHwgY29uZmlnLmNyb3NzVGV4dEl0ZXJbTWluKFtpLCBjb25maWcuY3Jvc3NUZXh0SXRlci5sZW5ndGggLSAxXSldID09IGNudGl0ZXIgfHwgY29uZmlnLmNyb3NzVGV4dEl0ZXJbTWluKFtpLCBjb25maWcuY3Jvc3NUZXh0SXRlci5sZW5ndGggLSAxXSldID09IFwiYWxsXCIgfHwgKGFuaW1QQyA9PSAxICYmIGNvbmZpZy5jcm9zc1RleHRJdGVyW01pbihbaSwgY29uZmlnLmNyb3NzVGV4dEl0ZXIubGVuZ3RoIC0gMV0pXSA9PSBcImxhc3RcIikpKSB7XG5cdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmZvbnQgPSBjb25maWcuY3Jvc3NUZXh0Rm9udFN0eWxlW01pbihbaSwgY29uZmlnLmNyb3NzVGV4dEZvbnRTdHlsZS5sZW5ndGggLSAxXSldICsgXCIgXCIgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuY3Jvc3NUZXh0Rm9udFNpemVbTWluKFtpLCBjb25maWcuY3Jvc3NUZXh0Rm9udFNpemUubGVuZ3RoIC0gMV0pXSkpLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgY29uZmlnLmNyb3NzVGV4dEZvbnRGYW1pbHlbTWluKFtpLCBjb25maWcuY3Jvc3NUZXh0Rm9udEZhbWlseS5sZW5ndGggLSAxXSldO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gY29uZmlnLmNyb3NzVGV4dEZvbnRDb2xvcltNaW4oW2ksIGNvbmZpZy5jcm9zc1RleHRGb250Q29sb3IubGVuZ3RoIC0gMV0pXTtcblx0XHRcdFx0dGV4dEFsaWduID0gY29uZmlnLmNyb3NzVGV4dEFsaWduW01pbihbaSwgY29uZmlnLmNyb3NzVGV4dEFsaWduLmxlbmd0aCAtIDFdKV07XG5cdFx0XHRcdHRleHRCYXNlbGluZSA9IGNvbmZpZy5jcm9zc1RleHRCYXNlbGluZVtNaW4oW2ksIGNvbmZpZy5jcm9zc1RleHRCYXNlbGluZS5sZW5ndGggLSAxXSldO1xuXHRcdFx0XHR0eHRwb3N4ID0gMSAqIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5jcm9zc1RleHRQb3NYW01pbihbaSwgY29uZmlnLmNyb3NzVGV4dFBvc1gubGVuZ3RoIC0gMV0pXSk7XG5cdFx0XHRcdHR4dHBvc3kgPSAxICogTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmNyb3NzVGV4dFBvc1lbTWluKFtpLCBjb25maWcuY3Jvc3NUZXh0UG9zWS5sZW5ndGggLSAxXSldKTtcblx0XHRcdFx0c3dpdGNoICgxICogY29uZmlnLmNyb3NzVGV4dFJlbGF0aXZlUG9zWFtNaW4oW2ksIGNvbmZpZy5jcm9zc1RleHRSZWxhdGl2ZVBvc1gubGVuZ3RoIC0gMV0pXSkge1xuXHRcdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHRcdGlmICh0ZXh0QWxpZ24gPT0gXCJkZWZhdWx0XCIpIHRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0dHh0cG9zeCArPSBib3JkZXJYO1xuXHRcdFx0XHRcdFx0aWYgKHRleHRBbGlnbiA9PSBcImRlZmF1bHRcIikgdGV4dEFsaWduID0gXCJyaWdodFwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0dHh0cG9zeCArPSBwb3NYO1xuXHRcdFx0XHRcdFx0aWYgKHRleHRBbGlnbiA9PSBcImRlZmF1bHRcIikgdGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgLTI6XG5cdFx0XHRcdFx0XHR0eHRwb3N4ICs9IGNvbnRleHQuY2FudmFzLndpZHRoIC8gMjtcblx0XHRcdFx0XHRcdGlmICh0ZXh0QWxpZ24gPT0gXCJkZWZhdWx0XCIpIHRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHR0eHRwb3N4ICs9IHR4dHBvc3ggKyAyICogcG9zWCAtIGJvcmRlclg7XG5cdFx0XHRcdFx0XHRpZiAodGV4dEFsaWduID09IFwiZGVmYXVsdFwiKSB0ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRcdHR4dHBvc3ggKz0gY29udGV4dC5jYW52YXMud2lkdGg7XG5cdFx0XHRcdFx0XHRpZiAodGV4dEFsaWduID09IFwiZGVmYXVsdFwiKSB0ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dHh0cG9zeCArPSBwb3NYO1xuXHRcdFx0XHRcdFx0aWYgKHRleHRBbGlnbiA9PSBcImRlZmF1bHRcIikgdGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAoMSAqIGNvbmZpZy5jcm9zc1RleHRSZWxhdGl2ZVBvc1lbTWluKFtpLCBjb25maWcuY3Jvc3NUZXh0UmVsYXRpdmVQb3NZLmxlbmd0aCAtIDFdKV0pIHtcblx0XHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0XHRpZiAodGV4dEJhc2VsaW5lID09IFwiZGVmYXVsdFwiKSB0ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRcdFx0dHh0cG9zeSArPSBib3JkZXJZO1xuXHRcdFx0XHRcdFx0aWYgKHRleHRCYXNlbGluZSA9PSBcImRlZmF1bHRcIikgdGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdHR4dHBvc3kgKz0gcG9zWTtcblx0XHRcdFx0XHRcdGlmICh0ZXh0QmFzZWxpbmUgPT0gXCJkZWZhdWx0XCIpIHRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIC0yOlxuXHRcdFx0XHRcdFx0dHh0cG9zeSArPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQgLyAyO1xuXHRcdFx0XHRcdFx0aWYgKHRleHRCYXNlbGluZSA9PSBcImRlZmF1bHRcIikgdGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdHR4dHBvc3kgKz0gdHh0cG9zeSArIDIgKiBwb3NZIC0gYm9yZGVyWTtcblx0XHRcdFx0XHRcdGlmICh0ZXh0QmFzZWxpbmUgPT0gXCJkZWZhdWx0XCIpIHRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHR0eHRwb3N5ICs9IGNvbnRleHQuY2FudmFzLmhlaWdodDtcblx0XHRcdFx0XHRcdGlmICh0ZXh0QmFzZWxpbmUgPT0gXCJkZWZhdWx0XCIpIHRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dHh0cG9zeSArPSBwb3NZO1xuXHRcdFx0XHRcdFx0aWYgKHRleHRCYXNlbGluZSA9PSBcImRlZmF1bHRcIikgdGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG5cdFx0XHRcdGN0eC50cmFuc2xhdGUoMSAqIHR4dHBvc3gsIDEgKiB0eHRwb3N5KTtcblx0XHRcdFx0dmFyIHJvdGF0ZVZhbD1NYXRoLlBJICogY29uZmlnLmNyb3NzVGV4dEFuZ2xlW01pbihbaSwgY29uZmlnLmNyb3NzVGV4dEFuZ2xlLmxlbmd0aCAtIDFdKV0gLyAxODA7XG5cdFx0XHRcdGN0eC5yb3RhdGUocm90YXRlVmFsKTtcblx0XHRcdFx0aWYgKGNvbmZpZy5jcm9zc1RleHRbaV0uc3Vic3RyaW5nKDAsIDEpID09IFwiJVwiKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBjb25maWcuY3Jvc3NUZXh0RnVuY3Rpb24gPT0gXCJmdW5jdGlvblwiKSBkaXNwdHh0ID0gY29uZmlnLmNyb3NzVGV4dEZ1bmN0aW9uKGksIGNvbmZpZy5jcm9zc1RleHRbaV0sIGN0eCwgY29uZmlnLCBwb3NYLCBwb3NZLCBib3JkZXJYLCBib3JkZXJZLCBvdmVybGF5LCBkYXRhLCBhbmltUEMpO1xuXHRcdFx0XHR9IGVsc2UgZGlzcHR4dCA9IGNvbmZpZy5jcm9zc1RleHRbaV07XG5cblx0XHRcdFx0c2V0VGV4dEJvcmRlcnNBbmRCYWNrZ3JvdW5kKGN0eCxkaXNwdHh0LE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmNyb3NzVGV4dEZvbnRTaXplW01pbihbaSwgY29uZmlnLmNyb3NzVGV4dEZvbnRTaXplLmxlbmd0aCAtIDFdKV0pLDAsMCxjb25maWcuY3Jvc3NUZXh0Qm9yZGVyc1tNaW4oW2ksIGNvbmZpZy5jcm9zc1RleHRCb3JkZXJzLmxlbmd0aCAtIDFdKV0sY29uZmlnLmNyb3NzVGV4dEJvcmRlcnNDb2xvcltNaW4oW2ksIGNvbmZpZy5jcm9zc1RleHRCb3JkZXJzQ29sb3IubGVuZ3RoIC0gMV0pXSxNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5jcm9zc1RleHRCb3JkZXJzV2lkdGhbTWluKFtpLCBjb25maWcuY3Jvc3NUZXh0Qm9yZGVyc1dpZHRoLmxlbmd0aCAtIDFdKV0pLE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5jcm9zc1RleHRCb3JkZXJzWFNwYWNlW01pbihbaSwgY29uZmlnLmNyb3NzVGV4dEJvcmRlcnNYU3BhY2UubGVuZ3RoIC0gMV0pXSksTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmNyb3NzVGV4dEJvcmRlcnNZU3BhY2VbTWluKFtpLCBjb25maWcuY3Jvc3NUZXh0Qm9yZGVyc1lTcGFjZS5sZW5ndGggLSAxXSldKSxjb25maWcuY3Jvc3NUZXh0Qm9yZGVyc1N0eWxlW01pbihbaSwgY29uZmlnLmNyb3NzVGV4dEJvcmRlcnNTdHlsZS5sZW5ndGggLSAxXSldLGNvbmZpZy5jcm9zc1RleHRCYWNrZ3JvdW5kQ29sb3JbTWluKFtpLCBjb25maWcuY3Jvc3NUZXh0QmFja2dyb3VuZENvbG9yLmxlbmd0aCAtIDFdKV0sXCJDUk9TU1RFWFRcIixjb25maWcuY3Jvc3NUZXh0Qm9yZGVyc1JhZGl1cyk7XG5cdFx0XHRcdGlmKChhbmltUEM9PTEgJiYgY29uZmlnLmNyb3NzVGV4dEl0ZXJbTWluKFtpLCBjb25maWcuY3Jvc3NUZXh0SXRlci5sZW5ndGggLSAxXSldID09IFwiYWxsXCIpIHx8IGNvbmZpZy5jcm9zc1RleHRJdGVyW01pbihbaSwgY29uZmlnLmNyb3NzVGV4dEl0ZXIubGVuZ3RoIC0gMV0pXSAhPSBcImxhc3RcIikge1xuXHRcdFx0XHQgICAgICAgY3R4LmZpbGxUZXh0TXVsdGlMaW5lKGRpc3B0eHQsIDAsIDAsIGN0eC50ZXh0QmFzZWxpbmUsIE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmNyb3NzVGV4dEZvbnRTaXplW01pbihbaSwgY29uZmlnLmNyb3NzVGV4dEZvbnRTaXplLmxlbmd0aCAtIDFdKV0pLHRydWUsY29uZmlnLmRldGVjdE1vdXNlT25UZXh0LGN0eCxcIkNST1NTVEVYVF9URVhUTU9VU0VcIixyb3RhdGVWYWwsMSAqIHR4dHBvc3gsIDEgKiB0eHRwb3N5LGksLTEpO1xuXHRcdFx0XHR9IGVsc2UgY3R4LmZpbGxUZXh0TXVsdGlMaW5lKGRpc3B0eHQsIDAsIDAsIGN0eC50ZXh0QmFzZWxpbmUsIE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmNyb3NzVGV4dEZvbnRTaXplW01pbihbaSwgY29uZmlnLmNyb3NzVGV4dEZvbnRTaXplLmxlbmd0aCAtIDFdKV0pLHRydWUsZmFsc2UsY3R4LFwiQ1JPU1NURVhUX1RFWFRNT1VTRVwiLHJvdGF0ZVZhbCwxICogdHh0cG9zeCwgMSAqIHR4dHBvc3ksaSwtMSk7XG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGRpc3BDcm9zc0ltYWdlKGN0eCwgY29uZmlnLCBwb3NYLCBwb3NZLCBib3JkZXJYLCBib3JkZXJZLCBvdmVybGF5LCBkYXRhLCBhbmltUEMsIGNudGl0ZXIpIHtcblx0XHR2YXIgaSwgZGlzcHR4dCwgaW1hZ2Vwb3N4LCBpbWFnZXBvc3ksIGltYWdlQWxpZ24sIGltYWdlQmFzZWxpbmU7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGNvbmZpZy5jcm9zc0ltYWdlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodHlwZW9mIGNvbmZpZy5jcm9zc0ltYWdlW2ldICE9IFwidW5kZWZpbmVkXCIgJiYgY29uZmlnLmNyb3NzSW1hZ2VPdmVybGF5W01pbihbaSwgY29uZmlnLmNyb3NzSW1hZ2VPdmVybGF5Lmxlbmd0aCAtIDFdKV0gPT0gb3ZlcmxheSAmJiAoKGNudGl0ZXIgPT0gLTEgJiYgY29uZmlnLmNyb3NzSW1hZ2VJdGVyW01pbihbaSwgY29uZmlnLmNyb3NzSW1hZ2VJdGVyLmxlbmd0aCAtIDFdKV0gPT0gXCJiYWNrZ3JvdW5kXCIpIHx8IChjbnRpdGVyID09IDEgJiYgY29uZmlnLmNyb3NzSW1hZ2VJdGVyW01pbihbaSwgY29uZmlnLmNyb3NzSW1hZ2VJdGVyLmxlbmd0aCAtIDFdKV0gPT0gXCJmaXJzdFwiKSB8fCBjb25maWcuY3Jvc3NJbWFnZUl0ZXJbTWluKFtpLCBjb25maWcuY3Jvc3NJbWFnZUl0ZXIubGVuZ3RoIC0gMV0pXSA9PSBjbnRpdGVyIHx8IChjbnRpdGVyICE9IC0xICYmIGNvbmZpZy5jcm9zc0ltYWdlSXRlcltNaW4oW2ksIGNvbmZpZy5jcm9zc0ltYWdlSXRlci5sZW5ndGggLSAxXSldID09IFwiYWxsXCIpIHx8IChhbmltUEMgPT0gMSAmJiBjb25maWcuY3Jvc3NJbWFnZUl0ZXJbTWluKFtpLCBjb25maWcuY3Jvc3NJbWFnZUl0ZXIubGVuZ3RoIC0gMV0pXSA9PSBcImxhc3RcIikpKSB7XG5cdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0aW1hZ2VBbGlnbiA9IGNvbmZpZy5jcm9zc0ltYWdlQWxpZ25bTWluKFtpLCBjb25maWcuY3Jvc3NJbWFnZUFsaWduLmxlbmd0aCAtIDFdKV07XG5cdFx0XHRcdGltYWdlQmFzZWxpbmUgPSBjb25maWcuY3Jvc3NJbWFnZUJhc2VsaW5lW01pbihbaSwgY29uZmlnLmNyb3NzSW1hZ2VCYXNlbGluZS5sZW5ndGggLSAxXSldO1xuXHRcdFx0XHRpbWFnZXBvc3ggPSAxICogTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmNyb3NzSW1hZ2VQb3NYW01pbihbaSwgY29uZmlnLmNyb3NzSW1hZ2VQb3NYLmxlbmd0aCAtIDFdKV0pO1xuXHRcdFx0XHRpbWFnZXBvc3kgPSAxICogTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmNyb3NzSW1hZ2VQb3NZW01pbihbaSwgY29uZmlnLmNyb3NzSW1hZ2VQb3NZLmxlbmd0aCAtIDFdKV0pO1xuXHRcdFx0XHRzd2l0Y2ggKDEgKiBjb25maWcuY3Jvc3NJbWFnZVJlbGF0aXZlUG9zWFtNaW4oW2ksIGNvbmZpZy5jcm9zc0ltYWdlUmVsYXRpdmVQb3NYLmxlbmd0aCAtIDFdKV0pIHtcblx0XHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0XHRpZiAoaW1hZ2VBbGlnbiA9PSBcImRlZmF1bHRcIikgaW1hZ2VBbGlnbiA9IFwibGVmdFwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0aW1hZ2Vwb3N4ICs9IGJvcmRlclg7XG5cdFx0XHRcdFx0XHRpZiAoaW1hZ2VBbGlnbiA9PSBcImRlZmF1bHRcIikgaW1hZ2VBbGlnbiA9IFwicmlnaHRcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdGltYWdlcG9zeCArPSBwb3NYO1xuXHRcdFx0XHRcdFx0aWYgKGltYWdlQWxpZ24gPT0gXCJkZWZhdWx0XCIpIGltYWdlQWxpZ24gPSBcImNlbnRlclwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAtMjpcblx0XHRcdFx0XHRcdGltYWdlcG9zeCArPSBjb250ZXh0LmNhbnZhcy53aWR0aCAvIDI7XG5cdFx0XHRcdFx0XHRpZiAoaW1hZ2VBbGlnbiA9PSBcImRlZmF1bHRcIikgaW1hZ2VBbGlnbiA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHRpbWFnZXBvc3ggKz0gaW1hZ2Vwb3N4ICsgMiAqIHBvc1ggLSBib3JkZXJYO1xuXHRcdFx0XHRcdFx0aWYgKGltYWdlQWxpZ24gPT0gXCJkZWZhdWx0XCIpIGltYWdlQWxpZ24gPSBcImxlZnRcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRcdGltYWdlcG9zeCArPSBjb250ZXh0LmNhbnZhcy53aWR0aDtcblx0XHRcdFx0XHRcdGlmIChpbWFnZUFsaWduID09IFwiZGVmYXVsdFwiKSBpbWFnZUFsaWduID0gXCJyaWdodFwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGltYWdlcG9zeCArPSBwb3NYO1xuXHRcdFx0XHRcdFx0aWYgKGltYWdlQWxpZ24gPT0gXCJkZWZhdWx0XCIpIGltYWdlQWxpZ24gPSBcImNlbnRlclwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoICgxICogY29uZmlnLmNyb3NzSW1hZ2VSZWxhdGl2ZVBvc1lbTWluKFtpLCBjb25maWcuY3Jvc3NJbWFnZVJlbGF0aXZlUG9zWS5sZW5ndGggLSAxXSldKSB7XG5cdFx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdFx0aWYgKGltYWdlQmFzZWxpbmUgPT0gXCJkZWZhdWx0XCIpIGltYWdlQmFzZWxpbmUgPSBcInRvcFwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRcdFx0aW1hZ2Vwb3N5ICs9IGJvcmRlclk7XG5cdFx0XHRcdFx0XHRpZiAoaW1hZ2VCYXNlbGluZSA9PSBcImRlZmF1bHRcIikgaW1hZ2VCYXNlbGluZSA9IFwidG9wXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0XHRpbWFnZXBvc3kgKz0gcG9zWTtcblx0XHRcdFx0XHRcdGlmIChpbWFnZUJhc2VsaW5lID09IFwiZGVmYXVsdFwiKSBpbWFnZUJhc2VsaW5lID0gXCJtaWRkbGVcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgLTI6XG5cdFx0XHRcdFx0XHRpbWFnZXBvc3kgKz0gY29udGV4dC5jYW52YXMuaGVpZ2h0IC8gMjtcblx0XHRcdFx0XHRcdGlmIChpbWFnZUJhc2VsaW5lID09IFwiZGVmYXVsdFwiKSBpbWFnZUJhc2VsaW5lID0gXCJtaWRkbGVcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdGltYWdlcG9zeSArPSBpbWFnZXBvc3kgKyAyICogcG9zWSAtIGJvcmRlclk7XG5cdFx0XHRcdFx0XHRpZiAoaW1hZ2VCYXNlbGluZSA9PSBcImRlZmF1bHRcIikgaW1hZ2VCYXNlbGluZSA9IFwiYm90dG9tXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHRpbWFnZXBvc3kgKz0gY29udGV4dC5jYW52YXMuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0aWYgKGltYWdlQmFzZWxpbmUgPT0gXCJkZWZhdWx0XCIpIGltYWdlQmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGltYWdlcG9zeSArPSBwb3NZO1xuXHRcdFx0XHRcdFx0aWYgKGltYWdlQmFzZWxpbmUgPT0gXCJkZWZhdWx0XCIpIGltYWdlQmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGltYWdlV2lkdGggPSBjb25maWcuY3Jvc3NJbWFnZVtpXS53aWR0aDtcblx0XHRcdFx0c3dpdGNoIChpbWFnZUFsaWduKSB7XG5cdFx0XHRcdFx0Y2FzZSBcImxlZnRcIjpcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJyaWdodFwiOlxuXHRcdFx0XHRcdFx0aW1hZ2Vwb3N4IC09IGltYWdlV2lkdGg7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiY2VudGVyXCI6XG5cdFx0XHRcdFx0XHRpbWFnZXBvc3ggLT0gKGltYWdlV2lkdGggLyAyKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgaW1hZ2VIZWlnaHQgPSBjb25maWcuY3Jvc3NJbWFnZVtpXS5oZWlnaHQ7XG5cdFx0XHRcdHN3aXRjaCAoaW1hZ2VCYXNlbGluZSkge1xuXHRcdFx0XHRcdGNhc2UgXCJ0b3BcIjpcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJib3R0b21cIjpcblx0XHRcdFx0XHRcdGltYWdlcG9zeSAtPSBpbWFnZUhlaWdodDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJtaWRkbGVcIjpcblx0XHRcdFx0XHRcdGltYWdlcG9zeSAtPSAoaW1hZ2VIZWlnaHQgLyAyKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHgudHJhbnNsYXRlKDEgKiBpbWFnZXBvc3gsIDEgKiBpbWFnZXBvc3kpO1xuXHRcdFx0XHRjdHgucm90YXRlKE1hdGguUEkgKiBjb25maWcuY3Jvc3NJbWFnZUFuZ2xlW01pbihbaSwgY29uZmlnLmNyb3NzSW1hZ2VBbmdsZS5sZW5ndGggLSAxXSldIC8gMTgwKTtcblx0XHRcdFx0Y3R4LmRyYXdJbWFnZShjb25maWcuY3Jvc3NJbWFnZVtpXSwgMCwgMCk7XG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHQvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gc2V0TWVhc3VyZXMoZGF0YSwgY29uZmlnLCBjdHgsIGNhbnZhc2hlaWdodCwgY2FudmFzd2lkdGgsIHlsYWJlbHMsIHlsYWJlbHMyLCByZXZlcnNlTGVnZW5kLCByZXZlcnNlQXhpcywgZHJhd0F4aXMsIGRyYXdMZWdlbmRPbkRhdGEsIGxlZ2VuZEJveCwgdHlwZWdyYXBoKSB7XG5cbiAgICAgICAgXHR2YXIgaGVpZ2h0PWNhbnZhc2hlaWdodDtcbiAgICAgICAgXHR2YXIgd2lkdGg9Y2FudmFzd2lkdGg7XG5cdFx0aWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvPjEpIHtcblx0XHRcdGhlaWdodD1oZWlnaHQvd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cdFx0XHR3aWR0aD13aWR0aC93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblx0XHR9XG5cblxuICAgICAgICBcdFxuXHRcdGlmIChjb25maWcuY2FudmFzQmFja2dyb3VuZENvbG9yICE9IFwibm9uZVwiKSBjdHguY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSBjb25maWcuY2FudmFzQmFja2dyb3VuZENvbG9yO1xuXHRcdHZhciBib3JkZXJXaWR0aCA9IDA7XG5cdFx0dmFyIHhBeGlzTGFiZWxQb3MgPSAwO1xuXHRcdHZhciBncmFwaFRpdGxlSGVpZ2h0ID0gMDtcblx0XHR2YXIgZ3JhcGhUaXRsZVBvc1kgPSAwO1xuXHRcdHZhciBncmFwaFN1YlRpdGxlSGVpZ2h0ID0gMDtcblx0XHR2YXIgZ3JhcGhTdWJUaXRsZVBvc1kgPSAwO1xuXHRcdHZhciBmb290Tm90ZUhlaWdodCA9IDA7XG5cdFx0dmFyIGZvb3ROb3RlUG9zWSA9IDA7XG5cdFx0dmFyIHlBeGlzVW5pdEhlaWdodCA9IDA7XG5cdFx0dmFyIHlBeGlzVW5pdFBvc1kgPSAwO1xuXHRcdHZhciB3aWRlc3RMZWdlbmQgPSAwO1xuXHRcdHZhciBuYmVsdExlZ2VuZCA9IDA7XG5cdFx0dmFyIG5iTGVnZW5kTGluZXMgPSAwO1xuXHRcdHZhciBuYkxlZ2VuZENvbHMgPSAwO1xuXHRcdHZhciBzcGFjZUxlZ2VuZEhlaWdodCA9IDA7XG5cdFx0dmFyIHhGaXJzdExlZ2VuZFRleHRQb3MgPSAwO1xuXHRcdHZhciB5Rmlyc3RMZWdlbmRUZXh0UG9zID0gMDtcblx0XHR2YXIgeExlZ2VuZEJvcmRlclBvcyA9IDA7XG5cdFx0dmFyIHlMZWdlbmRCb3JkZXJQb3MgPSAwO1xuXHRcdHZhciB5QXhpc0xhYmVsV2lkdGggPSAwO1xuXHRcdHZhciB5QXhpc0xhYmVsUG9zTGVmdCA9IDA7XG5cdFx0dmFyIHlBeGlzTGFiZWxQb3NSaWdodCA9IDA7XG5cdFx0dmFyIHhBeGlzTGFiZWxIZWlnaHQgPSAwO1xuXHRcdHZhciB4TGFiZWxIZWlnaHQgPSAwO1xuXHRcdHZhciB3aWRlc3RYTGFiZWwgPSAxO1xuXHRcdHZhciBoaWdoZXN0WExhYmVsID0gMTtcblx0XHR2YXIgd2lkZXN0WUxhYmVsID0gMDtcblx0XHR2YXIgaGlnaGVzdFlMYWJlbCA9IDE7XG5cdFx0dmFyIHdpZGVzdFlMYWJlbDIgPSAwO1xuXHRcdHZhciBoaWdoZXN0WUxhYmVsMiA9IDE7XG5cdFx0dmFyIGxlZnROb3RVc2FibGVTaXplID0gMDtcblx0XHR2YXIgcmlnaHROb3RVc2FibGVTaXplID0gMDtcblx0XHR2YXIgcm90YXRlTGFiZWxzID0gMDtcblx0XHR2YXIgeExhYmVsUG9zID0gMDtcblx0XHR2YXIgbGVnZW5kQm9yZGVyV2lkdGggPSAwO1xuXHRcdHZhciBsZWdlbmRCb3JkZXJIZWlnaHQgPSAwO1xuXG5cdFx0Y3R4LndpZHRoQXRTZXRNZWFzdXJlcz13aWR0aDtcblx0XHRjdHguaGVpZ2h0QXRTZXRNZWFzdXJlcz1oZWlnaHQ7XG5cdFx0XG5cdFx0Ly8gQm9yZGVyc1xuXHRcdGlmIChjb25maWcuY2FudmFzQm9yZGVycykgYm9yZGVyV2lkdGggPSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5jYW52YXNCb3JkZXJzV2lkdGgpO1xuXHRcdC8vIGNvbXB1dGUgd2lkZXN0IFggbGFiZWxcblx0XHR2YXIgdGV4dE1zcixpO1xuXHRcdGlmIChkcmF3QXhpcykge1xuXHRcdFx0Y3R4LmZvbnQgPSBjb25maWcuc2NhbGVGb250U3R5bGUgKyBcIiBcIiArIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5zY2FsZUZvbnRTaXplKSkudG9TdHJpbmcoKSArIFwicHggXCIgKyBjb25maWcuc2NhbGVGb250RmFtaWx5O1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGEubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmKHNob3dMYWJlbHMoY3R4LGRhdGEsY29uZmlnLGkpID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0dGV4dE1zciA9IGN0eC5tZWFzdXJlVGV4dE11bHRpTGluZShmbXRDaGFydEpTKGNvbmZpZywgZGF0YS5sYWJlbHNbaV0sIGNvbmZpZy5mbXRYTGFiZWwpLCAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpKTtcblx0XHRcdFx0XHQvL0lmIHRoZSB0ZXh0IGxlbmd0aCBpcyBsb25nZXIgLSBtYWtlIHRoYXQgZXF1YWwgdG8gbG9uZ2VzdCB0ZXh0IVxuXHRcdFx0XHRcdHdpZGVzdFhMYWJlbCA9ICh0ZXh0TXNyLnRleHRXaWR0aCA+IHdpZGVzdFhMYWJlbCkgPyB0ZXh0TXNyLnRleHRXaWR0aCA6IHdpZGVzdFhMYWJlbDtcblx0XHRcdFx0XHRoaWdoZXN0WExhYmVsID0gKHRleHRNc3IudGV4dEhlaWdodCA+IGhpZ2hlc3RYTGFiZWwpID8gdGV4dE1zci50ZXh0SGVpZ2h0IDogaGlnaGVzdFhMYWJlbDtcblx0XHRcdFx0fSBcblx0XHRcdH1cblx0XHRcdGlmICh3aWRlc3RYTGFiZWwgPCBNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy54U2NhbGVMYWJlbHNNaW5pbXVtV2lkdGgpKSB3aWRlc3RYTGFiZWwgPSBNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy54U2NhbGVMYWJlbHNNaW5pbXVtV2lkdGgpO1xuXHRcdH1cblx0XHQvLyBjb21wdXRlIFkgTGFiZWwgV2lkdGhcblx0XHRpZiAoZHJhd0F4aXMpIHtcblx0XHRcdHdpZGVzdFlMYWJlbCA9IDE7XG5cdFx0XHRpZiAoeWxhYmVscyAhPSBudWxsICYmIHlsYWJlbHMgIT0gXCJuaWhpbFwiKSB7XG5cdFx0XHRcdGN0eC5mb250ID0gY29uZmlnLnNjYWxlRm9udFN0eWxlICsgXCIgXCIgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgY29uZmlnLnNjYWxlRm9udEZhbWlseTtcblx0XHRcdFx0Zm9yIChpID0geWxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YoeWxhYmVsc1tpXSkgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0aWYoc2hvd1lMYWJlbHMoY3R4LGRhdGEsY29uZmlnLGkseWxhYmVsc1tpXSkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHlsYWJlbHNbaV0udHJpbSgpICE9IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0XHR0ZXh0TXNyID0gY3R4Lm1lYXN1cmVUZXh0TXVsdGlMaW5lKGZtdENoYXJ0SlMoY29uZmlnLCB5bGFiZWxzW2ldLCBjb25maWcuZm10WUxhYmVsKSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSk7XG5cdFx0XHRcdFx0XHRcdFx0Ly9JZiB0aGUgdGV4dCBsZW5ndGggaXMgbG9uZ2VyIC0gbWFrZSB0aGF0IGVxdWFsIHRvIGxvbmdlc3QgdGV4dCFcblx0XHRcdFx0XHRcdFx0XHR3aWRlc3RZTGFiZWwgPSAodGV4dE1zci50ZXh0V2lkdGggPiB3aWRlc3RZTGFiZWwpID8gdGV4dE1zci50ZXh0V2lkdGggOiB3aWRlc3RZTGFiZWw7XG5cdFx0XHRcdFx0XHRcdFx0aGlnaGVzdFlMYWJlbCA9ICh0ZXh0TXNyLnRleHRIZWlnaHQgPiBoaWdoZXN0WUxhYmVsKSA/IHRleHRNc3IudGV4dEhlaWdodCA6IGhpZ2hlc3RZTGFiZWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh3aWRlc3RZTGFiZWwgPCBNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy55U2NhbGVMYWJlbHNNaW5pbXVtV2lkdGgpKSB7XG5cdFx0XHRcdHdpZGVzdFlMYWJlbCA9IE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnlTY2FsZUxhYmVsc01pbmltdW1XaWR0aCk7XG5cdFx0XHR9XG5cdFx0XHR3aWRlc3RZTGFiZWwyID0gMTtcblx0XHRcdGlmICh5bGFiZWxzMiAhPSBudWxsICYmIGNvbmZpZy55QXhpc1JpZ2h0KSB7XG5cdFx0XHRcdGN0eC5mb250ID0gY29uZmlnLnNjYWxlRm9udFN0eWxlICsgXCIgXCIgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuc2NhbGVGb250U2l6ZSkpLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgY29uZmlnLnNjYWxlRm9udEZhbWlseTtcblx0XHRcdFx0Zm9yIChpID0geWxhYmVsczIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mKHlsYWJlbHMyW2ldKSA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHRpZiAoeWxhYmVsczJbaV0udHJpbSgpICE9IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0dGV4dE1zciA9IGN0eC5tZWFzdXJlVGV4dE11bHRpTGluZShmbXRDaGFydEpTKGNvbmZpZywgeWxhYmVsczJbaV0sIGNvbmZpZy5mbXRZTGFiZWwyKSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnNjYWxlRm9udFNpemUpKSk7XG5cdFx0XHRcdFx0XHRcdC8vSWYgdGhlIHRleHQgbGVuZ3RoIGlzIGxvbmdlciAtIG1ha2UgdGhhdCBlcXVhbCB0byBsb25nZXN0IHRleHQhXG5cdFx0XHRcdFx0XHRcdHdpZGVzdFlMYWJlbDIgPSAodGV4dE1zci50ZXh0V2lkdGggPiB3aWRlc3RZTGFiZWwyKSA/IHRleHRNc3IudGV4dFdpZHRoIDogd2lkZXN0WUxhYmVsMjtcblx0XHRcdFx0XHRcdFx0aGlnaGVzdFlMYWJlbDIgPSAodGV4dE1zci50ZXh0SGVpZ2h0ID4gaGlnaGVzdFlMYWJlbDIpID8gdGV4dE1zci50ZXh0SGVpZ2h0IDogaGlnaGVzdFlMYWJlbDI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aWRlc3RZTGFiZWwyID0gd2lkZXN0WUxhYmVsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHdpZGVzdFlMYWJlbDIgPCBNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy55U2NhbGVMYWJlbHNNaW5pbXVtV2lkdGgpKSB7XG5cdFx0XHRcdHdpZGVzdFlMYWJlbDIgPSBNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy55U2NhbGVMYWJlbHNNaW5pbXVtV2lkdGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyB5QXhpc0xhYmVsXG5cdFx0bGVmdE5vdFVzYWJsZVNpemUgPSBib3JkZXJXaWR0aCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpXG5cdFx0cmlnaHROb3RVc2FibGVTaXplID0gYm9yZGVyV2lkdGggKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VSaWdodCk7XG5cdFx0aWYgKGRyYXdBeGlzKSB7XG5cdFx0XHRpZiAodHlwZW9mKGNvbmZpZy55QXhpc0xhYmVsKSAhPSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdGlmIChjb25maWcueUF4aXNMYWJlbC50cmltKCkgIT0gXCJcIikge1xuXHRcdFx0XHRcdHlBeGlzTGFiZWxXaWR0aCA9IChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy55QXhpc0ZvbnRTaXplKSkgKiAoY29uZmlnLnlBeGlzTGFiZWwuc3BsaXQoXCJcXG5cIikubGVuZ3RoIHx8IDEpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnlBeGlzTGFiZWxTcGFjZUxlZnQpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnlBeGlzTGFiZWxTcGFjZVJpZ2h0KTtcblx0XHRcdFx0XHR5QXhpc0xhYmVsUG9zTGVmdCA9IGJvcmRlcldpZHRoICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlTGVmdCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNMYWJlbFNwYWNlTGVmdCkgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcueUF4aXNGb250U2l6ZSkpO1xuXHRcdFx0XHRcdHlBeGlzTGFiZWxQb3NSaWdodCA9IHdpZHRoIC0gYm9yZGVyV2lkdGggLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VSaWdodCkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNMYWJlbFNwYWNlTGVmdCkgLSAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcueUF4aXNGb250U2l6ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGNvbmZpZy55QXhpc0xhYmVsQmFja2dyb3VuZENvbG9yICE9XCJub25lXCIgfHwgY29uZmlnLnlBeGlzTGFiZWxCb3JkZXJzKSB7XG5cdFx0XHRcdFx0eUF4aXNMYWJlbFdpZHRoKz0yKihNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNMYWJlbEJvcmRlcnNZU3BhY2UpKTtcblx0XHRcdFx0XHR5QXhpc0xhYmVsUG9zTGVmdCs9TWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnlBeGlzTGFiZWxCb3JkZXJzWVNwYWNlKTtcblx0XHRcdFx0XHR5QXhpc0xhYmVsUG9zUmlnaHQtPU1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc0xhYmVsQm9yZGVyc1lTcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihjb25maWcuZ3JhcGhUaXRsZUJvcmRlcnMpIHtcblx0XHRcdFx0XHR5QXhpc0xhYmVsV2lkdGgrPTIqKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnlBeGlzTGFiZWxCb3JkZXJzV2lkdGgpKTtcblx0XHRcdFx0XHR5QXhpc0xhYmVsUG9zTGVmdCs9TWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcueUF4aXNMYWJlbEJvcmRlcnNXaWR0aCk7XG5cdFx0XHRcdFx0eUF4aXNMYWJlbFBvc1JpZ2h0LT1NYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy55QXhpc0xhYmVsQm9yZGVyc1dpZHRoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbmZpZy55QXhpc0xlZnQpIHtcblx0XHRcdFx0aWYgKHJldmVyc2VBeGlzID09IGZhbHNlKSBsZWZ0Tm90VXNhYmxlU2l6ZSA9IGJvcmRlcldpZHRoICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlTGVmdCkgKyB5QXhpc0xhYmVsV2lkdGggKyB3aWRlc3RZTGFiZWwgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNTcGFjZUxlZnQpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnlBeGlzU3BhY2VSaWdodCk7XG5cdFx0XHRcdGVsc2UgICAgICAgICAgICAgICAgICAgICAgbGVmdE5vdFVzYWJsZVNpemUgPSBib3JkZXJXaWR0aCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpICsgeUF4aXNMYWJlbFdpZHRoICsgd2lkZXN0WExhYmVsICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnlBeGlzU3BhY2VMZWZ0KSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc1NwYWNlUmlnaHQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbmZpZy55QXhpc1JpZ2h0KSB7XG5cdFx0XHRcdGlmIChyZXZlcnNlQXhpcyA9PSBmYWxzZSkgcmlnaHROb3RVc2FibGVTaXplID0gYm9yZGVyV2lkdGggKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VSaWdodCkgKyB5QXhpc0xhYmVsV2lkdGggKyB3aWRlc3RZTGFiZWwyICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnlBeGlzU3BhY2VMZWZ0KSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc1NwYWNlUmlnaHQpO1xuXHRcdFx0XHRlbHNlICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0Tm90VXNhYmxlU2l6ZSA9IGJvcmRlcldpZHRoICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlUmlnaHQpICsgeUF4aXNMYWJlbFdpZHRoICsgd2lkZXN0WExhYmVsICArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc1NwYWNlTGVmdCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNTcGFjZVJpZ2h0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0YXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIGxlZnROb3RVc2FibGVTaXplIC0gcmlnaHROb3RVc2FibGVTaXplO1xuXHRcdC8vIFRpdGxlXG5cdFx0aWYgKGNvbmZpZy5ncmFwaFRpdGxlLnRyaW0oKSAhPSBcIlwiKSB7XG5cdFx0XHRncmFwaFRpdGxlSGVpZ2h0ID0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmdyYXBoVGl0bGVGb250U2l6ZSkpICogKGNvbmZpZy5ncmFwaFRpdGxlLnNwbGl0KFwiXFxuXCIpLmxlbmd0aCB8fCAxKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5ncmFwaFRpdGxlU3BhY2VCZWZvcmUpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmdyYXBoVGl0bGVTcGFjZUFmdGVyKTtcblx0XHRcdGdyYXBoVGl0bGVQb3NZID0gYm9yZGVyV2lkdGggKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VUb3ApICsgZ3JhcGhUaXRsZUhlaWdodCAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5ncmFwaFRpdGxlU3BhY2VBZnRlcik7XG5cdFx0XHRpZihjb25maWcuZ3JhcGhUaXRsZUJhY2tncm91bmRDb2xvciAhPVwibm9uZVwiIHx8IGNvbmZpZy5ncmFwaFRpdGxlQm9yZGVycykge1xuXHRcdFx0XHRncmFwaFRpdGxlSGVpZ2h0Kz0yKihNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuZ3JhcGhUaXRsZUJvcmRlcnNZU3BhY2UpKTtcblx0XHRcdFx0Z3JhcGhUaXRsZVBvc1krPU1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5ncmFwaFRpdGxlQm9yZGVyc1lTcGFjZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGNvbmZpZy5ncmFwaFRpdGxlQm9yZGVycykge1xuXHRcdFx0XHRncmFwaFRpdGxlSGVpZ2h0Kz0yKihNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5ncmFwaFRpdGxlQm9yZGVyc1dpZHRoKSk7XG5cdFx0XHRcdGdyYXBoVGl0bGVQb3NZKz1NYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5ncmFwaFRpdGxlQm9yZGVyc1dpZHRoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gc3ViVGl0bGVcblx0XHRpZiAoY29uZmlnLmdyYXBoU3ViVGl0bGUudHJpbSgpICE9IFwiXCIpIHtcblx0XHRcdGdyYXBoU3ViVGl0bGVIZWlnaHQgPSAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuZ3JhcGhTdWJUaXRsZUZvbnRTaXplKSkgKiAoY29uZmlnLmdyYXBoU3ViVGl0bGUuc3BsaXQoXCJcXG5cIikubGVuZ3RoIHx8IDEpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmdyYXBoU3ViVGl0bGVTcGFjZUJlZm9yZSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuZ3JhcGhTdWJUaXRsZVNwYWNlQWZ0ZXIpO1xuXHRcdFx0Z3JhcGhTdWJUaXRsZVBvc1kgPSBib3JkZXJXaWR0aCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZVRvcCkgKyBncmFwaFRpdGxlSGVpZ2h0ICsgZ3JhcGhTdWJUaXRsZUhlaWdodCAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5ncmFwaFN1YlRpdGxlU3BhY2VBZnRlcik7XG5cdFx0XHRpZihjb25maWcuZ3JhcGhTdWJUaXRsZUJhY2tncm91bmRDb2xvciAhPVwibm9uZVwiIHx8IGNvbmZpZy5ncmFwaFN1YlRpdGxlQm9yZGVycykge1xuXHRcdFx0XHRncmFwaFN1YlRpdGxlSGVpZ2h0Kz0yKihNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuZ3JhcGhTdWJUaXRsZUJvcmRlcnNZU3BhY2UpKTtcblx0XHRcdFx0Z3JhcGhTdWJUaXRsZVBvc1krPU1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5ncmFwaFN1YlRpdGxlQm9yZGVyc1lTcGFjZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGNvbmZpZy5ncmFwaFN1YlRpdGxlQm9yZGVycykge1xuXHRcdFx0XHRncmFwaFN1YlRpdGxlSGVpZ2h0Kz0yKihNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5ncmFwaFN1YlRpdGxlQm9yZGVyc1dpZHRoKSk7XG5cdFx0XHRcdGdyYXBoU3ViVGl0bGVQb3NZKz1NYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5ncmFwaFN1YlRpdGxlQm9yZGVyc1dpZHRoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8geUF4aXNVbml0XG5cdFx0aWYgKGRyYXdBeGlzKSB7XG5cdFx0XHRpZiAoY29uZmlnLnlBeGlzVW5pdC50cmltKCkgIT0gXCJcIikge1xuXHRcdFx0XHR5QXhpc1VuaXRIZWlnaHQgPSAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcueUF4aXNVbml0Rm9udFNpemUpKSAqIChjb25maWcueUF4aXNVbml0LnNwbGl0KFwiXFxuXCIpLmxlbmd0aCB8fCAxKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc1VuaXRTcGFjZUJlZm9yZSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNVbml0U3BhY2VBZnRlcik7XG5cdFx0XHRcdHlBeGlzVW5pdFBvc1kgPSBib3JkZXJXaWR0aCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZVRvcCkgKyBncmFwaFRpdGxlSGVpZ2h0ICsgZ3JhcGhTdWJUaXRsZUhlaWdodCArIHlBeGlzVW5pdEhlaWdodCAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc1VuaXRTcGFjZUFmdGVyKTtcblx0XHRcdH1cblx0XHRcdGlmKGNvbmZpZy55QXhpc1VuaXRCYWNrZ3JvdW5kQ29sb3IgIT1cIm5vbmVcIiB8fCBjb25maWcueUF4aXNVbml0Qm9yZGVycykge1xuXHRcdFx0XHR5QXhpc1VuaXRIZWlnaHQrPTIqKE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc1VuaXRCb3JkZXJzWVNwYWNlKSk7XG5cdFx0XHRcdHlBeGlzVW5pdFBvc1krPU1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc1VuaXRCb3JkZXJzWVNwYWNlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoY29uZmlnLnlBeGlzVW5pdEJvcmRlcnMpIHtcblx0XHRcdFx0eUF4aXNVbml0SGVpZ2h0Kz0yKihNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy55QXhpc1VuaXRCb3JkZXJzV2lkdGgpKTtcblx0XHRcdFx0eUF4aXNVbml0UG9zWSs9TWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcueUF4aXNVbml0Qm9yZGVyc1dpZHRoKTtcblx0XHRcdH1cblxuXG5cdFx0fVxuXHRcdHRvcE5vdFVzYWJsZVNpemUgPSBib3JkZXJXaWR0aCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZVRvcCkgKyBncmFwaFRpdGxlSGVpZ2h0ICsgZ3JhcGhTdWJUaXRsZUhlaWdodCArIHlBeGlzVW5pdEhlaWdodCArIE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmdyYXBoU3BhY2VCZWZvcmUpO1xuXHRcdC8vIGZvb3ROb3RlXG5cdFx0aWYgKHR5cGVvZihjb25maWcuZm9vdE5vdGUpICE9IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGlmIChjb25maWcuZm9vdE5vdGUudHJpbSgpICE9IFwiXCIpIHtcblx0XHRcdFx0Zm9vdE5vdGVIZWlnaHQgPSAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuZm9vdE5vdGVGb250U2l6ZSkpICogKGNvbmZpZy5mb290Tm90ZS5zcGxpdChcIlxcblwiKS5sZW5ndGggfHwgMSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuZm9vdE5vdGVTcGFjZUJlZm9yZSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuZm9vdE5vdGVTcGFjZUFmdGVyKTtcblx0XHRcdFx0Zm9vdE5vdGVQb3NZID0gaGVpZ2h0IC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlQm90dG9tKSAtIGJvcmRlcldpZHRoIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmZvb3ROb3RlU3BhY2VBZnRlcik7XG5cdFx0XHRcdGlmKGNvbmZpZy5mb290Tm90ZUJhY2tncm91bmRDb2xvciAhPVwibm9uZVwiIHx8IGNvbmZpZy5mb290Tm90ZUJvcmRlcnMpIHtcblx0XHRcdFx0XHRmb290Tm90ZUhlaWdodCs9MiooTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmZvb3ROb3RlQm9yZGVyc1lTcGFjZSkpO1xuXHRcdFx0XHRcdGZvb3ROb3RlUG9zWS09TWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmZvb3ROb3RlQm9yZGVyc1lTcGFjZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoY29uZmlnLmZvb3ROb3RlQm9yZGVycykge1xuXHRcdFx0XHRcdGZvb3ROb3RlSGVpZ2h0Kz0yKihNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5mb290Tm90ZUJvcmRlcnNXaWR0aCkpO1xuXHRcdFx0XHRcdGZvb3ROb3RlUG9zWS09TWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuZm9vdE5vdGVCb3JkZXJzV2lkdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIHhBeGlzTGFiZWxcblx0XHRpZiAoZHJhd0F4aXMpIHtcblx0XHRcdGlmICh0eXBlb2YoY29uZmlnLnhBeGlzTGFiZWwpICE9IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0aWYgKGNvbmZpZy54QXhpc0xhYmVsLnRyaW0oKSAhPSBcIlwiKSB7XG5cdFx0XHRcdFx0eEF4aXNMYWJlbEhlaWdodCA9IChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy54QXhpc0ZvbnRTaXplKSkgKiAoY29uZmlnLnhBeGlzTGFiZWwuc3BsaXQoXCJcXG5cIikubGVuZ3RoIHx8IDEpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnhBeGlzTGFiZWxTcGFjZUJlZm9yZSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueEF4aXNMYWJlbFNwYWNlQWZ0ZXIpO1xuXHRcdFx0XHRcdHhBeGlzTGFiZWxQb3MgPSBoZWlnaHQgLSBib3JkZXJXaWR0aCAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUJvdHRvbSkgLSBmb290Tm90ZUhlaWdodCAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy54QXhpc0xhYmVsU3BhY2VBZnRlcik7XG5cdFx0XHRcdFx0aWYoY29uZmlnLnhBeGlzTGFiZWxCYWNrZ3JvdW5kQ29sb3IgIT1cIm5vbmVcIiB8fCBjb25maWcuZm9vdE5vdGVCb3JkZXJzKSB7XG5cdFx0XHRcdFx0XHR4QXhpc0xhYmVsSGVpZ2h0Kz0yKihNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueEF4aXNMYWJlbEJvcmRlcnNZU3BhY2UpKTtcblx0XHRcdFx0XHRcdHhBeGlzTGFiZWxQb3MtPU1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy54QXhpc0xhYmVsQm9yZGVyc1lTcGFjZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGNvbmZpZy5mb290Tm90ZUJvcmRlcnMpIHtcblx0XHRcdFx0XHRcdHhBeGlzTGFiZWxIZWlnaHQrPTIqKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnhBeGlzTGFiZWxCb3JkZXJzV2lkdGgpKTtcblx0XHRcdFx0XHRcdHhBeGlzTGFiZWxQb3MtPU1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLnhBeGlzTGFiZWxCb3JkZXJzV2lkdGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJvdHRvbU5vdFVzYWJsZUhlaWdodFdpdGhvdXRYTGFiZWxzID0gYm9yZGVyV2lkdGggKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VCb3R0b20pICsgZm9vdE5vdGVIZWlnaHQgKyB4QXhpc0xhYmVsSGVpZ2h0ICsgTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuZ3JhcGhTcGFjZUFmdGVyKTtcblxuXHRcdC8vIGNvbXB1dGUgc3BhY2UgZm9yIExlZ2VuZFxuXHRcdGlmICh0eXBlb2YoY29uZmlnLmxlZ2VuZCkgIT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0aWYgKGNvbmZpZy5sZWdlbmQgPT0gdHJ1ZSkge1xuXHRcdFx0XHRjdHguZm9udCA9IGNvbmZpZy5sZWdlbmRGb250U3R5bGUgKyBcIiBcIiArIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRGb250U2l6ZSkpLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgY29uZmlnLmxlZ2VuZEZvbnRGYW1pbHk7XG5cdFx0XHRcdHZhciB0ZXh0TGVuZ3RoO1xuXHRcdFx0XHRpZiAoZHJhd0xlZ2VuZE9uRGF0YSkge1xuXHRcdFx0XHRcdGZvciAoaSA9IGRhdGEuZGF0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoZGF0YS5kYXRhc2V0c1tpXS50aXRsZSkgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0XHRpZiAoZGF0YS5kYXRhc2V0c1tpXS50aXRsZS50cmltKCkgIT0gXCJcIikge1xuXHRcdFx0XHRcdFx0XHRcdG5iZWx0TGVnZW5kKys7XG5cdFx0XHRcdFx0XHRcdFx0dGV4dExlbmd0aCA9IGN0eC5tZWFzdXJlVGV4dChmbXRDaGFydEpTKGNvbmZpZywgZGF0YS5kYXRhc2V0c1tpXS50aXRsZSwgY29uZmlnLmZtdExlZ2VuZCkpLndpZHRoO1xuXHRcdFx0XHRcdFx0XHRcdC8vSWYgdGhlIHRleHQgbGVuZ3RoIGlzIGxvbmdlciAtIG1ha2UgdGhhdCBlcXVhbCB0byBsb25nZXN0IHRleHQhXG5cdFx0XHRcdFx0XHRcdFx0d2lkZXN0TGVnZW5kID0gKHRleHRMZW5ndGggPiB3aWRlc3RMZWdlbmQpID8gdGV4dExlbmd0aCA6IHdpZGVzdExlZ2VuZDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKGRhdGFbaV0udGl0bGUpID09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGRhdGFbaV0udGl0bGUudHJpbSgpICE9IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRuYmVsdExlZ2VuZCsrO1xuXHRcdFx0XHRcdFx0XHRcdHRleHRMZW5ndGggPSBjdHgubWVhc3VyZVRleHQoZm10Q2hhcnRKUyhjb25maWcsIGRhdGFbaV0udGl0bGUsIGNvbmZpZy5mbXRMZWdlbmQpKS53aWR0aDtcblx0XHRcdFx0XHRcdFx0XHQvL0lmIHRoZSB0ZXh0IGxlbmd0aCBpcyBsb25nZXIgLSBtYWtlIHRoYXQgZXF1YWwgdG8gbG9uZ2VzdCB0ZXh0IVxuXHRcdFx0XHRcdFx0XHRcdHdpZGVzdExlZ2VuZCA9ICh0ZXh0TGVuZ3RoID4gd2lkZXN0TGVnZW5kKSA/IHRleHRMZW5ndGggOiB3aWRlc3RMZWdlbmQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5iZWx0TGVnZW5kID4gMSB8fCAobmJlbHRMZWdlbmQgPT0gMSAmJiBjb25maWcuc2hvd1NpbmdsZUxlZ2VuZCkpIHtcblx0XHRcdFx0XHR3aWRlc3RMZWdlbmQgKz0gTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kQmxvY2tTaXplKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5Cb3hBbmRUZXh0KTtcblx0XHRcdFx0XHRpZihjb25maWcubGVnZW5kUG9zWT09MSB8fCBjb25maWcubGVnZW5kUG9zWT09MiB8fCBjb25maWcubGVnZW5kUG9zWT09Mykge1xuXHRcdFx0XHRcdFx0YXZhaWxhYmxlTGVnZW5kV2lkdGggPSBhdmFpbGFibGVXaWR0aC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlTGVmdFRleHQpKSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZVJpZ2h0VGV4dCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGF2YWlsYWJsZUxlZ2VuZFdpZHRoID0gd2lkdGggLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VMZWZ0KSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZVJpZ2h0KSAtIDIgKiAoYm9yZGVyV2lkdGgpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlTGVmdFRleHQpKSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZVJpZ2h0VGV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjb25maWcubGVnZW5kQm9yZGVycyA9PSB0cnVlKSBhdmFpbGFibGVMZWdlbmRXaWR0aCAtPSAyICogKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNTcGFjZUxlZnQpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNTcGFjZVJpZ2h0KTtcblx0XHRcdFx0XHRtYXhMZWdlbmRPbkxpbmUgPSBNaW4oW01hdGguZmxvb3IoKGF2YWlsYWJsZUxlZ2VuZFdpZHRoICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRIb3Jpem9udGFsKSkgLyAod2lkZXN0TGVnZW5kICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRIb3Jpem9udGFsKSkpLGNvbmZpZy5tYXhMZWdlbmRDb2xzXSk7XG5cdFx0XHRcdFx0bmJMZWdlbmRMaW5lcyA9IE1hdGguY2VpbChuYmVsdExlZ2VuZCAvIG1heExlZ2VuZE9uTGluZSk7XG5cdFx0XHRcdFx0bmJMZWdlbmRDb2xzID0gTWF0aC5jZWlsKG5iZWx0TGVnZW5kIC8gbmJMZWdlbmRMaW5lcyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBsZWdlbmRIZWlnaHQgPSBuYkxlZ2VuZExpbmVzICogKChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRGb250U2l6ZSkpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRWZXJ0aWNhbCkpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRWZXJ0aWNhbCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZWZvcmVUZXh0KSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUFmdGVyVGV4dCk7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKGNvbmZpZy5sZWdlbmRQb3NZKSB7XG5cdFx0XHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0XHRcdHhGaXJzdExlZ2VuZFRleHRQb3MgPSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VMZWZ0KSArICh3aWR0aCAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlUmlnaHQpIC0gbmJMZWdlbmRDb2xzICogKHdpZGVzdExlZ2VuZCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRIb3Jpem9udGFsKSkgLyAyO1xuXHRcdFx0XHRcdFx0XHRzcGFjZUxlZ2VuZEhlaWdodCA9IGxlZ2VuZEhlaWdodDtcblx0XHRcdFx0XHRcdFx0aWYgKGNvbmZpZy5sZWdlbmRCb3JkZXJzID09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHR5TGVnZW5kQm9yZGVyUG9zID0gdG9wTm90VXNhYmxlU2l6ZSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VCZWZvcmUpICsgKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkvMik7XG5cdFx0XHRcdFx0XHRcdFx0eUZpcnN0TGVnZW5kVGV4dFBvcyA9IHlMZWdlbmRCb3JkZXJQb3MgICsgKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkvMikgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZWZvcmVUZXh0KSsoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kRm9udFNpemUpKTtcblx0XHRcdFx0XHRcdFx0XHRzcGFjZUxlZ2VuZEhlaWdodCArPSAyICogTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1dpZHRoKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VCZWZvcmUpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNTcGFjZUFmdGVyKTtcblx0XHRcdFx0XHRcdFx0XHR4TGVnZW5kQm9yZGVyUG9zID0gTWF0aC5mbG9vcih4Rmlyc3RMZWdlbmRUZXh0UG9zIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlTGVmdFRleHQpIC0gKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkgLyAyKSk7XG5cdFx0XHRcdFx0XHRcdFx0bGVnZW5kQm9yZGVySGVpZ2h0ID0gTWF0aC5jZWlsKHNwYWNlTGVnZW5kSGVpZ2h0IC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1dpZHRoKSkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlQmVmb3JlKSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VBZnRlcik7XG5cdFx0XHRcdFx0XHRcdFx0bGVnZW5kQm9yZGVyV2lkdGggPSBNYXRoLmNlaWwobmJMZWdlbmRDb2xzICogKHdpZGVzdExlZ2VuZCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkpKSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlUmlnaHRUZXh0KSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUxlZnRUZXh0KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR5Rmlyc3RMZWdlbmRUZXh0UG9zID0gdG9wTm90VXNhYmxlU2l6ZSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VCZWZvcmUpICsgKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkvMik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoeUF4aXNVbml0SGVpZ2h0PjApIHtcblx0XHRcdFx0XHRcdFx0XHR5QXhpc1VuaXRQb3NZKz1zcGFjZUxlZ2VuZEhlaWdodDtcblx0XHRcdFx0XHRcdFx0XHRpZihjb25maWcubGVnZW5kQm9yZGVycz09dHJ1ZSl5TGVnZW5kQm9yZGVyUG9zLT15QXhpc1VuaXRIZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdFx0eUZpcnN0TGVnZW5kVGV4dFBvcy09eUF4aXNVbml0SGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRvcE5vdFVzYWJsZVNpemUgKz0gc3BhY2VMZWdlbmRIZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0XHRzcGFjZUxlZ2VuZEhlaWdodCA9IGxlZ2VuZEhlaWdodDtcblx0XHRcdFx0XHRcdFx0eEZpcnN0TGVnZW5kVGV4dFBvcyA9IE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpICsgKHdpZHRoIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlTGVmdCkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VSaWdodCkgLSBuYkxlZ2VuZENvbHMgKiAod2lkZXN0TGVnZW5kICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRIb3Jpem9udGFsKSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZXR3ZWVuVGV4dEhvcml6b250YWwpKSAvIDI7XG5cdFx0XHRcdFx0XHRcdHlGaXJzdExlZ2VuZFRleHRQb3MgPSB0b3BOb3RVc2FibGVTaXplICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmVmb3JlVGV4dCkrKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSk7XG5cdFx0XHRcdFx0XHRcdGlmIChjb25maWcubGVnZW5kQm9yZGVycyA9PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0eUZpcnN0TGVnZW5kVGV4dFBvcyArPSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlQmVmb3JlKStNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpO1xuXHRcdFx0XHRcdFx0XHRcdHlMZWdlbmRCb3JkZXJQb3MgPSB5Rmlyc3RMZWdlbmRUZXh0UG9zIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmVmb3JlVGV4dCkgLSAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kRm9udFNpemUpKSAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpIC8yICk7XG5cdFx0XHRcdFx0XHRcdFx0c3BhY2VMZWdlbmRIZWlnaHQgKz0gMiAqIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlQmVmb3JlKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VBZnRlcik7XG5cdFx0XHRcdFx0XHRcdFx0eExlZ2VuZEJvcmRlclBvcyA9IE1hdGguZmxvb3IoeEZpcnN0TGVnZW5kVGV4dFBvcyAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUxlZnRUZXh0KSAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpIC8gMikpO1xuXHRcdFx0XHRcdFx0XHRcdGxlZ2VuZEJvcmRlckhlaWdodCA9IE1hdGguY2VpbChzcGFjZUxlZ2VuZEhlaWdodCAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNTcGFjZUJlZm9yZSkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlQWZ0ZXIpO1xuXHRcdFx0XHRcdFx0XHRcdGxlZ2VuZEJvcmRlcldpZHRoID0gTWF0aC5jZWlsKG5iTGVnZW5kQ29scyAqICh3aWRlc3RMZWdlbmQgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZXR3ZWVuVGV4dEhvcml6b250YWwpKSkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZXR3ZWVuVGV4dEhvcml6b250YWwpICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1dpZHRoKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZVJpZ2h0VGV4dCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VMZWZ0VGV4dCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0XHRcdHNwYWNlTGVnZW5kSGVpZ2h0ID0gbGVnZW5kSGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHR4Rmlyc3RMZWdlbmRUZXh0UG9zID0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlTGVmdCkgKyAod2lkdGggLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VMZWZ0KSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZVJpZ2h0KSAtIG5iTGVnZW5kQ29scyAqICh3aWRlc3RMZWdlbmQgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZXR3ZWVuVGV4dEhvcml6b250YWwpKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkpIC8gMjtcblx0XHRcdFx0XHRcdFx0eUZpcnN0TGVnZW5kVGV4dFBvcyA9IHRvcE5vdFVzYWJsZVNpemUgKyAoaGVpZ2h0IC0gdG9wTm90VXNhYmxlU2l6ZSAtIGJvdHRvbU5vdFVzYWJsZUhlaWdodFdpdGhvdXRYTGFiZWxzIC0gc3BhY2VMZWdlbmRIZWlnaHQpIC8yICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmVmb3JlVGV4dCkrKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSk7XG5cdFx0XHRcdFx0XHRcdGlmIChjb25maWcubGVnZW5kQm9yZGVycyA9PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0eUZpcnN0TGVnZW5kVGV4dFBvcyArPSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlQmVmb3JlKSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VBZnRlcik7XG5cdFx0XHRcdFx0XHRcdFx0eUxlZ2VuZEJvcmRlclBvcyA9IHlGaXJzdExlZ2VuZFRleHRQb3MgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZWZvcmVUZXh0KSAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRGb250U2l6ZSkpIC0gKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkgLzIgKTtcblx0XHRcdFx0XHRcdFx0XHRzcGFjZUxlZ2VuZEhlaWdodCArPSAyICogTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1dpZHRoKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VCZWZvcmUpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNTcGFjZUFmdGVyKTtcblx0XHRcdFx0XHRcdFx0XHR4TGVnZW5kQm9yZGVyUG9zID0gTWF0aC5mbG9vcih4Rmlyc3RMZWdlbmRUZXh0UG9zIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlTGVmdFRleHQpIC0gKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkgLyAyKSk7XG5cdFx0XHRcdFx0XHRcdFx0bGVnZW5kQm9yZGVySGVpZ2h0ID0gTWF0aC5jZWlsKHNwYWNlTGVnZW5kSGVpZ2h0IC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1dpZHRoKSkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlQmVmb3JlKSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VBZnRlcik7XG5cdFx0XHRcdFx0XHRcdFx0bGVnZW5kQm9yZGVyV2lkdGggPSBNYXRoLmNlaWwobmJMZWdlbmRDb2xzICogKHdpZGVzdExlZ2VuZCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkpKSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlUmlnaHRUZXh0KSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUxlZnRUZXh0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgLTI6XG5cdFx0XHRcdFx0XHRcdHNwYWNlTGVnZW5kSGVpZ2h0ID0gbGVnZW5kSGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHR4Rmlyc3RMZWdlbmRUZXh0UG9zID0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlTGVmdCkgKyAod2lkdGggLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VMZWZ0KSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZVJpZ2h0KSAtIG5iTGVnZW5kQ29scyAqICh3aWRlc3RMZWdlbmQgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZXR3ZWVuVGV4dEhvcml6b250YWwpKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkpIC8gMjtcblx0XHRcdFx0XHRcdFx0eUZpcnN0TGVnZW5kVGV4dFBvcyA9IChoZWlnaHQgLSBzcGFjZUxlZ2VuZEhlaWdodCkgLzIgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZWZvcmVUZXh0KSsoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kRm9udFNpemUpKTtcblx0XHRcdFx0XHRcdFx0aWYgKGNvbmZpZy5sZWdlbmRCb3JkZXJzID09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHR5Rmlyc3RMZWdlbmRUZXh0UG9zICs9IE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VCZWZvcmUpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNTcGFjZUFmdGVyKTtcblx0XHRcdFx0XHRcdFx0XHR5TGVnZW5kQm9yZGVyUG9zID0geUZpcnN0TGVnZW5kVGV4dFBvcyAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJlZm9yZVRleHQpIC0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSkgLSAoTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1dpZHRoKSAvMiApO1xuXHRcdFx0XHRcdFx0XHRcdHNwYWNlTGVnZW5kSGVpZ2h0ICs9IDIgKiBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNTcGFjZUJlZm9yZSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlQWZ0ZXIpO1xuXHRcdFx0XHRcdFx0XHRcdHhMZWdlbmRCb3JkZXJQb3MgPSBNYXRoLmZsb29yKHhGaXJzdExlZ2VuZFRleHRQb3MgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VMZWZ0VGV4dCkgLSAoTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1dpZHRoKSAvIDIpKTtcblx0XHRcdFx0XHRcdFx0XHRsZWdlbmRCb3JkZXJIZWlnaHQgPSBNYXRoLmNlaWwoc3BhY2VMZWdlbmRIZWlnaHQgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpKSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VCZWZvcmUpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNTcGFjZUFmdGVyKTtcblx0XHRcdFx0XHRcdFx0XHRsZWdlbmRCb3JkZXJXaWR0aCA9IE1hdGguY2VpbChuYkxlZ2VuZENvbHMgKiAod2lkZXN0TGVnZW5kICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRIb3Jpem9udGFsKSkpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRIb3Jpem9udGFsKSArIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VSaWdodFRleHQpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlTGVmdFRleHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRcdFx0XHRzcGFjZUxlZ2VuZEhlaWdodCA9IGxlZ2VuZEhlaWdodDtcblx0XHRcdFx0XHRcdFx0eEZpcnN0TGVnZW5kVGV4dFBvcyA9IE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpICsgKHdpZHRoIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlTGVmdCkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VSaWdodCkgLSBuYkxlZ2VuZENvbHMgKiAod2lkZXN0TGVnZW5kICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRIb3Jpem9udGFsKSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZXR3ZWVuVGV4dEhvcml6b250YWwpKSAvIDI7XG5cdFx0XHRcdFx0XHRcdGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIHRvcE5vdFVzYWJsZVNpemUgLSBib3R0b21Ob3RVc2FibGVIZWlnaHRXaXRob3V0WExhYmVscztcblx0XHRcdFx0XHRcdFx0eUZpcnN0TGVnZW5kVGV4dFBvcyA9IHRvcE5vdFVzYWJsZVNpemUgKyBhdmFpbGFibGVIZWlnaHQgLSBzcGFjZUxlZ2VuZEhlaWdodCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJlZm9yZVRleHQpKyhNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRGb250U2l6ZSkpO1xuXHRcdFx0XHRcdFx0XHRpZiAoY29uZmlnLmxlZ2VuZEJvcmRlcnMgPT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdHlGaXJzdExlZ2VuZFRleHRQb3MgLT0gKE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VBZnRlcikrTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1dpZHRoKSk7XG5cdFx0XHRcdFx0XHRcdFx0eUxlZ2VuZEJvcmRlclBvcyA9IHlGaXJzdExlZ2VuZFRleHRQb3MgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZWZvcmVUZXh0KSAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRGb250U2l6ZSkpIC0gKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkgLzIgKTtcblx0XHRcdFx0XHRcdFx0XHRzcGFjZUxlZ2VuZEhlaWdodCArPSAyICogTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1dpZHRoKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VCZWZvcmUpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNTcGFjZUFmdGVyKTtcblx0XHRcdFx0XHRcdFx0XHR4TGVnZW5kQm9yZGVyUG9zID0gTWF0aC5mbG9vcih4Rmlyc3RMZWdlbmRUZXh0UG9zIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlTGVmdFRleHQpIC0gKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkgLyAyKSk7XG5cdFx0XHRcdFx0XHRcdFx0bGVnZW5kQm9yZGVySGVpZ2h0ID0gTWF0aC5jZWlsKHNwYWNlTGVnZW5kSGVpZ2h0IC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1dpZHRoKSkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlQmVmb3JlKSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VBZnRlcik7XG5cdFx0XHRcdFx0XHRcdFx0bGVnZW5kQm9yZGVyV2lkdGggPSBNYXRoLmNlaWwobmJMZWdlbmRDb2xzICogKHdpZGVzdExlZ2VuZCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkpKSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlUmlnaHRUZXh0KSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUxlZnRUZXh0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHNwYWNlTGVnZW5kSGVpZ2h0ID0gbGVnZW5kSGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHR5Rmlyc3RMZWdlbmRUZXh0UG9zID0gaGVpZ2h0IC0gYm9yZGVyV2lkdGggLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VCb3R0b20pIC0gZm9vdE5vdGVIZWlnaHQgLSBzcGFjZUxlZ2VuZEhlaWdodCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJlZm9yZVRleHQpICsgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSk7XG5cdFx0XHRcdFx0XHRcdHhGaXJzdExlZ2VuZFRleHRQb3MgPSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VMZWZ0KSArICh3aWR0aCAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlUmlnaHQpIC0gbmJMZWdlbmRDb2xzICogKHdpZGVzdExlZ2VuZCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRIb3Jpem9udGFsKSkgLyAyO1xuXHRcdFx0XHRcdFx0XHRpZiAoY29uZmlnLmxlZ2VuZEJvcmRlcnMgPT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdHNwYWNlTGVnZW5kSGVpZ2h0ICs9IDIgKiBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNTcGFjZUJlZm9yZSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlQWZ0ZXIpO1xuXHRcdFx0XHRcdFx0XHRcdHlGaXJzdExlZ2VuZFRleHRQb3MgLT0gKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlQWZ0ZXIpKTtcblx0XHRcdFx0XHRcdFx0XHR5TGVnZW5kQm9yZGVyUG9zID0gTWF0aC5mbG9vcihoZWlnaHQgLSBib3JkZXJXaWR0aCAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUJvdHRvbSkgLSBmb290Tm90ZUhlaWdodCAtIHNwYWNlTGVnZW5kSGVpZ2h0ICsgKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkgLyAyKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VCZWZvcmUpKTtcblx0XHRcdFx0XHRcdFx0XHR4TGVnZW5kQm9yZGVyUG9zID0gTWF0aC5mbG9vcih4Rmlyc3RMZWdlbmRUZXh0UG9zIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlTGVmdFRleHQpIC0gKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkgLyAyKSk7XG5cdFx0XHRcdFx0XHRcdFx0bGVnZW5kQm9yZGVySGVpZ2h0ID0gTWF0aC5jZWlsKHNwYWNlTGVnZW5kSGVpZ2h0IC0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1dpZHRoKSkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlQmVmb3JlKSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VBZnRlcik7XG5cdFx0XHRcdFx0XHRcdFx0bGVnZW5kQm9yZGVyV2lkdGggPSBNYXRoLmNlaWwobmJMZWdlbmRDb2xzICogKHdpZGVzdExlZ2VuZCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkpKSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlUmlnaHRUZXh0KSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUxlZnRUZXh0KTtcblx0XHRcdFx0XHRcdFx0fSBcblx0XHRcdFx0XHRcdFx0eEF4aXNMYWJlbFBvcyAtPSBzcGFjZUxlZ2VuZEhlaWdodDtcblx0XHRcdFx0XHRcdFx0Ym90dG9tTm90VXNhYmxlSGVpZ2h0V2l0aG91dFhMYWJlbHMgKz1zcGFjZUxlZ2VuZEhlaWdodDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVx0XHRcblx0XHRcdFx0XHR2YXIgZnVsbExlZ2VuZFdpZHRoPU1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZVJpZ2h0VGV4dCkgKyBuYkxlZ2VuZENvbHMgKiAod2lkZXN0TGVnZW5kICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRIb3Jpem9udGFsKSkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZXR3ZWVuVGV4dEhvcml6b250YWwpICtNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VMZWZ0VGV4dCk7XG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5sZWdlbmRCb3JkZXJzID09IHRydWUpIHtcblx0XHRcdFx0XHRcdGZ1bGxMZWdlbmRXaWR0aCs9MipNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpK01hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzU3BhY2VMZWZ0KStNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlUmlnaHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHN3aXRjaCAoY29uZmlnLmxlZ2VuZFBvc1gpIHtcblx0XHRcdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdFx0eEZpcnN0TGVnZW5kVGV4dFBvcyA9IE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpICsgY29uZmlnLmNhbnZhc0JvcmRlcnMgKiBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5jYW52YXNCb3JkZXJzV2lkdGgpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlTGVmdFRleHQpOyAgXG5cdFx0XHRcdFx0XHRcdGlmIChjb25maWcubGVnZW5kQm9yZGVycyA9PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0eEZpcnN0TGVnZW5kVGV4dFBvcyArPSAoTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1dpZHRoKS8yKStNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlTGVmdCk7XG5cdFx0XHRcdFx0XHRcdFx0eExlZ2VuZEJvcmRlclBvcyA9IE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpICsgY29uZmlnLmNhbnZhc0JvcmRlcnMgKiBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5jYW52YXNCb3JkZXJzV2lkdGgpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNTcGFjZUxlZnQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGNvbmZpZy5sZWdlbmRQb3NYPT0wICYmICgoY29uZmlnLmxlZ2VuZFBvc1k+PTEgJiYgY29uZmlnLmxlZ2VuZFBvc1kgPD0zKSB8fCBjb25maWcubGVnZW5kUG9zWT09LTIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGVmdE5vdFVzYWJsZVNpemUrPWZ1bGxMZWdlbmRXaWR0aDtcblx0XHRcdFx0XHRcdFx0XHR5QXhpc0xhYmVsUG9zTGVmdCs9ZnVsbExlZ2VuZFdpZHRoO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0XHR4Rmlyc3RMZWdlbmRUZXh0UG9zID0gbGVmdE5vdFVzYWJsZVNpemUgKyAod2lkdGggLSByaWdodE5vdFVzYWJsZVNpemUgLSBsZWZ0Tm90VXNhYmxlU2l6ZSkvMiAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VMZWZ0VGV4dCktTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlUmlnaHRUZXh0KSkgLSAobmJMZWdlbmRDb2xzICogKHdpZGVzdExlZ2VuZCArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5UZXh0SG9yaXpvbnRhbCkpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRIb3Jpem9udGFsKSkgLyAyOyAgXG5cdFx0XHRcdFx0XHRcdGlmIChjb25maWcubGVnZW5kQm9yZGVycyA9PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0eEZpcnN0TGVnZW5kVGV4dFBvcyAtPSAoKE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkvMikgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kQm9yZGVyc1NwYWNlUmlnaHQpKTtcblx0XHRcdFx0XHRcdFx0XHR4TGVnZW5kQm9yZGVyUG9zID0geEZpcnN0TGVnZW5kVGV4dFBvcyAtIE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCkvMiAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUxlZnRUZXh0KSA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGlmKChjb25maWcubGVnZW5kUG9zWT49MSAmJiBjb25maWcubGVnZW5kUG9zWSA8PTMpIHx8IGNvbmZpZy5sZWdlbmRQb3NZPT0tMikge1xuXHRcdFx0XHRcdFx0XHRcdHJpZ2h0Tm90VXNhYmxlU2l6ZSs9ZnVsbExlZ2VuZFdpZHRoO1xuXHRcdFx0XHRcdFx0XHRcdHlBeGlzTGFiZWxQb3NSaWdodC09ZnVsbExlZ2VuZFdpZHRoO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHRcdHhGaXJzdExlZ2VuZFRleHRQb3MgPSB3aWR0aCAtIHJpZ2h0Tm90VXNhYmxlU2l6ZSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZVJpZ2h0VGV4dCkgLSBuYkxlZ2VuZENvbHMgKiAod2lkZXN0TGVnZW5kICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZFNwYWNlQmV0d2VlblRleHRIb3Jpem9udGFsKSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZXR3ZWVuVGV4dEhvcml6b250YWwpIC8gMjsgIFxuXHRcdFx0XHRcdFx0XHRpZiAoY29uZmlnLmxlZ2VuZEJvcmRlcnMgPT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdHhGaXJzdExlZ2VuZFRleHRQb3MgLT0gKChNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpLzIpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNTcGFjZVJpZ2h0KSk7XG5cdFx0XHRcdFx0XHRcdFx0eExlZ2VuZEJvcmRlclBvcyA9IHhGaXJzdExlZ2VuZFRleHRQb3MgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5sZWdlbmRCb3JkZXJzV2lkdGgpLzIgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VMZWZ0VGV4dCkgO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGNvbmZpZy5sZWdlbmRQb3NYPT00ICYmICgoY29uZmlnLmxlZ2VuZFBvc1k+PTEgJiYgY29uZmlnLmxlZ2VuZFBvc1kgPD0zKSB8fCBjb25maWcubGVnZW5kUG9zWT09LTIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmlnaHROb3RVc2FibGVTaXplKz1mdWxsTGVnZW5kV2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0eUF4aXNMYWJlbFBvc1JpZ2h0LT1mdWxsTGVnZW5kV2lkdGg7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoY29uZmlnLmxlZ2VuZEJvcmRlcnM9PXRydWUpIHtcblx0XHRcdFx0XHRcdHlMZWdlbmRCb3JkZXJQb3MrPU1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRZUGFkZGluZyk7XG5cdFx0XHRcdFx0XHR4TGVnZW5kQm9yZGVyUG9zKz1NYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kWFBhZGRpbmcpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHlGaXJzdExlZ2VuZFRleHRQb3MrPU1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRZUGFkZGluZyk7XHRcblx0XHRcdFx0XHR4Rmlyc3RMZWdlbmRUZXh0UG9zKz1NYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kWFBhZGRpbmcpO1x0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdH1cblx0XHR4TGFiZWxXaWR0aCA9IDA7XG5cdFx0Ym90dG9tTm90VXNhYmxlSGVpZ2h0V2l0aFhMYWJlbHMgPSBib3R0b21Ob3RVc2FibGVIZWlnaHRXaXRob3V0WExhYmVscztcblx0XHRpZiAoZHJhd0F4aXMgJiYgKGNvbmZpZy54QXhpc0JvdHRvbSB8fCBjb25maWcueEF4aXNUb3ApKSB7XG5cdFx0XHR2YXIgd2lkZXN0TGFiZWwsaGlnaGVzdExhYmVsO1x0XHRcblx0XHRcdGlmIChyZXZlcnNlQXhpcyA9PSBmYWxzZSkge1xuXHRcdFx0XHR3aWRlc3RMYWJlbCA9IHdpZGVzdFhMYWJlbDtcblx0XHRcdFx0aGlnaGVzdExhYmVsID0gaGlnaGVzdFhMYWJlbDtcblx0XHRcdFx0bmJsYWIgPSBkYXRhLmxhYmVscy5sZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aWRlc3RMYWJlbCA9IHdpZGVzdFlMYWJlbDtcblx0XHRcdFx0aGlnaGVzdExhYmVsID0gaGlnaGVzdFlMYWJlbDtcblx0XHRcdFx0bmJsYWIgPSB5bGFiZWxzLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcucm90YXRlTGFiZWxzID09IFwic21hcnRcIikge1xuXHRcdFx0XHRyb3RhdGVMYWJlbHMgPSAwO1xuXHRcdFx0XHRpZiAoKGF2YWlsYWJsZVdpZHRoICsgTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcueEF4aXNTcGFjZUJldHdlZW5MYWJlbHMpKSAvIG5ibGFiIDwgKHdpZGVzdExhYmVsICsgTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcueEF4aXNTcGFjZUJldHdlZW5MYWJlbHMpKSkge1xuXHRcdFx0XHRcdHJvdGF0ZUxhYmVscyA9IDQ1O1xuXHRcdFx0XHRcdGlmIChhdmFpbGFibGVXaWR0aCAvIG5ibGFiIDwgTWF0aC5hYnMoTWF0aC5jb3Mocm90YXRlTGFiZWxzICogTWF0aC5QSSAvIDE4MCkgKiB3aWRlc3RMYWJlbCkpIHtcblx0XHRcdFx0XHRcdHJvdGF0ZUxhYmVscyA9IDkwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cm90YXRlTGFiZWxzID0gY29uZmlnLnJvdGF0ZUxhYmVsc1xuXHRcdFx0XHRpZiAocm90YXRlTGFiZWxzIDwgMCkgcm90YXRlTGFiZWxzID0gMDtcblx0XHRcdFx0aWYgKHJvdGF0ZUxhYmVscyA+IDE4MCkgcm90YXRlTGFiZWxzID0gMTgwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJvdGF0ZUxhYmVscyA+IDkwKSByb3RhdGVMYWJlbHMgKz0gMTgwO1xuXHRcdFx0eExhYmVsSGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90YXRlTGFiZWxzICogTWF0aC5QSSAvIDE4MCkgKiB3aWRlc3RMYWJlbCkgKyBNYXRoLmFicyhNYXRoLnNpbigocm90YXRlTGFiZWxzICsgOTApICogTWF0aC5QSSAvIDE4MCkgKiBoaWdoZXN0TGFiZWwpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnhBeGlzU3BhY2VCZWZvcmUpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnhBeGlzU3BhY2VBZnRlcik7XG5cdFx0XHR4TGFiZWxQb3MgPSBoZWlnaHQgLSBib3JkZXJXaWR0aCAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUJvdHRvbSkgLSBmb290Tm90ZUhlaWdodCAtIHhBeGlzTGFiZWxIZWlnaHQgLSAoeExhYmVsSGVpZ2h0IC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnhBeGlzU3BhY2VCZWZvcmUpKSAtIE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmdyYXBoU3BhY2VBZnRlcik7XG5cdFx0XHR4TGFiZWxXaWR0aCA9IE1hdGguYWJzKE1hdGguY29zKHJvdGF0ZUxhYmVscyAqIE1hdGguUEkgLyAxODApICogd2lkZXN0TGFiZWwpICsgTWF0aC5hYnMoTWF0aC5jb3MoKHJvdGF0ZUxhYmVscyArIDkwKSAqIE1hdGguUEkgLyAxODApICogaGlnaGVzdExhYmVsKTtcblx0XHRcdGxlZnROb3RVc2FibGVTaXplID0gTWF4KFtsZWZ0Tm90VXNhYmxlU2l6ZSwgYm9yZGVyV2lkdGggKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VMZWZ0KSArIHhMYWJlbFdpZHRoIC8gMl0pO1xuXHRcdFx0cmlnaHROb3RVc2FibGVTaXplID0gTWF4KFtyaWdodE5vdFVzYWJsZVNpemUsIGJvcmRlcldpZHRoICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlUmlnaHQpICsgeExhYmVsV2lkdGggLyAyXSk7XG5cdFx0XHRhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbGVmdE5vdFVzYWJsZVNpemUgLSByaWdodE5vdFVzYWJsZVNpemU7XG5cdFx0XHRpZiAoY29uZmlnLmxlZ2VuZCAmJiBjb25maWcueEF4aXNCb3R0b20gJiYgY29uZmlnLmxlZ2VuZFBvc1k9PTQpIHtcblx0XHRcdFx0eExhYmVsUG9zLT1zcGFjZUxlZ2VuZEhlaWdodDtcblx0XHRcdH0gXG5cdFx0XHRib3R0b21Ob3RVc2FibGVIZWlnaHRXaXRoWExhYmVscyA9IGJvdHRvbU5vdFVzYWJsZUhlaWdodFdpdGhvdXRYTGFiZWxzICsgeExhYmVsSGVpZ2h0IDtcblx0XHR9ICBlbHNlIHtcblx0XHRcdGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBsZWZ0Tm90VXNhYmxlU2l6ZSAtIHJpZ2h0Tm90VXNhYmxlU2l6ZTtcblx0XHR9XG5cblx0XHRhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSB0b3BOb3RVc2FibGVTaXplIC0gYm90dG9tTm90VXNhYmxlSGVpZ2h0V2l0aFhMYWJlbHM7XG5cblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBEUkFXIEVYVEVSTkFMIEVMRU1FTlRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRkaXNwQ3Jvc3NJbWFnZShjdHgsIGNvbmZpZywgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIGZhbHNlLCBkYXRhLCAtMSwgLTEpO1xuXG5cdFx0aWYodHlwZW9mIGNvbmZpZy5pbml0RnVuY3Rpb24gPT0gXCJmdW5jdGlvblwiKSBjb25maWcuaW5pdEZ1bmN0aW9uKFwiSU5JVEZVTkNUSU9OXCIsY3R4LGRhdGEsbnVsbCwtMSwtMSx7YW5pbWF0aW9uVmFsdWUgOiAwLCBjbnRpdGVyOiAwLCBjb25maWcgOiBjb25maWcsIGJvcmRlclggOiAwLCBib3JkZXJZIDogMCwgbWlkUG9zWCA6IDAsIG1pZFBvc1kgOiAwfSk7XG5cbiBcdFx0XG5cdFx0IGlmICh5bGFiZWxzICE9IFwibmloaWxcIikge1xuXHRcdFx0Ly8gRHJhdyBCb3JkZXJzXG5cdFx0XHRpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG5cdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGNvbmZpZy5jYW52YXNCb3JkZXJzU3R5bGUpKTtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY29uZmlnLmNhbnZhc0JvcmRlcnNDb2xvcjtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuXHRcdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oY29uZmlnLmNhbnZhc0JvcmRlcnNTdHlsZSkpO1xuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuY2FudmFzQm9yZGVyc0NvbG9yO1xuXHRcdFx0XHRjdHguZHJhd1JlY3RhbmdsZSh7eDowK2JvcmRlcldpZHRoLzIseTowK2JvcmRlcldpZHRoLzIsd2lkdGg6d2lkdGgtYm9yZGVyV2lkdGgsaGVpZ2h0OmhlaWdodC1ib3JkZXJXaWR0aCxib3JkZXJSYWRpdXM6Y29uZmlnLmNhbnZhc0JvcmRlcnNSYWRpdXMsZmlsbDpmYWxzZSxzdHJva2U6dHJ1ZX0pXG5cdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBEcmF3IEdyYXBoIFRpdGxlXG5cdFx0XHRpZiAoZ3JhcGhUaXRsZUhlaWdodCA+IDApIHtcblx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHguZm9udCA9IGNvbmZpZy5ncmFwaFRpdGxlRm9udFN0eWxlICsgXCIgXCIgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuZ3JhcGhUaXRsZUZvbnRTaXplKSkudG9TdHJpbmcoKSArIFwicHggXCIgKyBjb25maWcuZ3JhcGhUaXRsZUZvbnRGYW1pbHk7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBjb25maWcuZ3JhcGhUaXRsZUZvbnRDb2xvcjtcblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuXG5cdFx0XHRcdHNldFRleHRCb3JkZXJzQW5kQmFja2dyb3VuZChjdHgsY29uZmlnLmdyYXBoVGl0bGUsKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmdyYXBoVGl0bGVGb250U2l6ZSkpLE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpICsgKHdpZHRoIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlTGVmdCkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VSaWdodCkpIC8gMixncmFwaFRpdGxlUG9zWSxjb25maWcuZ3JhcGhUaXRsZUJvcmRlcnMsY29uZmlnLmdyYXBoVGl0bGVCb3JkZXJzQ29sb3IsTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuZ3JhcGhUaXRsZUJvcmRlcnNXaWR0aCksTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmdyYXBoVGl0bGVCb3JkZXJzWFNwYWNlKSxNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuZ3JhcGhUaXRsZUJvcmRlcnNZU3BhY2UpLGNvbmZpZy5ncmFwaFRpdGxlQm9yZGVyc1N0eWxlLGNvbmZpZy5ncmFwaFRpdGxlQmFja2dyb3VuZENvbG9yLFwiR1JBUEhUSVRMRVwiLGNvbmZpZy5ncmFwaFRpdGxlQm9yZGVyc1JhZGl1cyk7XG5cblx0XHRcdFx0Y3R4LnRyYW5zbGF0ZShNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VMZWZ0KSArICh3aWR0aCAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlUmlnaHQpKSAvIDIsIGdyYXBoVGl0bGVQb3NZKTtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGNvbmZpZy5ncmFwaFRpdGxlLCAwLCAwLCBjdHgudGV4dEJhc2VsaW5lLCAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuZ3JhcGhUaXRsZUZvbnRTaXplKSksdHJ1ZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiVElUTEVfVEVYVE1PVVNFXCIsMCxNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VMZWZ0KSArICh3aWR0aCAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlUmlnaHQpKSAvIDIsIGdyYXBoVGl0bGVQb3NZLC0xLC0xKTtcblxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBEcmF3IEdyYXBoIFN1Yi1UaXRsZVxuXHRcdFx0aWYgKGdyYXBoU3ViVGl0bGVIZWlnaHQgPiAwKSB7XG5cdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmZvbnQgPSBjb25maWcuZ3JhcGhTdWJUaXRsZUZvbnRTdHlsZSArIFwiIFwiICsgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmdyYXBoU3ViVGl0bGVGb250U2l6ZSkpLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgY29uZmlnLmdyYXBoU3ViVGl0bGVGb250RmFtaWx5O1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gY29uZmlnLmdyYXBoU3ViVGl0bGVGb250Q29sb3I7XG5cdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuXHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcblx0XHRcdFx0c2V0VGV4dEJvcmRlcnNBbmRCYWNrZ3JvdW5kKGN0eCxjb25maWcuZ3JhcGhTdWJUaXRsZSwoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuZ3JhcGhTdWJUaXRsZUZvbnRTaXplKSksTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlTGVmdCkgKyAod2lkdGggLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VMZWZ0KSAtIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZVJpZ2h0KSkgLyAyLGdyYXBoU3ViVGl0bGVQb3NZLGNvbmZpZy5ncmFwaFN1YlRpdGxlQm9yZGVycyxjb25maWcuZ3JhcGhTdWJUaXRsZUJvcmRlcnNDb2xvcixNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5ncmFwaFN1YlRpdGxlQm9yZGVyc1dpZHRoKSxNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuZ3JhcGhTdWJUaXRsZUJvcmRlcnNYU3BhY2UpLE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5ncmFwaFN1YlRpdGxlQm9yZGVyc1lTcGFjZSksY29uZmlnLmdyYXBoU3ViVGl0bGVCb3JkZXJzU3R5bGUsY29uZmlnLmdyYXBoU3ViVGl0bGVCYWNrZ3JvdW5kQ29sb3IsXCJHUkFQSFNVQlRJVExFXCIsY29uZmlnLmdyYXBoU3ViVGl0bGVCb3JkZXJzUmFkaXVzKTtcblxuXHRcdFx0XHRjdHgudHJhbnNsYXRlKE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpICsgKHdpZHRoIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlTGVmdCkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VSaWdodCkpIC8gMiwgZ3JhcGhTdWJUaXRsZVBvc1kpO1xuXHRcdFx0XHRjdHguZmlsbFRleHRNdWx0aUxpbmUoY29uZmlnLmdyYXBoU3ViVGl0bGUsIDAsIDAsIGN0eC50ZXh0QmFzZWxpbmUsIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5ncmFwaFN1YlRpdGxlRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJTVUJUSVRMRV9URVhUTU9VU0VcIiwwLE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUxlZnQpICsgKHdpZHRoIC0gTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlTGVmdCkgLSBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VSaWdodCkpIC8gMiwgZ3JhcGhTdWJUaXRsZVBvc1ksLTEsLTEpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBEcmF3IFkgQXhpcyBVbml0XG5cdFx0XHRpZiAoeUF4aXNVbml0SGVpZ2h0ID4gMCkge1xuXHRcdFx0XHRpZiAoY29uZmlnLnlBeGlzTGVmdCkge1xuXHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5mb250ID0gY29uZmlnLnlBeGlzVW5pdEZvbnRTdHlsZSArIFwiIFwiICsgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnlBeGlzVW5pdEZvbnRTaXplKSkudG9TdHJpbmcoKSArIFwicHggXCIgKyBjb25maWcueUF4aXNVbml0Rm9udEZhbWlseTtcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gY29uZmlnLnlBeGlzVW5pdEZvbnRDb2xvcjtcblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcblx0XHRcblx0XHRcdFx0XHRzZXRUZXh0Qm9yZGVyc0FuZEJhY2tncm91bmQoY3R4LGNvbmZpZy55QXhpc1VuaXQsKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnlBeGlzVW5pdEZvbnRTaXplKSksbGVmdE5vdFVzYWJsZVNpemUsIHlBeGlzVW5pdFBvc1ksY29uZmlnLnlBeGlzVW5pdEJvcmRlcnMsY29uZmlnLnlBeGlzVW5pdEJvcmRlcnNDb2xvcixNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy55QXhpc1VuaXRCb3JkZXJzV2lkdGgpLE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc1VuaXRCb3JkZXJzWFNwYWNlKSxNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNVbml0Qm9yZGVyc1lTcGFjZSksY29uZmlnLnlBeGlzVW5pdEJvcmRlcnNTdHlsZSxjb25maWcueUF4aXNVbml0QmFja2dyb3VuZENvbG9yLFwiWUFYSVNVTklUXCIsY29uZmlnLnlBeGlzVW5pdEJvcmRlcnNSYWRpdXMpO1xuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUobGVmdE5vdFVzYWJsZVNpemUsIHlBeGlzVW5pdFBvc1kpO1xuXHRcdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShjb25maWcueUF4aXNVbml0LCAwLCAwLCBjdHgudGV4dEJhc2VsaW5lLCAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcueUF4aXNVbml0Rm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJZTEVGVEFYSVNVTklUX1RFWFRNT1VTRVwiLDAsbGVmdE5vdFVzYWJsZVNpemUsIHlBeGlzVW5pdFBvc1ksLTEsLTEpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjb25maWcueUF4aXNSaWdodCkge1xuXHRcdFx0XHRcdGlmIChjb25maWcueUF4aXNVbml0MiA9PSAnJykgY29uZmlnLnlBeGlzVW5pdDIgPSBjb25maWcueUF4aXNVbml0O1xuXHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5mb250ID0gY29uZmlnLnlBeGlzVW5pdEZvbnRTdHlsZSArIFwiIFwiICsgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnlBeGlzVW5pdEZvbnRTaXplKSkudG9TdHJpbmcoKSArIFwicHggXCIgKyBjb25maWcueUF4aXNVbml0Rm9udEZhbWlseTtcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gY29uZmlnLnlBeGlzVW5pdEZvbnRDb2xvcjtcblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcblx0XHRcdFx0XHRzZXRUZXh0Qm9yZGVyc0FuZEJhY2tncm91bmQoY3R4LGNvbmZpZy55QXhpc1VuaXQyLChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy55QXhpc1VuaXRGb250U2l6ZSkpLHdpZHRoIC0gcmlnaHROb3RVc2FibGVTaXplLCB5QXhpc1VuaXRQb3NZLGNvbmZpZy55QXhpc1VuaXRCb3JkZXJzLGNvbmZpZy55QXhpc1VuaXRCb3JkZXJzQ29sb3IsTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcueUF4aXNVbml0Qm9yZGVyc1dpZHRoKSxNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNVbml0Qm9yZGVyc1hTcGFjZSksTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnlBeGlzVW5pdEJvcmRlcnNZU3BhY2UpLGNvbmZpZy55QXhpc1VuaXRCb3JkZXJzU3R5bGUsY29uZmlnLnlBeGlzVW5pdEJhY2tncm91bmRDb2xvcixcIllBWElTVU5JVFwiLGNvbmZpZy55QXhpc1VuaXRCb3JkZXJzUmFkaXVzKTtcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHdpZHRoIC0gcmlnaHROb3RVc2FibGVTaXplLCB5QXhpc1VuaXRQb3NZKTtcblx0XHRcdFx0XHRjdHguZmlsbFRleHRNdWx0aUxpbmUoY29uZmlnLnlBeGlzVW5pdDIsIDAsIDAsIGN0eC50ZXh0QmFzZWxpbmUsIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy55QXhpc1VuaXRGb250U2l6ZSkpLHRydWUsY29uZmlnLmRldGVjdE1vdXNlT25UZXh0LGN0eCxcIllSSUdIVEFYSVNVTklUX1RFWFRNT1VTRVwiLDAsd2lkdGggLSByaWdodE5vdFVzYWJsZVNpemUsIHlBeGlzVW5pdFBvc1ksLTEsLTEpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBEcmF3IFkgQXhpcyBMYWJlbFxuXHRcdFx0aWYgKHlBeGlzTGFiZWxXaWR0aCA+IDApIHtcblx0XHRcdFx0aWYgKGNvbmZpZy55QXhpc0xlZnQpIHtcblx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRjdHguZm9udCA9IGNvbmZpZy55QXhpc0ZvbnRTdHlsZSArIFwiIFwiICsgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnlBeGlzRm9udFNpemUpKS50b1N0cmluZygpICsgXCJweCBcIiArIGNvbmZpZy55QXhpc0ZvbnRGYW1pbHk7XG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGNvbmZpZy55QXhpc0ZvbnRDb2xvcjtcblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcblxuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoeUF4aXNMYWJlbFBvc0xlZnQsIHRvcE5vdFVzYWJsZVNpemUgKyAoYXZhaWxhYmxlSGVpZ2h0IC8gMikpO1xuXHRcdFx0XHRcdGN0eC5yb3RhdGUoLSg5MCAqIChNYXRoLlBJIC8gMTgwKSkpO1xuXHRcdFx0XHRcdHNldFRleHRCb3JkZXJzQW5kQmFja2dyb3VuZChjdHgsY29uZmlnLnlBeGlzTGFiZWwsKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnlBeGlzRm9udFNpemUpKSwgMCwwLCBjb25maWcueUF4aXNMYWJlbEJvcmRlcnMsY29uZmlnLnlBeGlzTGFiZWxCb3JkZXJzQ29sb3IsTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcueUF4aXNMYWJlbEJvcmRlcnNXaWR0aCksTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnlBeGlzTGFiZWxCb3JkZXJzWFNwYWNlKSxNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNMYWJlbEJvcmRlcnNZU3BhY2UpLGNvbmZpZy55QXhpc0xhYmVsQm9yZGVyc1N0eWxlLGNvbmZpZy55QXhpc0xhYmVsQmFja2dyb3VuZENvbG9yLFwiWUFYSVNMQUJFTExFRlRcIixjb25maWcueUF4aXNMYWJlbEJvcmRlcnNSYWRpdXMpO1xuXHRcdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShjb25maWcueUF4aXNMYWJlbCwgMCwgMCwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnlBeGlzRm9udFNpemUpKSxmYWxzZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiWUxFRlRBWElTTEFCRUxfVEVYVE1PVVNFXCIsLSg5MCAqIChNYXRoLlBJIC8gMTgwKSkseUF4aXNMYWJlbFBvc0xlZnQsIHRvcE5vdFVzYWJsZVNpemUgKyAoYXZhaWxhYmxlSGVpZ2h0IC8gMiksLTEsLTEpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjb25maWcueUF4aXNSaWdodCkge1xuXHRcdFx0XHRcdGlmIChjb25maWcueUF4aXNMYWJlbDIgPT0gJycpIGNvbmZpZy55QXhpc0xhYmVsMiA9IGNvbmZpZy55QXhpc0xhYmVsO1xuXHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5mb250ID0gY29uZmlnLnlBeGlzRm9udFN0eWxlICsgXCIgXCIgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcueUF4aXNGb250U2l6ZSkpLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgY29uZmlnLnlBeGlzRm9udEZhbWlseTtcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gY29uZmlnLnlBeGlzRm9udENvbG9yO1xuXHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuXHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoeUF4aXNMYWJlbFBvc1JpZ2h0LCB0b3BOb3RVc2FibGVTaXplICsgKGF2YWlsYWJsZUhlaWdodCAvIDIpKTtcblx0XHRcdFx0XHRjdHgucm90YXRlKCsoOTAgKiAoTWF0aC5QSSAvIDE4MCkpKTtcblx0XHRcdFx0XHRzZXRUZXh0Qm9yZGVyc0FuZEJhY2tncm91bmQoY3R4LGNvbmZpZy55QXhpc0xhYmVsMiwoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcueUF4aXNGb250U2l6ZSkpLCAwLDAsIGNvbmZpZy55QXhpc0xhYmVsQm9yZGVycyxjb25maWcueUF4aXNMYWJlbEJvcmRlcnNDb2xvcixNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy55QXhpc0xhYmVsQm9yZGVyc1dpZHRoKSxNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueUF4aXNMYWJlbEJvcmRlcnNYU3BhY2UpLE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy55QXhpc0xhYmVsQm9yZGVyc1lTcGFjZSksY29uZmlnLnlBeGlzTGFiZWxCb3JkZXJzU3R5bGUsY29uZmlnLnlBeGlzTGFiZWxCYWNrZ3JvdW5kQ29sb3IsXCJZQVhJU0xBQkVMTEVGVFwiLGNvbmZpZy55QXhpc0xhYmVsQm9yZGVyc1JhZGl1cyk7XG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKGNvbmZpZy55QXhpc0xhYmVsMiwgMCwgMCwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnlBeGlzRm9udFNpemUpKSxmYWxzZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiWVJJR0hUQVhJU0xBQkVMX1RFWFRNT1VTRVwiLCsoOTAgKiAoTWF0aC5QSSAvIDE4MCkpLHlBeGlzTGFiZWxQb3NSaWdodCwgdG9wTm90VXNhYmxlU2l6ZSArIChhdmFpbGFibGVIZWlnaHQgLyAyKSwtMSwtMSk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIERyYXcgWCBBeGlzIExhYmVsXG5cdFx0XHRpZiAoeEF4aXNMYWJlbEhlaWdodCA+IDApIHtcblx0XHRcdFx0aWYgKGNvbmZpZy54QXhpc0JvdHRvbSkge1xuXHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5mb250ID0gY29uZmlnLnhBeGlzRm9udFN0eWxlICsgXCIgXCIgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcueEF4aXNGb250U2l6ZSkpLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgY29uZmlnLnhBeGlzRm9udEZhbWlseTtcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gY29uZmlnLnhBeGlzRm9udENvbG9yO1xuXHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuXHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuXHRcdFx0XHRcdHNldFRleHRCb3JkZXJzQW5kQmFja2dyb3VuZChjdHgsY29uZmlnLnhBeGlzTGFiZWwsKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnhBeGlzRm9udFNpemUpKSxsZWZ0Tm90VXNhYmxlU2l6ZSArIChhdmFpbGFibGVXaWR0aCAvIDIpLCB4QXhpc0xhYmVsUG9zLGNvbmZpZy54QXhpc0xhYmVsQm9yZGVycyxjb25maWcueEF4aXNMYWJlbEJvcmRlcnNDb2xvcixNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy54QXhpc0xhYmVsQm9yZGVyc1dpZHRoKSxNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcueEF4aXNMYWJlbEJvcmRlcnNYU3BhY2UpLE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy54QXhpc0xhYmVsQm9yZGVyc1lTcGFjZSksY29uZmlnLnhBeGlzTGFiZWxCb3JkZXJzU3R5bGUsY29uZmlnLnhBeGlzTGFiZWxCYWNrZ3JvdW5kQ29sb3IsXCJYQVhJU0xBQkVMXCIsY29uZmlnLnhBeGlzTGFiZWxCb3JkZXJzUmFkaXVzKTtcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKGxlZnROb3RVc2FibGVTaXplICsgKGF2YWlsYWJsZVdpZHRoIC8gMiksIHhBeGlzTGFiZWxQb3MpO1xuXHRcdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShjb25maWcueEF4aXNMYWJlbCwgMCwgMCwgY3R4LnRleHRCYXNlbGluZSwgKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLnhBeGlzRm9udFNpemUpKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJYQVhJU0xBQkVMX1RFWFRNT1VTRVwiLDAsbGVmdE5vdFVzYWJsZVNpemUgKyAoYXZhaWxhYmxlV2lkdGggLyAyKSwgeEF4aXNMYWJlbFBvcywtMSwtMSk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIERyYXcgTGVnZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVnZW5kTXNyO1xuXHRcdFx0aWYgKG5iZWx0TGVnZW5kID4gMSB8fCAobmJlbHRMZWdlbmQgPT0gMSAmJiBjb25maWcuc2hvd1NpbmdsZUxlZ2VuZCkpIHtcblx0XHRcdFx0bGVnZW5kTXNyPXtkaXNwTGVnZW5kIDogdHJ1ZSwgeExlZ2VuZEJvcmRlclBvcyA6IHhMZWdlbmRCb3JkZXJQb3MsXG5cdFx0XHRcdFx0ICAgeUxlZ2VuZEJvcmRlclBvcyA6IHlMZWdlbmRCb3JkZXJQb3MsIGxlZ2VuZEJvcmRlcldpZHRoIDogbGVnZW5kQm9yZGVyV2lkdGgsIGxlZ2VuZEJvcmRlckhlaWdodCA6IGxlZ2VuZEJvcmRlckhlaWdodCwgXG5cdFx0XHRcdFx0ICAgbmJMZWdlbmRDb2xzOiBuYkxlZ2VuZENvbHMsIHhGaXJzdExlZ2VuZFRleHRQb3MgOiB4Rmlyc3RMZWdlbmRUZXh0UG9zICwgeUZpcnN0TGVnZW5kVGV4dFBvcyA6IHlGaXJzdExlZ2VuZFRleHRQb3MsIFxuXHRcdFx0XHRcdCAgIGRyYXdMZWdlbmRPbkRhdGEgOiBkcmF3TGVnZW5kT25EYXRhLCByZXZlcnNlTGVnZW5kIDogcmV2ZXJzZUxlZ2VuZCwgbGVnZW5kQm94IDogbGVnZW5kQm94LCB3aWRlc3RMZWdlbmQgOiB3aWRlc3RMZWdlbmQgfTtcblx0XHRcdFx0aWYoY29uZmlnLmxlZ2VuZFBvc1k9PTAgfHwgY29uZmlnLmxlZ2VuZFBvc1k9PTQgfHwgY29uZmlnLmxlZ2VuZFBvc1g9PTAgfHwgY29uZmlnLmxlZ2VuZFBvc1g9PTQpIHtcblxuXHRcdFx0XHRcdGRyYXdMZWdlbmQobGVnZW5kTXNyLGRhdGEsY29uZmlnLGN0eCx0eXBlZ3JhcGgpO1xuXHRcdFx0XHRcdGxlZ2VuZE1zcj17ZGlzcExlZ2VuZCA6IGZhbHNlfTtcblx0XHRcdFx0fSBcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxlZ2VuZE1zcj17ZGlzcExlZ2VuZCA6IGZhbHNlIH07XG5cdFx0XHR9XG5cdFx0XHQvLyBEcmF3IEZvb3ROb3RlXG5cdFx0XHRpZiAoY29uZmlnLmZvb3ROb3RlLnRyaW0oKSAhPSBcIlwiKSB7XG5cdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdGN0eC5mb250ID0gY29uZmlnLmZvb3ROb3RlRm9udFN0eWxlICsgXCIgXCIgKyAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcuZm9vdE5vdGVGb250U2l6ZSkpLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgY29uZmlnLmZvb3ROb3RlRm9udEZhbWlseTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5mb290Tm90ZUZvbnRDb2xvcjtcblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuXG5cdFx0XHRcdHNldFRleHRCb3JkZXJzQW5kQmFja2dyb3VuZChjdHgsY29uZmlnLmZvb3ROb3RlLChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5mb290Tm90ZUZvbnRTaXplKSksbGVmdE5vdFVzYWJsZVNpemUgKyAoYXZhaWxhYmxlV2lkdGggLyAyKSwgZm9vdE5vdGVQb3NZLGNvbmZpZy5mb290Tm90ZUJvcmRlcnMsY29uZmlnLmZvb3ROb3RlQm9yZGVyc0NvbG9yLE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmZvb3ROb3RlQm9yZGVyc1dpZHRoKSxNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuZm9vdE5vdGVCb3JkZXJzWFNwYWNlKSxNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuZm9vdE5vdGVCb3JkZXJzWVNwYWNlKSxjb25maWcuZm9vdE5vdGVCb3JkZXJzU3R5bGUsY29uZmlnLmZvb3ROb3RlQmFja2dyb3VuZENvbG9yLFwiRk9PVE5PVEVcIixjb25maWcuZm9vdE5vdGVCb3JkZXJzUmFkaXVzKTtcblxuXHRcdFx0XHRjdHgudHJhbnNsYXRlKGxlZnROb3RVc2FibGVTaXplICsgKGF2YWlsYWJsZVdpZHRoIC8gMiksIGZvb3ROb3RlUG9zWSk7XG5cdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShjb25maWcuZm9vdE5vdGUsIDAsIDAsIGN0eC50ZXh0QmFzZWxpbmUsIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5mb290Tm90ZUZvbnRTaXplKSksdHJ1ZSxjb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiRk9PVE5PVEVfVEVYVE1PVVNFXCIsMCxsZWZ0Tm90VXNhYmxlU2l6ZSArIChhdmFpbGFibGVXaWR0aCAvIDIpLCBmb290Tm90ZVBvc1ksLTEsLTEpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNscnggPSBsZWZ0Tm90VXNhYmxlU2l6ZTtcblx0XHRjbHJ3aWR0aCA9IGF2YWlsYWJsZVdpZHRoO1xuXHRcdGNscnkgPSB0b3BOb3RVc2FibGVTaXplO1xuXHRcdGNscmhlaWdodCA9IGF2YWlsYWJsZUhlaWdodDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bGVmdE5vdFVzYWJsZVNpemU6IGxlZnROb3RVc2FibGVTaXplLFxuXHRcdFx0cmlnaHROb3RVc2FibGVTaXplOiByaWdodE5vdFVzYWJsZVNpemUsXG5cdFx0XHRhdmFpbGFibGVXaWR0aDogYXZhaWxhYmxlV2lkdGgsXG5cdFx0XHR0b3BOb3RVc2FibGVTaXplOiB0b3BOb3RVc2FibGVTaXplLFxuXHRcdFx0Ym90dG9tTm90VXNhYmxlSGVpZ2h0V2l0aG91dFhMYWJlbHM6IGJvdHRvbU5vdFVzYWJsZUhlaWdodFdpdGhvdXRYTGFiZWxzLFxuXHRcdFx0Ym90dG9tTm90VXNhYmxlSGVpZ2h0V2l0aFhMYWJlbHM6IGJvdHRvbU5vdFVzYWJsZUhlaWdodFdpdGhYTGFiZWxzLFxuXHRcdFx0YXZhaWxhYmxlSGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQsXG5cdFx0XHR3aWRlc3RYTGFiZWw6IHdpZGVzdFhMYWJlbCxcblx0XHRcdGhpZ2hlc3RYTGFiZWw6IGhpZ2hlc3RYTGFiZWwsXG5cdFx0XHR3aWRlc3RZTGFiZWw6IHdpZGVzdFlMYWJlbCxcblx0XHRcdHdpZGVzdFlMYWJlbDI6IHdpZGVzdFlMYWJlbDIsXG5cdFx0XHRoaWdoZXN0WUxhYmVsOiBoaWdoZXN0WUxhYmVsLFxuXHRcdFx0cm90YXRlTGFiZWxzOiByb3RhdGVMYWJlbHMsXG5cdFx0XHR4TGFiZWxQb3M6IHhMYWJlbFBvcyxcblx0XHRcdGNscng6IGNscngsXG5cdFx0XHRjbHJ5OiBjbHJ5LFxuXHRcdFx0Y2xyd2lkdGg6IGNscndpZHRoLFxuXHRcdFx0Y2xyaGVpZ2h0OiBjbHJoZWlnaHQsXG5cdFx0XHRsZWdlbmRNc3IgOiBsZWdlbmRNc3Jcblx0XHR9O1xuXHR9O1xuXG5cblx0Ly8gRnVuY3Rpb24gZm9yIGRyYXdpbmcgbGluZXMgKEJhckxpbmV8TGluZSlcblxuXHRmdW5jdGlvbiBkcmF3TGluZXNEYXRhc2V0KGFuaW1QYywgZGF0YSwgY29uZmlnLCBjdHgsIHN0YXREYXRhLHZhcnMpIHtcblx0XHR2YXIgeTEseTIseTMsZGlmZm5iLGRpZmZuYmosZmFjdCwgY3VycmVudEFuaW1QYztcblx0XHR2YXIgcHJldnlwb3M7XG5cdFx0dmFyIHB0cz1bXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkFOSU1BVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uYW5pbWF0aW9uLGNvbmZpZy5hbmltYXRpb24sXCJhbmltYXRpb25cIixpLC0xLHtudWxsdmFsdWUgOiBudWxsfSApPT10cnVlIHx8IGFuaW1QYyA+PSAxKSB7XG5cdFx0XHRcdHByZXZ5cG9zPVwidW5kZWZpbmVkXCI7XG5cdFx0XHRcdGlmKHN0YXREYXRhW2ldWzBdLnRwY2hhcnQhPVwiTGluZVwiKWNvbnRpbnVlO1xuXHRcdFx0XHRpZiAoc3RhdERhdGFbaV0ubGVuZ3RoID09IDApIGNvbnRpbnVlO1xuXHRcdFx0XHRpZiAoc3RhdERhdGFbaV1bMF0uZmlyc3ROb3RNaXNzaW5nID09IC0xKSBjb250aW51ZTtcblx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0XHRcdHByZXZBbmltUGM9eyBtYWluVmFsOjAgLCBzdWJWYWwgOiAwLGFuaW1WYWwgOiAwIH07XG5cdFx0XHRcdHZhciBmaXJzdHB0PS0xO1xuXHRcdFx0XHR2YXIgbGFzdHhQb3M9LTE7XG5cdFx0XHRcdGZvciAodmFyIGogPSBzdGF0RGF0YVtpXVswXS5maXJzdE5vdE1pc3Npbmc7IGogPD0gc3RhdERhdGFbaV1bMF0ubGFzdE5vdE1pc3Npbmc7IGorKykge1xuXHRcdFx0XHRcdGlmKHByZXZBbmltUGMuYW5pbVZhbD09MCAmJiBqPnN0YXREYXRhW2ldWzBdLmZpcnN0Tm90TWlzc2luZykgY29udGludWU7XHRcblx0XHRcdFx0XHRjdXJyZW50QW5pbVBjID0gYW5pbWF0aW9uQ29ycmVjdGlvbihhbmltUGMsIGRhdGEsIGNvbmZpZywgaSwgaiwgdHJ1ZSk7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRBbmltUGMubWFpblZhbCA9PSAwICAmJiAocHJldkFuaW1QYy5tYWluVmFsID4gMCAmJiBmaXJzdHB0ICE9LTEpKSB7XG5cdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiTElORURBU0hcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmRhdGFzZXRTdHJva2VTdHlsZSxjb25maWcuZGF0YXNldFN0cm9rZVN0eWxlLFwiZGF0YXNldFN0cm9rZVN0eWxlXCIsaSxqLHtudWxsdmFsdWUgOiBudWxsfSApKSk7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0XHRcdFx0aWYoY29uZmlnLmV4dHJhcG9sYXRlTWlzc2luZ0RhdGEpIHtcblx0XHRcdFx0XHRcdFx0eTE9c3RhdERhdGFbaV1bc3RhdERhdGFbaV1bal0ucHJldk5vdE1pc3NpbmddLnlBeGlzUG9zIC0gcHJldkFuaW1QYy5tYWluVmFsKnN0YXREYXRhW2ldW3N0YXREYXRhW2ldW2pdLnByZXZOb3RNaXNzaW5nXS55UG9zT2Zmc2V0O1x0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0eTI9c3RhdERhdGFbaV1bal0ueUF4aXNQb3MgLSBwcmV2QW5pbVBjLm1haW5WYWwqc3RhdERhdGFbaV1bc3RhdERhdGFbaV1bai0xXS5uZXh0Tm90TWlzc2luZ10ueVBvc09mZnNldDtcblx0XHRcdFx0XHRcdFx0ZGlmZm5iPXN0YXREYXRhW2ldW2otMV0ubmV4dE5vdE1pc3Npbmctc3RhdERhdGFbaV1bal0ucHJldk5vdE1pc3Npbmc7XG5cdFx0XHRcdFx0XHRcdGRpZmZuYmo9KGotMSktc3RhdERhdGFbaV1bal0ucHJldk5vdE1pc3Npbmc7XG5cdFx0XHRcdFx0XHRcdGZhY3Q9KGRpZmZuYmorcHJldkFuaW1QYy5zdWJWYWwpL2RpZmZuYjtcblx0XHRcdFx0XHRcdFx0eTM9eTErZmFjdCooeTIteTEpO1x0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0dHJhY2VMaW5lKHB0cyxjdHgsc3RhdERhdGFbaV1bc3RhdERhdGFbaV1bal0ucHJldk5vdE1pc3NpbmddLnhQb3MgKyBmYWN0KihzdGF0RGF0YVtpXVtzdGF0RGF0YVtpXVtqLTFdLm5leHROb3RNaXNzaW5nXS54UG9zLXN0YXREYXRhW2ldW3N0YXREYXRhW2ldW2pdLnByZXZOb3RNaXNzaW5nXS54UG9zKSAsIHkzLGNvbmZpZyxkYXRhLHN0YXREYXRhLGksc2V0WXBvc09yaWdpbihpLGosZGF0YSxzdGF0RGF0YSkpO1xuXHRcdFx0XHRcdFx0XHRjbG9zZWJ6KHB0cyxjdHgsY29uZmlnLGkpO1xuXHRcdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiTElORURBU0hcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmRhdGFzZXRTdHJva2VTdHlsZSxjb25maWcuZGF0YXNldFN0cm9rZVN0eWxlLFwiZGF0YXNldFN0cm9rZVN0eWxlXCIsaSxqLHtudWxsdmFsdWUgOiBudWxsfSApKSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsMCwwLDApXCI7XG5cdFx0XHRcdFx0XHRcdGlmKGNvbmZpZy5kYXRhc2V0RmlsbCAmJiBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJMSU5LVFlQRVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0ubGlua1R5cGUsY29uZmlnLmxpbmtUeXBlLFwibGlua1R5cGVcIixpLGose251bGx2YWx1ZSA6IG51bGx9ICkhPTEpIHtcblx0XHRcdFx0XHRcdFx0XHRjdHgubGluZVRvKHN0YXREYXRhW2ldW3N0YXREYXRhW2ldW2pdLnByZXZOb3RNaXNzaW5nXS54UG9zICsgZmFjdCooc3RhdERhdGFbaV1bc3RhdERhdGFbaV1bai0xXS5uZXh0Tm90TWlzc2luZ10ueFBvcy1zdGF0RGF0YVtpXVtzdGF0RGF0YVtpXVtqXS5wcmV2Tm90TWlzc2luZ10ueFBvcykgLCBzdGF0RGF0YVtpXVtqXS55QXhpc1BvcyApO1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5saW5lVG8oc3RhdERhdGFbaV1bZmlyc3RwdF0ueFBvcywgc3RhdERhdGFbaV1bZmlyc3RwdF0ueEF4aXNQb3NZLXN0YXREYXRhW2ldWzBdLnplcm9ZKTtcblx0XHRcdFx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIkNPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5maWxsQ29sb3IsY29uZmlnLmRlZmF1bHRGaWxsQ29sb3IsXCJmaWxsQ29sb3JcIixpLGose2FuaW1hdGlvblZhbHVlOiBjdXJyZW50QW5pbVBjLm1haW5WYWwsIHhQb3NMZWZ0IDogc3RhdERhdGFbaV1bMF0ueFBvcywgeVBvc0JvdHRvbSA6IE1hdGgubWF4KHN0YXREYXRhW2ldWzBdLnlBeGlzUG9zLHN0YXREYXRhW2ldWzBdLnlBeGlzUG9zLSAoKGNvbmZpZy5hbmltYXRpb25MZWZ0VG9SaWdodCkgPyAxIDogMSpjdXJyZW50QW5pbVBjLm1haW5WYWwpICogc3RhdERhdGFbaV1bMF0ubG1pbnZhbHVlX29mZnNldCksIHhQb3NSaWdodCA6IHN0YXREYXRhW2ldW2RhdGEuZGF0YXNldHNbaV0uZGF0YS5sZW5ndGgtMV0ueFBvcywgeVBvc1RvcCA6IE1hdGgubWluKHN0YXREYXRhW2ldWzBdLnlBeGlzUG9zLCBzdGF0RGF0YVtpXVswXS55QXhpc1BvcyAtICgoY29uZmlnLmFuaW1hdGlvbkxlZnRUb1JpZ2h0KSA/IDEgOiAxKmN1cnJlbnRBbmltUGMubWFpblZhbCkgKiBzdGF0RGF0YVtpXVswXS5sbWF4dmFsdWVfb2Zmc2V0KX0gKTtcblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0XHRcdFx0XHRcdGZpcnN0cHQ9LTE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoISh0eXBlb2Ygc3RhdERhdGFbaV1bal0udmFsdWUgPT0gXCJ1bmRlZmluZWRcIikpIHtcblx0XHRcdFx0XHRcdFx0dHJhY2VMaW5lKHB0cyxjdHgsc3RhdERhdGFbaV1bai0xXS54UG9zICsgcHJldkFuaW1QYy5zdWJWYWwqKHN0YXREYXRhW2ldW2pdLnhQb3Mtc3RhdERhdGFbaV1bai0xXS54UG9zKSAsIHN0YXREYXRhW2ldW2pdLnlBeGlzUG9zIC0gcHJldkFuaW1QYy5tYWluVmFsKnN0YXREYXRhW2ldW3N0YXREYXRhW2ldW2otMV0ubmV4dE5vdE1pc3NpbmddLnlQb3NPZmZzZXQsY29uZmlnLGRhdGEsc3RhdERhdGEsaSxzZXRZcG9zT3JpZ2luKGksaixkYXRhLHN0YXREYXRhKSk7XG5cdFx0XHRcdFx0XHRcdGNsb3NlYnoocHRzLGN0eCxjb25maWcsaSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJMSU5FREFTSFwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uZGF0YXNldFN0cm9rZVN0eWxlLGNvbmZpZy5kYXRhc2V0U3Ryb2tlU3R5bGUsXCJkYXRhc2V0U3Ryb2tlU3R5bGVcIixpLGose251bGx2YWx1ZSA6IG51bGx9ICkpKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwwLDAsMClcIjtcblx0XHRcdFx0XHRcdFx0aWYoY29uZmlnLmRhdGFzZXRGaWxsICYmIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkxJTktUWVBFXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5saW5rVHlwZSxjb25maWcubGlua1R5cGUsXCJsaW5rVHlwZVwiLGksaix7bnVsbHZhbHVlIDogbnVsbH0gKSE9MSkge1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5saW5lVG8oc3RhdERhdGFbaV1bai0xXS54UG9zICsgcHJldkFuaW1QYy5zdWJWYWwqKHN0YXREYXRhW2ldW2pdLnhQb3Mtc3RhdERhdGFbaV1bai0xXS54UG9zKSAsIHN0YXREYXRhW2ldW2pdLnlBeGlzUG9zICk7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhzdGF0RGF0YVtpXVtmaXJzdHB0XS54UG9zLCBzdGF0RGF0YVtpXVtmaXJzdHB0XS54QXhpc1Bvc1ktc3RhdERhdGFbaV1bMF0uemVyb1kpO1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIkNPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5maWxsQ29sb3IsY29uZmlnLmRlZmF1bHRGaWxsQ29sb3IsXCJmaWxsQ29sb3JcIixpLGose2FuaW1hdGlvblZhbHVlOiBjdXJyZW50QW5pbVBjLm1haW5WYWwsIHhQb3NMZWZ0IDogc3RhdERhdGFbaV1bMF0ueFBvcywgeVBvc0JvdHRvbSA6IE1hdGgubWF4KHN0YXREYXRhW2ldWzBdLnlBeGlzUG9zLHN0YXREYXRhW2ldWzBdLnlBeGlzUG9zLSAoKGNvbmZpZy5hbmltYXRpb25MZWZ0VG9SaWdodCkgPyAxIDogMSpjdXJyZW50QW5pbVBjLm1haW5WYWwpICogc3RhdERhdGFbaV1bMF0ubG1pbnZhbHVlX29mZnNldCksIHhQb3NSaWdodCA6IHN0YXREYXRhW2ldW2RhdGEuZGF0YXNldHNbaV0uZGF0YS5sZW5ndGgtMV0ueFBvcywgeVBvc1RvcCA6IE1hdGgubWluKHN0YXREYXRhW2ldWzBdLnlBeGlzUG9zLCBzdGF0RGF0YVtpXVswXS55QXhpc1BvcyAtICgoY29uZmlnLmFuaW1hdGlvbkxlZnRUb1JpZ2h0KSA/IDEgOiAxKmN1cnJlbnRBbmltUGMubWFpblZhbCkgKiBzdGF0RGF0YVtpXVswXS5sbWF4dmFsdWVfb2Zmc2V0KX0gKTtcblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwcmV2QW5pbVBjID0gY3VycmVudEFuaW1QYztcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZihjdXJyZW50QW5pbVBjLnRvdFZhbCA9PTApIHtcblx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJMSU5FREFTSFwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uZGF0YXNldFN0cm9rZVN0eWxlLGNvbmZpZy5kYXRhc2V0U3Ryb2tlU3R5bGUsXCJkYXRhc2V0U3Ryb2tlU3R5bGVcIixpLGose251bGx2YWx1ZSA6IG51bGx9ICkpKTtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwwLDAsMClcIjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkxJTkVEQVNIXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5kYXRhc2V0U3Ryb2tlU3R5bGUsY29uZmlnLmRhdGFzZXRTdHJva2VTdHlsZSxcImRhdGFzZXRTdHJva2VTdHlsZVwiLGksaix7bnVsbHZhbHVlIDogbnVsbH0gKSkpO1xuXHRcdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZT1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJTVFJPS0VDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uc3Ryb2tlQ29sb3IsY29uZmlnLmRlZmF1bHRTdHJva2VDb2xvcixcInN0cm9rZUNvbG9yXCIsaSxqLHtudWxsdmFsdWUgOiBudWxsfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcmV2QW5pbVBjID0gY3VycmVudEFuaW1QYztcblxuXHRcdFx0XHRcdHN3aXRjaCh0eXBlb2YgZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFwidW5kZWZpbmVkXCIgOlxuXHRcdFx0XHRcdFx0XHRpZiAoIWNvbmZpZy5leHRyYXBvbGF0ZU1pc3NpbmdEYXRhKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoZmlyc3RwdD09LTEpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHRcdGNsb3NlYnoocHRzLGN0eCxjb25maWcsaSk7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkxJTkVEQVNIXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5kYXRhc2V0U3Ryb2tlU3R5bGUsY29uZmlnLmRhdGFzZXRTdHJva2VTdHlsZSxcImRhdGFzZXRTdHJva2VTdHlsZVwiLGksaix7bnVsbHZhbHVlIDogbnVsbH0gKSkpO1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjb25maWcuZGF0YXNldEZpbGwgJiYgZmlyc3RwdCAhPSAtMSAmJiBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJMSU5LVFlQRVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0ubGlua1R5cGUsY29uZmlnLmxpbmtUeXBlLFwibGlua1R5cGVcIixpLGose251bGx2YWx1ZSA6IG51bGx9ICkhPTEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxhc3R4UG9zPS0xO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsMCwwLDApXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdHgubGluZVRvKHN0YXREYXRhW2ldW2otMV0ueFBvcywgc3RhdERhdGFbaV1bai0xXS55QXhpc1Bvcyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdHgubGluZVRvKHN0YXREYXRhW2ldW2ZpcnN0cHRdLnhQb3MsIHN0YXREYXRhW2ldW2ZpcnN0cHRdLnlBeGlzUG9zKTtcblx0XHRcdFx0XHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGU9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmZpbGxDb2xvcixjb25maWcuZGVmYXVsdEZpbGxDb2xvcixcImZpbGxDb2xvclwiLGksaix7YW5pbWF0aW9uVmFsdWU6IGN1cnJlbnRBbmltUGMubWFpblZhbCwgeFBvc0xlZnQgOiBzdGF0RGF0YVtpXVswXS54UG9zLCB5UG9zQm90dG9tIDogTWF0aC5tYXgoc3RhdERhdGFbaV1bMF0ueUF4aXNQb3Msc3RhdERhdGFbaV1bMF0ueUF4aXNQb3MtICgoY29uZmlnLmFuaW1hdGlvbkxlZnRUb1JpZ2h0KSA/IDEgOiAxKmN1cnJlbnRBbmltUGMubWFpblZhbCkgKiBzdGF0RGF0YVtpXVswXS5sbWludmFsdWVfb2Zmc2V0KSwgeFBvc1JpZ2h0IDogc3RhdERhdGFbaV1bZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aC0xXS54UG9zLCB5UG9zVG9wIDogTWF0aC5taW4oc3RhdERhdGFbaV1bMF0ueUF4aXNQb3MsIHN0YXREYXRhW2ldWzBdLnlBeGlzUG9zIC0gKChjb25maWcuYW5pbWF0aW9uTGVmdFRvUmlnaHQpID8gMSA6IDEqY3VycmVudEFuaW1QYy5tYWluVmFsKSAqIHN0YXREYXRhW2ldWzBdLmxtYXh2YWx1ZV9vZmZzZXQpfSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0XHRcdHByZXZBbmltUGM9eyBtYWluVmFsOjAgLCBzdWJWYWwgOiAwIH07XG5cdFx0XHRcdFx0XHRcdFx0Zmlyc3RwdD0tMTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50QW5pbVBjLnN1YlZhbCA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRsYXN0eFBvcz1zdGF0RGF0YVtpXVtqXS54UG9zICsgY3VycmVudEFuaW1QYy5zdWJWYWwqKHN0YXREYXRhW2ldW2orMV0ueFBvcy1zdGF0RGF0YVtpXVtqXS54UG9zKTtcblx0XHRcdFx0XHRcdFx0XHR5MT1zdGF0RGF0YVtpXVtzdGF0RGF0YVtpXVtqKzFdLnByZXZOb3RNaXNzaW5nXS55QXhpc1BvcyAtIHN0YXREYXRhW2ldW3N0YXREYXRhW2ldW2orMV0ucHJldk5vdE1pc3NpbmddLnlQb3NPZmZzZXQ7XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdHkyPXN0YXREYXRhW2ldW3N0YXREYXRhW2ldW2pdLm5leHROb3RNaXNzaW5nXS55QXhpc1BvcyAtIHN0YXREYXRhW2ldW3N0YXREYXRhW2ldW2pdLm5leHROb3RNaXNzaW5nXS55UG9zT2Zmc2V0O1xuXHRcdFx0XHRcdFx0XHRcdGRpZmZuYj1zdGF0RGF0YVtpXVtqXS5uZXh0Tm90TWlzc2luZy1zdGF0RGF0YVtpXVtqKzFdLnByZXZOb3RNaXNzaW5nO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmZuYmo9KGopLXN0YXREYXRhW2ldW2orMV0ucHJldk5vdE1pc3Npbmc7XG5cdFx0XHRcdFx0XHRcdFx0ZmFjdD0oZGlmZm5iaitwcmV2QW5pbVBjLnN1YlZhbCkvZGlmZm5iO1xuXHRcdFx0XHRcdFx0XHRcdHkzPXkxK2ZhY3QqKHkyLXkxKTtcdFx0XHRcdFx0XG4vL1x0XHRcdFx0XHRcdFx0XHR0cmFjZUxpbmUocHRzLGN0eCxzdGF0RGF0YVtpXVtqXS54UG9zICsgY3VycmVudEFuaW1QYy5zdWJWYWwqKHN0YXREYXRhW2ldW2orMV0ueFBvcy1zdGF0RGF0YVtpXVtqXS54UG9zKSwgeTMsY29uZmlnLGRhdGEsc3RhdERhdGEsaSk7XG5cdFx0XHRcdFx0XHRcdFx0dHJhY2VMaW5lKHB0cyxjdHgsc3RhdERhdGFbaV1bc3RhdERhdGFbaV1bal0ucHJldk5vdE1pc3NpbmddLnhQb3MgKyBmYWN0KihzdGF0RGF0YVtpXVtzdGF0RGF0YVtpXVtqLTFdLm5leHROb3RNaXNzaW5nXS54UG9zLXN0YXREYXRhW2ldW3N0YXREYXRhW2ldW2pdLnByZXZOb3RNaXNzaW5nXS54UG9zKSAsIHkzLGNvbmZpZyxkYXRhLHN0YXREYXRhLGksc2V0WXBvc09yaWdpbihpLGosZGF0YSxzdGF0RGF0YSkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdCA6IFxuXHRcdFx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJMSU5FV0lEVEhcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmRhdGFzZXRTdHJva2VXaWR0aCxjb25maWcuZGF0YXNldFN0cm9rZVdpZHRoLFwiZGF0YXNldFN0cm9rZVdpZHRoXCIsaSxqLHtudWxsdmFsdWUgOiBudWxsfSApKTtcblx0XHRcdFx0XHRcdFx0aWYgKGZpcnN0cHQ9PS0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zmlyc3RwdD1qO1xuXHRcdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdFx0XHRpZihzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJMSU5LVFlQRVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0ubGlua1R5cGUsY29uZmlnLmxpbmtUeXBlLFwibGlua1R5cGVcIixpLGose251bGx2YWx1ZSA6IG51bGx9ICk9PTEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHR5cGVvZiBzdGF0RGF0YVtpXVtqXS55UG9zT2Zmc2V0T3JpZ2luICE9IFwidW5kZWZpbmVkXCIpY3R4Lm1vdmVUbyhzdGF0RGF0YVtpXVtqXS54UG9zLCBzdGF0RGF0YVtpXVtqXS55QXhpc1BvcyAtIGN1cnJlbnRBbmltUGMubWFpblZhbCAqIHN0YXREYXRhW2ldW2pdLnlQb3NPZmZzZXRPcmlnaW4pO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSBjdHgubW92ZVRvKHN0YXREYXRhW2ldW2ZpcnN0cHRdLnhQb3MsIHN0YXREYXRhW2ldW2ZpcnN0cHRdLnhBeGlzUG9zWS1zdGF0RGF0YVtpXVswXS56ZXJvWSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdHgubGluZVRvKHN0YXREYXRhW2ldW2pdLnhQb3MsIHN0YXREYXRhW2ldW2pdLnlBeGlzUG9zIC0gY3VycmVudEFuaW1QYy5tYWluVmFsICogc3RhdERhdGFbaV1bal0ueVBvc09mZnNldCk7XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBjdHgubW92ZVRvKHN0YXREYXRhW2ldW2pdLnhQb3MsIHN0YXREYXRhW2ldW2pdLnlBeGlzUG9zIC0gY3VycmVudEFuaW1QYy5tYWluVmFsICogc3RhdERhdGFbaV1bal0ueVBvc09mZnNldCk7XG5cdFx0XHRcdFx0XHRcdFx0aW5pdGJ6KHB0cyxzdGF0RGF0YVtpXVtqXS54UG9zLCBzdGF0RGF0YVtpXVtqXS55QXhpc1BvcyAtIGN1cnJlbnRBbmltUGMubWFpblZhbCAqIHN0YXREYXRhW2ldW2pdLnlQb3NPZmZzZXQsaSk7XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHRsYXN0eFBvcz1zdGF0RGF0YVtpXVtqXS54UG9zO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGxhc3R4UG9zPXN0YXREYXRhW2ldW2pdLnhQb3M7XG5cdFx0XHRcdFx0XHRcdFx0dHJhY2VMaW5lKHB0cyxjdHgsc3RhdERhdGFbaV1bal0ueFBvcywgc3RhdERhdGFbaV1bal0ueUF4aXNQb3MgLSBjdXJyZW50QW5pbVBjLm1haW5WYWwgKiBzdGF0RGF0YVtpXVtqXS55UG9zT2Zmc2V0LGNvbmZpZyxkYXRhLHN0YXREYXRhLGksc2V0WXBvc09yaWdpbihpLGosZGF0YSxzdGF0RGF0YSkpO1xuXHRcdFx0XHRcdFx0XHR9XHRcblx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRBbmltUGMuc3ViVmFsID4gMCAmJiBzdGF0RGF0YVtpXVtqXS5uZXh0Tm90TWlzc2luZyAhPS0xICYmIChjb25maWcuZXh0cmFwb2xhdGVNaXNzaW5nIHx8IHN0YXREYXRhW2ldW2pdLm5leHROb3RNaXNzaW5nPT1qKzEpKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGFzdHhQb3M9c3RhdERhdGFbaV1bal0ueFBvcyArIGN1cnJlbnRBbmltUGMuc3ViVmFsKihzdGF0RGF0YVtpXVtqKzFdLnhQb3Mtc3RhdERhdGFbaV1bal0ueFBvcyk7XG5cdFx0XHRcdFx0XHRcdFx0eTE9c3RhdERhdGFbaV1bc3RhdERhdGFbaV1baisxXS5wcmV2Tm90TWlzc2luZ10ueUF4aXNQb3MgLSBzdGF0RGF0YVtpXVtzdGF0RGF0YVtpXVtqKzFdLnByZXZOb3RNaXNzaW5nXS55UG9zT2Zmc2V0O1x0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHR5Mj1zdGF0RGF0YVtpXVtzdGF0RGF0YVtpXVtqXS5uZXh0Tm90TWlzc2luZ10ueUF4aXNQb3MgLSBzdGF0RGF0YVtpXVtzdGF0RGF0YVtpXVtqXS5uZXh0Tm90TWlzc2luZ10ueVBvc09mZnNldDtcblx0XHRcdFx0XHRcdFx0XHR5Mz15MStjdXJyZW50QW5pbVBjLnN1YlZhbCooeTIteTEpO1x0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHR0cmFjZUxpbmUocHRzLGN0eCxzdGF0RGF0YVtpXVtqXS54UG9zICsgY3VycmVudEFuaW1QYy5zdWJWYWwqKHN0YXREYXRhW2ldW3N0YXREYXRhW2ldW2pdLm5leHROb3RNaXNzaW5nXS54UG9zLXN0YXREYXRhW2ldW2pdLnhQb3MpICwgeTMsY29uZmlnLGRhdGEsc3RhdERhdGEsaSxzZXRZcG9zT3JpZ2luKGksaixkYXRhLHN0YXREYXRhKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2xvc2VieihwdHMsY3R4LGNvbmZpZyxpKTtcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkxJTkVEQVNIXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5kYXRhc2V0U3Ryb2tlU3R5bGUsY29uZmlnLmRhdGFzZXRTdHJva2VTdHlsZSxcImRhdGFzZXRTdHJva2VTdHlsZVwiLGksaix7bnVsbHZhbHVlIDogbnVsbH0gKSkpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcdGlmIChjb25maWcuZGF0YXNldEZpbGwgICYmIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkxJTktUWVBFXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5saW5rVHlwZSxjb25maWcubGlua1R5cGUsXCJsaW5rVHlwZVwiLGksaix7bnVsbHZhbHVlIDogbnVsbH0gKSE9MSkge1xuXHRcdFx0XHRcdGlmIChmaXJzdHB0Pj0wICkge1xuXHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsMCwwLDApXCI7XG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGxhc3R4UG9zLCBzdGF0RGF0YVtpXVswXS54QXhpc1Bvc1ktc3RhdERhdGFbaV1bMF0uemVyb1kpO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhzdGF0RGF0YVtpXVtmaXJzdHB0XS54UG9zLCBzdGF0RGF0YVtpXVtmaXJzdHB0XS54QXhpc1Bvc1ktc3RhdERhdGFbaV1bMF0uemVyb1kpO1xuXHRcdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJDT0xPUlwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uZmlsbENvbG9yLGNvbmZpZy5kZWZhdWx0RmlsbENvbG9yLFwiZmlsbENvbG9yXCIsaSwtMSx7YW5pbWF0aW9uVmFsdWU6IGN1cnJlbnRBbmltUGMubWFpblZhbCwgeFBvc0xlZnQgOiBzdGF0RGF0YVtpXVswXS54UG9zLCB5UG9zQm90dG9tIDogTWF0aC5tYXgoc3RhdERhdGFbaV1bMF0ueUF4aXNQb3Msc3RhdERhdGFbaV1bMF0ueUF4aXNQb3MtICgoY29uZmlnLmFuaW1hdGlvbkxlZnRUb1JpZ2h0KSA/IDEgOiAxKmN1cnJlbnRBbmltUGMubWFpblZhbCkgKiBzdGF0RGF0YVtpXVswXS5sbWludmFsdWVfb2Zmc2V0KSwgeFBvc1JpZ2h0IDogc3RhdERhdGFbaV1bZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aC0xXS54UG9zLCB5UG9zVG9wIDogTWF0aC5taW4oc3RhdERhdGFbaV1bMF0ueUF4aXNQb3MsIHN0YXREYXRhW2ldWzBdLnlBeGlzUG9zIC0gKChjb25maWcuYW5pbWF0aW9uTGVmdFRvUmlnaHQpID8gMSA6IDEqY3VycmVudEFuaW1QYy5tYWluVmFsKSAqIHN0YXREYXRhW2ldWzBdLmxtYXh2YWx1ZV9vZmZzZXQpfSApO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdGlmIChhbmltUGMgPj0gMSkge1xuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBkYXRhLmRhdGFzZXRzW2ldLmRhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdGlmICghKHR5cGVvZihkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0pID09ICd1bmRlZmluZWQnKSkge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50QW5pbVBjID0gYW5pbWF0aW9uQ29ycmVjdGlvbihhbmltUGMsIGRhdGEsIGNvbmZpZywgaSwgaiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChjdXJyZW50QW5pbVBjLm1haW5WYWwgPiAwIHx8ICFjb25maWcuYW5pbWF0aW9uTGVmdFRvUmlnaHQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZihzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJQT0lOVERPVFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcucG9pbnREb3QsXCJwb2ludERvdFwiLGksaix7bnVsbHZhbHVlIDogbnVsbH0gKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJNQVJLRVJGSUxMQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLnBvaW50Q29sb3IsY29uZmlnLmRlZmF1bHRTdHJva2VDb2xvcixcInBvaW50Q29sb3JcIixpLGose251bGx2YWx1ZTogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZT1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJNQVJLRVJTVFJPS0VTVFlMRVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0ucG9pbnRTdHJva2VDb2xvcixjb25maWcuZGVmYXVsdFN0cm9rZUNvbG9yLFwicG9pbnRTdHJva2VDb2xvclwiLGksaix7bnVsbHZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aD1zZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydExpbmVTY2FsZSxcIk1BUktFUkxJTkVXSURUSFwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0ucG9pbnREb3RTdHJva2VXaWR0aCxjb25maWcucG9pbnREb3RTdHJva2VXaWR0aCxcInBvaW50RG90U3Ryb2tlV2lkdGhcIixpLGose251bGx2YWx1ZTogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBtYXJrZXJTaGFwZT1zZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJNQVJLRVJTSEFQRVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0ubWFya2VyU2hhcGUsY29uZmlnLm1hcmtlclNoYXBlLFwibWFya2VyU2hhcGVcIixpLGose251bGx2YWx1ZTogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBtYXJrZXJSYWRpdXM9c2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiTUFSS0VSUkFESVVTXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5wb2ludERvdFJhZGl1cyxjb25maWcucG9pbnREb3RSYWRpdXMsXCJwb2ludERvdFJhZGl1c1wiLGksaix7bnVsbHZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG1hcmtlclN0cm9rZVN0eWxlPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIk1BUktFUlNUUk9LRVNUWUxFXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5wb2ludERvdFN0cm9rZVN0eWxlLGNvbmZpZy5wb2ludERvdFN0cm9rZVN0eWxlLFwicG9pbnREb3RTdHJva2VTdHlsZVwiLGksaix7bnVsbHZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZHJhd01hcmtlcihjdHgsIHN0YXREYXRhW2ldW2pdLnhQb3MgLCBzdGF0RGF0YVtpXVtqXS55QXhpc1BvcyAtIGN1cnJlbnRBbmltUGMubWFpblZhbCAqIHN0YXREYXRhW2ldW2pdLnlQb3NPZmZzZXQsIG1hcmtlclNoYXBlLG1hcmtlclJhZGl1cyxtYXJrZXJTdHJva2VTdHlsZSk7XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHR9XG4gICAgICAgIFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYW5pbVBjID49IGNvbmZpZy5hbmltYXRpb25TdG9wVmFsdWUpIHtcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSkgPT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aWYoIShkYXRhLmRhdGFzZXRzW2ldLm1vdXNlRGV0ZWN0aW9uPT1mYWxzZSkpanNHcmFwaEFubm90YXRlW2N0eC5DaGFydE5ld0lkXVtqc0dyYXBoQW5ub3RhdGVbY3R4LkNoYXJ0TmV3SWRdLmxlbmd0aF0gPSBbXCJQT0lOVFwiLCBpLCBqLCBzdGF0RGF0YSxzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJBTk5PVEFURURJU1BMQVlcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmFubm90YXRlRGlzcGxheSxjb25maWcuYW5ub3RhdGVEaXNwbGF5LFwiYW5ub3RhdGVEaXNwbGF5XCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSldO1xuXHRcdFx0XHRcdFx0aWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBU0hPV1wiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uaW5HcmFwaERhdGFTaG93LGNvbmZpZy5pbkdyYXBoRGF0YVNob3csXCJpbkdyYXBoRGF0YVNob3dcIixpLGose251bGxWYWx1ZSA6IHRydWV9KSkge1xuXHQgXHRcdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQWxpZ24sXCJpbkdyYXBoRGF0YUFsaWduXCIsaSxqLHtudWxsVmFsdWU6IHRydWUgIH0pO1xuXHRcdFx0XHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFWQUxJR05cIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhVkFsaWduLFwiaW5HcmFwaERhdGFWQWxpZ25cIixpLGose251bGxWYWx1ZSA6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHRcdGN0eC5mb250ID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFGT05UU1RZTEVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udFN0eWxlLFwiaW5HcmFwaERhdGFGb250U3R5bGVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgKyAnICcgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFRleHRTY2FsZSxcIklOR1JBUEhEQVRBRk9OVFNJWkVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udFNpemUsXCJpbkdyYXBoRGF0YUZvbnRTaXplXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApICsgJ3B4ICcgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQUZPTlRGQU1JTFlcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udEZhbWlseSxcImluR3JhcGhEYXRhRm9udEZhbWlseVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBRk9OVENPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRDb2xvcixcImluR3JhcGhEYXRhRm9udENvbG9yXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0XHR2YXIgcGFkZGluZ1RleHRYID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiSU5HUkFQSERBVEFQQURESU5HWFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFQYWRkaW5nWCxcImluR3JhcGhEYXRhUGFkZGluZ1hcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksXG5cdFx0XHRcdFx0XHRcdCAgICBwYWRkaW5nVGV4dFkgPSBzZXRPcHRpb25WYWx1ZSh0cnVlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJJTkdSQVBIREFUQVBBRERJTkdZXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdZLFwiaW5HcmFwaERhdGFQYWRkaW5nWVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdFx0dmFyIGRpc3BTdHJpbmcgPSB0bXBsYmlzKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBVE1QTFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFUbXBsLFwiaW5HcmFwaERhdGFUbXBsXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLCBzdGF0RGF0YVtpXVtqXSxjb25maWcpO1xuXHRcdFx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHN0YXREYXRhW2ldW2pdLnhQb3MgKyBwYWRkaW5nVGV4dFgsIHN0YXREYXRhW2ldW2pdLnlBeGlzUG9zIC0gY3VycmVudEFuaW1QYy5tYWluVmFsICogc3RhdERhdGFbaV1bal0ueVBvc09mZnNldCAtIHBhZGRpbmdUZXh0WSk7XG5cdFx0XHRcdFx0XHRcdHZhciByb3RhdGVWYWw9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFST1RBVEVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUm90YXRlLFwiaW5HcmFwaERhdGFSb3RhdGVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICkgKiAoTWF0aC5QSSAvIDE4MCk7XG5cdFx0XHRcdFx0XHRcdGN0eC5yb3RhdGUocm90YXRlVmFsKTtcblx0XHRcdFx0XHRcdFx0c2V0VGV4dEJvcmRlcnNBbmRCYWNrZ3JvdW5kKGN0eCxkaXNwU3RyaW5nLHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0VGV4dFNjYWxlLFwiSU5HUkFQSERBVEFGT05UU0laRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U2l6ZSxcImluR3JhcGhEYXRhRm9udFNpemVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksMCwwLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQk9SREVSU1wiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFCb3JkZXJzLFwiaW5HcmFwaERhdGFCb3JkZXJzXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQk9SREVSU0NPTE9SXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNDb2xvcixcImluR3JhcGhEYXRhQm9yZGVyc0NvbG9yXCIsaSxqLHtudWxsVmFsdWUgOiB0cnVlfSApLHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0TGluZVNjYWxlLFwiSU5HUkFQSERBVEFCT1JERVJTV0lEVEhcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVyc1dpZHRoLFwiaW5HcmFwaERhdGFCb3JkZXJzV2lkdGhcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiSU5HUkFQSERBVEFCT1JERVJTWFNQQUNFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNYU3BhY2UsXCJpbkdyYXBoRGF0YUJvcmRlcnNYU3BhY2VcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRTcGFjZVNjYWxlLFwiSU5HUkFQSERBVEFCT1JERVJTWVNQQUNFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNZU3BhY2UsXCJpbkdyYXBoRGF0YUJvcmRlcnNZU3BhY2VcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFCT1JERVJTU1RZTEVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQm9yZGVyc1N0eWxlLFwiaW5HcmFwaERhdGFCb3JkZXJzU3R5bGVcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFCQUNLR1JPVU5EQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhQmFja2dyb3VuZENvbG9yLFwiaW5HcmFwaERhdGFCYWNrZ3JvdW5kQ29sb3JcIixpLGose251bGxWYWx1ZSA6IHRydWV9ICksXCJJTkdSQVBIREFUQVwiLGNvbmZpZy5pbkdyYXBoRGF0YUJvcmRlcnNSYWRpdXMpO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFRleHRNdWx0aUxpbmUoZGlzcFN0cmluZywgMCwgMCwgY3R4LnRleHRCYXNlbGluZSwgc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRUZXh0U2NhbGUsXCJJTkdSQVBIREFUQUZPTlRTSVpFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRTaXplLFwiaW5HcmFwaERhdGFGb250U2l6ZVwiLGksaix7bnVsbFZhbHVlIDogdHJ1ZX0gKSx0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJJTkdSQVBIREFUQV9URVhUTU9VU0VcIixyb3RhdGVWYWwsc3RhdERhdGFbaV1bal0ueFBvcyArIHBhZGRpbmdUZXh0WCwgc3RhdERhdGFbaV1bal0ueUF4aXNQb3MgLSBjdXJyZW50QW5pbVBjLm1haW5WYWwgKiBzdGF0RGF0YVtpXVtqXS55UG9zT2Zmc2V0IC0gcGFkZGluZ1RleHRZLGksaik7XG5cdFx0XHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdFxuXHRcdGZ1bmN0aW9uIGluaXRieihwdHMseHBvcyx5cG9zLGkpIHtcblx0XHRcdGlmIChzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJMSU5LVFlQRVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0ubGlua1R5cGUsY29uZmlnLmxpbmtUeXBlLFwibGlua1R5cGVcIixpLGose251bGx2YWx1ZSA6IG51bGx9ICk9PTAgJiYgc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiQkVaSUVSQ1VSVkVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmJlemllckN1cnZlLFwiYmV6aWVyQ3VydmVcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSkpIHtcblx0XHRcdFx0cHRzLmxlbmd0aD0wO1xuXHRcdFx0XHRwdHMucHVzaCh4cG9zKTtwdHMucHVzaCh5cG9zKTtcblx0XHRcdH1cblx0XHRcdHByZXZ5cG9zPXlwb3M7XG5cdFx0fSA7XG5cdFx0XG5cdFx0ZnVuY3Rpb24gc2V0WXBvc09yaWdpbihpLGosZGF0YSxzdGF0RGF0YSkge1xuXHRcdFx0eXBvc09yaWdpbj1cInVuZGVmaW5lZFwiO1xuXHRcdFx0aWYodHlwZW9mIHN0YXREYXRhW2ldW2pdLnlQb3NPZmZzZXRPcmlnaW4gIT0gXCJ1bmRlZmluZWRcIil5cG9zT3JpZ2luPSBzdGF0RGF0YVtpXVtqXS55QXhpc1BvcyAtIGN1cnJlbnRBbmltUGMubWFpblZhbCAqIHN0YXREYXRhW2ldW2pdLnlQb3NPZmZzZXRPcmlnaW47XG5cdFx0XHRyZXR1cm4oeXBvc09yaWdpbik7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRmdW5jdGlvbiB0cmFjZUxpbmUocHRzLGN0eCx4cG9zLHlwb3MsY29uZmlnLGRhdGEsc3RhdERhdGEsaSx5cG9zT3JpZ2luKSB7XG5cdFx0XHRpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiTElOS1RZUEVcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmxpbmtUeXBlLGNvbmZpZy5saW5rVHlwZSxcImxpbmtUeXBlXCIsaSxqLHtudWxsdmFsdWUgOiBudWxsfSApPT0wICYmIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkJFWklFUkNVUlZFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5iZXppZXJDdXJ2ZSxcImJlemllckN1cnZlXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0pKSB7XG5cdFx0XHRcdHB0cy5wdXNoKHhwb3MpO1x0cHRzLnB1c2goeXBvcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZihzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJMSU5LVFlQRVwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0ubGlua1R5cGUsY29uZmlnLmxpbmtUeXBlLFwibGlua1R5cGVcIixpLGose251bGx2YWx1ZSA6IG51bGx9ICk9PTApY3R4LmxpbmVUbyh4cG9zLHlwb3MpO1xuXHRcdFx0XHRlbHNlIGlmKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkxJTktUWVBFXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5saW5rVHlwZSxjb25maWcubGlua1R5cGUsXCJsaW5rVHlwZVwiLGksaix7bnVsbHZhbHVlIDogbnVsbH0gKT09MSl7XG5cdFx0XHRcdFx0aWYoeXBvc09yaWdpbiAhPSBcInVuZGVmaW5lZFwiKWN0eC5tb3ZlVG8oeHBvcywgeXBvc09yaWdpbik7XG5cdFx0XHRcdFx0ZWxzZSBjdHgubW92ZVRvKHhwb3MsIHN0YXREYXRhW2ldWzBdLnhBeGlzUG9zWS1zdGF0RGF0YVtpXVswXS56ZXJvWSk7XG4vL1x0XHRcdFx0XHRjdHgubW92ZVRvKHhwb3MsIHN0YXREYXRhW2ldWzBdLnhBeGlzUG9zWS1zdGF0RGF0YVtpXVswXS56ZXJvWSk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh4cG9zLHlwb3MpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkxJTktUWVBFXCIsY3R4LGRhdGEsc3RhdERhdGEsZGF0YS5kYXRhc2V0c1tpXS5saW5rVHlwZSxjb25maWcubGlua1R5cGUsXCJsaW5rVHlwZVwiLGksaix7bnVsbHZhbHVlIDogbnVsbH0gKT09MiAmJiB0eXBlb2YgcHJldnlwb3MhPVwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeHBvcyxwcmV2eXBvcyk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh4cG9zLHlwb3MpO1xuXHRcdFx0XHRcdHByZXZ5cG9zPXlwb3M7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IDtcblx0XHRcblx0XHRmdW5jdGlvbiBjbG9zZWJ6KHB0cyxjdHgsY29uZmlnLGkpe1xuXHRcdFxuXHRcdFx0aWYoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiTElOS1RZUEVcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmxpbmtUeXBlLGNvbmZpZy5saW5rVHlwZSxcImxpbmtUeXBlXCIsaSxqLHtudWxsdmFsdWUgOiBudWxsfSApPT0wICYmIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIkJFWklFUkNVUlZFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5iZXppZXJDdXJ2ZSxcImJlemllckN1cnZlXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0pKSB7XG5cdFx0XHRcdG1pbmltdW1wb3M9IHN0YXREYXRhW2ldWzBdLnhBeGlzUG9zWTtcblx0XHRcdFx0bWF4aW11bXBvcz0gc3RhdERhdGFbaV1bMF0ueEF4aXNQb3NZIC0gc3RhdERhdGFbaV1bMF0uY2FsY3VsYXRlZFNjYWxlLnN0ZXBzKnN0YXREYXRhW2ldWzBdLnNjYWxlSG9wO1xuXHRcdFx0XHRkcmF3U3BsaW5lKGN0eCxwdHMsc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiQkVaSUVSQ1VSVkVURU5TSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5iZXppZXJDdXJ2ZVRlbnNpb24sXCJiZXppZXJDdXJ2ZVRlbnNpb25cIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSksbWluaW11bXBvcyxtYXhpbXVtcG9zKTtcblx0XHRcdFx0cHRzLmxlbmd0aD0wO1x0XHRcdFxuXHRcdFx0fVxuXHRcdFx0cHJldnlwb3M9dW5kZWZpbmVkO1xuXHRcdH07XHRcdFxuXG5cdFx0Ly9Qcm9wcyB0byBSb2IgU3BlbmNlciBhdCBzY2FsZWQgaW5ub3ZhdGlvbiBmb3IgaGlzIHBvc3Qgb24gc3BsaW5pbmcgYmV0d2VlbiBwb2ludHNcblx0XHQvL2h0dHA6Ly9zY2FsZWRpbm5vdmF0aW9uLmNvbS9hbmFseXRpY3Mvc3BsaW5lcy9hYm91dFNwbGluZXMuaHRtbFxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29udHJvbFBvaW50cyh4MCx5MCx4MSx5MSx4Mix5Mix0KXtcblx0XHRcdC8vICB4MCx5MCx4MSx5MSBhcmUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBlbmQgKGtub3QpIHB0cyBvZiB0aGlzIHNlZ21lbnRcblx0XHRcdC8vICB4Mix5MiBpcyB0aGUgbmV4dCBrbm90IC0tIG5vdCBjb25uZWN0ZWQgaGVyZSBidXQgbmVlZGVkIHRvIGNhbGN1bGF0ZSBwMlxuXHRcdFx0Ly8gIHAxIGlzIHRoZSBjb250cm9sIHBvaW50IGNhbGN1bGF0ZWQgaGVyZSwgZnJvbSB4MSBiYWNrIHRvd2FyZCB4MC5cblx0XHRcdC8vICBwMiBpcyB0aGUgbmV4dCBjb250cm9sIHBvaW50LCBjYWxjdWxhdGVkIGhlcmUgYW5kIHJldHVybmVkIHRvIGJlY29tZSB0aGUgXG5cdFx0XHQvLyAgbmV4dCBzZWdtZW50J3MgcDEuXG5cdFx0XHQvLyAgdCBpcyB0aGUgJ3RlbnNpb24nIHdoaWNoIGNvbnRyb2xzIGhvdyBmYXIgdGhlIGNvbnRyb2wgcG9pbnRzIHNwcmVhZC5cbiAgICAgICAgXHRcblx0XHRcdC8vICBTY2FsaW5nIGZhY3RvcnM6IGRpc3RhbmNlcyBmcm9tIHRoaXMga25vdCB0byB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBrbm90cy5cblx0XHRcdHZhciBkMDE9TWF0aC5zcXJ0KE1hdGgucG93KHgxLXgwLDIpK01hdGgucG93KHkxLXkwLDIpKTtcblx0XHRcdHZhciBkMTI9TWF0aC5zcXJ0KE1hdGgucG93KHgyLXgxLDIpK01hdGgucG93KHkyLXkxLDIpKTtcbiAgIFxuXHRcdFx0dmFyIGZhPXQqZDAxLyhkMDErZDEyKTtcblx0XHRcdHZhciBmYj10LWZhO1xuICBcblx0XHRcdHZhciBwMXg9eDErZmEqKHgwLXgyKTtcblx0XHRcdHZhciBwMXk9eTErZmEqKHkwLXkyKTtcblxuXHRcdFx0dmFyIHAyeD14MS1mYiooeDAteDIpO1xuXHRcdFx0dmFyIHAyeT15MS1mYiooeTAteTIpOyAgXG4gICAgXG5cdFx0XHRyZXR1cm4gW3AxeCxwMXkscDJ4LHAyeV1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZHJhd1NwbGluZShjdHgscHRzLHQsbWluaW11bXBvcyxtYXhpbXVtcG9zKXtcblx0XHRcdHZhciBjcD1bXTsgICAvLyBhcnJheSBvZiBjb250cm9sIHBvaW50cywgYXMgeDAseTAseDEseTEsLi4uXG5cdFx0XHR2YXIgbj1wdHMubGVuZ3RoO1xuXG5cdFx0XHRwdHMucHVzaCgyKnB0c1tuLTJdLXB0c1tuLTRdKTtcblx0XHRcdHB0cy5wdXNoKDIqcHRzW24tMV0tcHRzW24tM10pO1xuXG5cdFx0XHRpZiAobj09NCl7XG5cdFx0XHRcdGN0eC5tb3ZlVG8ocHRzWzBdLHB0c1sxXSk7XG5cdFx0XHRcdGN0eC5saW5lVG8ocHRzWzJdLHB0c1szXSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIERyYXcgYW4gb3BlbiBjdXJ2ZSwgbm90IGNvbm5lY3RlZCBhdCB0aGUgZW5kc1xuXHRcdFx0Zm9yKHZhciB0aT0wO3RpPG4tMjt0aSs9Mil7XG5cdFx0XHRcdGNwPWNwLmNvbmNhdChnZXRDb250cm9sUG9pbnRzKHB0c1t0aV0scHRzW3RpKzFdLHB0c1t0aSsyXSxwdHNbdGkrM10scHRzW3RpKzRdLHB0c1t0aSs1XSx0KSk7XG4gICAgICAgIFx0XHR9ICAgIFxuXHRcdFx0Ly8gIEZvciBmaXJzdCBpcyBhIHNpbXBsZSBxdWFkcmF0aWNzLlxuXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGU9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU1RST0tFQ09MT1JcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLnN0cm9rZUNvbG9yLGNvbmZpZy5kZWZhdWx0U3Ryb2tlQ29sb3IsXCJzdHJva2VDb2xvclwiLGksaix7bnVsbHZhbHVlIDogbnVsbH0gKTtcblx0XHRcdGN0eC5saW5lV2lkdGggPSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKnNldE9wdGlvblZhbHVlKHRydWUsMSxcIkxJTkVXSURUSFwiLGN0eCxkYXRhLHN0YXREYXRhLGRhdGEuZGF0YXNldHNbaV0uZGF0YXNldFN0cm9rZVdpZHRoLGNvbmZpZy5kYXRhc2V0U3Ryb2tlV2lkdGgsXCJkYXRhc2V0U3Ryb2tlV2lkdGhcIixpLGose251bGx2YWx1ZSA6IG51bGx9ICkpO1xuXHRcdFx0Y3R4Lm1vdmVUbyhwdHNbMF0scHRzWzFdKTtcblx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNwWzBdLE1hdGgubWF4KE1hdGgubWluKGNwWzFdLG1pbmltdW1wb3MpLG1heGltdW1wb3MpLHB0c1syXSxwdHNbM10pO1xuXHRcdFx0XG4vLyAgICAgICAgXHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihjb25maWcuZGF0YXNldFN0cm9rZVN0eWxlKSk7XG5cdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiTElORURBU0hcIixjdHgsZGF0YSxzdGF0RGF0YSxkYXRhLmRhdGFzZXRzW2ldLmRhdGFzZXRTdHJva2VTdHlsZSxjb25maWcuZGF0YXNldFN0cm9rZVN0eWxlLFwiZGF0YXNldFN0cm9rZVN0eWxlXCIsaSxqLHtudWxsdmFsdWUgOiBudWxsfSApKSk7XG5cdFx0XHRmb3IodGk9Mjt0aTxwdHMubGVuZ3RoLTQ7dGkrPTIpe1xuXHRcdFx0XHR5MT1NYXRoLm1heChNYXRoLm1pbihjcFsyKnRpLTFdLG1pbmltdW1wb3MpLG1heGltdW1wb3MpO1xuXHRcdFx0XHR5Mj1NYXRoLm1heChNYXRoLm1pbihjcFsyKnRpKzFdLG1pbmltdW1wb3MpLG1heGltdW1wb3MpO1xuXHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjcFsyKnRpLTJdLHkxLGNwWzIqdGldLHkyLHB0c1t0aSsyXSxwdHNbdGkrM10pO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH07XG4gXHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gbG9nMTAodmFsKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMTA7XG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0UmVjdChjdHgsIGNvbmZpZykge1xuXHRcdGlmIChjb25maWcuY2xlYXJSZWN0KSB7XG5cdFx0XHRpZiAoIWNvbmZpZy5tdWx0aUdyYXBoKSB7XG5cblx0XHRcdFx0Y2xlYXIoY3R4KTtcblx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2xlYXIoY3R4KTtcblx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdFxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5zYXZlUG5nQmFja2dyb3VuZENvbG9yO1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY29uZmlnLnNhdmVQbmdCYWNrZ3JvdW5kQ29sb3I7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKDAsIDApO1xuXHRcdFx0Y3R4LmxpbmVUbygwLCBjdHguY2FudmFzLmhlaWdodCk7XG5cdFx0XHRjdHgubGluZVRvKGN0eC5jYW52YXMud2lkdGgsIGN0eC5jYW52YXMuaGVpZ2h0KTtcblx0XHRcdGN0eC5saW5lVG8oY3R4LmNhbnZhcy53aWR0aCwgMCk7XG5cdFx0XHRjdHgubGluZVRvKDAsIDApO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0Y3R4LmZpbGwoKTtcblx0XHR9XG5cdH07XG5cblxuXHRmdW5jdGlvbiBkZWZNb3VzZShjdHgsZGF0YSxjb25maWcpIHtcblxuXHRcdHZhciBtb3VzZXdoZWVsZXZ0PSgvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpPyBcIkRPTU1vdXNlU2Nyb2xsXCIgOiBcIm1vdXNld2hlZWxcIiBcblxuXG4gICAgICAgIFx0Ly8gcmVzZXQgbW91c2VBY3Rpb24gdG8gY2hlY2s7XG5cbiAgICAgICAgXHRpZih0eXBlb2YgY3R4Lm1vdXNlQWN0aW9uPT1cInVuZGVmaW5lZFwiKSB7IGN0eC5tb3VzZUFjdGlvbj1bXTt9XG4gICAgICAgIFx0ZWxzZSB7XG4gICAgICAgIFx0XHRmb3IodmFyIGk9MDtpPGN0eC5tb3VzZUFjdGlvbjtpKyspe1xuXHRcdFx0XHRpZihjdHgubW91c2VBY3Rpb24uc3Vic3RyaW5nKDAsMSkhPVwiL1wiKWN0eC5tb3VzZUFjdGlvbltpXT1cIi9cIitjdHgubW91c2VBY3Rpb25baV07XG5cdFx0XHR9XG5cdFx0fVxuXG4gICAgICAgIFx0Ly8gbGlzdGUgbW91c2Ugb3B0aW9ucztcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHRcdFxuXHRcdC8vIC0gYW5ub3RhdGVEaXNwbGF5IDogdHJ1ZSwgYW5ub3RhdGVGdW5jdGlvbjogXCJtb3VzZW1vdmVcIlxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cdFx0XG5cdFx0Ly8gLSBzYXZlU2NyZWVuIDogc2F2ZVBuZ0Z1bmN0aW9uOiBcIm1vdXNlZG93biByaWdodFwiIC0gc2F2ZVBuZz10cnVlXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVx0XHRcbiAgICAgICAgICAgICAgICAvLyBoaWdoTGlnaHQgOiBmYWxzZSwgXHRoaWdoTGlnaHRNb3VzZUZ1bmN0aW9uIDogXCJtb3VzZW1vdmVcIixcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHRcdFxuXHRcdC8vIC0gbW91c2Ugc29ydGlyIG91IGVudHJlciBkYW5zIHVuZSBwacOoY2UgPT4gUGFzIGQnaW5mbHVlbmNlIHN1ciB1bmUgYWN0aW9uIGRlIHNvdXJpcy4gQydlc3QgbGnDqSDDoCBsJ2FjdGlvbiBkZSBhbm5vdGF0ZUZ1bmN0aW9uXG5cdFx0Ly8gICAgICBcdGFubm90YXRlRnVuY3Rpb25JbiA6IGluQmFyLFxuICAgICAgXHRcdC8vXHRcdGFubm90YXRlRnVuY3Rpb25PdXQgOiBvdXRCYXIsXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVx0XHRcblx0XHQvLyAtIG1vdXNlRG93blJpZ2h0XHRtb3VzZURvd25MZWZ0OiBudWxsICBtb3VzZURvd25NaWRkbGU6IG51bGwgIFxuXHRcdC8vIC0gbW91c2VNb3ZlOiBudWxsIFx0bW91c2VXaGVlbCA6IG51bGwgICAgbW91c2VPdXQ6IG51bGwgKGxvcnNxdWUgbGEgc291cmlzIHNvcnQgZHUgY2FudmFzKSBcdFxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cdFx0XG5cdFx0Ly8gIG1vdXNlIHN1ciB0ZXh0ZSA6IGRldGVjdE1vdXNlT25UZXh0ID0+IFBhcyBkJ2luZmx1ZW5jZSBzdXIgdW5lIGFjdGlvbiBkZSBzb3VyaXMuIEMnZXN0IGxpw6kgw6AgdW5lIGF1dHJlIGFjdGlvbjtcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHRcdFxuXG5cdFx0ZnVuY3Rpb24gc2V0QWN0aW9uKGN0eCxhY3Rpb24pe1xuXHRcdFx0aWYoY3R4Lm1vdXNlQWN0aW9uLmluZGV4T2YoXCIvXCIrYWN0aW9uKT49MCljdHgubW91c2VBY3Rpb25bY3R4Lm1vdXNlQWN0aW9uLmluZGV4T2YoXCIvXCIrYWN0aW9uKV09YWN0aW9uO1xuXHRcdFx0ZWxzZSBpZihjdHgubW91c2VBY3Rpb24uaW5kZXhPZihhY3Rpb24pPDApY3R4Lm1vdXNlQWN0aW9uW2N0eC5tb3VzZUFjdGlvbi5sZW5ndGhdPWFjdGlvbjtcblx0XHR9O1xuXHRcdFxuXHRcdGZ1bmN0aW9uIGFkZF9saXN0ZW5lcihjdHgsYWN0aW9uKSB7XG5cdFx0XHRpZiAoaXNJRSgpIDwgOSAmJiBpc0lFKCkgIT0gZmFsc2UpIGN0eC5jYW52YXMuYXR0YWNoRXZlbnQoXCJvblwiICsgYWN0aW9uLnNwbGl0KCcgJylbMF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGRvTW91c2VBY3Rpb24oZXZlbnQsY3R4LkNoYXJ0TmV3SWQsIGFjdGlvbi5zcGxpdCgnICcpWzBdKTtcblx0XHRcdH0pO1xuXHRcdFx0ZWxzZSBjdHguY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoYWN0aW9uLnNwbGl0KCcgJylbMF0sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGRvTW91c2VBY3Rpb24oZXZlbnQsY3R4LCBhY3Rpb24uc3BsaXQoJyAnKVswXSk7XG5cdFx0XHR9LCBmYWxzZSk7XG5cdFx0fTtcblxuXHRcdC8vIC0gc2F2ZVNjcmVlbiA6IHNhdmVQbmdGdW5jdGlvbjogXCJtb3VzZWRvd24gcmlnaHRcIiAtIHNhdmVQbmc9dHJ1ZVxuXHRcdGlmKGNvbmZpZy5zYXZlUG5nPT10cnVlKSB7XG5cdFx0XHQgICAgIGlmKGNvbmZpZy5zYXZlUG5nRnVuY3Rpb249PVwibW91c2Vkb3duIGxlZnRcIilzZXRBY3Rpb24oY3R4LFwibW91c2Vkb3duIDFcIik7XG5cdFx0XHRlbHNlIGlmKGNvbmZpZy5zYXZlUG5nRnVuY3Rpb249PVwibW91c2Vkb3duIG1pZGRsZVwiKXNldEFjdGlvbihjdHgsXCJtb3VzZWRvd24gMlwiKTtcblx0XHRcdGVsc2UgaWYoY29uZmlnLnNhdmVQbmdGdW5jdGlvbj09XCJtb3VzZWRvd24gcmlnaHRcIilzZXRBY3Rpb24oY3R4LFwibW91c2Vkb3duIDNcIik7XG5cdFx0fVxuXHRcdFxuXG5cdFx0Ly8gLSBhbm5vdGF0ZURpc3BsYXkgOiB0cnVlLCBhbm5vdGF0ZUZ1bmN0aW9uOiBcIm1vdXNlbW92ZVwiXG5cdFx0aWYoY29uZmlnLmFubm90YXRlRGlzcGxheT09dHJ1ZSkge1xuXHRcdFx0aWYgKGN1cnNvckRpdkNyZWF0ZWQgPT0gZmFsc2UpIG9DdXJzb3IgPSBuZXcgbWFrZUN1cnNvck9iaignZGl2Q3Vyc29yJyk7XG5cdFx0XHQgICAgIGlmKGNvbmZpZy5hbm5vdGF0ZUZ1bmN0aW9uPT1cIm1vdXNlZG93biBsZWZ0XCIpc2V0QWN0aW9uKGN0eCxcIm1vdXNlZG93biAxXCIpO1xuXHRcdFx0ZWxzZSBpZihjb25maWcuYW5ub3RhdGVGdW5jdGlvbj09XCJtb3VzZWRvd24gbWlkZGxlXCIpc2V0QWN0aW9uKGN0eCxcIm1vdXNlZG93biAyXCIpO1xuXHRcdFx0ZWxzZSBpZihjb25maWcuYW5ub3RhdGVGdW5jdGlvbj09XCJtb3VzZWRvd24gcmlnaHRcIilzZXRBY3Rpb24oY3R4LFwibW91c2Vkb3duIDNcIik7XG5cdFx0XHRlbHNlIGlmKGNvbmZpZy5hbm5vdGF0ZUZ1bmN0aW9uPT1cIm1vdXNlbW92ZVwiKXNldEFjdGlvbihjdHgsXCJtb3VzZW1vdmVcIik7XG5cdFx0fVxuXG4gICAgICAgICAgICAgICAgLy8gaGlnaExpZ2h0IDogZmFsc2UsIFx0aGlnaExpZ2h0TW91c2VGdW5jdGlvbiA6IFwibW91c2Vtb3ZlXCIsXG5cdFx0aWYoY29uZmlnLmhpZ2hMaWdodD09dHJ1ZSkge1xuXHRcdFx0ICAgICBpZihjb25maWcuaGlnaExpZ2h0TW91c2VGdW5jdGlvbj09XCJtb3VzZWRvd24gbGVmdFwiKXNldEFjdGlvbihjdHgsXCJtb3VzZWRvd24gMVwiKTtcblx0XHRcdGVsc2UgaWYoY29uZmlnLmhpZ2hMaWdodE1vdXNlRnVuY3Rpb249PVwibW91c2Vkb3duIG1pZGRsZVwiKXNldEFjdGlvbihjdHgsXCJtb3VzZWRvd24gMlwiKTtcblx0XHRcdGVsc2UgaWYoY29uZmlnLmhpZ2hMaWdodE1vdXNlRnVuY3Rpb249PVwibW91c2Vkb3duIHJpZ2h0XCIpc2V0QWN0aW9uKGN0eCxcIm1vdXNlZG93biAzXCIpO1xuXHRcdFx0ZWxzZSBpZihjb25maWcuaGlnaExpZ2h0TW91c2VGdW5jdGlvbj09XCJtb3VzZW1vdmVcIilzZXRBY3Rpb24oY3R4LFwibW91c2Vtb3ZlXCIpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBtb3VzZSBhY3Rpb25zO1xuXHRcdGlmKHR5cGVvZiBjb25maWcubW91c2VNb3ZlPT1cImZ1bmN0aW9uXCIpIHNldEFjdGlvbihjdHgsXCJtb3VzZW1vdmVcIik7XG5cdFx0aWYodHlwZW9mIGNvbmZpZy5tb3VzZURvd25MZWZ0PT1cImZ1bmN0aW9uXCIpIHNldEFjdGlvbihjdHgsXCJtb3VzZWRvd24gMVwiKTtcblx0XHRpZih0eXBlb2YgY29uZmlnLm1vdXNlRG93bk1pZGRsZT09XCJmdW5jdGlvblwiKSBzZXRBY3Rpb24oY3R4LFwibW91c2Vkb3duIDJcIik7XG5cdFx0aWYodHlwZW9mIGNvbmZpZy5tb3VzZURvd25SaWdodD09XCJmdW5jdGlvblwiKSBzZXRBY3Rpb24oY3R4LFwibW91c2Vkb3duIDNcIik7XG5cdFx0aWYodHlwZW9mIGNvbmZpZy5tb3VzZVdoZWVsPT1cImZ1bmN0aW9uXCIpIHNldEFjdGlvbihjdHgsbW91c2V3aGVlbGV2dCk7XG5cdFx0aWYodHlwZW9mIGNvbmZpZy5tb3VzZU91dD09XCJmdW5jdGlvblwiKSBzZXRBY3Rpb24oY3R4LFwibW91c2VvdXRcIik7XG5cdFx0aWYodHlwZW9mIGNvbmZpZy5tb3VzZURibENsaWNrPT1cImZ1bmN0aW9uXCIpIHNldEFjdGlvbihjdHgsXCJkYmxjbGlja1wiKTtcblxuXHRcdHZhciBtb3VzZUFjdGlvbj1mYWxzZTtcdFx0XG5cblx0XHQvLyBhZGQgbW91c2UgZXZlbnRcblx0XHRpZigoY3R4Lm1vdXNlQWN0aW9uLmluZGV4T2YoXCJtb3VzZW1vdmVcIik+PTAgJiYgY3R4Lm1vdXNlQWN0aW9uLmluZGV4T2YoXCIvbW91c2Vtb3ZlXCIpPDApIHx8IChjdHgubW91c2VBY3Rpb24uaW5kZXhPZihcIm1vdXNlb3V0XCIpPj0wICYmIGN0eC5tb3VzZUFjdGlvbi5pbmRleE9mKFwiL21vdXNlb3V0XCIpPDApKSB7XG5cdFx0XHRzZXRBY3Rpb24oY3R4LFwibW91c2VvdXRcIik7XG5cdFx0XHRtb3VzZUFjdGlvbj10cnVlO1xuXHRcdFx0YWRkX2xpc3RlbmVyKGN0eCxcIm1vdXNlb3V0XCIpO1xuXHRcdFx0Ly8gbW91c2VPdXQgYWN0aW9uO1x0XHRcdFxuXHRcdH1cblxuXG5cdFx0aWYoKGN0eC5tb3VzZUFjdGlvbi5pbmRleE9mKFwibW91c2Vtb3ZlXCIpPj0wICYmIGN0eC5tb3VzZUFjdGlvbi5pbmRleE9mKFwiL21vdXNlbW92ZVwiKTwwKSB8fCAoY3R4Lm1vdXNlQWN0aW9uLmluZGV4T2YobW91c2V3aGVlbGV2dCk+PTAgJiYgY3R4Lm1vdXNlQWN0aW9uLmluZGV4T2YoXCIvXCIrbW91c2V3aGVlbGV2dCk8MCkpIHtcblx0XHRcdHNldEFjdGlvbihjdHgsbW91c2V3aGVlbGV2dCk7XG5cdFx0XHRtb3VzZUFjdGlvbj10cnVlO1xuXHRcdFx0YWRkX2xpc3RlbmVyKGN0eCxtb3VzZXdoZWVsZXZ0KTtcblx0XHRcdC8vIG1vdXNlV2hlZWwgYWN0aW9uO1x0XHRcdFxuXHRcdH1cblxuXHRcdGlmKGN0eC5tb3VzZUFjdGlvbi5pbmRleE9mKFwibW91c2Vtb3ZlXCIpPj0wICYmIGN0eC5tb3VzZUFjdGlvbi5pbmRleE9mKFwiL21vdXNlbW92ZVwiKTwwKSB7XG5cdFx0XHRtb3VzZUFjdGlvbj10cnVlO1xuXHRcdFx0YWRkX2xpc3RlbmVyKGN0eCxcIm1vdXNlbW92ZVwiKTtcblx0XHRcdC8vIG1vdXNlTW92ZSBhY3Rpb247XHRcdFx0XG5cdFx0fVxuXG5cdFx0aWYoY3R4Lm1vdXNlQWN0aW9uLmluZGV4T2YoXCJkYmxjbGlja1wiKT49MCAmJiBjdHgubW91c2VBY3Rpb24uaW5kZXhPZihcIi9kYmxjbGlja1wiKTwwKSB7XG5cdFx0XHRtb3VzZUFjdGlvbj10cnVlO1xuXHRcdFx0YWRkX2xpc3RlbmVyKGN0eCxcImRibGNsaWNrXCIpO1xuXHRcdFx0Ly8gbW91c2VNb3ZlIGFjdGlvbjtcdFx0XHRcblx0XHR9XG5cblx0XHRpZigoY3R4Lm1vdXNlQWN0aW9uLmluZGV4T2YoXCJtb3VzZWRvd24gMVwiKT49MCAmJiBjdHgubW91c2VBY3Rpb24uaW5kZXhPZihcIi9tb3VzZWRvd24gMVwiKTwwKSB8fCAoY3R4Lm1vdXNlQWN0aW9uLmluZGV4T2YoXCJtb3VzZWRvd24gMlwiKT49MCAmJiBjdHgubW91c2VBY3Rpb24uaW5kZXhPZihcIi9tb3VzZWRvd24gMlwiKTwwKSB8fCAoY3R4Lm1vdXNlQWN0aW9uLmluZGV4T2YoXCJtb3VzZWRvd24gM1wiKT49MCAmJiBjdHgubW91c2VBY3Rpb24uaW5kZXhPZihcIi9tb3VzZWRvd24gM1wiKTwwKSkge1xuXHRcdFx0bW91c2VBY3Rpb249dHJ1ZTtcblx0XHRcdGFkZF9saXN0ZW5lcihjdHgsXCJtb3VzZWRvd25cIik7XG5cdFx0XHQvLyBtb3VzZURvd24gYWN0aW9uO1x0XHRcdFxuXHRcdH1cblxuXHRcdC8vIHJlbW92ZSBjb250ZXh0TWVudSBpZiBmb3JjZWQgd2l0aCBvcHRpb24gY29udGV4dE1lbnUgb3IgaWYgbW91c2VEb3duUmlnaHQgaXMgZGVmaW5lZFxuXHRcdGlmKChjb25maWcuY29udGV4dE1lbnU9PWZhbHNlIHx8IGN0eC5tb3VzZUFjdGlvbi5pbmRleE9mKFwibW91c2Vkb3duIDNcIik+PTApICYmIGN0eC5tb3VzZUFjdGlvbi5pbmRleE9mKFwiL3JlbW92ZUNvbnRleHRNZW51XCIpPDApe1xuXHRcdFx0Y3R4Lm1vdXNlQWN0aW9uW2N0eC5tb3VzZUFjdGlvbi5sZW5ndGhdPVwicmVtb3ZlQ29udGV4dE1lbnVcIjtcblx0XHRcdGN0eC5jYW52YXMub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRcblx0XHQvLyBpbml0aWFsaXNlciBsZXMgdmFyaWFibGVzIG7DqWNlc3NhaXJlcyBwb3VyIGwnYWN0aW9uIGRvTW91c2VBY3Rpb247XG4gICAgICAgICAgICAgICAgaW5Nb3VzZUFjdGlvbltjdHguQ2hhcnROZXdJZF09ZmFsc2U7XG5cdFx0bW91c2VBY3Rpb25EYXRhW2N0eC5DaGFydE5ld0lkXT17IGRhdGEgOiBkYXRhLCBjb25maWc6IGNvbmZpZywgcHJldlNob3cgOiAtMSB9O1xuXHR9O1xuXG59O1xuXG5mdW5jdGlvbiBhbmltYXRpb25Db3JyZWN0aW9uKGFuaW1hdGlvblZhbHVlLCBkYXRhLCBjb25maWcsIHZkYXRhLCB2c3ViZGF0YSwgaXNsaW5lKSB7XG5cdHZhciBhbmltVmFsdWU9YW5pbWF0aW9uVmFsdWU7XG5cdHZhciBhbmltU3ViVmFsdWUgPSAwO1xuXHRcblx0aWYodnN1YmRhdGE8MCkge1xuXHRcdGlmKHZkYXRhIDwgMSpjb25maWcuYW5pbWF0aW9uU3RhcnRXaXRoRGF0YS0xKSBhbmltVmFsdWUgPSAxO1xuXHRcdGVsc2Uge1xuXHRcdFx0c3dpdGNoIChjb25maWcuYW5pbWF0aW9uQnlEYXRhc2V0KSB7XG5cdFx0XHRcdGNhc2UgXCJCeUFyY1wiIDpcblx0XHRcdFx0XHRhbmltVmFsdWUgPSBhbmltYXRpb25WYWx1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSB0cnVlOlxuXHRcdFx0XHRcdGFuaW1WYWx1ZSA9IGFuaW1hdGlvblZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGZhbHNlOlxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGFuaW1WYWx1ZSA9IGFuaW1hdGlvblZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR2YXIgc3RhcnRWYWw9TWF0aC5tYXgoMSxjb25maWcuYW5pbWF0aW9uU3RhcnRXaXRoRGF0YXNldCk7XG5cdFx0dmFyIHN0YXJ0U3ViVmFsPU1hdGgubWF4KDEsY29uZmlnLmFuaW1hdGlvblN0YXJ0V2l0aERhdGEpO1xuXHRcblx0XHRpZih2ZGF0YSA8IDEqY29uZmlnLmFuaW1hdGlvblN0YXJ0V2l0aERhdGFzZXQtMSkgYW5pbVZhbHVlID0gMTtcblx0XHRlbHNlIGlmKHZzdWJkYXRhIDwxKmNvbmZpZy5hbmltYXRpb25TdGFydFdpdGhEYXRhLTEpIGFuaW1WYWx1ZSA9IDE7XG5cdFx0ZWxzZSB7XG5cdFx0ICAgICAgICB2YXIgbWF4RGF0YT0wO1xuXHRcdFx0aWYoY29uZmlnLmFuaW1hdGlvbkxlZnRUb1JpZ2h0KSB7XG5cdFx0XHRcdGZvcih2YXIgaT0wO2k8ZGF0YS5kYXRhc2V0cy5sZW5ndGg7aSsrKVx0bWF4RGF0YT1NYXRoLm1heChtYXhEYXRhLGRhdGEuZGF0YXNldHNbaV0uZGF0YS5sZW5ndGgpXG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKGNvbmZpZy5hbmltYXRpb25CeURhdGFzZXQpIHtcblx0XHRcdFx0Y2FzZSB0cnVlOlxuXHRcdFx0XHRcdHN3aXRjaChjb25maWcuYW5pbWF0aW9uTGVmdFRvUmlnaHQpIHtcblx0XHRcdFx0XHRcdGNhc2UgdHJ1ZTogXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJwb3M9KHZkYXRhLShzdGFydFZhbC0xKSkqKG1heERhdGEtKHN0YXJ0U3ViVmFsLTEpKSsodnN1YmRhdGEtKHN0YXJ0U3ViVmFsLTEpKTtcblx0XHRcdFx0XHRcdFx0bWF4RGF0YT0obWF4RGF0YS0oc3RhcnRTdWJWYWwtMSkpKihkYXRhLmRhdGFzZXRzLmxlbmd0aC0oc3RhcnRWYWwtMSkpO1xuXHRcdFx0XHRcdFx0XHRpZihhbmltYXRpb25WYWx1ZSA8IChjdXJwb3MvbWF4RGF0YSkpIHtcblx0XHRcdFx0XHRcdFx0XHRhbmltVmFsdWU9MDtcblx0XHRcdFx0XHRcdFx0XHRpZihpc2xpbmUgJiYgdnN1YmRhdGErMT09c3RhcnRTdWJWYWwpYW5pbVZhbHVlPTE7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZihhbmltYXRpb25WYWx1ZSA8ICgoY3VycG9zKzEpL21heERhdGEpKSB7XG5cdFx0XHRcdFx0XHRcdFx0YW5pbVZhbHVlPShhbmltYXRpb25WYWx1ZS0oY3VycG9zL21heERhdGEpKSptYXhEYXRhO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGlzbGluZSl7XG5cdFx0XHRcdFx0XHRcdFx0XHRhbmltU3ViVmFsdWU9YW5pbVZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0YW5pbVZhbHVlPTE7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgYW5pbVZhbHVlPTE7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBmYWxzZTpcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGlmKGFuaW1hdGlvblZhbHVlIDwgKHZkYXRhLShzdGFydFZhbC0xKSkvKGRhdGEuZGF0YXNldHMubGVuZ3RoLShzdGFydFZhbC0xKSkpIHtcblx0XHRcdFx0XHRcdFx0XHRhbmltVmFsdWU9MC4wMDE7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZihhbmltYXRpb25WYWx1ZSA8ICh2ZGF0YS0oc3RhcnRWYWwtMSkrMSkvKGRhdGEuZGF0YXNldHMubGVuZ3RoLShzdGFydFZhbC0xKSkpIHtcblx0XHRcdFx0XHRcdFx0XHRhbmltVmFsdWU9KGRhdGEuZGF0YXNldHMubGVuZ3RoLShzdGFydFZhbC0xKSkqKGFuaW1hdGlvblZhbHVlLSh2ZGF0YS0oc3RhcnRWYWwtMSkpLyhkYXRhLmRhdGFzZXRzLmxlbmd0aC0oc3RhcnRWYWwtMSkpKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGFuaW1WYWx1ZT0xO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgZmFsc2U6XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0c3dpdGNoKGNvbmZpZy5hbmltYXRpb25MZWZ0VG9SaWdodCkge1xuXHRcdFx0XHRcdFx0Y2FzZSB0cnVlOiBcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnBvcz0odnN1YmRhdGEtKHN0YXJ0U3ViVmFsLTEpKTtcblx0XHRcdFx0XHRcdFx0bWF4RGF0YT0obWF4RGF0YS0oc3RhcnRTdWJWYWwtMSkpO1xuXHRcdFx0XHRcdFx0XHRpZihhbmltYXRpb25WYWx1ZSA8IChjdXJwb3MvbWF4RGF0YSkpIGFuaW1WYWx1ZT0wO1xuXHRcdFx0XHRcdFx0XHRlbHNlIGlmKGFuaW1hdGlvblZhbHVlIDwgKChjdXJwb3MrMSkvbWF4RGF0YSkpIHtcblx0XHRcdFx0XHRcdFx0XHRhbmltVmFsdWU9KGFuaW1hdGlvblZhbHVlLShjdXJwb3MvbWF4RGF0YSkpKm1heERhdGE7XG5cdFx0XHRcdFx0XHRcdFx0aWYoaXNsaW5lKXtcblx0XHRcdFx0XHRcdFx0XHRcdGFuaW1TdWJWYWx1ZT1hbmltVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRhbmltVmFsdWU9MTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBhbmltVmFsdWU9MTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIGZhbHNlOlxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0YW5pbVZhbHVlID0gYW5pbWF0aW9uVmFsdWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHtcblx0XHRtYWluVmFsOiBhbmltVmFsdWUsXG5cdFx0c3ViVmFsOiBhbmltU3ViVmFsdWUsXG5cdFx0YW5pbVZhbDogYW5pbVZhbHVlICsgYW5pbVN1YlZhbHVlXG5cdH07XG5cbn07XG5cblxuZnVuY3Rpb24gc2hvd0xhYmVscyhjdHgsZGF0YSxjb25maWcsaSkge1xuXHR2YXIgZG9TaG93TGFiZWxzPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNIT1dMQUJFTFwiLGN0eCxkYXRhLHVuZGVmaW5lZCx1bmRlZmluZWQsY29uZmlnLnNob3dYTGFiZWxzLFwic2hvd1hMYWJlbHNcIixpLC0xLHVuZGVmaW5lZCx7bGFiZWxWYWx1ZTogZm10Q2hhcnRKUyhjb25maWcsIGRhdGEubGFiZWxzW2ldLCBjb25maWcuZm10WExhYmVsKSwgdW5mb3JtYXRlZExhYmVsVmFsdWU6ZGF0YS5sYWJlbHNbaV19KTtcblx0aWYodHlwZW9mIGRvU2hvd0xhYmVscz09XCJudW1iZXJcIikge1xuXHRcdGlmKGk+PWNvbmZpZy5maXJzdExhYmVsVG9TaG93LTEpZG9TaG93TGFiZWxzPSgoaStjb25maWcuZmlyc3RMYWJlbFRvU2hvdy0xKSAlIHBhcnNlSW50KGRvU2hvd0xhYmVscykgPT0wID8gdHJ1ZSA6IGZhbHNlKTtcblx0XHRlbHNlIGRvU2hvd0xhYmVscz1mYWxzZTtcblx0fVxuXHRyZXR1cm4gZG9TaG93TGFiZWxzO1xufTtcblxuZnVuY3Rpb24gc2hvd1lMYWJlbHMoY3R4LGRhdGEsY29uZmlnLGksdGV4dCkge1xuXHR2YXIgZG9TaG93TGFiZWxzPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNIT1dZTEFCRUxcIixjdHgsZGF0YSx1bmRlZmluZWQsdW5kZWZpbmVkLGNvbmZpZy5zaG93WUxhYmVscyxcInNob3dZTGFiZWxzXCIsLTEsaSx1bmRlZmluZWQse2xhYmVsVmFsdWU6IHRleHR9KTtcblx0aWYodHlwZW9mIGRvU2hvd0xhYmVscz09XCJudW1iZXJcIikge1xuXHRcdGlmKGk+PWNvbmZpZy5maXJzdFlMYWJlbFRvU2hvdy0xKWRvU2hvd0xhYmVscz0oKGkrY29uZmlnLmZpcnN0WUxhYmVsVG9TaG93LTEpICUgcGFyc2VJbnQoZG9TaG93TGFiZWxzKSA9PTAgPyB0cnVlIDogZmFsc2UpO1xuXHRcdGVsc2UgZG9TaG93TGFiZWxzPWZhbHNlO1xuXHR9XG5cdHJldHVybiBkb1Nob3dMYWJlbHM7XG59O1xuXG5cbmZ1bmN0aW9uIGRyYXdMZWdlbmQobGVnZW5kTXNyLGRhdGEsY29uZmlnLGN0eCx0eXBlZ3JhcGgpIHtcblx0dmFyIGxndHh0O1xuXHRpZiAoY29uZmlnLmxlZ2VuZEJvcmRlcnMgPT0gdHJ1ZSkge1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGNvbmZpZy5sZWdlbmRCb3JkZXJzU3R5bGUpKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmxlZ2VuZEJvcmRlcnNXaWR0aCk7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gY29uZmlnLmxlZ2VuZEJvcmRlcnNDb2xvcnM7XG5cdFx0Y3R4Lm1vdmVUbyhsZWdlbmRNc3IueExlZ2VuZEJvcmRlclBvcywgbGVnZW5kTXNyLnlMZWdlbmRCb3JkZXJQb3MpO1xuXHRcdGN0eC5saW5lVG8obGVnZW5kTXNyLnhMZWdlbmRCb3JkZXJQb3MsIGxlZ2VuZE1zci55TGVnZW5kQm9yZGVyUG9zICsgbGVnZW5kTXNyLmxlZ2VuZEJvcmRlckhlaWdodCk7XG5cdFx0Y3R4LmxpbmVUbyhsZWdlbmRNc3IueExlZ2VuZEJvcmRlclBvcyArIGxlZ2VuZE1zci5sZWdlbmRCb3JkZXJXaWR0aCwgbGVnZW5kTXNyLnlMZWdlbmRCb3JkZXJQb3MgKyBsZWdlbmRNc3IubGVnZW5kQm9yZGVySGVpZ2h0KTtcblx0XHRjdHgubGluZVRvKGxlZ2VuZE1zci54TGVnZW5kQm9yZGVyUG9zICsgbGVnZW5kTXNyLmxlZ2VuZEJvcmRlcldpZHRoLCBsZWdlbmRNc3IueUxlZ2VuZEJvcmRlclBvcyk7XG5cdFx0Y3R4LmxpbmVUbyhsZWdlbmRNc3IueExlZ2VuZEJvcmRlclBvcywgbGVnZW5kTXNyLnlMZWdlbmRCb3JkZXJQb3MpO1xuXHRcdC8vY3R4LmxpbmVUbyhsZWdlbmRNc3IueExlZ2VuZEJvcmRlclBvcyArIGxlZ2VuZE1zci5sZWdlbmRCb3JkZXJXaWR0aCwgbGVnZW5kTXNyLnlMZWdlbmRCb3JkZXJQb3MpO1xuXHRcdC8vY3R4LmxpbmVUbyhsZWdlbmRNc3IueExlZ2VuZEJvcmRlclBvcywgbGVnZW5kTXNyLnlMZWdlbmRCb3JkZXJQb3MpO1xuXHRcdC8vY3R4LmxpbmVUbyhsZWdlbmRNc3IueExlZ2VuZEJvcmRlclBvcywgbGVnZW5kTXNyLnlMZWdlbmRCb3JkZXJQb3MgKyBsZWdlbmRNc3IubGVnZW5kQm9yZGVySGVpZ2h0KTtcblxuXHRcdFx0XHRcdFxuXHRcdGN0eC5zdHJva2UoKTtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcblx0XHRjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsMCwwLDApXCI7IC8vIGNvbmZpZy5sZWdlbmRGaWxsQ29sb3I7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5sZWdlbmRGaWxsQ29sb3I7XG5cdFx0Y3R4LmZpbGwoKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9XG5cdG5iY29scyA9IGxlZ2VuZE1zci5uYkxlZ2VuZENvbHMgLSAxO1xuXHR5cG9zID0gbGVnZW5kTXNyLnlGaXJzdExlZ2VuZFRleHRQb3MgLSAoKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZXR3ZWVuVGV4dFZlcnRpY2FsKSk7XG5cdHhwb3MgPSAwO1xuXHRpZiAobGVnZW5kTXNyLmRyYXdMZWdlbmRPbkRhdGEpIGZyb21pID0gZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG5cdGVsc2UgZnJvbWkgPSBkYXRhLmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IGZyb21pIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRvcmRlcmkgPSBpO1xuXHRcdGlmIChsZWdlbmRNc3IucmV2ZXJzZUxlZ2VuZCkge1xuXHRcdFx0aWYgKGxlZ2VuZE1zci5kcmF3TGVnZW5kT25EYXRhKSBvcmRlcmkgPSBkYXRhLmRhdGFzZXRzLmxlbmd0aCAtIGkgLSAxO1xuXHRcdFx0ZWxzZSBvcmRlcmkgPSBkYXRhLmxlbmd0aCAtIGkgLSAxO1xuXHRcdH1cblx0XHRpZiAobGVnZW5kTXNyLmRyYXdMZWdlbmRPbkRhdGEpIHRwb2YgPSB0eXBlb2YoZGF0YS5kYXRhc2V0c1tvcmRlcmldLnRpdGxlKTtcblx0XHRlbHNlIHRwb2YgPSB0eXBlb2YoZGF0YVtvcmRlcmldLnRpdGxlKVxuXHRcdGlmICh0cG9mID09IFwic3RyaW5nXCIpIHtcblx0XHRcdGlmIChsZWdlbmRNc3IuZHJhd0xlZ2VuZE9uRGF0YSkgbGd0eHQgPSBmbXRDaGFydEpTKGNvbmZpZywgZGF0YS5kYXRhc2V0c1tvcmRlcmldLnRpdGxlLCBjb25maWcuZm10TGVnZW5kKS50cmltKCk7XG5cdFx0XHRlbHNlIGxndHh0ID0gZm10Q2hhcnRKUyhjb25maWcsIGRhdGFbb3JkZXJpXS50aXRsZSwgY29uZmlnLmZtdExlZ2VuZCkudHJpbSgpO1xuXHRcdFx0aWYgKGxndHh0ICE9IFwiXCIpIHtcblx0XHRcdFx0bmJjb2xzKys7XG5cdFx0XHRcdGlmIChuYmNvbHMgPT0gbGVnZW5kTXNyLm5iTGVnZW5kQ29scykge1xuXHRcdFx0XHRcdG5iY29scyA9IDA7XG5cdFx0XHRcdFx0eHBvcyA9IGxlZ2VuZE1zci54Rmlyc3RMZWdlbmRUZXh0UG9zO1xuXHRcdFx0XHRcdHlwb3MgKz0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZXR3ZWVuVGV4dFZlcnRpY2FsKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4cG9zICs9IGxlZ2VuZE1zci53aWRlc3RMZWdlbmQgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZXR3ZWVuVGV4dEhvcml6b250YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0dmFyIGxnZGJveD1sZWdlbmRNc3IubGVnZW5kQm94O1xuXHRcdFx0XHRpZihjdHgudHBjaGFydD09XCJCYXJcIiB8fCBjdHgudHBjaGFydD09XCJTdGFja2VkQmFyXCIpIGlmIChkYXRhLmRhdGFzZXRzW29yZGVyaV0udHlwZT09XCJMaW5lXCIgJiYgKCFjb25maWcuZGF0YXNldEZpbGwgfHwgc2V0T3B0aW9uVmFsdWUoZmFsc2UsMSxcIkxJTktUWVBFXCIsY3R4LGRhdGEsdW5kZWZpbmVkLGRhdGEuZGF0YXNldHNbb3JkZXJpXS5saW5rVHlwZSxjb25maWcubGlua1R5cGUsXCJsaW5rVHlwZVwiLG9yZGVyaSwtMSx7bnVsbHZhbHVlIDogbnVsbH0gKT09MSkpIGxnZGJveD1mYWxzZTtcblx0XHRcdFx0aWYgKGxnZGJveCkge1xuXHRcdFx0XHRcdGlmIChsZWdlbmRNc3IuZHJhd0xlZ2VuZE9uRGF0YSkge1xuXHQgXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKnNldE9wdGlvblZhbHVlKGZhbHNlLDEsXCJMSU5FV0lEVEhcIixjdHgsZGF0YSx1bmRlZmluZWQsZGF0YS5kYXRhc2V0c1tvcmRlcmldLmRhdGFzZXRTdHJva2VXaWR0aCxjb25maWcuZGF0YXNldFN0cm9rZVdpZHRoLFwiZGF0YXNldFN0cm9rZVdpZHRoXCIsb3JkZXJpLC0xLHtudWxsdmFsdWUgOiBudWxsfSApKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqY29uZmlnLmRhdGFzZXRTdHJva2VXaWR0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRpZiAobGVnZW5kTXNyLmRyYXdMZWdlbmRPbkRhdGEpIHtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZT1zZXRPcHRpb25WYWx1ZShmYWxzZSwxLFwiTEVHRU5EU1RST0tFQ09MT1JcIixjdHgsZGF0YSx1bmRlZmluZWQsZGF0YS5kYXRhc2V0c1tvcmRlcmldLnN0cm9rZUNvbG9yLGNvbmZpZy5kZWZhdWx0RmlsbENvbG9yLFwic3Ryb2tlQ29sb3JcIixvcmRlcmksLTEse2FuaW1hdGlvblZhbHVlOiAxLCB4UG9zTGVmdCA6IHhwb3MsIHlQb3NCb3R0b20gOiB5cG9zLCB4UG9zUmlnaHQgOiB4cG9zICsgTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kQmxvY2tTaXplKSwgeVBvc1RvcCA6IHlwb3MgLSAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kRm9udFNpemUpKX0gKTtcblx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihzZXRPcHRpb25WYWx1ZShmYWxzZSwxLFwiTEVHRU5ETElORURBU0hcIixjdHgsZGF0YSx1bmRlZmluZWQsZGF0YS5kYXRhc2V0c1tvcmRlcmldLmRhdGFzZXRTdHJva2VTdHlsZSxjb25maWcuZGF0YXNldFN0cm9rZVN0eWxlLFwiZGF0YXNldFN0cm9rZVN0eWxlXCIsb3JkZXJpLC0xLHthbmltYXRpb25WYWx1ZTogMSwgeFBvc0xlZnQgOiB4cG9zLCB5UG9zQm90dG9tIDogeXBvcywgeFBvc1JpZ2h0IDogeHBvcyArIE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEJsb2NrU2l6ZSksIHlQb3NUb3AgOiB5cG9zIC0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSl9ICkpKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGU9c2V0T3B0aW9uVmFsdWUoZmFsc2UsMSxcIkxFR0VORFNUUk9LRUNPTE9SXCIsY3R4LGRhdGEsdW5kZWZpbmVkLGRhdGFbb3JkZXJpXS5zdHJva2VDb2xvcixjb25maWcuZGVmYXVsdEZpbGxDb2xvcixcInN0cm9rZUNvbG9yXCIsb3JkZXJpLC0xLHthbmltYXRpb25WYWx1ZTogMSwgeFBvc0xlZnQgOiB4cG9zLCB5UG9zQm90dG9tIDogeXBvcywgeFBvc1JpZ2h0IDogeHBvcyArIE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEJsb2NrU2l6ZSksIHlQb3NUb3AgOiB5cG9zIC0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSl9ICk7XG5cdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oc2V0T3B0aW9uVmFsdWUoZmFsc2UsMSxcIkxFR0VORFNFR01FTlRUUk9LRVNUWUxFXCIsY3R4LGRhdGEsdW5kZWZpbmVkLGRhdGFbb3JkZXJpXS5zZWdtZW50U3Ryb2tlU3R5bGUsY29uZmlnLnNlZ21lbnRTdHJva2VTdHlsZSxcInNlZ21lbnRTdHJva2VTdHlsZVwiLG9yZGVyaSwtMSx7YW5pbWF0aW9uVmFsdWU6IDEsIHhQb3NMZWZ0IDogeHBvcywgeVBvc0JvdHRvbSA6IHlwb3MsIHhQb3NSaWdodCA6IHhwb3MgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRCbG9ja1NpemUpLCB5UG9zVG9wIDogeXBvcyAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRGb250U2l6ZSkpfSApKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oeHBvcywgeXBvcyk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh4cG9zICsgTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kQmxvY2tTaXplKSwgeXBvcyk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh4cG9zICsgTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kQmxvY2tTaXplKSwgeXBvcyAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRGb250U2l6ZSkpKTtcblx0XHRcdFx0XHRjdHgubGluZVRvKHhwb3MsIHlwb3MgLSAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kRm9udFNpemUpKSk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh4cG9zLCB5cG9zKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRcdGlmIChsZWdlbmRNc3IuZHJhd0xlZ2VuZE9uRGF0YSkge1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1zZXRPcHRpb25WYWx1ZShmYWxzZSwxLFwiTEVHRU5ERklMTENPTE9SXCIsY3R4LGRhdGEsdW5kZWZpbmVkLGRhdGEuZGF0YXNldHNbb3JkZXJpXS5maWxsQ29sb3IsY29uZmlnLmRlZmF1bHRGaWxsQ29sb3IsXCJmaWxsQ29sb3JcIixvcmRlcmksLTEse2FuaW1hdGlvblZhbHVlOiAxLCB4UG9zTGVmdCA6IHhwb3MsIHlQb3NCb3R0b20gOiB5cG9zLCB4UG9zUmlnaHQgOiB4cG9zICsgTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kQmxvY2tTaXplKSwgeVBvc1RvcCA6IHlwb3MgLSAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kRm9udFNpemUpKX0gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1zZXRPcHRpb25WYWx1ZShmYWxzZSwxLFwiTEVHRU5ERklMTENPTE9SXCIsY3R4LGRhdGEsdW5kZWZpbmVkLGRhdGFbb3JkZXJpXS5jb2xvcixjb25maWcuZGVmYXVsdEZpbGxDb2xvcixcImNvbG9yXCIsb3JkZXJpLC0xLHthbmltYXRpb25WYWx1ZTogMSwgeFBvc0xlZnQgOiB4cG9zLCB5UG9zQm90dG9tIDogeXBvcywgeFBvc1JpZ2h0IDogeHBvcyArIE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEJsb2NrU2l6ZSksIHlQb3NUb3AgOiB5cG9zIC0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSl9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGNvbmZpZy5sZWdlbmRDb2xvckluZGljYXRvclN0cm9rZVdpZHRoID9cblx0XHRcdFx0XHRcdGNvbmZpZy5sZWdlbmRDb2xvckluZGljYXRvclN0cm9rZVdpZHRoIDogTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpzZXRPcHRpb25WYWx1ZShmYWxzZSwxLFwiTElORVdJRFRIXCIsY3R4LGRhdGEsdW5kZWZpbmVkLGRhdGEuZGF0YXNldHNbb3JkZXJpXS5kYXRhc2V0U3Ryb2tlV2lkdGgsY29uZmlnLmRhdGFzZXRTdHJva2VXaWR0aCxcImRhdGFzZXRTdHJva2VXaWR0aFwiLG9yZGVyaSwtMSx7bnVsbHZhbHVlIDogbnVsbH0gKSk7XG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5sZWdlbmRDb2xvckluZGljYXRvclN0cm9rZVdpZHRoICYmIGNvbmZpZy5sZWdlbmRDb2xvckluZGljYXRvclN0cm9rZVdpZHRoID4gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSkpIHtcblx0XHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kRm9udFNpemUpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGxlZ2VuZE1zci5kcmF3TGVnZW5kT25EYXRhKSB7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGU9c2V0T3B0aW9uVmFsdWUoZmFsc2UsMSxcIkxFR0VORFNUUk9LRUNPTE9SXCIsY3R4LGRhdGEsdW5kZWZpbmVkLGRhdGEuZGF0YXNldHNbb3JkZXJpXS5zdHJva2VDb2xvcixjb25maWcuZGVmYXVsdEZpbGxDb2xvcixcInN0cm9rZUNvbG9yXCIsb3JkZXJpLC0xLHthbmltYXRpb25WYWx1ZTogMSwgeFBvc0xlZnQgOiB4cG9zLCB5UG9zQm90dG9tIDogeXBvcywgeFBvc1JpZ2h0IDogeHBvcyArIE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEJsb2NrU2l6ZSksIHlQb3NUb3AgOiB5cG9zIC0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSl9ICk7XG5cdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oc2V0T3B0aW9uVmFsdWUoZmFsc2UsMSxcIkxFR0VORExJTkVEQVNIXCIsY3R4LGRhdGEsdW5kZWZpbmVkLGRhdGEuZGF0YXNldHNbb3JkZXJpXS5kYXRhc2V0U3Ryb2tlU3R5bGUsY29uZmlnLmRhdGFzZXRTdHJva2VTdHlsZSxcImRhdGFzZXRTdHJva2VTdHlsZVwiLG9yZGVyaSwtMSx7YW5pbWF0aW9uVmFsdWU6IDEsIHhQb3NMZWZ0IDogeHBvcywgeVBvc0JvdHRvbSA6IHlwb3MsIHhQb3NSaWdodCA6IHhwb3MgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRCbG9ja1NpemUpLCB5UG9zVG9wIDogeXBvcyAtIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRGb250U2l6ZSkpfSApKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZT1zZXRPcHRpb25WYWx1ZShmYWxzZSwxLFwiTEVHRU5EU1RST0tFQ09MT1JcIixjdHgsZGF0YSx1bmRlZmluZWQsZGF0YVtvcmRlcmldLnN0cm9rZUNvbG9yLGNvbmZpZy5kZWZhdWx0RmlsbENvbG9yLFwic3Ryb2tlQ29sb3JcIixvcmRlcmksLTEse2FuaW1hdGlvblZhbHVlOiAxLCB4UG9zTGVmdCA6IHhwb3MsIHlQb3NCb3R0b20gOiB5cG9zLCB4UG9zUmlnaHQgOiB4cG9zICsgTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kQmxvY2tTaXplKSwgeVBvc1RvcCA6IHlwb3MgLSAoTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kRm9udFNpemUpKX0gKTtcblx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihzZXRPcHRpb25WYWx1ZShmYWxzZSwxLFwiTEVHRU5EU0VHTUVOVFRST0tFU1RZTEVcIixjdHgsZGF0YSx1bmRlZmluZWQsZGF0YVtvcmRlcmldLnNlZ21lbnRTdHJva2VTdHlsZSxjb25maWcuc2VnbWVudFN0cm9rZVN0eWxlLFwic2VnbWVudFN0cm9rZVN0eWxlXCIsb3JkZXJpLC0xLHthbmltYXRpb25WYWx1ZTogMSwgeFBvc0xlZnQgOiB4cG9zLCB5UG9zQm90dG9tIDogeXBvcywgeFBvc1JpZ2h0IDogeHBvcyArIE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEJsb2NrU2l6ZSksIHlQb3NUb3AgOiB5cG9zIC0gKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSl9ICkpKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdHgubW92ZVRvKHhwb3MgKyAyLCB5cG9zIC0gKChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRGb250U2l6ZSkpIC8gMikpO1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeHBvcyArIDIgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRCbG9ja1NpemUpLCB5cG9zIC0gKChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRGb250U2l6ZSkpIC8gMikpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cblx0XHRcdFx0XHRpZihjb25maWcucG9pbnREb3QpIHtcblx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0IFx0XHRjdHguZmlsbFN0eWxlPXNldE9wdGlvblZhbHVlKGZhbHNlLDEsXCJMRUdFTkRNQVJLRVJGSUxMQ09MT1JcIixjdHgsZGF0YSx1bmRlZmluZWQsZGF0YS5kYXRhc2V0c1tvcmRlcmldLnBvaW50Q29sb3IsY29uZmlnLmRlZmF1bHRTdHJva2VDb2xvcixcInBvaW50Q29sb3JcIixvcmRlcmksLTEse251bGx2YWx1ZTogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZT1zZXRPcHRpb25WYWx1ZShmYWxzZSwxLFwiTEVHRU5ETUFSS0VSU1RST0tFU1RZTEVcIixjdHgsZGF0YSx1bmRlZmluZWQsZGF0YS5kYXRhc2V0c1tvcmRlcmldLnBvaW50U3Ryb2tlQ29sb3IsY29uZmlnLmRlZmF1bHRTdHJva2VDb2xvcixcInBvaW50U3Ryb2tlQ29sb3JcIixvcmRlcmksLTEse251bGx2YWx1ZTogdHJ1ZX0gKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lV2lkdGg9c2V0T3B0aW9uVmFsdWUoZmFsc2UsY3R4LmNoYXJ0TGluZVNjYWxlLFwiTEVHRU5ETUFSS0VSTElORVdJRFRIXCIsY3R4LGRhdGEsdW5kZWZpbmVkLGRhdGEuZGF0YXNldHNbb3JkZXJpXS5wb2ludERvdFN0cm9rZVdpZHRoLGNvbmZpZy5wb2ludERvdFN0cm9rZVdpZHRoLFwicG9pbnREb3RTdHJva2VXaWR0aFwiLG9yZGVyaSwtMSx7bnVsbHZhbHVlOiB0cnVlfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgXHRcblx0XHRcdFx0XHRcdHZhciBtYXJrZXJTaGFwZT1zZXRPcHRpb25WYWx1ZShmYWxzZSwxLFwiTEVHRU5ETUFSS0VSU0hBUEVcIixjdHgsZGF0YSx1bmRlZmluZWQsZGF0YS5kYXRhc2V0c1tvcmRlcmldLm1hcmtlclNoYXBlLGNvbmZpZy5tYXJrZXJTaGFwZSxcIm1hcmtlclNoYXBlXCIsb3JkZXJpLC0xLHtudWxsdmFsdWU6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHR2YXIgbWFya2VyUmFkaXVzPXNldE9wdGlvblZhbHVlKGZhbHNlLGN0eC5jaGFydFNwYWNlU2NhbGUsXCJMRUdFTkRNQVJLRVJSQURJVVNcIixjdHgsZGF0YSx1bmRlZmluZWQsZGF0YS5kYXRhc2V0c1tvcmRlcmldLnBvaW50RG90UmFkaXVzLGNvbmZpZy5wb2ludERvdFJhZGl1cyxcInBvaW50RG90UmFkaXVzXCIsb3JkZXJpLC0xLHtudWxsdmFsdWU6IHRydWV9ICk7XG5cdFx0XHRcdFx0XHR2YXIgbWFya2VyU3Ryb2tlU3R5bGU9c2V0T3B0aW9uVmFsdWUoZmFsc2UsMSxcIkxFR0VORE1BUktFUlNUUk9LRVNUWUxFXCIsY3R4LGRhdGEsdW5kZWZpbmVkLGRhdGEuZGF0YXNldHNbb3JkZXJpXS5wb2ludERvdFN0cm9rZVN0eWxlLGNvbmZpZy5wb2ludERvdFN0cm9rZVN0eWxlLFwicG9pbnREb3RTdHJva2VTdHlsZVwiLG9yZGVyaSwtMSx7bnVsbHZhbHVlOiB0cnVlfSApO1xuXHRcdFx0XHRcdFx0ZHJhd01hcmtlcihjdHgseHBvcyArIDIgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRCbG9ja1NpemUpLzIsIHlwb3MgLSAoKE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEZvbnRTaXplKSkgLyAyKSwgbWFya2VyU2hhcGUsbWFya2VyUmFkaXVzLG1hcmtlclN0cm9rZVN0eWxlKTtcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguZmlsbCgpO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHguZm9udCA9IGNvbmZpZy5sZWdlbmRGb250U3R5bGUgKyBcIiBcIiArIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmNvbmZpZy5sZWdlbmRGb250U2l6ZSkpLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgY29uZmlnLmxlZ2VuZEZvbnRGYW1pbHk7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBzZXRPcHRpb25WYWx1ZShmYWxzZSwxLFwiTEVHRU5ERk9OVENPTE9SXCIsY3R4LGRhdGEsdW5kZWZpbmVkLHVuZGVmaW5lZCxjb25maWcubGVnZW5kRm9udENvbG9yLFwibGVnZW5kRm9udENvbG9yXCIsb3JkZXJpLC0xLHtudWxsdmFsdWU6IHRydWV9ICk7XG5cdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG5cdFx0XHRcdGN0eC50cmFuc2xhdGUoeHBvcyArIE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqY29uZmlnLmxlZ2VuZEJsb2NrU2l6ZSkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcubGVnZW5kU3BhY2VCZXR3ZWVuQm94QW5kVGV4dCksIHlwb3MpO1xuLy9cdFx0XHRcdGN0eC5maWxsVGV4dChsZ3R4dCwgMCwgMCk7XG5cdFx0XHRcdGN0eC5maWxsVGV4dE11bHRpTGluZShsZ3R4dCwgMCwgMCwgY3R4LnRleHRCYXNlbGluZSwgTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kRm9udFNpemUpLCB0cnVlLGNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJMRUdFTkRfVEVYVE1PVVNFXCIsMCx4cG9zICsgTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpjb25maWcubGVnZW5kQmxvY2tTaXplKSArIE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5sZWdlbmRTcGFjZUJldHdlZW5Cb3hBbmRUZXh0KSwgeXBvcyxvcmRlcmksLTEpO1xuXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5mdW5jdGlvbiBkcmF3TWFya2VyKGN0eCx4cG9zLHlwb3MsbWFya2VyLG1hcmtlcnNpemUsbWFya2VyU3Ryb2tlU3R5bGUpIHtcblx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKG1hcmtlclN0cm9rZVN0eWxlKSk7XG5cdHN3aXRjaCAobWFya2VyKSB7XG5cdFx0Y2FzZSBcInNxdWFyZVwiOlxuXHRcdFx0Y3R4LnJlY3QoeHBvcy1tYXJrZXJzaXplLHlwb3MtbWFya2Vyc2l6ZSwyKm1hcmtlcnNpemUsMiptYXJrZXJzaXplKTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcInRyaWFuZ2xlXCI6XG5cdFx0XHRwb2ludEFfeD0wO1xuXHRcdFx0cG9pbnRBX3k9Mi8zKm1hcmtlcnNpemU7XG5cdFx0XHRjdHgubW92ZVRvKHhwb3MseXBvcy1wb2ludEFfeSk7XG5cdFx0XHRjdHgubGluZVRvKHhwb3MrcG9pbnRBX3kqTWF0aC5zaW4oNC8zKSx5cG9zK3BvaW50QV95Kk1hdGguY29zKDQvMykpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4cG9zLXBvaW50QV95Kk1hdGguc2luKDQvMykseXBvcytwb2ludEFfeSpNYXRoLmNvcyg0LzMpKTtcblx0XHRcdGN0eC5saW5lVG8oeHBvcyx5cG9zLXBvaW50QV95KTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcImRpYW1vbmRcIjpcblx0XHRcdGN0eC5tb3ZlVG8oeHBvcywgeXBvcyttYXJrZXJzaXplKTtcblx0XHRcdGN0eC5saW5lVG8oeHBvcyttYXJrZXJzaXplLCB5cG9zKTtcblx0XHRcdGN0eC5saW5lVG8oeHBvcywgeXBvcy1tYXJrZXJzaXplKTtcblx0XHRcdGN0eC5saW5lVG8oeHBvcy1tYXJrZXJzaXplLCB5cG9zKTtcblx0XHRcdGN0eC5saW5lVG8oeHBvcywgeXBvcyttYXJrZXJzaXplKTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcInBsdXNcIjpcblx0XHRcdGN0eC5tb3ZlVG8oeHBvcywgeXBvcy1tYXJrZXJzaXplKTtcblx0XHRcdGN0eC5saW5lVG8oeHBvcywgeXBvcyttYXJrZXJzaXplKTtcblx0XHRcdGN0eC5tb3ZlVG8oeHBvcy1tYXJrZXJzaXplLCB5cG9zKTtcblx0XHRcdGN0eC5saW5lVG8oeHBvcyttYXJrZXJzaXplLCB5cG9zKTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwiY3Jvc3NcIjpcblx0XHRcdGN0eC5tb3ZlVG8oeHBvcy1tYXJrZXJzaXplLCB5cG9zLW1hcmtlcnNpemUpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4cG9zK21hcmtlcnNpemUsIHlwb3MrbWFya2Vyc2l6ZSk7XG5cdFx0XHRjdHgubW92ZVRvKHhwb3MtbWFya2Vyc2l6ZSwgeXBvcyttYXJrZXJzaXplKTtcblx0XHRcdGN0eC5saW5lVG8oeHBvcyttYXJrZXJzaXplLCB5cG9zLW1hcmtlcnNpemUpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJjaXJjbGVcIjpcblx0XHRkZWZhdWx0OlxuXHRcdFx0Y3R4LmFyYyh4cG9zLCB5cG9zLCBtYXJrZXJzaXplLCAwLCAyKk1hdGguUEkgKiAxLCB0cnVlKTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0YnJlYWs7XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGluaXRQYXNzVmFyaWFibGVEYXRhX3BhcnQxKGRhdGEsY29uZmlnLGN0eCkge1xudmFyIGksaixyZXN1bHQsIG14dmFsdWUgLG1udmFsdWUsIGN1bXZhbHVlLCB0b3R2YWx1ZSxsbWF4dmFsdWUsbG1pbnZhbHVlLGxndHh0LGxndHh0Mix0cCxwcmV2cG9zLGZpcnN0Tm90TWlzc2luZ2ksbGFzdE5vdE1pc3NpbmdpLGZpcnN0Tm90TWlzc2luZ2osbGFzdE5vdE1pc3NpbmdqLGdyYW5kdG90YWw7XG5zd2l0Y2goY3R4LnRwZGF0YSkge1xuXHRjYXNlIDEgOlxuXG5cdFx0cmVzdWx0PVtdO1xuXHRcdHZhciBzZWdtZW50QW5nbGUsY3VtdWxhdGl2ZUFuZ2xlLHJlYWxDdW11bGF0aXZlQW5nbGU7XG5cblx0XHR2YXIgcmVhbEFtcGxpdHVkZSA9ICgoKGNvbmZpZy50b3RhbEFtcGxpdHVkZSAqIChNYXRoLlBJIC8gMTgwKSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkpICsgMiogTWF0aC5QSSkgJSAoMiogTWF0aC5QSSkgOyBcblx0XHRpZihyZWFsQW1wbGl0dWRlIDw9IGNvbmZpZy56ZXJvVmFsdWUpcmVhbEFtcGxpdHVkZT0yKk1hdGguUEk7XG5cblx0XHRjdW11bGF0aXZlQW5nbGUgPSAoKCgtY29uZmlnLnN0YXJ0QW5nbGUgKiAoTWF0aC5QSSAvIDE4MCkgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpKSArIDIqIE1hdGguUEkpICUgKDIqIE1hdGguUEkpIDsgXG5cdFx0cmVhbEN1bXVsYXRpdmVBbmdsZSA9ICgoKGNvbmZpZy5zdGFydEFuZ2xlICogKE1hdGguUEkgLyAxODApICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSkgKyAyKiBNYXRoLlBJKSAlICgyKiBNYXRoLlBJKSA7IFxuXG5cdFx0c3RhcnRBbmdsZT1jdW11bGF0aXZlQW5nbGU7XG5cdFx0dG90dmFsdWUgPSAwO1xuXHRcdG5vdGVtcHR5dmFsPTA7XG5cdFx0dmFyIGZpcnN0Tm90TWlzc2luZyA9IC0xO1xuXHRcdHZhciBsYXN0Tm90TWlzc2luZyA9IC0xO1xuXHRcdHZhciBwcmV2Tm90TWlzc2luZyA9IC0xO1xuXHRcdG14dmFsdWU9LU51bWJlci5NQVhfVkFMVUU7XG5cdFx0bW52YWx1ZT1OdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZihjdHgudHBjaGFydCAhPSBcIlBvbGFyQXJlYVwiICYmIDEqZGF0YVtpXS52YWx1ZTwwKWNvbnRpbnVlO1xuXHRcdFx0aWYgKCEodHlwZW9mKGRhdGFbaV0udmFsdWUpID09ICd1bmRlZmluZWQnKSkgeyBcblx0XHRcdFx0aWYoZmlyc3ROb3RNaXNzaW5nPT0tMSlmaXJzdE5vdE1pc3Npbmc9aTtcblx0XHRcdFx0bXh2YWx1ZT1NYXRoLm1heChteHZhbHVlLDEqZGF0YVtpXS52YWx1ZSk7XG5cdFx0XHRcdG1udmFsdWU9TWF0aC5taW4obW52YWx1ZSwxKmRhdGFbaV0udmFsdWUpO1xuXHRcdFx0XHRub3RlbXB0eXZhbCsrOyBcblx0XHRcdFx0dG90dmFsdWUgKz0gMSAqIGRhdGFbaV0udmFsdWU7XG5cdFx0XHRcdGxhc3ROb3RNaXNzaW5nPWk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRjdW12YWx1ZT0wO1xuXHRcdHZhciBwcmV2TWlzc2luZz0tMTtcblx0XHRmb3IoaT0wO2k8ZGF0YS5sZW5ndGg7aSsrKSB7XG5cdFx0XHRpZiAodHlwZW9mKGRhdGFbaV0udGl0bGUpID09IFwic3RyaW5nXCIpIGxndHh0ID0gZGF0YVtpXS50aXRsZS50cmltKCk7XG5cdFx0XHRlbHNlIGxndHh0ID0gXCJcIjtcblx0XHRcdGlmICghKHR5cGVvZihkYXRhW2ldLnZhbHVlKSA9PSAndW5kZWZpbmVkJykgJiYgKGN0eC50cGNoYXJ0ID09IFwiUG9sYXJBcmVhXCIgfHwgMSpkYXRhW2ldLnZhbHVlPj0wKSkge1xuLy9cdFx0XHRcdGlmKGN0eC50cGNoYXJ0PT1cIlBvbGFyQXJlYVwiKSB7IGlmKG5vdGVtcHR5dmFsPjApc2VnbWVudEFuZ2xlPSAoTWF0aC5QSSAqMikvbm90ZW1wdHl2YWw7IGVsc2Ugc2VnbWVudEFuZ2xlPTA7IH1cbi8vXHRcdFx0XHRlbHNlIHNlZ21lbnRBbmdsZSA9ICgxICogZGF0YVtpXS52YWx1ZSAvIHRvdHZhbHVlKSAqIChNYXRoLlBJICogMik7XG5cdFx0XHRcdGlmKGN0eC50cGNoYXJ0PT1cIlBvbGFyQXJlYVwiKSB7IGlmKG5vdGVtcHR5dmFsPjApc2VnbWVudEFuZ2xlPSByZWFsQW1wbGl0dWRlL25vdGVtcHR5dmFsOyBlbHNlIHNlZ21lbnRBbmdsZT0wOyB9XG5cdFx0XHRcdGVsc2Ugc2VnbWVudEFuZ2xlID0gKDEgKiBkYXRhW2ldLnZhbHVlIC8gdG90dmFsdWUpICogcmVhbEFtcGxpdHVkZTtcblx0XHRcdFx0aWYgKHNlZ21lbnRBbmdsZSA+PSBNYXRoLlBJICogMikgc2VnbWVudEFuZ2xlID0gTWF0aC5QSSAqIDIgLSAwLjAwMTsgLy8gYnVnIG9uIEFuZHJvaWQgd2hlbiBzZWdtZW50QW5nbGUgaXMgPj0gMipQSTtcblx0XHRcdFx0Y3VtdmFsdWUgKz0gMSAqIGRhdGFbaV0udmFsdWU7XG5cdFx0XHRcdHJlc3VsdFtpXT0ge1xuXHRcdFx0XHRcdGNvbmZpZzogY29uZmlnLFxuXHRcdFx0XHRcdHYxOiBmbXRDaGFydEpTKGNvbmZpZywgbGd0eHQsIGNvbmZpZy5mbXRWMSksXG5cdFx0XHRcdFx0djI6IGZtdENoYXJ0SlMoY29uZmlnLCAxICogZGF0YVtpXS52YWx1ZSwgY29uZmlnLmZtdFYyKSxcblx0XHRcdFx0XHR2MzogZm10Q2hhcnRKUyhjb25maWcsIGN1bXZhbHVlLCBjb25maWcuZm10VjMpLFxuXHRcdFx0XHRcdHY0OiBmbXRDaGFydEpTKGNvbmZpZywgdG90dmFsdWUsIGNvbmZpZy5mbXRWNCksXG5cdFx0XHRcdFx0djU6IGZtdENoYXJ0SlMoY29uZmlnLCBzZWdtZW50QW5nbGUsIGNvbmZpZy5mbXRWNSksXG5cdFx0XHRcdFx0djY6IHJvdW5kVG9XaXRoVGhvdXNhbmRzKGNvbmZpZywgZm10Q2hhcnRKUyhjb25maWcsIDEwMCAqIGRhdGFbaV0udmFsdWUgLyB0b3R2YWx1ZSwgY29uZmlnLmZtdFY2KSwgY29uZmlnLnJvdW5kUGN0KSxcblx0XHRcdFx0XHR2NyA6IDAsXG5cdFx0XHRcdFx0djggOiAwLFxuXHRcdFx0XHRcdHY5IDogMCxcblx0XHRcdFx0XHR2MTAgOiAwLFxuXHRcdFx0XHRcdHYxMTogZm10Q2hhcnRKUyhjb25maWcsIGN1bXVsYXRpdmVBbmdsZSAtIHNlZ21lbnRBbmdsZSwgY29uZmlnLmZtdFYxMSksXG5cdFx0XHRcdFx0djEyOiBmbXRDaGFydEpTKGNvbmZpZywgY3VtdWxhdGl2ZUFuZ2xlLCBjb25maWcuZm10VjEyKSxcblx0XHRcdFx0XHR2MTM6IGZtdENoYXJ0SlMoY29uZmlnLCBpLCBjb25maWcuZm10VjEzKSxcblx0XHRcdFx0XHRsZ3R4dDogbGd0eHQsXG5cdFx0XHRcdFx0ZGF0YXZhbHVlOiAxICogZGF0YVtpXS52YWx1ZSxcblx0XHRcdFx0XHRjdW12YWx1ZTogY3VtdmFsdWUsXG5cdFx0XHRcdFx0dG90dmFsdWU6IHRvdHZhbHVlLFxuXHRcdFx0XHRcdHNlZ21lbnRBbmdsZTogc2VnbWVudEFuZ2xlLFxuXHRcdFx0XHRcdGZpcnN0QW5nbGUgOiBzdGFydEFuZ2xlLFxuXHRcdFx0XHRcdHBjdHZhbHVlOiAxMDAgKiBkYXRhW2ldLnZhbHVlIC8gdG90dmFsdWUsXG5cdFx0XHRcdFx0c3RhcnRBbmdsZTogY3VtdWxhdGl2ZUFuZ2xlLFxuXHRcdFx0XHRcdHJlYWxTdGFydEFuZ2xlIDogcmVhbEN1bXVsYXRpdmVBbmdsZSxcblx0XHRcdFx0XHRlbmRBbmdsZTogY3VtdWxhdGl2ZUFuZ2xlK3NlZ21lbnRBbmdsZSxcblx0XHRcdFx0XHRtYXh2YWx1ZSA6IG14dmFsdWUsXG5cdFx0XHRcdFx0bWludmFsdWUgOiBtbnZhbHVlLFxuXHRcdFx0XHRcdGk6IGksXG5cdFx0XHRcdFx0Zmlyc3ROb3RNaXNzaW5nIDogZmlyc3ROb3RNaXNzaW5nLFxuXHRcdFx0XHRcdGxhc3ROb3RNaXNzaW5nIDogbGFzdE5vdE1pc3NpbmcsXG5cdFx0XHRcdFx0cHJldk5vdE1pc3NpbmcgOiBwcmV2Tm90TWlzc2luZyxcblx0XHRcdFx0XHRwcmV2TWlzc2luZyA6IHByZXZNaXNzaW5nLFxuXHRcdFx0XHRcdG5leHROb3RNaXNzaW5nIDogLTEsXG5cdFx0XHRcdCAgICAgICAgcmFkaXVzT2Zmc2V0IDogMCxcblx0XHRcdFx0XHRtaWRQb3NYIDogMCxcblx0XHRcdFx0XHRtaWRQb3NZIDogMCxcblx0XHRcdFx0XHRpbnRfcmFkaXVzIDogMCxcblx0XHRcdFx0XHRleHRfcmFkaXVzIDogMCxcblx0XHRcdFx0XHRkYXRhOiBkYXRhXG5cdFx0XHRcdH07ICAgXG5cdFx0XHRcdGN1bXVsYXRpdmVBbmdsZSArPSBzZWdtZW50QW5nbGU7XG5cdFx0XHRcdHJlYWxDdW11bGF0aXZlQW5nbGUgLT0gc2VnbWVudEFuZ2xlO1xuXHRcdFx0XHRpZihwcmV2Tm90TWlzc2luZyAhPSAtMSkgcmVzdWx0W3ByZXZOb3RNaXNzaW5nXS5uZXh0Tm90TWlzc2luZz1pO1xuXHRcdFx0XHRwcmV2Tm90TWlzc2luZyA9IGk7XG4gICAgICAgIFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRbaV09eyBcblx0XHRcdFx0XHR2MTpsZ3R4dCxcblx0XHRcdFx0XHRtYXh2YWx1ZSA6IG14dmFsdWUsXG5cdFx0XHRcdFx0bWludmFsdWUgOiBtbnZhbHVlLFxuXHRcdFx0XHRcdGk6IGksXG5cdFx0XHRcdFx0Zmlyc3ROb3RNaXNzaW5nIDogZmlyc3ROb3RNaXNzaW5nLFxuXHRcdFx0XHRcdGxhc3ROb3RNaXNzaW5nIDogbGFzdE5vdE1pc3NpbmcsXG5cdFx0XHRcdFx0cHJldk5vdE1pc3NpbmcgOiBwcmV2Tm90TWlzc2luZ1xuXHRcdFx0XHQgfTsgXG5cdFx0XHRcdCBwcmV2TWlzc2luZz1pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRicmVhaztcblx0Y2FzZSAwOlxuXHRkZWZhdWx0IDogXG5cdFx0dmFyIGF4aXM7XG5cdFx0cmVzdWx0PVtdO1xuXHRcdG14dmFsdWU9W107XG5cdFx0bXh2YWx1ZVswXT1bXTtcblx0XHRteHZhbHVlWzFdPVtdO1xuXHRcdG1udmFsdWU9W107XG5cdFx0bW52YWx1ZVswXT1bXTtcblx0XHRtbnZhbHVlWzFdPVtdO1xuXHRcdGN1bXZhbHVlPVtdO1xuXHRcdGN1bXZhbHVlWzBdPVtdO1xuXHRcdGN1bXZhbHVlWzFdPVtdO1xuXHRcdHRvdHZhbHVlPVtdO1xuXHRcdHRvdHZhbHVlWzBdPVtdO1xuXHRcdHRvdHZhbHVlWzFdPVtdO1xuXHRcdGxtYXh2YWx1ZT1bXTtcblx0XHRsbWF4dmFsdWVbMF09W107XG5cdFx0bG1heHZhbHVlWzFdPVtdO1xuXHRcdGxtaW52YWx1ZT1bXTtcblx0XHRsbWludmFsdWVbMF09W107XG5cdFx0bG1pbnZhbHVlWzFdPVtdO1xuXHRcdHByZXZwb3M9W107XG5cdFx0Zmlyc3ROb3RNaXNzaW5naT1bXTtcblx0XHRsYXN0Tm90TWlzc2luZ2k9W107XG5cdFx0Zmlyc3ROb3RNaXNzaW5naj1bXTtcblx0XHRsYXN0Tm90TWlzc2luZ2o9W107XG5cdFx0cHJldnBvc1swXT1bXTtcblx0XHRwcmV2cG9zWzFdPVtdO1xuXHRcdGdyYW5kdG90YWw9MDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQvLyBCVUcgd2hlbiBhbGwgZGF0YSBhcmUgbWlzc2luZyAhXG5cdFx0XHRpZiAodHlwZW9mIGRhdGEuZGF0YXNldHNbaV0ueFBvcyAhPSBcInVuZGVmaW5lZFwiICYmIHRwZHJhdyhjdHgsZGF0YS5kYXRhc2V0c1tpXSk9PVwiTGluZVwiKSB7XG5cdFx0XHRcdGZvcihqPWRhdGEuZGF0YXNldHNbaV0uZGF0YS5sZW5ndGg7ajxkYXRhLmRhdGFzZXRzW2ldLnhQb3MubGVuZ3RoO2orKylkYXRhLmRhdGFzZXRzW2ldLmRhdGEucHVzaCh1bmRlZmluZWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yKGo9ZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aDtqPGRhdGEubGFiZWxzLmxlbmd0aDtqKyspZGF0YS5kYXRhc2V0c1tpXS5kYXRhLnB1c2godW5kZWZpbmVkKTtcblx0XHRcdH1cblx0XHRcdFx0XG5cblx0XHRcdGlmKGRhdGEuZGF0YXNldHNbaV0uYXhpcyA9PSAyKSBheGlzPTA7ZWxzZSBheGlzPTE7XG5cdFx0XHRyZXN1bHRbaV09W107XG5cdFx0XHRsbWF4dmFsdWVbMF1baV09LU51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHRsbWF4dmFsdWVbMV1baV09LU51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHRsbWludmFsdWVbMF1baV09TnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdGxtaW52YWx1ZVsxXVtpXT1OdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdFx0Zmlyc3ROb3RNaXNzaW5naVtpXT0tMTtcblx0XHRcdGxhc3ROb3RNaXNzaW5naVtpXT0tMTtcblx0XHRcdGZvciAoaiA9IDA7IGogPCBkYXRhLmRhdGFzZXRzW2ldLmRhdGEubGVuZ3RoOyBqKyspIHtcblxuXHRcdFx0XHRpZih0eXBlb2YgZmlyc3ROb3RNaXNzaW5naltqXT09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdGZpcnN0Tm90TWlzc2luZ2pbal09LTE7XG5cdFx0XHRcdFx0bGFzdE5vdE1pc3NpbmdqW2pdPS0xO1xuXHRcdFx0XHRcdHRvdHZhbHVlWzBdW2pdID0gMDsgXG5cdFx0XHRcdFx0bXh2YWx1ZVswXVtqXT0tTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdFx0XHRtbnZhbHVlWzBdW2pdPU51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHRcdFx0dG90dmFsdWVbMV1bal0gPSAwOyBcblx0XHRcdFx0XHRteHZhbHVlWzFdW2pdPS1OdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdFx0XHRcdG1udmFsdWVbMV1bal09TnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoISh0eXBlb2YgZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdID09ICd1bmRlZmluZWQnKSkge1xuXHRcdFx0XHRcdGdyYW5kdG90YWwgKz0gMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXTtcblx0XHRcdFx0XHRpZihmaXJzdE5vdE1pc3NpbmdpW2ldPT0tMSlmaXJzdE5vdE1pc3NpbmdpW2ldPWo7XG5cdFx0XHRcdFx0bGFzdE5vdE1pc3NpbmdpW2ldPWo7XG5cdFx0XHRcdFx0aWYoZmlyc3ROb3RNaXNzaW5naltqXT09LTEpZmlyc3ROb3RNaXNzaW5naltqXT1pO1xuXHRcdFx0XHRcdGxhc3ROb3RNaXNzaW5naltqXT1pO1xuXHRcdFx0XHRcdHRvdHZhbHVlW2F4aXNdW2pdICs9IDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal07IFxuXHRcdFx0XHRcdG14dmFsdWVbYXhpc11bal0gPU1hdGgubWF4KG14dmFsdWVbYXhpc11bal0sMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSk7XG5cdFx0XHRcdFx0bW52YWx1ZVtheGlzXVtqXSA9TWF0aC5taW4obW52YWx1ZVtheGlzXVtqXSwxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKTtcblx0XHRcdFx0XHRsbWF4dmFsdWVbYXhpc11baV0gPU1hdGgubWF4KGxtYXh2YWx1ZVtheGlzXVtpXSwxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKTtcblx0XHRcdFx0XHRsbWludmFsdWVbYXhpc11baV0gPU1hdGgubWluKGxtaW52YWx1ZVtheGlzXVtpXSwxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYoZGF0YS5kYXRhc2V0c1tpXS5heGlzID09IDIpIGF4aXM9MDtlbHNlIGF4aXM9MTtcblx0XHRcdGlmICh0eXBlb2YoZGF0YS5kYXRhc2V0c1tpXS50aXRsZSkgPT0gXCJzdHJpbmdcIikgbGd0eHQgPSBkYXRhLmRhdGFzZXRzW2ldLnRpdGxlLnRyaW0oKTtcblx0XHRcdGVsc2UgbGd0eHQgPSBcIlwiO1xuXHRcdFx0dmFyIHByZXZub3RlbXB0eWo9LTE7XG5cdFx0XHR2YXIgcHJldmVtcHR5aj0tMTtcblx0XHRcdGZvciAoaiA9IDA7IGogPCBkYXRhLmRhdGFzZXRzW2ldLmRhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFxuXHRcdFx0XHRpZih0eXBlb2YgY3VtdmFsdWVbMF1bal09PSBcInVuZGVmaW5lZFwiKXtjdW12YWx1ZVswXVtqXSA9IDA7IHByZXZwb3NbMF1bal09LTE7Y3VtdmFsdWVbMV1bal0gPSAwOyBwcmV2cG9zWzFdW2pdPS0xOyB9XG5cdFx0XHRcdGxndHh0MiA9IFwiXCI7XG5cdFx0XHRcdGlmICh0eXBlb2YgZGF0YS5kYXRhc2V0c1tpXS54UG9zICE9IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0XHRpZiAoISh0eXBlb2YgZGF0YS5kYXRhc2V0c1tpXS54UG9zW2pdID09IFwidW5kZWZpbmVkXCIpKSBsZ3R4dDIgPSBkYXRhLmRhdGFzZXRzW2ldLnhQb3Nbal07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxndHh0MiA9PSBcIlwiICYmICEodHlwZW9mKGRhdGEubGFiZWxzW2pdKSA9PSBcInVuZGVmaW5lZFwiKSkgbGd0eHQyID0gZGF0YS5sYWJlbHNbal07XG5cdFx0XHRcdGlmICh0eXBlb2YgbGd0eHQyID09IFwic3RyaW5nXCIpIGxndHh0MiA9IGxndHh0Mi50cmltKCk7XG5cbi8vXHRcdFx0XHRpZiAoISh0eXBlb2YoZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKSA9PSAndW5kZWZpbmVkJykgJiYgZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdICE9IDApIHtcblx0XHRcdFx0aWYgKCEodHlwZW9mKGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSkgPT0gJ3VuZGVmaW5lZCcpICkge1xuXHRcdFx0XHRcdGN1bXZhbHVlW2F4aXNdW2pdKz0xKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXTtcblx0XHRcdFx0XHRzd2l0Y2godHBkcmF3KGN0eCxkYXRhLmRhdGFzZXRzW2ldKSkgIHtcblx0XHRcdFx0XHRcdGNhc2UgXCJCYXJcIiA6XG5cdFx0XHRcdFx0XHRjYXNlIFwiU3RhY2tlZEJhclwiIDpcblx0XHRcdFx0XHRcdGNhc2UgXCJIb3Jpem9udGFsQmFyXCIgOlxuXHRcdFx0XHRcdFx0Y2FzZSBcIkhvcml6b250YWxTdGFja2VkQmFyXCIgOlxuXHRcdFx0XHRcdFx0XHRyZXN1bHRbaV1bal09IHtcblx0XHRcdFx0XHRcdFx0XHRjb25maWc6IGNvbmZpZyxcblx0XHRcdFx0XHRcdFx0XHR2MTogZm10Q2hhcnRKUyhjb25maWcsIGxndHh0LCBjb25maWcuZm10VjEpLFxuXHRcdFx0XHRcdFx0XHRcdHYyOiBmbXRDaGFydEpTKGNvbmZpZywgbGd0eHQyLCBjb25maWcuZm10VjIpLFxuXHRcdFx0XHRcdFx0XHRcdHYzOiBmbXRDaGFydEpTKGNvbmZpZywgMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSwgY29uZmlnLmZtdFYzKSxcblx0XHRcdFx0XHRcdFx0XHR2NDogZm10Q2hhcnRKUyhjb25maWcsIGN1bXZhbHVlW2F4aXNdW2pdLCBjb25maWcuZm10VjQpLFxuXHRcdFx0XHRcdFx0XHRcdHY1OiBmbXRDaGFydEpTKGNvbmZpZywgdG90dmFsdWVbYXhpc11bal0sIGNvbmZpZy5mbXRWNSksXG5cdFx0XHRcdFx0XHRcdFx0djY6IHJvdW5kVG9XaXRoVGhvdXNhbmRzKGNvbmZpZywgZm10Q2hhcnRKUyhjb25maWcsIDEwMCAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSAvIHRvdHZhbHVlW2F4aXNdW2pdLCBjb25maWcuZm10VjYpLCBjb25maWcucm91bmRQY3QpLFxuXHRcdFx0XHRcdFx0XHRcdHY2VDogcm91bmRUb1dpdGhUaG91c2FuZHMoY29uZmlnLCBmbXRDaGFydEpTKGNvbmZpZywgMTAwICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdIC8gZ3JhbmR0b3RhbCwgY29uZmlnLmZtdFY2VCksIGNvbmZpZy5yb3VuZFBjdCksXG5cdFx0XHRcdFx0XHRcdFx0djExOiBmbXRDaGFydEpTKGNvbmZpZywgaSwgY29uZmlnLmZtdFYxMSksXG5cdFx0XHRcdFx0XHRcdFx0djEyOiBmbXRDaGFydEpTKGNvbmZpZywgaiwgY29uZmlnLmZtdFYxMiksXG5cdFx0XHRcdFx0XHRcdFx0bGd0eHQ6IGxndHh0LFxuXHRcdFx0XHRcdFx0XHRcdGxndHh0MjogbGd0eHQyLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGF2YWx1ZTogMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSxcblx0XHRcdFx0XHRcdFx0XHRjdW12YWx1ZTogY3VtdmFsdWVbYXhpc11bal0sXG5cdFx0XHRcdFx0XHRcdFx0dG90dmFsdWU6IHRvdHZhbHVlW2F4aXNdW2pdLFxuXHRcdFx0XHRcdFx0XHRcdHBjdHZhbHVlOiAxMDAgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gLyB0b3R2YWx1ZVtheGlzXVtqXSxcblx0XHRcdFx0XHRcdFx0XHRwY3R2YWx1ZVQ6IDEwMCAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSAvIGdyYW5kdG90YWwsXG5cdFx0XHRcdFx0XHRcdFx0bWF4dmFsdWUgOiBteHZhbHVlW2F4aXNdW2pdLFxuXHRcdFx0XHRcdFx0XHRcdG1pbnZhbHVlIDogbW52YWx1ZVtheGlzXVtqXSxcblx0XHRcdFx0XHRcdFx0XHRsbWF4dmFsdWUgOiBsbWF4dmFsdWVbYXhpc11baV0sXG5cdFx0XHRcdFx0XHRcdFx0bG1pbnZhbHVlIDogbG1pbnZhbHVlW2F4aXNdW2ldLFxuXHRcdFx0XHRcdFx0XHRcdGdyYW5kdG90YWwgOiBncmFuZHRvdGFsLFxuXHRcdFx0XHRcdFx0XHRcdGZpcnN0Tm90TWlzc2luZyA6IGZpcnN0Tm90TWlzc2luZ2pbal0sXG5cdFx0XHRcdFx0XHRcdFx0bGFzdE5vdE1pc3NpbmcgOiBsYXN0Tm90TWlzc2luZ2pbal0sXG5cdFx0XHRcdFx0XHRcdFx0cHJldk5vdE1pc3NpbmcgOiBwcmV2bm90ZW1wdHlqLFxuXHRcdFx0XHRcdFx0XHRcdHByZXZNaXNzaW5nIDogcHJldmVtcHR5aixcblx0XHRcdFx0XHRcdFx0XHRuZXh0Tm90TWlzc2luZyA6IC0xLFxuXHRcdFx0XHRcdFx0XHRcdGo6IGosXG5cdFx0XHRcdFx0XHRcdFx0aTogaSxcblx0XHRcdFx0XHRcdFx0XHRkYXRhOiBkYXRhXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGlmKDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal09PTAgJiYgKHRwZHJhdyhjdHgsZGF0YS5kYXRhc2V0c1tpXSk9PVwiSG9yaXpvbnRhbFN0YWNrZWRCYXJcIiB8fCB0cGRyYXcoY3R4LGRhdGEuZGF0YXNldHNbaV0pPT1cIlN0YWNrZWRCYXJcIikpcmVzdWx0W2ldW2pdLnYzPVwiXCI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIkxpbmVcIiA6XG5cdFx0XHRcdFx0XHRjYXNlIFwiUmFkYXJcIiA6XG5cdFx0XHRcdFx0XHRcdHJlc3VsdFtpXVtqXT0ge1xuXHRcdFx0XHRcdFx0XHRcdGNvbmZpZzogY29uZmlnLFxuXHRcdFx0XHRcdFx0XHRcdHYxOiBmbXRDaGFydEpTKGNvbmZpZywgbGd0eHQsIGNvbmZpZy5mbXRWMSksXG5cdFx0XHRcdFx0XHRcdFx0djI6IGZtdENoYXJ0SlMoY29uZmlnLCBsZ3R4dDIsIGNvbmZpZy5mbXRWMiksXG5cdFx0XHRcdFx0XHRcdFx0djM6IGZtdENoYXJ0SlMoY29uZmlnLCAxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdLCBjb25maWcuZm10VjMpLFxuXHRcdFx0XHRcdFx0XHRcdHY1OiBmbXRDaGFydEpTKGNvbmZpZywgMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSwgY29uZmlnLmZtdFY1KSxcblx0XHRcdFx0XHRcdFx0XHR2NjogZm10Q2hhcnRKUyhjb25maWcsIG14dmFsdWVbYXhpc11bal0sIGNvbmZpZy5mbXRWNiksXG5cdFx0XHRcdFx0XHRcdFx0djc6IGZtdENoYXJ0SlMoY29uZmlnLCB0b3R2YWx1ZVtheGlzXVtqXSwgY29uZmlnLmZtdFY3KSxcblx0XHRcdFx0XHRcdFx0XHR2ODogcm91bmRUb1dpdGhUaG91c2FuZHMoY29uZmlnLCBmbXRDaGFydEpTKGNvbmZpZywgMTAwICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdIC8gdG90dmFsdWVbYXhpc11bal0sIGNvbmZpZy5mbXRWOCksIGNvbmZpZy5yb3VuZFBjdCksXG5cdFx0XHRcdFx0XHRcdFx0djhUOiByb3VuZFRvV2l0aFRob3VzYW5kcyhjb25maWcsIGZtdENoYXJ0SlMoY29uZmlnLCAxMDAgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gLyBncmFuZHRvdGFsLCBjb25maWcuZm10VjhUKSwgY29uZmlnLnJvdW5kUGN0KSxcblx0XHRcdFx0XHRcdFx0XHR2MTE6IGZtdENoYXJ0SlMoY29uZmlnLCBpLCBjb25maWcuZm10VjExKSxcblx0XHRcdFx0XHRcdFx0XHR2MTI6IGZtdENoYXJ0SlMoY29uZmlnLCBqLCBjb25maWcuZm10VjEyKSxcblx0XHRcdFx0XHRcdFx0XHRsZ3R4dDogbGd0eHQsXG5cdFx0XHRcdFx0XHRcdFx0bGd0eHQyOiBsZ3R4dDIsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YXZhbHVlOiAxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdLFxuXHRcdFx0XHRcdFx0XHRcdGRpZmZuZXh0OiAxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdLFxuXHRcdFx0XHRcdFx0XHRcdHBjdHZhbHVlOiAxMDAgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gLyB0b3R2YWx1ZVtheGlzXVtqXSxcblx0XHRcdFx0XHRcdFx0XHRwY3R2YWx1ZVQ6IDEwMCAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSAvIGdyYW5kdG90YWwsXG5cdFx0XHRcdFx0XHRcdFx0dG90dmFsdWUgOiB0b3R2YWx1ZVtheGlzXVtqXSxcblx0XHRcdFx0XHRcdFx0XHRjdW12YWx1ZTogY3VtdmFsdWVbYXhpc11bal0sXG5cdFx0XHRcdFx0XHRcdFx0bWF4dmFsdWUgOiBteHZhbHVlW2F4aXNdW2pdLFxuXHRcdFx0XHRcdFx0XHRcdG1pbnZhbHVlIDogbW52YWx1ZVtheGlzXVtqXSxcblx0XHRcdFx0XHRcdFx0XHRsbWF4dmFsdWUgOiBsbWF4dmFsdWVbYXhpc11baV0sXG5cdFx0XHRcdFx0XHRcdFx0bG1pbnZhbHVlIDogbG1pbnZhbHVlW2F4aXNdW2ldLFxuXHRcdFx0XHRcdFx0XHRcdGdyYW5kdG90YWwgOiBncmFuZHRvdGFsLFxuXHRcdFx0XHRcdFx0XHRcdGZpcnN0Tm90TWlzc2luZyA6IGZpcnN0Tm90TWlzc2luZ2lbaV0sXG5cdFx0XHRcdFx0XHRcdFx0bGFzdE5vdE1pc3NpbmcgOiBsYXN0Tm90TWlzc2luZ2lbaV0sXG5cdFx0XHRcdFx0XHRcdFx0cHJldk5vdE1pc3NpbmcgOiBwcmV2bm90ZW1wdHlqLFxuXHRcdFx0XHRcdFx0XHRcdHByZXZNaXNzaW5nIDogcHJldmVtcHR5aixcblx0XHRcdFx0XHRcdFx0XHRuZXh0Tm90TWlzc2luZyA6IC0xLFxuXHRcdFx0XHRcdFx0XHRcdGo6IGosXG5cdFx0XHRcdFx0XHRcdFx0aTogaSxcblx0XHRcdFx0XHRcdFx0XHRkYXRhOiBkYXRhXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGlmKHByZXZwb3NbYXhpc11bal0+PTApe1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdFtpXVtqXS52ND1mbXRDaGFydEpTKGNvbmZpZywgKHByZXZwb3NbYXhpc11bal0gIT0gLTEgPyAxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdLXJlc3VsdFtwcmV2cG9zW2F4aXNdW2pdXVtqXS5kYXRhdmFsdWUgOiAxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKSwgY29uZmlnLmZtdFY0KTtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRbaV1bal0uZGlmZnByZXY9KHByZXZwb3NbYXhpc11bal0gIT0gLTEgPyAxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdLXJlc3VsdFtwcmV2cG9zW2F4aXNdW2pdXVtqXS5kYXRhdmFsdWUgOiAxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKTtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRbcHJldnBvc1theGlzXVtqXV1bal0uZGlmZm5leHQ9ZGF0YS5kYXRhc2V0c1twcmV2cG9zW2F4aXNdW2pdXS5kYXRhW2pdIC0gZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdO1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdFtwcmV2cG9zW2F4aXNdW2pdXVtqXS52NT1yZXN1bHRbcHJldnBvc1theGlzXVtqXV1bal0uZGlmZm5leHQ7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0W2ldW2pdLnY0PTEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal07XG5cdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHJldnBvc1theGlzXVtqXT1pO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZighKHR5cGVvZihkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0pID09ICd1bmRlZmluZWQnKSkge1xuXHRcdFx0XHRcdFx0aWYocHJldm5vdGVtcHR5aiE9IC0xKSB7Zm9yKGs9cHJldm5vdGVtcHR5ajtrPGo7aysrKSByZXN1bHRbaV1ba10ubmV4dE5vdE1pc3Npbmc9ajt9XHRcblx0XHRcdFx0XHRcdHByZXZub3RlbXB0eWo9ajtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHJldmVtcHR5aj1qOyBcblx0XHRcdFx0XHRzd2l0Y2godHBkcmF3KGN0eCxkYXRhLmRhdGFzZXRzW2ldKSkgIHtcblx0XHRcdFx0XHRcdGNhc2UgXCJCYXJcIiA6XG5cdFx0XHRcdFx0XHRjYXNlIFwiU3RhY2tlZEJhclwiIDpcblx0XHRcdFx0XHRcdGNhc2UgXCJIb3Jpem9udGFsQmFyXCIgOlxuXHRcdFx0XHRcdFx0Y2FzZSBcIkhvcml6b250YWxTdGFja2VkQmFyXCIgOlxuXHRcdFx0XHRcdFx0XHRyZXN1bHRbaV1bal0gPXsgXG5cdFx0XHRcdFx0XHRcdFx0djE6bGd0eHQsXG5cdFx0XHRcdFx0XHRcdFx0bG1heHZhbHVlIDogbG1heHZhbHVlW2F4aXNdW2ldLFxuXHRcdFx0XHRcdFx0XHRcdGxtaW52YWx1ZSA6IGxtaW52YWx1ZVtheGlzXVtpXSxcblx0XHRcdFx0XHRcdFx0XHRmaXJzdE5vdE1pc3NpbmcgOiBmaXJzdE5vdE1pc3NpbmdqW2pdLFxuXHRcdFx0XHRcdFx0XHRcdGxhc3ROb3RNaXNzaW5nIDogbGFzdE5vdE1pc3NpbmdqW2pdLFxuXHRcdFx0XHRcdFx0XHRcdHByZXZOb3RNaXNzaW5nIDogcHJldm5vdGVtcHR5aixcblx0XHRcdFx0XHRcdFx0XHRwcmV2TWlzc2luZyA6IHByZXZlbXB0eWosXG5cdFx0XHRcdFx0XHRcdFx0Z3JhbmR0b3RhbCA6IGdyYW5kdG90YWxcblx0XHRcdFx0XHRcdFx0XHQgfTsgXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIkxpbmVcIiA6XG5cdFx0XHRcdFx0XHRjYXNlIFwiUmFkYXJcIiA6XG5cdFx0XHRcdFx0XHRcdHJlc3VsdFtpXVtqXSA9eyBcblx0XHRcdFx0XHRcdFx0XHR2MTpsZ3R4dCxcblx0XHRcdFx0XHRcdFx0XHRsbWF4dmFsdWUgOiBsbWF4dmFsdWVbYXhpc11baV0sXG5cdFx0XHRcdFx0XHRcdFx0bG1pbnZhbHVlIDogbG1pbnZhbHVlW2F4aXNdW2ldLFxuXHRcdFx0XHRcdFx0XHRcdGZpcnN0Tm90TWlzc2luZyA6IGZpcnN0Tm90TWlzc2luZ2lbaV0sXG5cdFx0XHRcdFx0XHRcdFx0bGFzdE5vdE1pc3NpbmcgOiBsYXN0Tm90TWlzc2luZ2lbaV0sXG5cdFx0XHRcdFx0XHRcdFx0cHJldk5vdE1pc3NpbmcgOiBwcmV2bm90ZW1wdHlqLFxuXHRcdFx0XHRcdFx0XHRcdHByZXZNaXNzaW5nIDogcHJldmVtcHR5aixcblx0XHRcdFx0XHRcdFx0XHRncmFuZHRvdGFsIDogZ3JhbmR0b3RhbFxuXHRcdFx0XHRcdFx0XHRcdCB9OyBcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0YnJlYWs7XG5cdH1cblxuXHRcbnJldHVybiByZXN1bHQ7XG5cbn07XG5cbmZ1bmN0aW9uIGluaXRQYXNzVmFyaWFibGVEYXRhX3BhcnQyKHN0YXREYXRhLGRhdGEsY29uZmlnLGN0eCxvdGhlcnZhcnMpIHtcbnZhciByZWFsYmFycz0wO1xudmFyIGksajtcbnN3aXRjaChjdHgudHBkYXRhKSB7XG5cdGNhc2UgMSA6XG5cdFx0Zm9yKGk9MDtpPGRhdGEubGVuZ3RoO2krKykge1xuXHRcdFx0c3RhdERhdGFbaV0udjc9IGZtdENoYXJ0SlMoY29uZmlnLCBvdGhlcnZhcnMubWlkUG9zWCwgY29uZmlnLmZtdFY3KTtcblx0XHRcdHN0YXREYXRhW2ldLnY4PSBmbXRDaGFydEpTKGNvbmZpZywgb3RoZXJ2YXJzLm1pZFBvc1ksIGNvbmZpZy5mbXRWOCksXG5cdFx0XHRzdGF0RGF0YVtpXS52OT0gZm10Q2hhcnRKUyhjb25maWcsIG90aGVydmFycy5pbnRfcmFkaXVzLCBjb25maWcuZm10VjkpO1xuXHRcdFx0c3RhdERhdGFbaV0udjEwPSBmbXRDaGFydEpTKGNvbmZpZywgb3RoZXJ2YXJzLmV4dF9yYWRpdXMsIGNvbmZpZy5mbXRWMTApO1xuXHRcdFx0aWYoY3R4LnRwY2hhcnQ9PVwiUG9sYXJBcmVhXCIpIHtcblx0XHRcdFx0c3RhdERhdGFbaV0ucmFkaXVzT2Zmc2V0PSBjYWxjdWxhdGVPZmZzZXQoY29uZmlnLmxvZ2FyaXRobWljLCAxICogZGF0YVtpXS52YWx1ZSwgb3RoZXJ2YXJzLmNhbGN1bGF0ZWRTY2FsZSwgb3RoZXJ2YXJzLnNjYWxlSG9wKTtcblx0XHRcdFx0c3RhdERhdGFbaV0udjEwPSBmbXRDaGFydEpTKGNvbmZpZywgc3RhdERhdGFbaV0ucmFkaXVzT2Zmc2V0LCBjb25maWcuZm10VjEwKTsgXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c3RhdERhdGFbaV0udjEwPSBmbXRDaGFydEpTKGNvbmZpZywgb3RoZXJ2YXJzLmV4dF9yYWRpdXMsIGNvbmZpZy5mbXRWMTApOyBcblx0XHRcdFx0c3RhdERhdGFbaV0ucmFkaXVzT2Zmc2V0PW90aGVydmFycy5leHRfcmFkaXVzO1xuXHRcdFx0fVxuXHRcdFx0c3RhdERhdGFbaV0ub3V0ZXJWYWw9IG90aGVydmFycy5vdXRlclZhbDtcblx0XHRcdHN0YXREYXRhW2ldLm1pZFBvc1g9IG90aGVydmFycy5taWRQb3NYO1xuXHRcdFx0c3RhdERhdGFbaV0ubWlkUG9zWT0gb3RoZXJ2YXJzLm1pZFBvc1k7XG5cdFx0XHRzdGF0RGF0YVtpXS5jYWxjdWxhdGVkU2NhbGU9b3RoZXJ2YXJzLmNhbGN1bGF0ZWRTY2FsZTtcblx0XHRcdHN0YXREYXRhW2ldLnNjYWxlSG9wPW90aGVydmFycy5zY2FsZUhvcDtcblx0XHRcdHN0YXREYXRhW2ldLmludF9yYWRpdXM9IG90aGVydmFycy5pbnRfcmFkaXVzO1xuXHRcdFx0c3RhdERhdGFbaV0uZXh0X3JhZGl1cz0gb3RoZXJ2YXJzLmV4dF9yYWRpdXM7XG5cdFx0fVxuXHRcdGJyZWFrO1xuXHRjYXNlIDA6XG5cdGRlZmF1bHQgOlxuXHRcdHZhciB0ZW1wcCA9IG5ldyBBcnJheShkYXRhLmRhdGFzZXRzLmxlbmd0aCk7XG5cdFx0dmFyIHRlbXBuID0gbmV3IEFycmF5KGRhdGEuZGF0YXNldHMubGVuZ3RoKTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c3dpdGNoKHRwZHJhdyhjdHgsZGF0YS5kYXRhc2V0c1tpXSkpIHtcblx0XHRcdFx0Y2FzZSBcIkxpbmVcIiA6XG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGRhdGEuZGF0YXNldHNbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ueEF4aXNQb3NZID0gb3RoZXJ2YXJzLnhBeGlzUG9zWTtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnlBeGlzUG9zWCA9IG90aGVydmFycy55QXhpc1Bvc1g7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS52YWx1ZUhvcCA9IG90aGVydmFycy52YWx1ZUhvcDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLm5iVmFsdWVIb3AgPSBvdGhlcnZhcnMubmJWYWx1ZUhvcDtcblx0XHRcdFx0XHRcdGlmIChkYXRhLmRhdGFzZXRzW2ldLmF4aXMgPT0gMikge1xuXHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5zY2FsZUhvcCA9IG90aGVydmFycy5zY2FsZUhvcDI7XG5cdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnplcm9ZID0gb3RoZXJ2YXJzLnplcm9ZMjtcblx0XHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uY2FsY3VsYXRlZFNjYWxlID0gb3RoZXJ2YXJzLmNhbGN1bGF0ZWRTY2FsZTI7XG5cdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLmxvZ2FyaXRobWljID0gb3RoZXJ2YXJzLmxvZ2FyaXRobWljMjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnNjYWxlSG9wID0gb3RoZXJ2YXJzLnNjYWxlSG9wO1xuXHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS56ZXJvWSA9IG90aGVydmFycy56ZXJvWTtcblx0XHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uY2FsY3VsYXRlZFNjYWxlID0gb3RoZXJ2YXJzLmNhbGN1bGF0ZWRTY2FsZTtcblx0XHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ubG9nYXJpdGhtaWMgID0gb3RoZXJ2YXJzLmxvZ2FyaXRobWljO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ueFBvcz14UG9zKGksaixkYXRhLG90aGVydmFycy55QXhpc1Bvc1gsb3RoZXJ2YXJzLnZhbHVlSG9wLG90aGVydmFycy5uYlZhbHVlSG9wKTtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnlBeGlzUG9zPW90aGVydmFycy54QXhpc1Bvc1kgLSBzdGF0RGF0YVtpXVtqXS56ZXJvWTtcblx0XHRcdFx0XHRcdGlmKGN0eC50cGNoYXJ0PT1cIkJhclwiIHx8IGN0eC50cGNoYXJ0PT1cIlN0YWNrZWRCYXJcIikge1xuXHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS54UG9zKz0ob3RoZXJ2YXJzLnZhbHVlSG9wLzIpO1xuXHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS55QXhpc1Bvc1ggKz0gKG90aGVydmFycy52YWx1ZUhvcC8yKTtcblx0XHRcdFx0XHRcdH1cdFx0XHRcblx0XHRcdFx0XHRcdGlmKGo9PTApIHtcblx0XHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ubG1heHZhbHVlX29mZnNldD1jYWxjdWxhdGVPZmZzZXQoc3RhdERhdGFbaV1bal0ubG9nYXJpdGhtaWMsIHN0YXREYXRhW2ldW2pdLmxtYXh2YWx1ZSwgc3RhdERhdGFbaV1bal0uY2FsY3VsYXRlZFNjYWxlLCBzdGF0RGF0YVtpXVtqXS5zY2FsZUhvcCkgLSBzdGF0RGF0YVtpXVtqXS56ZXJvWTtcblx0XHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ubG1pbnZhbHVlX29mZnNldD1jYWxjdWxhdGVPZmZzZXQoc3RhdERhdGFbaV1bal0ubG9nYXJpdGhtaWMsIHN0YXREYXRhW2ldW2pdLmxtaW52YWx1ZSwgc3RhdERhdGFbaV1bal0uY2FsY3VsYXRlZFNjYWxlLCBzdGF0RGF0YVtpXVtqXS5zY2FsZUhvcCkgLSBzdGF0RGF0YVtpXVtqXS56ZXJvWTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLmxtYXh2YWx1ZV9vZmZzZXQ9c3RhdERhdGFbaV1bMF0ubG1heHZhbHVlX29mZnNldDtcblx0XHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ubG1pbnZhbHVlX29mZnNldD1zdGF0RGF0YVtpXVswXS5sbWludmFsdWVfb2Zmc2V0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoISh0eXBlb2YoZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKSA9PSAndW5kZWZpbmVkJykpIHtcblx0XHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ueVBvc09mZnNldD0gY2FsY3VsYXRlT2Zmc2V0KHN0YXREYXRhW2ldW2pdLmxvZ2FyaXRobWljLCBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0sIHN0YXREYXRhW2ldW2pdLmNhbGN1bGF0ZWRTY2FsZSwgc3RhdERhdGFbaV1bal0uc2NhbGVIb3ApIC0gc3RhdERhdGFbaV1bal0uemVyb1k7XG5cdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnBvc1k9c3RhdERhdGFbaV1bal0ueUF4aXNQb3MgLSBzdGF0RGF0YVtpXVtqXS55UG9zT2Zmc2V0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZihkYXRhLmRhdGFzZXRzW2ldLm9yaWdpbikgPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCEodHlwZW9mKGRhdGEuZGF0YXNldHNbaV0ub3JpZ2luW2pdKSA9PSAndW5kZWZpbmVkJykpIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS55UG9zT2Zmc2V0T3JpZ2luPSBjYWxjdWxhdGVPZmZzZXQoc3RhdERhdGFbaV1bal0ubG9nYXJpdGhtaWMsIGRhdGEuZGF0YXNldHNbaV0ub3JpZ2luW2pdLCBzdGF0RGF0YVtpXVtqXS5jYWxjdWxhdGVkU2NhbGUsIHN0YXREYXRhW2ldW2pdLnNjYWxlSG9wKSAtIHN0YXREYXRhW2ldW2pdLnplcm9ZO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnBvc1lPcmlnaW49c3RhdERhdGFbaV1bal0ueUF4aXNQb3MgLSBzdGF0RGF0YVtpXVtqXS55UG9zT2Zmc2V0T3JpZ2luO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5wb3NYPXN0YXREYXRhW2ldW2pdLnhQb3M7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnY5PSBzdGF0RGF0YVtpXVtqXS54UG9zO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0udjEwPXN0YXREYXRhW2ldW2pdLnBvc1k7XG5cblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLmFubm90YXRlU3RhcnRQb3NYID0gc3RhdERhdGFbaV1bal0ueFBvcztcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLmFubm90YXRlRW5kUG9zWCA9IHN0YXREYXRhW2ldW2pdLnhQb3M7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5hbm5vdGF0ZVN0YXJ0UG9zWSA9IG90aGVydmFycy54QXhpc1Bvc1k7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5hbm5vdGF0ZUVuZFBvc1kgPSBvdGhlcnZhcnMueEF4aXNQb3NZLW90aGVydmFycy5tc3IuYXZhaWxhYmxlSGVpZ2h0O1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uRDFBPXVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLkQxQj11bmRlZmluZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiUmFkYXJcIiA6XG5cdFx0XHRcdFx0dmFyIHJvdGF0aW9uRGVncmVlID0gKDIgKiBNYXRoLlBJKSAvIGRhdGEuZGF0YXNldHNbMF0uZGF0YS5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGRhdGEuZGF0YXNldHNbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ubWlkUG9zWCA9ICBvdGhlcnZhcnMubWlkUG9zWDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLm1pZFBvc1kgPSAgb3RoZXJ2YXJzLm1pZFBvc1k7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5pbnRfcmFkaXVzPSAwO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uZXh0X3JhZGl1cz0gb3RoZXJ2YXJzLm1heFNpemU7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5yYWRpdXNPZmZzZXQ9IG90aGVydmFycy5tYXhTaXplO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uY2FsY3VsYXRlZFNjYWxlPSBvdGhlcnZhcnMuY2FsY3VsYXRlZFNjYWxlO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uc2NhbGVIb3A9IG90aGVydmFycy5zY2FsZUhvcDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLmNhbGN1bGF0ZWRfb2Zmc2V0PSBjYWxjdWxhdGVPZmZzZXQoY29uZmlnLmxvZ2FyaXRobWljLCBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0sIG90aGVydmFycy5jYWxjdWxhdGVkU2NhbGUsIG90aGVydmFycy5zY2FsZUhvcCk7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5vZmZzZXRYPU1hdGguY29zKGNvbmZpZy5zdGFydEFuZ2xlICogTWF0aC5QSSAvIDE4MCAtIGogKiByb3RhdGlvbkRlZ3JlZSkgKiBzdGF0RGF0YVtpXVtqXS5jYWxjdWxhdGVkX29mZnNldDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLm9mZnNldFk9TWF0aC5zaW4oY29uZmlnLnN0YXJ0QW5nbGUgKiBNYXRoLlBJIC8gMTgwIC0gaiAqIHJvdGF0aW9uRGVncmVlKSAqIHN0YXREYXRhW2ldW2pdLmNhbGN1bGF0ZWRfb2Zmc2V0O1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0udjk9c3RhdERhdGFbaV1bal0ubWlkUG9zWCArIHN0YXREYXRhW2ldW2pdLm9mZnNldFg7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS52MTA9c3RhdERhdGFbaV1bal0ubWlkUG9zWSAtIHN0YXREYXRhW2ldW2pdLm9mZnNldFk7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5wb3NYPXN0YXREYXRhW2ldW2pdLm1pZFBvc1ggKyBzdGF0RGF0YVtpXVtqXS5vZmZzZXRYO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ucG9zWT1zdGF0RGF0YVtpXVtqXS5taWRQb3NZIC0gc3RhdERhdGFbaV1bal0ub2Zmc2V0WTtcblx0XHRcdFx0XHRcdGlmKGo9PTApc3RhdERhdGFbaV1bal0uY2FsY3VsYXRlZF9vZmZzZXRfbWF4PWNhbGN1bGF0ZU9mZnNldChjb25maWcubG9nYXJpdGhtaWMsIHN0YXREYXRhW2ldW2pdLmxtYXh2YWx1ZSwgb3RoZXJ2YXJzLmNhbGN1bGF0ZWRTY2FsZSwgb3RoZXJ2YXJzLnNjYWxlSG9wKTtcblx0XHRcdFx0XHRcdGVsc2UgICAgc3RhdERhdGFbaV1bal0uY2FsY3VsYXRlZF9vZmZzZXRfbWF4PXN0YXREYXRhWzBdW2pdLmNhbGN1bGF0ZWRfb2Zmc2V0X21heDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLmFubm90YXRlU3RhcnRQb3NYID0gb3RoZXJ2YXJzLm1pZFBvc1g7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5hbm5vdGF0ZUVuZFBvc1ggPSBvdGhlcnZhcnMubWlkUG9zWCtNYXRoLmNvcyhjb25maWcuc3RhcnRBbmdsZSAqIE1hdGguUEkgLyAxODAgLSBqICogcm90YXRpb25EZWdyZWUpICogb3RoZXJ2YXJzLm1heFNpemU7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5hbm5vdGF0ZVN0YXJ0UG9zWSA9IG90aGVydmFycy5taWRQb3NZO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uYW5ub3RhdGVFbmRQb3NZID0gb3RoZXJ2YXJzLm1pZFBvc1ktTWF0aC5zaW4oY29uZmlnLnN0YXJ0QW5nbGUgKiBNYXRoLlBJIC8gMTgwIC0gaiAqIHJvdGF0aW9uRGVncmVlKSAqIG90aGVydmFycy5tYXhTaXplO1xuXHRcdFx0XHRcdFx0aWYoTWF0aC5hYnMoc3RhdERhdGFbaV1bal0uYW5ub3RhdGVTdGFydFBvc1gtc3RhdERhdGFbaV1bal0uYW5ub3RhdGVFbmRQb3NYKTxjb25maWcuemVyb1ZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLkQxQT11bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLkQxQj11bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLkQyQT0wO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uRDFBPShzdGF0RGF0YVtpXVtqXS5hbm5vdGF0ZVN0YXJ0UG9zWS1zdGF0RGF0YVtpXVtqXS5hbm5vdGF0ZUVuZFBvc1kpLyhzdGF0RGF0YVtpXVtqXS5hbm5vdGF0ZVN0YXJ0UG9zWC1zdGF0RGF0YVtpXVtqXS5hbm5vdGF0ZUVuZFBvc1gpO1xuXHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5EMUI9LXN0YXREYXRhW2ldW2pdLkQxQSpzdGF0RGF0YVtpXVtqXS5hbm5vdGF0ZVN0YXJ0UG9zWCtzdGF0RGF0YVtpXVtqXS5hbm5vdGF0ZVN0YXJ0UG9zWTtcblx0XHRcdFx0XHRcdFx0aWYoTWF0aC5hYnMoc3RhdERhdGFbaV1bal0uRDFBKT49Y29uZmlnLnplcm9WYWx1ZSlzdGF0RGF0YVtpXVtqXS5EMkE9LSgxL3N0YXREYXRhW2ldW2pdLkQxQSk7XG5cdFx0XHRcdFx0XHRcdGVsc2Ugc3RhdERhdGFbaV1bal0uRDJBPXVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHQgICAgICAgIH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcIkJhclwiIDpcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG5cblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnhBeGlzUG9zWSA9IG90aGVydmFycy54QXhpc1Bvc1k7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS55QXhpc1Bvc1ggPSBvdGhlcnZhcnMueUF4aXNQb3NYO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0udmFsdWVIb3AgPSBvdGhlcnZhcnMudmFsdWVIb3A7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5iYXJXaWR0aCA9IG90aGVydmFycy5iYXJXaWR0aDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLmFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzPSBvdGhlcnZhcnMuYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnM7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5uYlZhbHVlSG9wID0gb3RoZXJ2YXJzLm5iVmFsdWVIb3A7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5jYWxjdWxhdGVkU2NhbGUgPSBvdGhlcnZhcnMuY2FsY3VsYXRlZFNjYWxlO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uc2NhbGVIb3AgPSBvdGhlcnZhcnMuc2NhbGVIb3A7XG5cdFx0XHRcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0PSBvdGhlcnZhcnMueUF4aXNQb3NYICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmJhclZhbHVlU3BhY2luZykgKyBvdGhlcnZhcnMudmFsdWVIb3AgKiBqICsgb3RoZXJ2YXJzLmFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzK290aGVydmFycy5iYXJXaWR0aCAqIHJlYWxiYXJzICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmJhckRhdGFzZXRTcGFjaW5nKSAqIHJlYWxiYXJzICsgTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuYmFyU3Ryb2tlV2lkdGgpICogcmVhbGJhcnM7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS54UG9zUmlnaHQgPSBzdGF0RGF0YVtpXVtqXS54UG9zTGVmdCArIG90aGVydmFycy5iYXJXaWR0aDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b20gPW90aGVydmFycy54QXhpc1Bvc1kgLSBvdGhlcnZhcnMuemVyb1lcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLmJhckhlaWdodD1jYWxjdWxhdGVPZmZzZXQoY29uZmlnLmxvZ2FyaXRobWljLCAxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdLCBvdGhlcnZhcnMuY2FsY3VsYXRlZFNjYWxlLCBvdGhlcnZhcnMuc2NhbGVIb3ApIC0gb3RoZXJ2YXJzLnplcm9ZO1xuXHRcdFx0XHRcdFx0aWYgKGRhdGEuZGF0YXNldHNbaV0uYXhpcyA9PSAyKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b20gPW90aGVydmFycy54QXhpc1Bvc1kgLSBvdGhlcnZhcnMuemVyb1kyO1xuXHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5iYXJIZWlnaHQ9Y2FsY3VsYXRlT2Zmc2V0KGNvbmZpZy5sb2dhcml0aG1pYzIsIDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0sIG90aGVydmFycy5jYWxjdWxhdGVkU2NhbGUyLCBvdGhlcnZhcnMuc2NhbGVIb3AyKSAtIG90aGVydmFycy56ZXJvWTI7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tID1vdGhlcnZhcnMueEF4aXNQb3NZIC0gb3RoZXJ2YXJzLnplcm9ZXG5cdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLmJhckhlaWdodD1jYWxjdWxhdGVPZmZzZXQoY29uZmlnLmxvZ2FyaXRobWljLCAxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdLCBvdGhlcnZhcnMuY2FsY3VsYXRlZFNjYWxlLCBvdGhlcnZhcnMuc2NhbGVIb3ApIC0gb3RoZXJ2YXJzLnplcm9ZO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ueVBvc1RvcCA9IHN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b20gLSBzdGF0RGF0YVtpXVtqXS5iYXJIZWlnaHQgKyAoTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpjb25maWcuYmFyU3Ryb2tlV2lkdGgpIC8gMik7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS52Nz1zdGF0RGF0YVtpXVtqXS54UG9zTGVmdDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnY4PXN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b207XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS52OT1zdGF0RGF0YVtpXVtqXS54UG9zUmlnaHQ7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS52MTA9c3RhdERhdGFbaV1bal0ueVBvc1RvcDtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZWFsYmFycysrO1xuXHRcdFx0XHRcdGJyZWFrO1x0XHRcdFxuXHRcdFx0XHRjYXNlIFwiU3RhY2tlZEJhclwiIDpcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS54QXhpc1Bvc1kgPSBvdGhlcnZhcnMueEF4aXNQb3NZO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ueUF4aXNQb3NYID0gb3RoZXJ2YXJzLnlBeGlzUG9zWDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnZhbHVlSG9wID0gb3RoZXJ2YXJzLnZhbHVlSG9wO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uYmFyV2lkdGggPSBvdGhlcnZhcnMuYmFyV2lkdGg7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5hZGRpdGlvbmFsU3BhY2VCZXR3ZWVuQmFycz0gb3RoZXJ2YXJzLmFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ubmJWYWx1ZUhvcCA9IG90aGVydmFycy5uYlZhbHVlSG9wO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uY2FsY3VsYXRlZFNjYWxlID0gb3RoZXJ2YXJzLmNhbGN1bGF0ZWRTY2FsZTtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnNjYWxlSG9wID0gb3RoZXJ2YXJzLnNjYWxlSG9wO1xuLy9cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5uYlZhbHVlSG9wID0gb3RoZXJ2YXJzLm5iVmFsdWVIb3A7XG5cdFx0XHRcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgdGVtcHBbal09PVwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0XHRcdFx0dGVtcHBbal09MDtcblx0XHRcdFx0XHRcdFx0dGVtcG5bal09MDtcblx0XHRcdFx0XHRcdFx0emVyb1k9ICBjYWxjdWxhdGVPZmZzZXQoY29uZmlnLmxvZ2FyaXRobWljLCAwICwgb3RoZXJ2YXJzLmNhbGN1bGF0ZWRTY2FsZSwgb3RoZXJ2YXJzLnNjYWxlSG9wKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICgodHlwZW9mIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA9PSAndW5kZWZpbmVkJykpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ueFBvc0xlZnQ9IG90aGVydmFycy55QXhpc1Bvc1ggKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuYmFyVmFsdWVTcGFjaW5nKSArIG90aGVydmFycy52YWx1ZUhvcCAqIGorb3RoZXJ2YXJzLmFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzO1xuXHRcdFx0XHRcdFx0aWYgKDEqZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdPDApIHtcblx0XHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uYm90dmFsPXRlbXBuW2pdO1xuXHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS50b3B2YWw9dGVtcG5bal0rMSpkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gO1xuXHRcdFx0XHRcdFx0XHR0ZW1wbltqXT10ZW1wbltqXSsxKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5ib3R2YWw9dGVtcHBbal07XG5cdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnRvcHZhbD10ZW1wcFtqXSsxKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA7XG5cdFx0XHRcdFx0XHRcdHRlbXBwW2pdPXRlbXBwW2pdKzEqZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdIDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnhQb3NSaWdodCA9IHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0ICsgb3RoZXJ2YXJzLmJhcldpZHRoO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uYm90T2Zmc2V0ID0gY2FsY3VsYXRlT2Zmc2V0KGNvbmZpZy5sb2dhcml0aG1pYywgc3RhdERhdGFbaV1bal0uYm90dmFsICwgb3RoZXJ2YXJzLmNhbGN1bGF0ZWRTY2FsZSwgb3RoZXJ2YXJzLnNjYWxlSG9wKTtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnRvcE9mZnNldCA9IGNhbGN1bGF0ZU9mZnNldChjb25maWcubG9nYXJpdGhtaWMsIHN0YXREYXRhW2ldW2pdLnRvcHZhbCAsIG90aGVydmFycy5jYWxjdWxhdGVkU2NhbGUsIG90aGVydmFycy5zY2FsZUhvcCk7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tID1vdGhlcnZhcnMueEF4aXNQb3NZIC0gc3RhdERhdGFbaV1bal0uYm90T2Zmc2V0O1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ueVBvc1RvcCA9IG90aGVydmFycy54QXhpc1Bvc1kgLSBzdGF0RGF0YVtpXVtqXS50b3BPZmZzZXQ7XG5cdFx0XHRcdFx0XHQvLyB0cmVhdCBzcGFjZUJldHdlZW5CYXIgXG5cdFx0XHRcdFx0XHRpZihNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VCZXR3ZWVuQmFyKSA+IDApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmKDEqZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdPDApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tKz1NYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VCZXR3ZWVuQmFyKTtcblx0XHRcdFx0XHRcdFx0XHRpZih0ZW1wbltqXT09MSpkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0pc3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbS09KE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUJldHdlZW5CYXIpLzIpO1x0XG5cdFx0XHRcdFx0XHRcdFx0aWYoc3RhdERhdGFbaV1bal0ueVBvc1RvcDxzdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tKXN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b209c3RhdERhdGFbaV1bal0ueVBvc1RvcDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgxKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXT4wKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbS09TWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlQmV0d2VlbkJhcik7XHRcblx0XHRcdFx0XHRcdFx0XHRpZih0ZW1wcFtqXT09MSpkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0pc3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbSs9KE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUJldHdlZW5CYXIpLzIpO1x0XG5cdFx0XHRcdFx0XHRcdFx0aWYoc3RhdERhdGFbaV1bal0ueVBvc1RvcD5zdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tKXN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b209c3RhdERhdGFbaV1bal0ueVBvc1RvcDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0udjc9c3RhdERhdGFbaV1bal0ueFBvc0xlZnQ7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS52OD1zdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0udjk9c3RhdERhdGFbaV1bal0ueFBvc1JpZ2h0O1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0udjEwPXN0YXREYXRhW2ldW2pdLnlQb3NUb3A7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1x0XHRcdFxuXHRcdFx0XHRjYXNlIFwiSG9yaXpvbnRhbEJhclwiIDpcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG5cblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnhBeGlzUG9zWSA9IG90aGVydmFycy54QXhpc1Bvc1k7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS55QXhpc1Bvc1ggPSBvdGhlcnZhcnMueUF4aXNQb3NYO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0udmFsdWVIb3AgPSBvdGhlcnZhcnMudmFsdWVIb3A7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5iYXJXaWR0aCA9IG90aGVydmFycy5iYXJXaWR0aDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLmFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzPSBvdGhlcnZhcnMuYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnM7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5uYlZhbHVlSG9wID0gb3RoZXJ2YXJzLm5iVmFsdWVIb3A7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5jYWxjdWxhdGVkU2NhbGUgPSBvdGhlcnZhcnMuY2FsY3VsYXRlZFNjYWxlO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uc2NhbGVIb3AgPSBvdGhlcnZhcnMuc2NhbGVIb3A7XG5cblxuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ueFBvc0xlZnQ9IG90aGVydmFycy55QXhpc1Bvc1ggKyBvdGhlcnZhcnMuemVyb1k7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS55UG9zVG9wPW90aGVydmFycy54QXhpc1Bvc1kgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuYmFyVmFsdWVTcGFjaW5nKSAtIG90aGVydmFycy5zY2FsZUhvcCAqIChqICsgMSkgKyBvdGhlcnZhcnMuYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnMgKyBvdGhlcnZhcnMuYmFyV2lkdGggKiBpICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmJhckRhdGFzZXRTcGFjaW5nKSAqIGkgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmNvbmZpZy5iYXJTdHJva2VXaWR0aCkgKiBpO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbT1zdGF0RGF0YVtpXVtqXS55UG9zVG9wK290aGVydmFycy5iYXJXaWR0aDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLmJhcldpZHRoID0gY2FsY3VsYXRlT2Zmc2V0KGNvbmZpZy5sb2dhcml0aG1pYywgMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSwgb3RoZXJ2YXJzLmNhbGN1bGF0ZWRTY2FsZSwgb3RoZXJ2YXJzLnZhbHVlSG9wKSAtIG90aGVydmFycy56ZXJvWTtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnhQb3NSaWdodCA9IHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0ICsgc3RhdERhdGFbaV1bal0uYmFyV2lkdGg7XG5cblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnY3PXN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0O1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0udjg9c3RhdERhdGFbaV1bal0ueVBvc0JvdHRvbTtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnY5PXN0YXREYXRhW2ldW2pdLnhQb3NSaWdodDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnYxMD1zdGF0RGF0YVtpXVtqXS55UG9zVG9wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcdFx0XHRcblx0XHRcdFx0Y2FzZSBcIkhvcml6b250YWxTdGFja2VkQmFyXCIgOlxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBkYXRhLmRhdGFzZXRzW2ldLmRhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnhBeGlzUG9zWSA9IG90aGVydmFycy54QXhpc1Bvc1k7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS55QXhpc1Bvc1ggPSBvdGhlcnZhcnMueUF4aXNQb3NYO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0udmFsdWVIb3AgPSBvdGhlcnZhcnMudmFsdWVIb3A7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5iYXJXaWR0aCA9IG90aGVydmFycy5iYXJXaWR0aDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLmFkZGl0aW9uYWxTcGFjZUJldHdlZW5CYXJzPSBvdGhlcnZhcnMuYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnM7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5uYlZhbHVlSG9wID0gb3RoZXJ2YXJzLm5iVmFsdWVIb3A7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5jYWxjdWxhdGVkU2NhbGUgPSBvdGhlcnZhcnMuY2FsY3VsYXRlZFNjYWxlO1xuXHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0uc2NhbGVIb3AgPSBvdGhlcnZhcnMuc2NhbGVIb3A7XG5cblx0XHRcdFx0XHRcdGlmIChpID09IDApIHtcblx0XHRcdFx0XHRcdFx0dGVtcHBbal09MDtcblx0XHRcdFx0XHRcdFx0dGVtcG5bal09MDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKSA9PSAndW5kZWZpbmVkJykgIGNvbnRpbnVlO1xuLy9cdFx0XHRcdFx0XHRpZiAoKHR5cGVvZihkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0pID09ICd1bmRlZmluZWQnKSB8fCAxKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA9PSAwICkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0PSBvdGhlcnZhcnMueUF4aXNQb3NYICsgTWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLmJhclZhbHVlU3BhY2luZykgKyBvdGhlcnZhcnMudmFsdWVIb3AgKiBqO1xuXHRcdFx0XHRcdFx0aWYgKDEqZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdPDApIHtcblx0XHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ubGVmdHZhbD10ZW1wbltqXTtcblx0XHRcdFx0XHRcdFx0c3RhdERhdGFbaV1bal0ucmlnaHR2YWw9dGVtcG5bal0rMSpkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gO1xuXHRcdFx0XHRcdFx0XHR0ZW1wbltqXT10ZW1wbltqXSsxKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5sZWZ0dmFsPXRlbXBwW2pdO1xuXHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5yaWdodHZhbD10ZW1wcFtqXSsxKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA7XG5cdFx0XHRcdFx0XHRcdHRlbXBwW2pdPXRlbXBwW2pdKzEqZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdIDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnJpZ2h0T2Zmc2V0ID0gSG9yaXpvbnRhbENhbGN1bGF0ZU9mZnNldChzdGF0RGF0YVtpXVtqXS5yaWdodHZhbCAsIG90aGVydmFycy5jYWxjdWxhdGVkU2NhbGUsIG90aGVydmFycy52YWx1ZUhvcCk7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS5sZWZ0T2Zmc2V0ICA9IEhvcml6b250YWxDYWxjdWxhdGVPZmZzZXQoc3RhdERhdGFbaV1bal0ubGVmdHZhbCAsIG90aGVydmFycy5jYWxjdWxhdGVkU2NhbGUsIG90aGVydmFycy52YWx1ZUhvcCk7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS54UG9zUmlnaHQgPSBvdGhlcnZhcnMueUF4aXNQb3NYICsgc3RhdERhdGFbaV1bal0ucmlnaHRPZmZzZXQ7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS54UG9zTGVmdCAgPSBvdGhlcnZhcnMueUF4aXNQb3NYICsgc3RhdERhdGFbaV1bal0ubGVmdE9mZnNldDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnlQb3NUb3AgPW90aGVydmFycy54QXhpc1Bvc1kgKyBNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuYmFyVmFsdWVTcGFjaW5nKSAtIG90aGVydmFycy5zY2FsZUhvcCAqIChqICsgMSkgKyBvdGhlcnZhcnMuYWRkaXRpb25hbFNwYWNlQmV0d2VlbkJhcnM7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS55UG9zQm90dG9tID0gc3RhdERhdGFbaV1bal0ueVBvc1RvcCtvdGhlcnZhcnMuYmFyV2lkdGg7XG5cdFx0XHRcdFx0XHQvLyB0cmVhdCBzcGFjZUJldHdlZW5CYXIgXG5cdFx0XHRcdFx0XHRpZihNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VCZXR3ZWVuQmFyKSA+IDApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmKDEqZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdPDApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS54UG9zTGVmdC09TWF0aC5jZWlsKGN0eC5jaGFydFNwYWNlU2NhbGUqY29uZmlnLnNwYWNlQmV0d2VlbkJhcik7XHRcblx0XHRcdFx0XHRcdFx0XHRpZih0ZW1wbltqXT09MSpkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0pc3RhdERhdGFbaV1bal0ueFBvc0xlZnQrPShNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VCZXR3ZWVuQmFyKS8yKTtcdFxuXHRcdFx0XHRcdFx0XHRcdGlmKHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0PHN0YXREYXRhW2ldW2pdLnhQb3NSaWdodClzdGF0RGF0YVtpXVtqXS54UG9zTGVmdD1zdGF0RGF0YVtpXVtqXS54UG9zUmlnaHQ7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoMSpkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0+MCkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0Kz1NYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpjb25maWcuc3BhY2VCZXR3ZWVuQmFyKTtcdFxuXHRcdFx0XHRcdFx0XHRcdGlmKHRlbXBwW2pdPT0xKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSlzdGF0RGF0YVtpXVtqXS54UG9zTGVmdC09KE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmNvbmZpZy5zcGFjZUJldHdlZW5CYXIpLzIpO1x0XG5cdFx0XHRcdFx0XHRcdFx0aWYoc3RhdERhdGFbaV1bal0ueFBvc0xlZnQ+c3RhdERhdGFbaV1bal0ueFBvc1JpZ2h0KXN0YXREYXRhW2ldW2pdLnhQb3NMZWZ0PXN0YXREYXRhW2ldW2pdLnhQb3NSaWdodDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS52Nz1zdGF0RGF0YVtpXVtqXS54UG9zTGVmdDtcblx0XHRcdFx0XHRcdHN0YXREYXRhW2ldW2pdLnY4PXN0YXREYXRhW2ldW2pdLnlQb3NCb3R0b207XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS52OT1zdGF0RGF0YVtpXVtqXS54UG9zUmlnaHQ7XG5cdFx0XHRcdFx0XHRzdGF0RGF0YVtpXVtqXS52MTA9c3RhdERhdGFbaV1bal0ueVBvc1RvcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQgOiBcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0fVxuXHRcbn0gO1xuXG5cblxuXHRmdW5jdGlvbiB4UG9zKGl2YWwsIGl0ZXJhdGlvbiwgZGF0YSx5QXhpc1Bvc1gsdmFsdWVIb3AsbmJWYWx1ZUhvcCkge1xuLy9uYlZhbHVlSG9wPTg7XG5cdFx0aWYgKHR5cGVvZiBkYXRhLmRhdGFzZXRzW2l2YWxdLnhQb3MgPT0gXCJvYmplY3RcIikge1xuXHRcdFx0aWYgKCEodHlwZW9mIGRhdGEuZGF0YXNldHNbaXZhbF0ueFBvc1tNYXRoLmZsb29yKGl0ZXJhdGlvbiArIGNvbmZpZy56ZXJvVmFsdWUpXSA9PSBcInVuZGVmaW5lZFwiKSkge1xuXHRcdFx0XHR2YXIgd2lkdGggPSB2YWx1ZUhvcCAqIG5iVmFsdWVIb3A7XG5cblx0XHRcdFx0dmFyIGRlYiA9ICh0eXBlb2YgZGF0YS54QmVnaW4gIT0gXCJ1bmRlZmluZWRcIikgPyBkYXRhLnhCZWdpbiA6IDEgKiBkYXRhLmxhYmVsc1swXTtcblx0XHRcdFx0dmFyIGZpbiA9ICh0eXBlb2YgZGF0YS54RW5kICE9IFwidW5kZWZpbmVkXCIpID8gZGF0YS54RW5kIDogMSAqIGRhdGEubGFiZWxzW2RhdGEubGFiZWxzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRpZiAoZmluIDw9IGRlYikgZmluID0gZGViICsgMTAwO1xuXHRcdFx0XHRpZiAoMSAqIGRhdGEuZGF0YXNldHNbaXZhbF0ueFBvc1tNYXRoLmZsb29yKGl0ZXJhdGlvbiArIGNvbmZpZy56ZXJvVmFsdWUpXSA+PSBkZWIgJiYgZGF0YS5kYXRhc2V0c1tpdmFsXS54UG9zW01hdGguZmxvb3IoaXRlcmF0aW9uICsgY29uZmlnLnplcm9WYWx1ZSldIDw9IGZpbikge1xuXHRcdFx0XHRcdHZhciBwMSA9IHlBeGlzUG9zWCArIHdpZHRoICogKCgxICogZGF0YS5kYXRhc2V0c1tpdmFsXS54UG9zW01hdGguZmxvb3IoaXRlcmF0aW9uICsgY29uZmlnLnplcm9WYWx1ZSldIC0gZGViKSAvIChmaW4gLSBkZWIpKTtcblx0XHRcdFx0XHR2YXIgcDIgPSBwMTtcblx0XHRcdFx0XHRpZiAoTWF0aC5hYnMoaXRlcmF0aW9uIC0gTWF0aC5mbG9vcihpdGVyYXRpb24gKyBjb25maWcuemVyb1ZhbHVlKSkgPiBjb25maWcuemVyb1ZhbHVlKSB7XG5cdFx0XHRcdFx0XHRwMiA9IHhQb3MoaXZhbCwgTWF0aC5jZWlsKGl0ZXJhdGlvbiAtIGNvbmZpZy56ZXJvVmFsdWUpLCBkYXRhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHAxICsgKGl0ZXJhdGlvbiAtIE1hdGguZmxvb3IoaXRlcmF0aW9uICsgY29uZmlnLnplcm9WYWx1ZSkpICogKHAyIC0gcDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB5QXhpc1Bvc1ggKyAodmFsdWVIb3AgKiBpdGVyYXRpb24pO1xuXHR9O1xuXG5cblx0ZnVuY3Rpb24gY2FsY3VsYXRlT3JkZXJPZk1hZ25pdHVkZSh2YWwpIHtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjEwKTtcblx0fTtcblxuXHRmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQobG9nYXJpdGhtaWMsIHZhbCwgY2FsY3VsYXRlZFNjYWxlLCBzY2FsZUhvcCkge1xuXHRcdGlmICghbG9nYXJpdGhtaWMpIHsgLy8gbm8gbG9nYXJpdGhtaWMgc2NhbGVcblx0XHRcdHZhciBvdXRlclZhbHVlID0gY2FsY3VsYXRlZFNjYWxlLnN0ZXBzICogY2FsY3VsYXRlZFNjYWxlLnN0ZXBWYWx1ZTtcblx0XHRcdHZhciBhZGp1c3RlZFZhbHVlID0gdmFsIC0gY2FsY3VsYXRlZFNjYWxlLmdyYXBoTWluO1xuXHRcdFx0dmFyIHNjYWxpbmdGYWN0b3IgPSBDYXBWYWx1ZShhZGp1c3RlZFZhbHVlIC8gb3V0ZXJWYWx1ZSwgMSwgMCk7XG5cdFx0XHRyZXR1cm4gKHNjYWxlSG9wICogY2FsY3VsYXRlZFNjYWxlLnN0ZXBzKSAqIHNjYWxpbmdGYWN0b3I7XG5cdFx0fSBlbHNlIHsgLy8gbG9nYXJpdGhtaWMgc2NhbGVcbi8vXHRcdFx0cmV0dXJuIENhcFZhbHVlKGxvZzEwKHZhbCkgKiBzY2FsZUhvcCAtIGNhbGN1bGF0ZU9yZGVyT2ZNYWduaXR1ZGUoY2FsY3VsYXRlZFNjYWxlLmdyYXBoTWluKSAqIHNjYWxlSG9wLCB1bmRlZmluZWQsIDApO1xuXHRcdFx0cmV0dXJuIENhcFZhbHVlKGxvZzEwKHZhbCkgKiBzY2FsZUhvcCAtIGxvZzEwKGNhbGN1bGF0ZWRTY2FsZS5ncmFwaE1pbikgKiBzY2FsZUhvcCwgdW5kZWZpbmVkLCAwKTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gSG9yaXpvbnRhbENhbGN1bGF0ZU9mZnNldCh2YWwsIGNhbGN1bGF0ZWRTY2FsZSwgc2NhbGVIb3ApIHtcblx0XHR2YXIgb3V0ZXJWYWx1ZSA9IGNhbGN1bGF0ZWRTY2FsZS5zdGVwcyAqIGNhbGN1bGF0ZWRTY2FsZS5zdGVwVmFsdWU7XG5cdFx0dmFyIGFkanVzdGVkVmFsdWUgPSB2YWwgLSBjYWxjdWxhdGVkU2NhbGUuZ3JhcGhNaW47XG5cdFx0dmFyIHNjYWxpbmdGYWN0b3IgPSBDYXBWYWx1ZShhZGp1c3RlZFZhbHVlIC8gb3V0ZXJWYWx1ZSwgMSwgMCk7XG5cdFx0cmV0dXJuIChzY2FsZUhvcCAqIGNhbGN1bGF0ZWRTY2FsZS5zdGVwcykgKiBzY2FsaW5nRmFjdG9yO1xuXHR9O1xuXG5cdC8vQXBwbHkgY2FwIGEgdmFsdWUgYXQgYSBoaWdoIG9yIGxvdyBudW1iZXJcblx0ZnVuY3Rpb24gQ2FwVmFsdWUodmFsdWVUb0NhcCwgbWF4VmFsdWUsIG1pblZhbHVlKSB7XG5cdFx0aWYgKGlzTnVtYmVyKG1heFZhbHVlKSkge1xuXHRcdFx0aWYgKHZhbHVlVG9DYXAgPiBtYXhWYWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gbWF4VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChpc051bWJlcihtaW5WYWx1ZSkpIHtcblx0XHRcdGlmICh2YWx1ZVRvQ2FwIDwgbWluVmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIG1pblZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWVUb0NhcDtcblx0fTtcblx0ZnVuY3Rpb24gbG9nMTAodmFsKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMTA7XG5cdH07XG59O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW5PcHRpb25UcnVlKG9wdGlvblZhcixkZWZhdWx0dmFsdWUpIHtcblx0dmFyIGo7XG5cdGlmKHR5cGVvZiBvcHRpb252YXIgPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdGlmKHR5cGVvZiBkZWZhdWx0dmFsdWU9PVwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cdFx0ZWxzZSBpZih0eXBlb2YgZGVmYXVsdHZhbHVlID09IFwib2JqZWN0XCIpIHsgXG5cdFx0XHRmb3Ioaj0wO2o8ZGVmYXVsdHZhbHVlLmxlbmd0aDtqKyspIGlmIChkZWZhdWx0dmFsdWVbal0pcmV0dXJuIHRydWU7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIGRlZmF1bHR2YWx1ZTtcblx0fVxuXHRpZih0eXBlb2Ygb3B0aW9udmFyPT1cImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXHRlbHNlIGlmKHR5cGVvZiBvcHRpb252YXIgPT0gXCJvYmplY3RcIikge1xuXHRcdFx0Zm9yKGo9MDtqPG9wdGlvbnZhci5sZW5ndGg7aisrKSBpZiAob3B0aW9udmFyW2pdKXJldHVybiB0cnVlO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGVsc2UgcmV0dXJuIG9wdGlvbnZhcjtcbn07XG5cbmZ1bmN0aW9uIHNldE9wdGlvblZhbHVlKHRyZWF0X3NwZWNpYWwscmVzY2FsZSxyZWZlcmVuY2UsY3R4LGRhdGEsc3RhdERhdGEsb3B0aW9udmFyLGRlZmF1bHR2YWx1ZSx2YXJuYW1lLHBvc2kscG9zaixvdGhlcnZhcnMpIHtcblx0dmFyIHJ2OyAgICAgXG5cdGlmKHRyZWF0X3NwZWNpYWwgPT0gdHJ1ZSkge1xuXHRcdGlmKGN0eC50cGRhdGE9PTApIHtcblx0XHRcdGlmKHR5cGVvZiAoZGF0YS5zcGVjaWFsKT09XCJvYmplY3RcIikge1xuLy9cdFx0XHRcdGZvcih2YXIgdD0wO3Q8ZGF0YS5zcGVjaWFsLmxlbmd0aDt0Kyspe1xuXHRcdFx0XHRmb3IodmFyIHQ9ZGF0YS5zcGVjaWFsLmxlbmd0aC0xO3Q+PTA7dC0tKXtcblx0XHRcdFx0XHRpZih0eXBlb2YgZGF0YS5zcGVjaWFsW3RdLnBvc2kgPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZGF0YS5zcGVjaWFsW3RdLnBvc2ogPT0gXCJ1bmRlZmluZWRcIikgY29udGludWU7XG5cdFx0XHRcdFx0aWYoZGF0YS5zcGVjaWFsW3RdLnBvc2khPXBvc2kgfHwgZGF0YS5zcGVjaWFsW3RdLnBvc2ogIT0gcG9zaiB8fCBwb3NpPT0tMSB8fCBwb3NqPT0tMSkgY29udGludWU7XG5cdFx0XHRcdFx0aWYodHlwZW9mIGRhdGEuc3BlY2lhbFt0XVt2YXJuYW1lXSE9XCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGEuc3BlY2lhbFt0XVt2YXJuYW1lXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYodHlwZW9mIChkYXRhWzBdLnNwZWNpYWwpPT1cIm9iamVjdFwiKSB7XG5cdFx0XHRcdGZvcih2YXIgdD0wO3Q8ZGF0YVswXS5zcGVjaWFsLmxlbmd0aDt0Kyspe1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBkYXRhWzBdLnNwZWNpYWxbdF0ucG9zaSA9PSBcInVuZGVmaW5lZFwiICkgY29udGludWU7XG5cdFx0XHRcdFx0aWYoZGF0YVswXS5zcGVjaWFsW3RdLnBvc2khPXBvc2kgfHwgcG9zaT09LTEpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBkYXRhWzBdLnNwZWNpYWxbdF1bdmFybmFtZV0hPVwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0XHRcdHJldHVybiBkYXRhWzBdLnNwZWNpYWxbdF1bdmFybmFtZV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmKHR5cGVvZiBvcHRpb252YXIgPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdGlmKHR5cGVvZiBkZWZhdWx0dmFsdWU9PVwiZnVuY3Rpb25cIikgcmV0dXJuIGRlZmF1bHR2YWx1ZShyZWZlcmVuY2UsY3R4LGRhdGEsc3RhdERhdGEscG9zaSxwb3NqLG90aGVydmFycyk7XG5cdFx0ZWxzZSBpZih0eXBlb2YgZGVmYXVsdHZhbHVlID09IFwib2JqZWN0XCIpIHsgICAgIFxuXHRcdFx0XHRydj1kZWZhdWx0dmFsdWVbTWF0aC5taW4oZGVmYXVsdHZhbHVlLmxlbmd0aC0xLE1hdGgubWF4KDAscG9zaSkpXTtcblx0XHR9XG5cdFx0ZWxzZSB7IFxuXHRcdFx0cnY9ZGVmYXVsdHZhbHVlO1xuXHRcdH1cblx0XHRpZihyZXNjYWxlIT0xKXJ2PU1hdGguY2VpbChydipyZXNjYWxlKTtcblx0XHRyZXR1cm4gcnY7XG5cdH1cblx0aWYodHlwZW9mIG9wdGlvbnZhcj09XCJmdW5jdGlvblwiKSBydj1vcHRpb252YXIocmVmZXJlbmNlLGN0eCxkYXRhLHN0YXREYXRhLHBvc2kscG9zaixvdGhlcnZhcnMpO1xuXHRlbHNlIGlmKHR5cGVvZiBvcHRpb252YXIgPT0gXCJvYmplY3RcIikge1xuXHRcdGlmIChwb3NqPT0tMSkgcnY9b3B0aW9udmFyW01hdGgubWluKG9wdGlvbnZhci5sZW5ndGgtMSxNYXRoLm1heCgwLHBvc2kpKV07XG5cdFx0ZWxzZSBydj1vcHRpb252YXJbTWF0aC5taW4ob3B0aW9udmFyLmxlbmd0aC0xLE1hdGgubWF4KDAscG9zaikpXTtcblx0fVxuXHRlbHNlIHJ2PW9wdGlvbnZhcjtcblx0aWYocmVzY2FsZSE9MSlydj1NYXRoLmNlaWwocnYqcmVzY2FsZSk7XG5cdHJldHVybiBydjtcblxufTtcblxuZnVuY3Rpb24gdHBkcmF3KGN0eCxkYXRhdmFsKSB7XG5cdHN3aXRjaChjdHgudHBjaGFydCkgIHtcblx0XHRjYXNlIFwiQmFyXCIgOlxuXHRcdGNhc2UgXCJTdGFja2VkQmFyXCIgOlxuXHRcdFx0aWYgKGRhdGF2YWwudHlwZT09XCJMaW5lXCIpIHsgdHA9XCJMaW5lXCI7fSBcdFxuXHRcdFx0ZWxzZSB7dHA9Y3R4LnRwY2hhcnQ7fVxuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdCA6IFxuXHRcdFx0dHA9Y3R4LnRwY2hhcnQ7XG5cdFx0XHRicmVhaztcblx0fVxuXHRyZXR1cm4gdHA7XG59O1xuXG5mdW5jdGlvbiBzZXRUZXh0Qm9yZGVyc0FuZEJhY2tncm91bmQoY3R4LHRleHQsZm9udHNpemUseHBvcyx5cG9zLGJvcmRlcnMsYm9yZGVyc2NvbG9yLGJvcmRlcnN3aWR0aCxib3JkZXJzeHNwYWNlLGJvcmRlcnN5c3BhY2UsYm9yZGVyc3N0eWxlLGJhY2tncm91bmRjb2xvcixvcHRpb25ncm91cCxCb3JkZXJzUmFkaXVzKSB7XG5cdHZhciB0ZXh0SGVpZ2h0LHRleHRXaWR0aDtcblx0Ly8gY29tcHV0ZSB0ZXh0IHdpZHRoIGFuZCB0ZXh0IGhlaWdodDtcblx0aWYodHlwZW9mIHRleHQgIT0gXCJzdHJpbmdcIikge1xuXHRcdHZhciB0eHQ9dGV4dC50b1N0cmluZygpO1xuXHRcdHRleHRIZWlnaHQ9IGZvbnRzaXplICogKHR4dC5zcGxpdChcIlxcblwiKS5sZW5ndGggfHwgMSk7XG5cdFx0dGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHR4dCkud2lkdGg7XG5cdH0gZWxzZSB7XG5cdFx0dGV4dEhlaWdodD0gZm9udHNpemUgKiAodGV4dC5zcGxpdChcIlxcblwiKS5sZW5ndGggfHwgMSk7XG5cdFx0dGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuXHR9XG5cdFxuXHRcblx0Ly8gY29tcHV0ZSB4cmlnaHQsIHhsZWZ0LCB5dG9wLCB5Ym90O1xuXG4gICAgICAgIHZhciB4cmlnaHQsIHhsZWZ0LCB5dG9wLCB5Ym90O1xuXHRpZihjdHgudGV4dEFsaWduPT1cImNlbnRlclwiKSB7XG5cdFx0eHJpZ2h0PS10ZXh0V2lkdGgvMjtcblx0XHR4bGVmdD10ZXh0V2lkdGgvMjtcblx0fSBlbHNlIGlmKGN0eC50ZXh0QWxpZ249PVwibGVmdFwiKSB7XG5cdFx0eHJpZ2h0PTA7XG5cdFx0eGxlZnQ9dGV4dFdpZHRoO1xuXHR9IGVsc2UgaWYoY3R4LnRleHRBbGlnbj09XCJyaWdodFwiKSB7XG5cdFx0eHJpZ2h0PS10ZXh0V2lkdGg7XG5cdFx0eGxlZnQ9MDtcblx0fVxuXHRcblx0aWYoY3R4LnRleHRCYXNlbGluZT09XCJ0b3BcIikge1xuXHRcdHl0b3A9MDtcblx0XHR5Ym90dG9tPXRleHRIZWlnaHQ7XHRcblx0fSBlbHNlIGlmIChjdHgudGV4dEJhc2VsaW5lPT1cImNlbnRlclwiIHx8IGN0eC50ZXh0QmFzZWxpbmU9PVwibWlkZGxlXCIpIHtcblx0XHR5dG9wPS10ZXh0SGVpZ2h0LzI7XG5cdFx0eWJvdHRvbT10ZXh0SGVpZ2h0LzI7XHRcblx0fSBlbHNlIGlmIChjdHgudGV4dEJhc2VsaW5lPT1cImJvdHRvbVwiKSB7XG5cdFx0eXRvcD0tdGV4dEhlaWdodDtcblx0XHR5Ym90dG9tPTA7XHRcblx0fVxuXG5cdGN0eC5zYXZlKCk7XG5cdGN0eC5iZWdpblBhdGgoKTtcbiBcdGN0eC50cmFuc2xhdGUoeHBvcyx5cG9zKTtcblxuXHRpZihiYWNrZ3JvdW5kY29sb3IgIT0gXCJub25lXCIpIHtcblxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LmZpbGxTdHlsZT1iYWNrZ3JvdW5kY29sb3I7XG4vL1x0XHRjdHguZmlsbFJlY3QoeHJpZ2h0LWJvcmRlcnN4c3BhY2UseWJvdHRvbStib3JkZXJzeXNwYWNlLHhsZWZ0LXhyaWdodCsyKmJvcmRlcnN4c3BhY2UseXRvcC15Ym90dG9tLTIqYm9yZGVyc3lzcGFjZSk7XG4vL1x0XHRjdHguc3Ryb2tlKCk7XG5cdFx0Y3R4LmRyYXdSZWN0YW5nbGUoe3g6eHJpZ2h0LWJvcmRlcnN4c3BhY2UseTp5Ym90dG9tK2JvcmRlcnN5c3BhY2Usd2lkdGg6eGxlZnQteHJpZ2h0KzIqYm9yZGVyc3hzcGFjZSxoZWlnaHQ6eXRvcC15Ym90dG9tLTIqYm9yZGVyc3lzcGFjZSxib3JkZXJSYWRpdXM6Qm9yZGVyc1JhZGl1cyxmaWxsOnRydWUsc3Ryb2tlOmZhbHNlfSlcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdGN0eC5maWxsU3R5bGU9XCJibGFja1wiO1xuXHR9XHRcblxuXHQvLyBkcmF3IGJvcmRlcjtcblx0aWYgKGJvcmRlcnMpIHtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5saW5lV2lkdGggPSBib3JkZXJzd2lkdGg7XHRcblx0XHRjdHguc3Ryb2tlU3R5bGU9IGJvcmRlcnNjb2xvcjtcblx0XHRjdHguZmlsbFN0eWxlPSBib3JkZXJzY29sb3I7XG5cdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGJvcmRlcnNzdHlsZSkpO1xuXHRcdGN0eC5kcmF3UmVjdGFuZ2xlKHt4OnhyaWdodC1ib3JkZXJzeHNwYWNlLHk6eWJvdHRvbStib3JkZXJzeXNwYWNlLHdpZHRoOnhsZWZ0LXhyaWdodCsyKmJvcmRlcnN4c3BhY2UsaGVpZ2h0Onl0b3AteWJvdHRvbS0yKmJvcmRlcnN5c3BhY2UsYm9yZGVyUmFkaXVzOkJvcmRlcnNSYWRpdXMsZmlsbDpmYWxzZSxzdHJva2U6dHJ1ZX0pXG4vL1x0XHRjdHgucmVjdCh4cmlnaHQtYm9yZGVyc3dpZHRoLzItYm9yZGVyc3hzcGFjZSx5dG9wLWJvcmRlcnN3aWR0aC8yLWJvcmRlcnN5c3BhY2UseGxlZnQteHJpZ2h0K2JvcmRlcnN3aWR0aCsyKmJvcmRlcnN4c3BhY2UseWJvdHRvbS15dG9wK2JvcmRlcnN3aWR0aCsyKmJvcmRlcnN5c3BhY2UpOyBcbi8vXHRcdGN0eC5zdHJva2UoKTtcblx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH1cblx0XG5cdGN0eC5yZXN0b3JlKCk7XG59O1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVQaWVEcmF3aW5nU2l6ZShjdHgsbXNyLGNvbmZpZyxkYXRhLHN0YXREYXRhKSB7XG5cblx0dmFyIHJlYWxDdW11bGF0aXZlQW5nbGUgPSAoKChjb25maWcuc3RhcnRBbmdsZSAqIChNYXRoLlBJIC8gMTgwKSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSkpICsgMiogTWF0aC5QSSkgJSAoMiogTWF0aC5QSSkgOyBcblx0dmFyIHJlYWxBbXBsaXR1ZGUgPSAoKChjb25maWcudG90YWxBbXBsaXR1ZGUgKiAoTWF0aC5QSSAvIDE4MCkgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpKSArIDIqIE1hdGguUEkpICUgKDIqIE1hdGguUEkpIDsgXG5cdGlmKHJlYWxBbXBsaXR1ZGUgPD0gY29uZmlnLnplcm9WYWx1ZSlyZWFsQW1wbGl0dWRlPTIqTWF0aC5QSTtcblx0XHRcdFxuXHR2YXIgZGViQW5nbGU9KChyZWFsQ3VtdWxhdGl2ZUFuZ2xlLXJlYWxBbXBsaXR1ZGUpKzQqTWF0aC5QSSklKDIqTWF0aC5QSSk7XG5cdHZhciBmaW5BbmdsZT1kZWJBbmdsZStyZWFsQW1wbGl0dWRlO1xuXHRcdFx0XG5cdHZhciBxcG9zZGViPU1hdGguZmxvb3IoKChkZWJBbmdsZStjb25maWcuemVyb1ZhbHVlKS8oTWF0aC5QSS8yKSklNCk7XG5cdHZhciBxcG9zZmluPU1hdGguZmxvb3IoKChmaW5BbmdsZS1jb25maWcuemVyb1ZhbHVlKS8oTWF0aC5QSS8yKSklNCk7XG5cdHZhciBxPVswLDAsMCwwXTtcblx0aWYocXBvc2RlYjw9cXBvc2Zpbilmb3IodmFyIGk9cXBvc2RlYjtpPD1xcG9zZmluO2krKylxW2ldPTE7XG5cdGVsc2Uge1xuXHRcdGZvcih2YXIgaT1xcG9zZGViO2k8NDtpKyspcVtpXT0xO1xuXHRcdGZvcih2YXIgaT0wO2k8PXFwb3NmaW47aSsrKXFbaV09MTtcblx0fVxuXG5cdGlmKHFbMF09PTAgJiYgcVsxXT09MCkge1xuXHRcdG1pZFBpZVkgPSBtc3IudG9wTm90VXNhYmxlU2l6ZSs1O1xuXHRcdGRvdWdobnV0UmFkaXVzID0gbXNyLmF2YWlsYWJsZUhlaWdodC01O1xuXHR9IGVsc2UgaWYocVsyXT09MCAmJiBxWzNdPT0wKSB7XG5cdFx0bWlkUGllWSA9IG1zci50b3BOb3RVc2FibGVTaXplICsgbXNyLmF2YWlsYWJsZUhlaWdodDtcblx0XHRkb3VnaG51dFJhZGl1cyA9IG1zci5hdmFpbGFibGVIZWlnaHQtNTtcblx0fWVsc2Uge1xuXHRcdG1pZFBpZVkgPSBtc3IudG9wTm90VXNhYmxlU2l6ZSArIChtc3IuYXZhaWxhYmxlSGVpZ2h0IC8gMik7XG5cdFx0ZG91Z2hudXRSYWRpdXMgPSBtc3IuYXZhaWxhYmxlSGVpZ2h0LzItNTtcblx0fVxuXHR2YXIgcmVhbEF2YWlsYWJsZVdpZHRoO1xuXHRpZihxWzBdPT0wICYmIHFbM109PTApIHtcblx0XHRtaWRQaWVYID0gbXNyLmxlZnROb3RVc2FibGVTaXplICsgbXNyLmF2YWlsYWJsZVdpZHRoLTUgO1xuXHRcdGRvdWdobnV0UmFkaXVzID0gTWF0aC5taW4oZG91Z2hudXRSYWRpdXMsIG1zci5hdmFpbGFibGVXaWR0aCAtNSk7XG5cdFx0cmVhbEF2YWlsYWJsZVdpZHRoPW1zci5hdmFpbGFibGVXaWR0aCAtNVxuXHRcdFxuXHR9IGVsc2UgaWYocVsxXT09MCAmJiBxWzJdPT0wKSB7XG5cdFx0bWlkUGllWCA9IG1zci5sZWZ0Tm90VXNhYmxlU2l6ZSs1IDtcblx0XHRkb3VnaG51dFJhZGl1cyA9IE1hdGgubWluKGRvdWdobnV0UmFkaXVzLCBtc3IuYXZhaWxhYmxlV2lkdGggLTUpO1xuXHRcdHJlYWxBdmFpbGFibGVXaWR0aD1tc3IuYXZhaWxhYmxlV2lkdGggLTVcblx0fSBlbHNlIHtcblx0XHRtaWRQaWVYID0gbXNyLmxlZnROb3RVc2FibGVTaXplICsgKG1zci5hdmFpbGFibGVXaWR0aCAvIDIpO1xuXHRcdGRvdWdobnV0UmFkaXVzID0gTWF0aC5taW4oZG91Z2hudXRSYWRpdXMsIChtc3IuYXZhaWxhYmxlV2lkdGgvMikgLTUpO1xuXHRcdHJlYWxBdmFpbGFibGVXaWR0aD0obXNyLmF2YWlsYWJsZVdpZHRoLzIpIC01XG5cdH1cblxuXHQvLyBDb21wdXRlcmFuZ2UgUGllIFJhZGl1c1xuXHRpZiAoaXNCb29sZWFuT3B0aW9uVHJ1ZSh1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhU2hvdykgJiYgc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFSQURJVVNQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFSYWRpdXNQb3NpdGlvbixcImluR3JhcGhEYXRhUmFkaXVzUG9zaXRpb25cIiwwLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDMgJiYgc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFBTElHTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFBbGlnbixcImluR3JhcGhEYXRhQWxpZ25cIiwwLC0xLHtudWxsVmFsdWU6IHRydWUgIH0pID09IFwib2ZmLWNlbnRlclwiICYmIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUk9UQVRFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVJvdGF0ZSxcImluR3JhcGhEYXRhUm90YXRlXCIsMCwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAwKSB7XG5cdFx0ZG91Z2hudXRSYWRpdXMgPSBkb3VnaG51dFJhZGl1cyAtIHNldE9wdGlvblZhbHVlKHRydWUsY3R4LmNoYXJ0VGV4dFNjYWxlLFwiSU5HUkFQSERBVEFGT05UU0laRVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250U2l6ZSxcImluR3JhcGhEYXRhRm9udFNpemVcIiwwLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApIC0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFQQURESU5HUkFESVVTXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdSYWRpdXMsXCJpbkdyYXBoRGF0YVBhZGRpbmdSYWRpdXNcIiwwLC0xLHtudWxsVmFsdWU6IHRydWV9ICkgLSA1O1xuXHRcdHZhciBwb3NBbmdsZTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICghKHR5cGVvZihkYXRhW2ldLnZhbHVlKSA9PSAndW5kZWZpbmVkJykgJiYgMSpkYXRhW2ldLnZhbHVlPj0wKSB7XG5cdFx0XHRcdGN0eC5mb250ID0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFGT05UU1RZTEVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhRm9udFN0eWxlLFwiaW5HcmFwaERhdGFGb250U3R5bGVcIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApICsgJyAnICsgc2V0T3B0aW9uVmFsdWUodHJ1ZSxjdHguY2hhcnRUZXh0U2NhbGUsXCJJTkdSQVBIREFUQUZPTlRTSVpFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUZvbnRTaXplLFwiaW5HcmFwaERhdGFGb250U2l6ZVwiLGksLTEse251bGxWYWx1ZSA6IHRydWV9ICkgKyAncHggJyArIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBRk9OVEZBTUlMWVwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFGb250RmFtaWx5LFwiaW5HcmFwaERhdGFGb250RmFtaWx5XCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKTtcblx0XHRcdFx0aWYgKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBQU5HTEVQT1NJVElPTlwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFBbmdsZVBvc2l0aW9uLFwiaW5HcmFwaERhdGFBbmdsZVBvc2l0aW9uXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSA9PSAxKSBwb3NBbmdsZSA9IHJlYWxDdW11bGF0aXZlQW5nbGUgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVBBRERJTkFOR0xFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdBbmdsZSxcImluR3JhcGhEYXRhUGFkZGluZ0FuZ2xlXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlICB9KSAqIChNYXRoLlBJIC8gMTgwKTtcblx0XHRcdFx0ZWxzZSBpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFBTkdMRVBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUFuZ2xlUG9zaXRpb24sXCJpbkdyYXBoRGF0YUFuZ2xlUG9zaXRpb25cIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDIpIHBvc0FuZ2xlID0gcmVhbEN1bXVsYXRpdmVBbmdsZSAtIHN0YXREYXRhW2ldLnNlZ21lbnRBbmdsZSAvIDIgKyBzZXRPcHRpb25WYWx1ZSh0cnVlLDEsXCJJTkdSQVBIREFUQVBBRERJTkFOR0xFXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdBbmdsZSxcImluR3JhcGhEYXRhUGFkZGluZ0FuZ2xlXCIsaSwtMSx7bnVsbFZhbHVlOiB0cnVlICB9KSAqIChNYXRoLlBJIC8gMTgwKTtcblx0XHRcdFx0ZWxzZSBpZiAoc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFBTkdMRVBPU0lUSU9OXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YUFuZ2xlUG9zaXRpb24sXCJpbkdyYXBoRGF0YUFuZ2xlUG9zaXRpb25cIixpLC0xLHtudWxsVmFsdWUgOiB0cnVlfSApID09IDMpIHBvc0FuZ2xlID0gcmVhbEN1bXVsYXRpdmVBbmdsZSAtIHN0YXREYXRhW2ldLnNlZ21lbnRBbmdsZSArIHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBUEFERElOQU5HTEVcIixjdHgsZGF0YSxzdGF0RGF0YSx1bmRlZmluZWQsY29uZmlnLmluR3JhcGhEYXRhUGFkZGluZ0FuZ2xlLFwiaW5HcmFwaERhdGFQYWRkaW5nQW5nbGVcIixpLC0xLHtudWxsVmFsdWU6IHRydWUgIH0pICogKE1hdGguUEkgLyAxODApO1xuXHRcdFx0XHRyZWFsQ3VtdWxhdGl2ZUFuZ2xlIC09IHN0YXREYXRhW2ldLnNlZ21lbnRBbmdsZTtcblx0XHRcdFx0dmFyIGRpc3BTdHJpbmcgPSB0bXBsYmlzKHNldE9wdGlvblZhbHVlKHRydWUsMSxcIklOR1JBUEhEQVRBVE1QTFwiLGN0eCxkYXRhLHN0YXREYXRhLHVuZGVmaW5lZCxjb25maWcuaW5HcmFwaERhdGFUbXBsLFwiaW5HcmFwaERhdGFUbXBsXCIsaSwtMSx7bnVsbFZhbHVlIDogdHJ1ZX0gKSwgc3RhdERhdGFbaV0sY29uZmlnKTtcblx0XHRcdFx0dmFyIHRleHRNZWFzdXJlbWVudCA9IGN0eC5tZWFzdXJlVGV4dE11bHRpTGluZShkaXNwU3RyaW5nKS50ZXh0V2lkdGg7XG5cdFx0XHRcdHZhciBNYXhSYWRpdXNYID0gTWF0aC5hYnMoKHJlYWxBdmFpbGFibGVXaWR0aCAtIHRleHRNZWFzdXJlbWVudCkgLyBNYXRoLmNvcyhwb3NBbmdsZSkpIC0gc2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiSU5HUkFQSERBVEFQQURESU5HUkFESVVTXCIsY3R4LGRhdGEsc3RhdERhdGEsdW5kZWZpbmVkLGNvbmZpZy5pbkdyYXBoRGF0YVBhZGRpbmdSYWRpdXMsXCJpbkdyYXBoRGF0YVBhZGRpbmdSYWRpdXNcIixpLC0xLHtudWxsVmFsdWU6IHRydWV9ICkgLSA1O1xuXHRcdFx0XHRpZiAoTWF4UmFkaXVzWCA8IGRvdWdobnV0UmFkaXVzKSBkb3VnaG51dFJhZGl1cyA9IE1heFJhZGl1c1g7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGRvdWdobnV0UmFkaXVzID0gZG91Z2hudXRSYWRpdXMgKiBjb25maWcucmFkaXVzU2NhbGU7XG5cdHJldHVybiB7XG5cdFx0cmFkaXVzIDogZG91Z2hudXRSYWRpdXMsXG5cdFx0bWlkUGllWCA6IG1pZFBpZVgsXG5cdFx0bWlkUGllWSA6IG1pZFBpZVlcblx0fTtcbn07XG4iLCIkKGRvY3VtZW50KS5mb3VuZGF0aW9uKCk7XG52YXIgcmF3RGF0YVVSTCA9IFwiYXNzZXRzL2pzL2NoYXJ0Lmpzb25cIjtcblxuJChcIi5wcm9kdWN0LWNhcmRcIikuaG92ZXIoZnVuY3Rpb24oKSB7XG4gIFx0Y29uc29sZS5sb2coXCJob3ZlcmVkXCIpXG4gICAgJCh0aGlzKS5jaGlsZHJlbihcImRpdjpmaXJzdFwiKS50b2dnbGVDbGFzcygnc2hvdycpO1xufSk7XG4kLmdldEpTT04ocmF3RGF0YVVSTCwgZnVuY3Rpb24gKGpzb24pIHtcblx0dmFyIGRhdGEgPSBwcmVwRGF0YShqc29uKTtcblx0dmFyIGN0eCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlDaGFydFwiKTtcblx0dmFyIGNvbnRleHQgPSBjdHguZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRjb250ZXh0LnJlY3QoMCwgMCwgY3R4LndpZHRoLCBjdHguaGVpZ2h0KTtcblxuXHRcdC8vIGFkZCBsaW5lYXIgZ3JhZGllbnRcblx0XHR2YXIgZ3JkID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgyMDAsIDAsIDIwMCwgIGN0eC5oZWlnaHQpO1xuXHRcdC8vIGxpZ2h0IGJsdWVcblx0XHRncmQuYWRkQ29sb3JTdG9wKDAsICdyZ2JhKDAsIDAsIDAsIDEpJyk7ICAgXG5cdFx0Ly8gZGFyayBibHVlXG5cdFx0XHRncmQuYWRkQ29sb3JTdG9wKDAuNSwgJ3JnYmEoMCwgMCwgMCwgMC41KScpOyAgXG5cdFx0Z3JkLmFkZENvbG9yU3RvcCgxLCAncmdiYSgyNDQsIDI0NCwgMjQ0LCAwKScpO1xuXG5cdHZhciBsaW5lRGF0YSA9IHsgXG5cdFx0XHRcdCBcblx0XHQgICAgICAgIGxhYmVsczogZGF0YVswXS54LFxuXG5cdFx0ICAgICAgICBkYXRhc2V0czogW3tcblx0XHQgICAgICAgIFx0ZmlsbENvbG9yOiBncmFkaWVudENvbG9yLFxuICAgICAgICBcdFx0XHRncmFkaWVudENvbG9ycyA6IFtcInJnYmEoMjQ0LCAyNDQsIDI0NCwgMC42KSAxMDAlXCIsXCJyZ2JhKDI0NCwgMjQ0LCAyNDQsIDApIDAlXCJdLFxuXHRcdCAgICAgICAgXHRzdHJva2VDb2xvcjpcInJnYigyMjUsIDIzMiwgMjM4KVwiLFxuXHRcdCAgICAgICAgXHRib3JkZXJDb2xvcjogXCJyZ2IoMjI1LCAyMzIsIDIzOClcIixcblx0XHQgICAgICAgIFx0cG9pbnRSYWRpdXMgOiA1LFxuXHRcdCAgICAgICAgXHRwb2ludENvbG9yOiBcInJnYigyMjUsIDIzMiwgMjM4KVwiLFxuXHRcdCAgICAgICAgXHRwb2ludFN0cm9rZUNvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwxKScsXG5cdFx0ICAgICAgICBcdHBvaW50SG92ZXJSYWRpdXM6IDgsXG5cdFx0ICAgICAgICBcdHBvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDIyNSwgMjMyLCAyMzgpXCIsXG5cdFx0ICAgICAgICBcdHBvaW50SG92ZXJCb3JkZXJDb2xvcjogXCJyZ2JhKDI1NSwyNTUsMjU1LDEpXCIsXG5cdFx0ICAgICAgICAgICAgdGVuc2lvbjowLFxuXHQgICAgICAgICAgICBcdGJlemllckN1cnZlOiBmYWxzZSxcdFxuXHRcdCAgICAgICAgICAgIGRhdGE6IGRhdGFbMF0ueVxuXHRcdCAgICAgICAgfV1cblx0XHQgICAgfTtcblx0bGluZURhdGEuc2hhcGVzSW5DaGFydD1bXTtcblx0XHRmb3IodmFyIGk9MDtpPGxpbmVEYXRhLmxhYmVscy5sZW5ndGg7aSsrKXtcblx0XHRcdGNvbnNvbGUubG9nKGxpbmVEYXRhLmRhdGFzZXRzWzBdLmRhdGFbMV0pXG5cdFx0XHRsaW5lRGF0YS5zaGFwZXNJbkNoYXJ0W2ldPSB7XG5cdFx0XHRcdFx0cG9zaXRpb24gOiBcIklOQ0hBUlRcIixcblx0XHRcdFx0XHRzaGFwZTogXCJMSU5FXCIsXG5cdFx0XHRcdFx0c3Ryb2tlU3R5bGUgOiBcImRhc2hTcGFjZVwiLFxuXHRcdFx0XHRcdHN0cm9rZUNvbG9yOiBncmQsXG5cdFx0XHRcdFx0YW5pbWF0ZSA6IHRydWUsXG5cdFx0XHRcdFx0eDE6IGksXG5cdFx0XHRcdFx0eTE6IDAsXG5cdFx0XHRcdFx0eDI6IGksXG5cdFx0XHRcdFx0eTI6IE1hdGgubWF4KGxpbmVEYXRhLmRhdGFzZXRzWzBdLmRhdGFbaV0pLFxuXHRcdFx0XHRcdGl0ZXIgOiAnbGFzdCdcblx0XHRcdH1cblx0XHR9O1xuXG5cdHZhciBvcHRpb24gPSAge1xuXHRcdGNhbnZhc0JvcmRlcnMgOiBmYWxzZSxcblx0XHRsZWdlbmQgOiBmYWxzZSxcblx0XHRzY2FsZVNob3dHcmlkTGluZXM6ZmFsc2UsXG5cdFx0c2NhbGVHcmlkTGluZVN0eWxlOlwiZGFzaFNwYWNlXCIsXG5cdFx0c2NhbGVYR3JpZExpbmVzU3RlcDoxLFxuICAgIFx0c2NhbGVZR3JpZExpbmVzU3RlcDowLFxuICAgIFx0YW5ub3RhdGVEaXNwbGF5OnRydWUsXG4gICAgXHRzY2FsZUdyaWRMaW5lV2lkdGg6MSxcbiAgICBcdHNjYWxlR3JpZExpbmVDb2xvcjpncmQsXG4gICAgXHRpbkdyYXBoRGF0YUJvcmRlcnM6ZmFsc2UsXG4gICAgXHR5QXhpc0xlZnQ6ZmFsc2UsXG4gICAgXHR5QXhpc1JpZ2h0OmZhbHNlLFxuICAgIFx0YmV6aWVyQ3VydmU6ZmFsc2UsXG4gICAgXHRkcmF3WFNjYWxlTGluZTogW3twb3NpdGlvbjpcIjBcIixsaW5lV2lkdGg6MCxsaW5lQ29sb3I6XCJyZ2JhKDI1NSwyNTUsMjU1LDBcIn1dLFxuICAgIFx0c2NhbGVUaWNrU2l6ZUxlZnQ6MCxcbiAgICBcdHNjYWxlVGlja1NpemVCb3R0b206MCxcbiAgICBcdHNob3dZTGFiZWxzOiAwLFxuICAgIFx0c2NhbGVZR3JpZExpbmVzU3RlcDowLFxuICAgIFx0c2NhbGVMaW5lQ29sb3I6XCJyZ2JhKDI0NCwgMjQ0LCAyNDQsIDApXCIsXG4gICAgXHRhbm5vdGF0ZUJhY2tncm91bmRDb2xvcjpcInJnYigxMzEsMTQwLDE5OSlcIixcbiAgICBcdGFubm90YXRlQ2xhc3NOYW1lOiBcInRvb2xUaXBcIixcbiAgICBcdGFubm90YXRlTGFiZWw6IFwiPCU9JzxwPiZldXJvOycrdjMrJzwvcD4nKyc8cD5FYXJuZWQgZm9yICcrdjIrJzwvcD4nICU+XCIsXG4gICAgXHRlbmREcmF3U2NhbGVGdW5jdGlvbjogZHJhd1NoYXBlc1xuICAgIFxuICAgIH07XG5cbnZhciBteUNoYXJ0ID0gbmV3IENoYXJ0KGNvbnRleHQpLkxpbmUobGluZURhdGEsb3B0aW9uKTtcbn0pXG5cbnZhciBybmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdyYXBoUmFuZ2VcIik7XG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdyYXBoQ29udGFpbmVyXCIpLnNjcm9sbExlZnQgPSA4MDA7XG5ybmcub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdyYXBoQ29udGFpbmVyXCIpLnNjcm9sbExlZnQgPSB0aGlzLnZhbHVlICogMTY7XG59XG5cblxuZnVuY3Rpb24gcHJlcERhdGEocmF3RGF0YSkge1xuXHRkYXRhUmVmaW5lZCA9IHJhd0RhdGEubnVtYmVyc1xuICAgIHZhciB4ID0gW107XG4gICAgdmFyIHkgPSBbXTtcbiAgICAvLyB2YXIgdGV4dCA9IFtdO1xuXG4gICAgIGRhdGFSZWZpbmVkLmZvckVhY2goZnVuY3Rpb24oZGF0dW0sIGkpIHtcbiAgICAgXHRcbiAgICAgICAgeC5wdXNoKGRhdHVtLm1vbnRoKTtcbiAgICAgICAgeS5wdXNoKGRhdHVtLm1vbmV5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3tcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH1dO1xufVxuXG4iLCJcblxuXG52YXIgdGFnX2NhbnZhc19zdWZmaXg9XCJfVGFnX0NhbnZhc1wiO1xudmFyIGNvdW50X3RhZ19jYW52YXM9MDtcbnZhciBmaXJzdF90YWc9XCJub3RfeWV0X2RlZmluZWRcIjtcbnZhciBjdXJyZW50X3RhZz1cIm5vdF95ZXRfZGVmaW5lZFwiO1xudmFyIHRhZ19jYW52YXNfbGlzdD1bXTtcbnZhciB0YWdfZGVmX2hlaWdodD00MDA7XG52YXIgdGFnX2RlZl93aWR0aD04MDA7XG52YXIgdGFnX2FuaW1hdGlvbl9vbmx5X2F0X2ZpcnN0X2Rpc3BsYXk9ZmFsc2U7XG5cbmZ1bmN0aW9uIHNldENhbnZhcyh0cGdyYXBoLGRhdGEsb3B0aW9ucyxoZWlnaHQsd2lkdGgpIHsgXG5cdHZhciBzZXRoZWlnaHQsc2V0d2lkdGg7XG5cdGlmKHR5cGVvZiBoZWlnaHQ9PVwidW5kZWZpbmVkXCIpc2V0aGVpZ2h0PXRhZ19kZWZfaGVpZ2h0O1xuXHRlbHNlIHNldGhlaWdodD1oZWlnaHQ7XG5cdGlmKHR5cGVvZiB3aWR0aD09XCJ1bmRlZmluZWRcIilzZXR3aWR0aD10YWdfZGVmX3dpZHRoO1xuXHRlbHNlIHNldHdpZHRoPXdpZHRoO1xuXHRcblx0dmFyIGRpdnMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGl2Jyk7XG5cdGlmKGZpcnN0X3RhZz09XCJub3RfeWV0X2RlZmluZWRcIikgeyBmaXJzdF90YWc9ZGl2c1tkaXZzLmxlbmd0aC0xXS5pZDsgY3VycmVudF90YWc9Zmlyc3RfdGFnOyB9XG5cdGlmKHR5cGVvZiB0YWdfY2FudmFzX2xpc3RbZGl2c1tkaXZzLmxlbmd0aC0xXS5pZF09PVwidW5kZWZpbmVkXCIpIHRhZ19jYW52YXNfbGlzdFtkaXZzW2RpdnMubGVuZ3RoLTFdLmlkXSA9IFtdO1xuXHR2YXIgY252Y250PXRhZ19jYW52YXNfbGlzdFtkaXZzW2RpdnMubGVuZ3RoLTFdLmlkXS5sZW5ndGg7XG5cdGRvY3VtZW50LndyaXRlKFwiPGNhbnZhcyBpZD1cXFwiXCIrZGl2c1tkaXZzLmxlbmd0aC0xXS5pZCt0YWdfY2FudmFzX3N1ZmZpeCtcIl9cIitjbnZjbnQrXCJcXFwiIGhlaWdodD1cXFwiXCIrc2V0aGVpZ2h0K1wiXFxcIiB3aWR0aD1cXFwiXCIrc2V0d2lkdGgrXCJcXFwiPjwvY2FudmFzPlwiKTtcblx0dGFnX2NhbnZhc19saXN0W2RpdnNbZGl2cy5sZW5ndGgtMV0uaWRdW3RhZ19jYW52YXNfbGlzdFtkaXZzW2RpdnMubGVuZ3RoLTFdLmlkXS5sZW5ndGhdPXsgZmlyc3REaXNwbGF5OiB0cnVlLCB3aWR0aDpzZXR3aWR0aCwgaGVpZ2h0OiBzZXRoZWlnaHQsIHRwZ3JhcGg6dHBncmFwaCxkYXRhOmRhdGEsb3B0aW9uczpvcHRpb25zLCBydW5BbmltYXRpb246dHJ1ZSB9O1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkaXZzW2RpdnMubGVuZ3RoLTFdLmlkK3RhZ19jYW52YXNfc3VmZml4K1wiX1wiK2NudmNudCkuZ2V0Q29udGV4dChcIjJkXCIpLm9yaWdpbmFsX2hlaWdodD1zZXRoZWlnaHQ7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpdnNbZGl2cy5sZW5ndGgtMV0uaWQrdGFnX2NhbnZhc19zdWZmaXgrXCJfXCIrY252Y250KS5nZXRDb250ZXh0KFwiMmRcIikub3JpZ2luYWxfd2lkdGg9c2V0d2lkdGg7XG5cdGlmKGRpdnNbZGl2cy5sZW5ndGgtMV0uaWQ9PWZpcnN0X3RhZyl7XG5cdFx0Y29uc29sZS5sb2coXCJEaXNwbGF5IENhbnZhczogXCIrZGl2c1tkaXZzLmxlbmd0aC0xXS5pZCt0YWdfY2FudmFzX3N1ZmZpeCtcIl9cIitjbnZjbnQpO1xuXHRcdHRhYl9kaXNwX2NhbnZhcyhkaXZzW2RpdnMubGVuZ3RoLTFdLmlkK3RhZ19jYW52YXNfc3VmZml4K1wiX1wiK2NudmNudCx0cGdyYXBoLGRhdGEsb3B0aW9ucyx0cnVlLHNldHdpZHRoLHNldGhlaWdodCx0cnVlKTtcblx0XHRpZih0YWdfYW5pbWF0aW9uX29ubHlfYXRfZmlyc3RfZGlzcGxheT09dHJ1ZSl0YWdfY2FudmFzX2xpc3RbZGl2c1tkaXZzLmxlbmd0aC0xXS5pZF1bdGFnX2NhbnZhc19saXN0W2RpdnNbZGl2cy5sZW5ndGgtMV0uaWRdLmxlbmd0aC0xXVtcInJ1bkFuaW1hdGlvblwiXT1mYWxzZTtcblx0XHR0YWdfY2FudmFzX2xpc3RbZGl2c1tkaXZzLmxlbmd0aC0xXS5pZF1bdGFnX2NhbnZhc19saXN0W2RpdnNbZGl2cy5sZW5ndGgtMV0uaWRdLmxlbmd0aC0xXVtcImZpcnN0RGlzcGxheVwiXT1mYWxzZTtcdFxuXHR9XG59O1xuXG5cbmZ1bmN0aW9uIHRhYl9kaXNwX2dyYXBoKHRhYil7XG5cdGlmKHR5cGVvZiB0YWdfY2FudmFzX2xpc3RbdGFiXSE9XCJ1bmRlZmluZWRcIikge1xuXHRcdGZvcih2YXIgaT0wO2k8dGFnX2NhbnZhc19saXN0W3RhYl0ubGVuZ3RoO2krKykge1xuXHRcdFx0dGFiX2Rpc3BfY2FudmFzKHRhYit0YWdfY2FudmFzX3N1ZmZpeCtcIl9cIitpLHRhZ19jYW52YXNfbGlzdFt0YWJdW2ldW1widHBncmFwaFwiXSx0YWdfY2FudmFzX2xpc3RbdGFiXVtpXVtcImRhdGFcIl0sdGFnX2NhbnZhc19saXN0W3RhYl1baV1bXCJvcHRpb25zXCJdLHRhZ19jYW52YXNfbGlzdFt0YWJdW2ldW1wicnVuQW5pbWF0aW9uXCJdLHRhZ19jYW52YXNfbGlzdFt0YWJdW2ldW1wid2lkdGhcIl0sdGFnX2NhbnZhc19saXN0W3RhYl1baV1bXCJoZWlnaHRcIl0sdGFnX2NhbnZhc19saXN0W3RhYl1baV1bXCJmaXJzdERpc3BsYXlcIl0pO1xuXHRcdFx0aWYodGFnX2FuaW1hdGlvbl9vbmx5X2F0X2ZpcnN0X2Rpc3BsYXk9PXRydWUpdGFnX2NhbnZhc19saXN0W3RhYl1baV1bXCJydW5BbmltYXRpb25cIl09ZmFsc2U7XG5cdFx0XHR0YWdfY2FudmFzX2xpc3RbdGFiXVtpXVtcImZpcnN0RGlzcGxheVwiXT1mYWxzZTtcdFx0XHRcblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIHRhYl9kaXNwX2NhbnZhcyhjYW52YXMsdHBncmFwaCxkYXRhLG9wdGlvbnMscnVuQW5pbWF0aW9uLHNldFdpZHRoLHNldEhlaWdodCxmaXJzdERpc3Ape1xuXG5cdGlmKCFydW5BbmltYXRpb24pe1xuXHRcdGJvb3RTdHJhcENoYXJ0SnNSZXNpemUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzKS5nZXRDb250ZXh0KFwiMmRcIiksZGF0YSxvcHRpb25zKTtcblx0XHRyZXR1cm4oZmFsc2UpO1xuXHR9XG5cblx0aWYoIWZpcnN0RGlzcCkge1xuLy9cdFx0Ym9vdFN0cmFwQ2hhcnRKc1Jlc2l6ZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpLmdldENvbnRleHQoXCIyZFwiKSxkYXRhLG9wdGlvbnMpO1xuLy9cdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzKS5nZXRDb250ZXh0KFwiMmRcIikuZmlyc3RQYXNzPTk7XG4vL1x0XHRib290U3RyYXBDaGFydEpzUmVzaXplKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcykuZ2V0Q29udGV4dChcIjJkXCIpLGRhdGEsb3B0aW9ucyk7XG4vL1x0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpLmdldENvbnRleHQoXCIyZFwiKS5zdHJva2UoKTtcbi8vXHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcykuZ2V0Q29udGV4dChcIjJkXCIpLmNsZWFyUmVjdCgwLCAwLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpLmdldENvbnRleHQoXCIyZFwiKS5jYW52YXMud2lkdGgsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcykuZ2V0Q29udGV4dChcIjJkXCIpLmNhbnZhcy5oZWlnaHQpO1xuLy9cdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzKS5nZXRDb250ZXh0KFwiMmRcIikuc3Ryb2tlKCk7XG4vL1x0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpLmdldENvbnRleHQoXCIyZFwiKS5maXJzdFBhc3M9OTtcbi8vXHRcdHVwZGF0ZUNoYXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcykuZ2V0Q29udGV4dChcIjJkXCIpLGRhdGEsb3B0aW9ucyx0cnVlLHRydWUpO1xuXHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcykuZ2V0Q29udGV4dChcIjJkXCIpLmZpcnN0UGFzcz11bmRlZmluZWQ7XG5cdFx0ZXZhbChcInZhciBjaGFydCA9IG5ldyBDaGFydChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpLmdldENvbnRleHQoXFxcIjJkXFxcIikpLlwiK3RwZ3JhcGgrXCIoZGF0YSxvcHRpb25zKTtcIik7IFxuXHR9XG5cdGVsc2Uge1xuXHRcdGV2YWwoXCJ2YXIgY2hhcnQgPSBuZXcgQ2hhcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzKS5nZXRDb250ZXh0KFxcXCIyZFxcXCIpKS5cIit0cGdyYXBoK1wiKGRhdGEsb3B0aW9ucyk7XCIpOyBcblx0fVxufTtcblxuZnVuY3Rpb24gc2V0UmVmcmVzaENhbnZhcygpIHtcbiQoJ2FbZGF0YS10b2dnbGU9dGFiXScpLm9uKCdzaG93bi5icy50YWInLCBmdW5jdGlvbiAoZSkge1xudmFyIHZsX3RhcmdldD1lLnRhcmdldCtcIlwiO1xudmxfdGFyZ2V0PXZsX3RhcmdldC5zcGxpdChcIiNcIikucG9wKCk7XHRcbmN1cnJlbnRfdGFnPXZsX3RhcmdldDtcbnRhYl9kaXNwX2dyYXBoKHZsX3RhcmdldCk7XG59KTtcbn07XG5cbmZ1bmN0aW9uIGJvb3RTdHJhcENoYXJ0SnNSZXNpemUoY3R4LGRhdGEsb3B0aW9ucykge1xuXHRjdHguZmlyc3RQYXNzPTk7XG5cdHVwZGF0ZUNoYXJ0KGN0eCxkYXRhLG9wdGlvbnMsZmFsc2UsZmFsc2UpO1xufTtcblxuIiwiXG5cbnZhciBkcmlsbERvd25CYWNrRGF0YT1bXTtcbnZhciBkcmlsbERvd25CYWNrQ29uZmlnPVtdO1xuXG52YXIgcG9zRHJpbGxEb3duQmFja0RhdGE9MDtcblxuZnVuY3Rpb24gY2hhcnREcmlsbFVwKGV2ZW50LGN0eCxjb25maWcsZGF0YSxvdGhlcilcbntcblx0aWYocG9zRHJpbGxEb3duQmFja0RhdGE+MCkge1xuXHRcdHBvc0RyaWxsRG93bkJhY2tEYXRhLS07XG4vLyAgICAgICAgICBcdGN0eC5maXN0UGFzcz11bmRlZmluZWQ7XG4vL1x0XHRldmFsKFwidmFyIG5ld2NoYXJ0PW5ldyBDaGFydChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcXFwiY2FudmFzX2JhclxcXCIpLmdldENvbnRleHQoXFxcIjJkXFxcIikpLlwiK2N0eC50cGNoYXJ0K1wiKGRyaWxsRG93bkJhY2tEYXRhW3Bvc0RyaWxsRG93bkJhY2tEYXRhXSxkcmlsbERvd25CYWNrQ29uZmlnW3Bvc0RyaWxsRG93bkJhY2tEYXRhXSk7XCIpO1xuXHRcdGRlbGV0ZUhpZ2hMaWdodChjdHgsZHJpbGxEb3duQmFja0RhdGFbcG9zRHJpbGxEb3duQmFja0RhdGFdKTtcblx0XHR1cGRhdGVDaGFydChjdHgsZHJpbGxEb3duQmFja0RhdGFbcG9zRHJpbGxEb3duQmFja0RhdGFdLGRyaWxsRG93bkJhY2tDb25maWdbcG9zRHJpbGxEb3duQmFja0RhdGFdLGZhbHNlLGZhbHNlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjaGFydERyaWxsRG93bihldmVudCxjdHgsY29uZmlnLGRhdGEsb3RoZXIpXG57XG4gIGlmKG90aGVyICE9IG51bGwpIHtcbiAgXHRpZihkYXRhLmRhdGFzZXRzW290aGVyLmldLmRyaWxsRG93bkRhdGEgIT0gbnVsbCkge1xuICBcdFx0aWYoZGF0YS5kYXRhc2V0c1tvdGhlci5pXS5kcmlsbERvd25EYXRhW290aGVyLmpdICE9IG51bGwpIHtcbiAgXHRcdFx0dmFyIHZjb25maWc9Y29uZmlnO1xuXHQgIFx0XHRpZihkYXRhLmRhdGFzZXRzW290aGVyLmldLmRyaWxsRG93bkNvbmZpZyAhPSBudWxsKWlmKGRhdGEuZGF0YXNldHNbb3RoZXIuaV0uZHJpbGxEb3duQ29uZmlnW290aGVyLmpdICE9IG51bGwpdmNvbmZpZz1kYXRhLmRhdGFzZXRzW290aGVyLmldLmRyaWxsRG93bkNvbmZpZ1tvdGhlci5qXTtcblx0ICAgICAgICAgIFx0ZHJpbGxEb3duQmFja0NvbmZpZ1twb3NEcmlsbERvd25CYWNrRGF0YV09Y29uZmlnO1xuXHQgICAgICAgICAgXHRkcmlsbERvd25CYWNrRGF0YVtwb3NEcmlsbERvd25CYWNrRGF0YSsrXT1kYXRhO1xuLy9cdCAgICAgICAgICBcdGN0eC5maXN0UGFzcz11bmRlZmluZWQ7XG4vL1x0XHRcdGV2YWwoXCJ2YXIgbmV3Y2hhcnQ9bmV3IENoYXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxcXCJjYW52YXNfYmFyXFxcIikuZ2V0Q29udGV4dChcXFwiMmRcXFwiKSkuXCIrY3R4LnRwY2hhcnQrXCIoZGF0YS5kYXRhc2V0c1tvdGhlci5pXS5kcmlsbERvd25EYXRhW290aGVyLmpdLHZjb25maWcpO1wiKTtcblx0XHRcdGRlbGV0ZUhpZ2hMaWdodChjdHgsZGF0YS5kYXRhc2V0c1tvdGhlci5pXS5kcmlsbERvd25EYXRhW290aGVyLmpdKTtcblx0XHRcdHVwZGF0ZUNoYXJ0KGN0eCxkYXRhLmRhdGFzZXRzW290aGVyLmldLmRyaWxsRG93bkRhdGFbb3RoZXIual0sdmNvbmZpZyxmYWxzZSxmYWxzZSk7XG5cdFx0fVxuXHR9XG4gIH0gZWxzZSBpZihjb25maWcuZHJpbGxPdXRzaWRlVXApe1xuXHRpZihwb3NEcmlsbERvd25CYWNrRGF0YT4wKSB7XG5cdFx0cG9zRHJpbGxEb3duQmFja0RhdGEtLTtcbi8vICAgICAgICAgIFx0Y3R4LmZpc3RQYXNzPXVuZGVmaW5lZDtcbi8vXHRcdGV2YWwoXCJ2YXIgbmV3Y2hhcnQ9bmV3IENoYXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxcXCJjYW52YXNfYmFyXFxcIikuZ2V0Q29udGV4dChcXFwiMmRcXFwiKSkuXCIrY3R4LnRwY2hhcnQrXCIoZHJpbGxEb3duQmFja0RhdGFbcG9zRHJpbGxEb3duQmFja0RhdGFdLGRyaWxsRG93bkJhY2tDb25maWdbcG9zRHJpbGxEb3duQmFja0RhdGFdKTtcIik7XG5cdFx0ZGVsZXRlSGlnaExpZ2h0KGN0eCxkcmlsbERvd25CYWNrRGF0YVtwb3NEcmlsbERvd25CYWNrRGF0YV0pO1xuXHRcdHVwZGF0ZUNoYXJ0KGN0eCxkcmlsbERvd25CYWNrRGF0YVtwb3NEcmlsbERvd25CYWNrRGF0YV0sZHJpbGxEb3duQmFja0NvbmZpZ1twb3NEcmlsbERvd25CYWNrRGF0YV0sZmFsc2UsZmFsc2UpO1xuXHR9XG4gIH1cbn1cbiIsIi8vXG4vLyBBZGRpdGlvbmFsIGZvcm1hdHMgZm9yIENoYXJ0TmV3LmpzXG4vL1xuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9GVkFOQ09QL0NoYXJ0TmV3LmpzL3dpa2kvOTAwXzAxMF9mb3JtYXQuanNcbi8vXG5mdW5jdGlvbiBmbXRDaGFydEpTUGVyc28oY29uZmlnLCB2YWx1ZSwgZm10KSB7XG5cdHZhciByZXR1cm5fdmFsdWUsIHNwbHRkdDsgXG5cdHN3aXRjaCAoZm10LnNwbGl0KC9bXFxzLF0rLylbMF0udG9VcHBlckNhc2UoKSkge1xuXHRcdGNhc2UgXCJGSVhFRERFQ0lNQUxcIjpcblx0XHRjYXNlIFwiREVDSU1BTFwiOlxuXHRcdFx0dmFyIHNwbHRkdCA9IE1hdGgucm91bmQoZm10LnNwbGl0KC9bXFxzLF0rLylbMV0pO1xuXHRcdFx0dmFyIHJvdW5kVmFsO1xuXHRcdFx0aWYgKHNwbHRkdCA8PSAwKSB7XG5cdFx0XHRcdHJvdW5kVmFsID0gLXNwbHRkdDtcblx0XHRcdFx0cmV0dXJuX3ZhbHVlID0gKyhNYXRoLnJvdW5kKHZhbHVlICsgXCJlK1wiICsgcm91bmRWYWwpICsgXCJlLVwiICsgcm91bmRWYWwpO1xuXHRcdFx0XHQvLyBGb3JjZSBudW1iZXIgb2YgZGVjaW1hbHM7XG5cdFx0XHRcdGlmKGZtdC5zcGxpdCgvW1xccyxdKy8pWzBdLnRvVXBwZXJDYXNlKCk9PVwiRklYRURERUNJTUFMXCIpIHJldHVybl92YWx1ZT1yZXR1cm5fdmFsdWUudG9GaXhlZChNYXRoLmFicyhzcGx0ZHQpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJvdW5kVmFsID0gc3BsdGR0O1xuXHRcdFx0XHR2YXIgZGl2dmFsID0gXCIxZStcIiArIHJvdW5kVmFsO1xuXHRcdFx0XHRyZXR1cm5fdmFsdWUgPSArKE1hdGgucm91bmQodmFsdWUgLyBkaXZ2YWwpKSAqIGRpdnZhbDtcblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcuZGVjaW1hbFNlcGFyYXRvciAhPSBcIi5cIiB8fCBjb25maWcudGhvdXNhbmRTZXBhcmF0b3IgIT0gXCJcIikge1xuXHRcdFx0XHRyZXR1cm5fdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoL1xcLi9nLCBjb25maWcuZGVjaW1hbFNlcGFyYXRvcik7XG5cdFx0XHRcdGlmIChjb25maWcudGhvdXNhbmRTZXBhcmF0b3IgIT0gXCJcIikge1xuXHRcdFx0XHRcdHZhciBwYXJ0MSA9IHJldHVybl92YWx1ZTtcblx0XHRcdFx0XHR2YXIgcGFydDIgPSBcIlwiO1xuXHRcdFx0XHRcdHZhciBwb3NkZWMgPSBwYXJ0MS5pbmRleE9mKGNvbmZpZy5kZWNpbWFsU2VwYXJhdG9yKTtcblx0XHRcdFx0XHRpZiAocG9zZGVjID49IDApIHtcblx0XHRcdFx0XHRcdHBhcnQyID0gcGFydDEuc3Vic3RyaW5nKHBvc2RlYyArIDEsIHBhcnQxLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRwYXJ0MiA9IHBhcnQyLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7IC8vIHJldmVyc2Ugc3RyaW5nXG5cdFx0XHRcdFx0XHRwYXJ0MSA9IHBhcnQxLnN1YnN0cmluZygwLCBwb3NkZWMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJ0MSA9IHBhcnQxLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgY29uZmlnLnRob3VzYW5kU2VwYXJhdG9yKTtcblx0XHRcdFx0XHRwYXJ0MiA9IHBhcnQyLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7IC8vIHJldmVyc2Ugc3RyaW5nXG5cdFx0XHRcdFx0cmV0dXJuX3ZhbHVlID0gcGFydDFcblx0XHRcdFx0XHRpZiAocGFydDIgIT0gXCJcIikgcmV0dXJuX3ZhbHVlID0gcmV0dXJuX3ZhbHVlICsgY29uZmlnLmRlY2ltYWxTZXBhcmF0b3IgKyBwYXJ0Mjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcIkFCQlJFVklBVEVOVU1CRVJcIjpcblx0XHRcdHJldHVybl92YWx1ZSA9IHZhbHVlO1xuXHRcdFx0aWYgKHR5cGVvZih2YWx1ZSkgPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRyZXR1cm5fdmFsdWUgPSBhYmJyZXZpYXRlTnVtYmVyKHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJEQVRFXCI6XG5cdFx0XHRzcGx0ZHQgPSBmbXQucmVwbGFjZSgvLC9nLCBcIiBcIikucmVwbGFjZSgvOi9nLCBcIiBcIikuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRcdHZhciBvcHRpb25zID0gbmV3IEFycmF5KCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHNwbHRkdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzd2l0Y2ggKHNwbHRkdFtpXS50b1VwcGVyQ2FzZSgpKSB7XG5cdFx0XHRcdFx0Y2FzZSBcIldFRUtEQVlcIjpcblx0XHRcdFx0XHRjYXNlIFwiWUVBUlwiOlxuXHRcdFx0XHRcdGNhc2UgXCJNT05USFwiOlxuXHRcdFx0XHRcdGNhc2UgXCJEQVlcIjpcblx0XHRcdFx0XHRcdG9wdGlvbnNbc3BsdGR0W2ldXSA9IHNwbHRkdFtpICsgMV07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybl92YWx1ZSA9IHZhbHVlLnRvTG9jYWxlRGF0ZVN0cmluZyhmbXQuc3BsaXQoXCIgXCIpWzFdLCBvcHRpb25zKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJGTVREQVRFXCI6XG5cdFx0XHRzcGx0ZHQgPSBmbXQuc3BsaXQoL1tcXHMsXSsvKVsxXS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuX3ZhbHVlID0gc3BsdGR0LnJlcGxhY2VBcnJheShbXCJERFwiLCBcIk1NXCIsIFwiWVlZWVwiLCBcIllZXCJdLCBbdmFsdWUuZ2V0RGF0ZSgpLCAxICsgdmFsdWUuZ2V0TW9udGgoKSwgdmFsdWUuZ2V0RnVsbFllYXIoKSwgdmFsdWUuZ2V0WWVhcigpICUgMTAwXSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwiVElNRVwiOlxuXHRcdFx0cmV0dXJuX3ZhbHVlID0gdmFsdWUudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwiRk1UVElNRVwiOlxuXHRcdFx0c3BsdGR0ID0gZm10LnNwbGl0KC9bXFxzLF0rLylbMV0udG9VcHBlckNhc2UoKTtcblx0XHRcdHJldHVybl92YWx1ZSA9IHNwbHRkdC5yZXBsYWNlQXJyYXkoW1wiSEhcIiwgXCJNTVwiLCBcIlNTXCJdLCBbXG5cdFx0XHRcdHZhbHVlLmdldEhvdXJzKCkgPCAxMCA/ICcwJyArIHZhbHVlLmdldEhvdXJzKCkgOiB2YWx1ZS5nZXRIb3VycygpLFxuXHRcdFx0XHR2YWx1ZS5nZXRNaW51dGVzKCkgPCAxMCA/ICcwJyArIHZhbHVlLmdldE1pbnV0ZXMoKSA6IHZhbHVlLmdldE1pbnV0ZXMoKSxcblx0XHRcdFx0dmFsdWUuZ2V0U2Vjb25kcygpIDwgMTAgPyAnMCcgKyB2YWx1ZS5nZXRTZWNvbmRzKCkgOiB2YWx1ZS5nZXRTZWNvbmRzKClcblx0XHRcdF0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcIkZNVERBVEVUSU1FXCI6XG5cdFx0XHRzcGx0ZHQgPSBmbXQuc3BsaXRMaW1pdCgvW1xccyxdKy8sIDIpWzFdO1xuXHRcdFx0cmV0dXJuX3ZhbHVlID0gc3BsdGR0LnJlcGxhY2VBcnJheShbXCJERFwiLCBcIk1NXCIsIFwiWVlZWVwiLCBcIllZXCIsIFwiSEhcIiwgXCJtbVwiLCBcInNzXCJdLCBbXG5cdFx0XHRcdHZhbHVlLmdldERhdGUoKSwgMSArIHZhbHVlLmdldE1vbnRoKCksIHZhbHVlLmdldEZ1bGxZZWFyKCksIHZhbHVlLmdldFllYXIoKSAlIDEwMCxcblx0XHRcdFx0dmFsdWUuZ2V0SG91cnMoKSA8IDEwID8gJzAnICsgdmFsdWUuZ2V0SG91cnMoKSA6IHZhbHVlLmdldEhvdXJzKCksXG5cdFx0XHRcdHZhbHVlLmdldE1pbnV0ZXMoKSA8IDEwID8gJzAnICsgdmFsdWUuZ2V0TWludXRlcygpIDogdmFsdWUuZ2V0TWludXRlcygpLFxuXHRcdFx0XHR2YWx1ZS5nZXRTZWNvbmRzKCkgPCAxMCA/ICcwJyArIHZhbHVlLmdldFNlY29uZHMoKSA6IHZhbHVlLmdldFNlY29uZHMoKVxuXHRcdFx0XSk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuX3ZhbHVlID0gdmFsdWU7XG5cdFx0XHRicmVhaztcblx0fVxuXHRyZXR1cm4gKHJldHVybl92YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGFiYnJldmlhdGVOdW1iZXIobnVtKSB7XG5cdHZhciBzdWZmaXhlcyA9IFtcIlwiLCBcImtcIiwgXCJtXCIsIFwiYlwiLFwidFwiXTtcblx0dmFyIHNpZ24gPSBudW0gPiAwID8gMSA6IC0xO1xuXHRpZiAobnVtIDwgMTAwMCAmJiBudW0gPiAtMTAwMCApIHJldHVybiBudW07XG5cdHZhciBpID0gcGFyc2VJbnQoTWF0aC5mbG9vcihNYXRoLmxvZyhNYXRoLmFicyhudW0pKSAvIE1hdGgubG9nKDEwMDApKSk7XG5cdHJldHVybiAoKGkgJSAxID09IDAgKSA/IChudW0gLyBNYXRoLnBvdygxMDAwLCBpKSkgOiAobnVtIC8gTWF0aC5wb3coMTAwMCwgaSkpLnRvRml4ZWQoMSkpICsgJycgKyBzdWZmaXhlc1tpXTtcbn07XG5cblN0cmluZy5wcm90b3R5cGUucmVwbGFjZUFycmF5ID0gZnVuY3Rpb24oZmluZCwgcmVwbGFjZSkge1xuXHR2YXIgcmVwbGFjZVN0cmluZyA9IHRoaXM7XG5cdHZhciByZWdleDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmaW5kLmxlbmd0aDsgaSsrKSB7XG5cdFx0cmVnZXggPSBuZXcgUmVnRXhwKGZpbmRbaV0sIFwiZ1wiKTtcblx0XHRyZXBsYWNlU3RyaW5nID0gcmVwbGFjZVN0cmluZy5yZXBsYWNlKHJlZ2V4LCByZXBsYWNlW2ldKTtcblx0fVxuXHRyZXR1cm4gcmVwbGFjZVN0cmluZztcbn07XG4vKipcbiAqIHNwbGl0IGEgc3RyaW5nIGludG8gYW4gYXJyYXkgd2l0aCBsaW1pdCBlbnRyaWVzXG4gKiBUaGUgbGFzdCBlbnRyeSBjb250YWlucyB0aGUgbGFzdCBwYXJ0IG9mIHRoZSBzdHJpbmcsIHdoaWNoIGNhbiBjb250YWluIHRoZSBzZXBhcmF0b3IpXG4gKiBAcGFyYW0gc2VwYXJhdG9yIHtzdHJpbmd9IHN0cmluZyBzZXBhcmF0b3JcbiAqIEBwYXJhbSBsaW1pdCB7aW50ZWdlcn0gbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGFycmF5XG4gKiBAcmV0dXJuIGFycmF5IG9mIHNlcGFyYXRlZCBzdHJpbmdzXG4gKi9cblN0cmluZy5wcm90b3R5cGUuc3BsaXRMaW1pdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpIHtcblx0dmFyIHNwbGl0U3RyaW5nID0gdGhpcztcblx0dmFyIHJlc3VsdCA9IFtdO1xuXHR2YXIgcG9zID0gc3BsaXRTdHJpbmcuc2VhcmNoKHNlcGFyYXRvcik7XG5cdGlmIChwb3MgPCAwKSByZXR1cm4gZmFsc2U7XG5cdHJlc3VsdC5wdXNoKHNwbGl0U3RyaW5nLnN1YnN0cmluZygwLCBwb3MpKTtcblx0cmVzdWx0LnB1c2goc3BsaXRTdHJpbmcuc3Vic3RyaW5nKHBvcyArIDEpKTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cbiIsIi8vXG4vLyBTZWUgLi4vU2FtcGxlcy9pc3N1ZV8xMDIuaHRtbFxuLy9cbi8vIE1vZHVsZSBpbnRpYWxseSB3cml0dGVuIGJ5IE9sZSBLcm9nZXJcbi8vIENoYW5nZSAxIDogT21hciBTZWRraSAtIHBvc3NpYmlsaXR5IHRvIHNwZWNpZnkgYSBwZXJjZW50YWdlIFxuLy8gQ2hhbmdlIDIgOiBWYW5jb3BwZW5vbGxlIEZyYW7Dp29pcyAtIGdlbmVyYWxpemVkIGZvciBhbGwgZ3JhcGggdHlwZXNcbi8vXG5cblxuZnVuY3Rpb24gZ3JhZGllbnRDb2xvcihhcmVhLGN0eCxkYXRhLHN0YXREYXRhLHBvc2kscG9zaixvdGhlcnZhcnMpIHtcblx0Ly8gdjAgPSBsZWZ0IHhBeGlzIG9mIHJlY3RhbmdsZSBvciB4QXhpcyBvZiBjZW50ZXJcblx0Ly8gdjEgPSB0b3AgeUF4aXMgb2YgcmVjdGFuZ2xlIG9yIHlBeGlzIG9mIGNlbnRlclxuXHQvLyB2MiA9IHJpZ2h0IHhBeGlzIG9mIHJlY3RhbmdsZSBvciBpbnRlcm5hbCByYWRpdXMgKD0wIGZvciBQb2xhckFyZWEsIFBpZSBhbmQgUmFkYXIpXG5cdC8vIHYzID0gYm90dG9tIHlBeGlzIG9yIHJlY3RhbmdsZSBvciBleHRlcm5hbCByYWRpdXNcblx0dmFyIGdyZCwgZ3JhZGllbnRDb2xvcnM7XG5cdGlmIChhcmVhPT1cIlNIQVBFU0lOQ0hBUlRfUkVDVFwiKSB7XG5cdFx0Z3JkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KG90aGVydmFycy54UG9zTGVmdCwgb3RoZXJ2YXJzLnlQb3NCb3R0b20sIG90aGVydmFycy54UG9zTGVmdCwgb3RoZXJ2YXJzLnlQb3NUb3ApO1xuXHRcdGdyYWRpZW50Q29sb3JzID0gb3RoZXJ2YXJzLmdyYWRpZW50Q29sb3JzO1xuXHR9ZWxzZSBpZiAoYXJlYT09XCJTSEFQRVNJTkNIQVJUX0VMTElQU0VcIiB8fCBhcmVhPT1cIlNIQVBFU0lOQ0hBUlRfUkVHVUxBUlNIQVBFXCIgfHwgYXJlYT09XCJTSEFQRVNJTkNIQVJUX0NJUkNMRVwiKSB7XG5cdFx0Z3JkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KG90aGVydmFycy5taWRQb3NYLCBvdGhlcnZhcnMubWlkUG9zWSwgMCwgb3RoZXJ2YXJzLm1pZFBvc1gsIG90aGVydmFycy5taWRQb3NZICwgb3RoZXJ2YXJzLnJhZGl1cyk7XG5cdFx0Z3JhZGllbnRDb2xvcnMgPSBvdGhlcnZhcnMuZ3JhZGllbnRDb2xvcnM7XG5cdH1cblx0ZWxzZSB7XG5cdFx0c3dpdGNoKGN0eC50cGNoYXJ0KSB7XG5cdFx0XHRjYXNlIFwiUmFkYXJcIiA6XG5cdFx0XHRcdGlmIChhcmVhID09IFwiQ09MT1JcIikge1xuXHRcdFx0XHRcdGdyZCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChvdGhlcnZhcnMubWlkUG9zWCwgb3RoZXJ2YXJzLm1pZFBvc1ksIDAsIG90aGVydmFycy5taWRQb3NYLCBvdGhlcnZhcnMubWlkUG9zWSAsIG90aGVydmFycy5leHRfcmFkaXVzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRncmQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQob3RoZXJ2YXJzLnhQb3NMZWZ0ICsgKG90aGVydmFycy54UG9zUmlnaHQgLSBvdGhlcnZhcnMueFBvc0xlZnQpIC8gMiwgb3RoZXJ2YXJzLnlQb3NCb3R0b20gKyAob3RoZXJ2YXJzLnlQb3NUb3AgLSBvdGhlcnZhcnMueVBvc0JvdHRvbSkgLyAyLCAwLCBvdGhlcnZhcnMueFBvc0xlZnQgKyAob3RoZXJ2YXJzLnhQb3NSaWdodCAtIG90aGVydmFycy54UG9zTGVmdCkgLyAyLCBvdGhlcnZhcnMueVBvc0JvdHRvbSArIChvdGhlcnZhcnMueVBvc1RvcCAtIG90aGVydmFycy55UG9zQm90dG9tKSAvIDIsIE1hdGgubWF4KChvdGhlcnZhcnMueFBvc1JpZ2h0IC0gb3RoZXJ2YXJzLnhQb3NMZWZ0KSAvIDIsIChvdGhlcnZhcnMueVBvc1RvcCAtIG90aGVydmFycy55UG9zQm90dG9tKSAvIDIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRncmFkaWVudENvbG9ycyA9IGRhdGEuZGF0YXNldHNbcG9zaV0uZ3JhZGllbnRDb2xvcnM7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcIlBvbGFyQXJlYVwiIDpcblx0XHRcdGNhc2UgXCJQaWVcIiA6IFxuXHRcdFx0Y2FzZSBcIkRvdWdobnV0XCIgOlxuXHRcdFx0XHRpZiAoYXJlYSA9PSBcIkNPTE9SXCIpIHtcblx0XHRcdFx0XHRncmQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoc3RhdERhdGFbMF0ubWlkUG9zWCwgc3RhdERhdGFbMF0ubWlkUG9zWSwgb3RoZXJ2YXJzLnNjYWxlQW5pbWF0aW9uKnN0YXREYXRhWzBdLmludF9yYWRpdXMsIHN0YXREYXRhWzBdLm1pZFBvc1gsIHN0YXREYXRhWzBdLm1pZFBvc1kgLCBvdGhlcnZhcnMuc2NhbGVBbmltYXRpb24qIHN0YXREYXRhWzBdLnJhZGl1c09mZnNldCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Z3JkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KG90aGVydmFycy54UG9zTGVmdCArIChvdGhlcnZhcnMueFBvc1JpZ2h0IC0gb3RoZXJ2YXJzLnhQb3NMZWZ0KSAvIDIsIG90aGVydmFycy55UG9zQm90dG9tICsgKG90aGVydmFycy55UG9zVG9wIC0gb3RoZXJ2YXJzLnlQb3NCb3R0b20pIC8gMiwgMCwgb3RoZXJ2YXJzLnhQb3NMZWZ0ICsgKG90aGVydmFycy54UG9zUmlnaHQgLSBvdGhlcnZhcnMueFBvc0xlZnQpIC8gMiwgb3RoZXJ2YXJzLnlQb3NCb3R0b20gKyAob3RoZXJ2YXJzLnlQb3NUb3AgLSBvdGhlcnZhcnMueVBvc0JvdHRvbSkgLyAyLCBNYXRoLm1heCgob3RoZXJ2YXJzLnhQb3NSaWdodCAtIG90aGVydmFycy54UG9zTGVmdCkgLyAyLCAob3RoZXJ2YXJzLnlQb3NUb3AgLSBvdGhlcnZhcnMueVBvc0JvdHRvbSkgLyAyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Z3JhZGllbnRDb2xvcnMgPSBkYXRhW3Bvc2ldLmdyYWRpZW50Q29sb3JzO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJMaW5lXCIgOlxuXHRcdFx0Y2FzZSBcIkJhclwiIDpcblx0XHRcdGNhc2UgXCJTdGFja2VkQmFyXCIgOlxuXHRcdFx0XHRncmQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQob3RoZXJ2YXJzLnhQb3NMZWZ0LCBvdGhlcnZhcnMueVBvc0JvdHRvbSwgb3RoZXJ2YXJzLnhQb3NMZWZ0LCBvdGhlcnZhcnMueVBvc1RvcCk7XG5cdFx0XHRcdGdyYWRpZW50Q29sb3JzID0gZGF0YS5kYXRhc2V0c1twb3NpXS5ncmFkaWVudENvbG9ycztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiSG9yaXpvbnRhbEJhclwiIDpcblx0XHRcdGNhc2UgXCJIb3Jpem9udGFsU3RhY2tlZEJhclwiIDpcblx0XHRcdFx0Z3JkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KG90aGVydmFycy54UG9zTGVmdCwgb3RoZXJ2YXJzLnlQb3NCb3R0b20sIG90aGVydmFycy54UG9zUmlnaHQsIG90aGVydmFycy55UG9zQm90dG9tKTtcblx0XHRcdFx0Z3JhZGllbnRDb2xvcnMgPSBkYXRhLmRhdGFzZXRzW3Bvc2ldLmdyYWRpZW50Q29sb3JzO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQgOiBcblx0XHRcdFx0YnJlYWs7XG5cdFx0XG5cdFx0fVxuXHR9XG5cdHZhciBzdGVwcyA9IGdyYWRpZW50Q29sb3JzLmxlbmd0aDtcblx0dmFyIGN1cnJlbnRTdGVwVmFsdWUgPSAwO1xuXHR2YXIgc3RlcFZhbHVlcyA9IFtdO1xuXHR2YXIgUEVSQ0VOVF9SRUdFWCA9IC8oXFxkezEsMn18MTAwKSVcXHMqPyQvZ1xuXHRmb3IgKHZhciBpdGVyID0gMDsgaXRlciA8IHN0ZXBzOyBpdGVyKyspIHtcblx0XHR2YXIgdXNlclN0ZXBWYWx1ZSA9IGdyYWRpZW50Q29sb3JzW2l0ZXJdLm1hdGNoKFBFUkNFTlRfUkVHRVgpO1xuXHRcdGlmICghdXNlclN0ZXBWYWx1ZSkge1xuXHRcdFx0c3RlcFZhbHVlc1tpdGVyXSA9IGZhbHNlO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdHVzZXJTdGVwVmFsdWUgPSBwYXJzZUZsb2F0KHVzZXJTdGVwVmFsdWUpIC8gMTAwLjA7XG5cdFx0c3RlcFZhbHVlc1tpdGVyXSA9IHVzZXJTdGVwVmFsdWU7XG5cdH1cblx0Zm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPCBzdGVwczsgaXRlcisrKSB7XG5cdFx0aWYgKHN0ZXBWYWx1ZXNbaXRlcl0gPT09IGZhbHNlKSB7XG5cdFx0XHRpZiAoaXRlciA9PSAwKSB7XG5cdFx0XHRcdHN0ZXBWYWx1ZXNbaXRlcl0gPSAwO1xuXHRcdFx0fSBlbHNlIGlmIChpdGVyID09IHN0ZXBzIC0gMSkge1xuXHRcdFx0XHRzdGVwVmFsdWVzW2l0ZXJdID0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGZvdW5kIG5leHQgc3RlcFZhbHVlIHdoaWNoIGlzbid0IGZhbHNlXG5cdFx0XHRcdHZhciBzID0gaXRlciArIDE7XG5cdFx0XHRcdHdoaWxlIChzIDwgc3RlcHMgLSAxICYmIHN0ZXBWYWx1ZXNbc10gPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0cysrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBsYXN0U3RlcCA9ICgoaXRlciA9PSAwKSA/IDAgOiBzdGVwVmFsdWVzW2l0ZXIgLSAxXSk7XG5cdFx0XHRcdHN0ZXBWYWx1ZXNbaXRlcl0gPSAoKHMgPj0gc3RlcHMgLSAxKSA/IDEgOiBzdGVwVmFsdWVzW3MgKyAxXSkgLSBsYXN0U3RlcDtcblx0XHRcdFx0c3RlcFZhbHVlc1tpdGVyXSA9IGxhc3RTdGVwICsgc3RlcFZhbHVlc1tpdGVyXSAvIChzIC0gaXRlciArIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRHcmFkaWVudGNvbG9yc1dpdGhvdXRTdGVwID0gZ3JhZGllbnRDb2xvcnNbaXRlcl0ucmVwbGFjZShQRVJDRU5UX1JFR0VYLCBcIlwiKS50cmltKCk7XG5cdFx0Z3JkLmFkZENvbG9yU3RvcChzdGVwVmFsdWVzW2l0ZXJdLCBHcmFkaWVudGNvbG9yc1dpdGhvdXRTdGVwKTtcblx0fVxuXHRyZXR1cm4gZ3JkO1xufVxuIiwiLy8gSmF2YVNjcmlwdCBEb2N1bWVudFxuXG5mdW5jdGlvbiBhZGRIYXRjaChkYXRhLHBhcmFtKSB7XG5cblx0Ly8gY2hlY2sgY29uZGl0aW9ucztcblx0XG5cdGlmKGRhdGEuZGF0YXNldHMubGVuZ3RoICE9MikgcmV0dXJuO1xuXHQvLyBmaW5kIHhCZWdpbiBhbmQgeEVuZCB2YWx1ZXM7XG5cdGlmKHR5cGVvZiBkYXRhLnhCZWdpbiA9PSBcInVuZGVmaW5lZFwiKSBkYXRhLnhCZWdpbj0xICogZGF0YS5sYWJlbHNbMF07XG5cdGlmKHR5cGVvZiBkYXRhLnhFbmQgPT0gXCJ1bmRlZmluZWRcIikgZGF0YS54RW5kPTEgKiBkYXRhLmxhYmVsc1tkYXRhLmxhYmVscy5sZW5ndGggLSAxXTtcblx0aWYodHlwZW9mIGRhdGEueEJlZ2luICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oZGF0YS54QmVnaW4pKWRhdGEueEJlZ2luPTA7XG5cdGlmIChkYXRhLnhFbmQgPD0gZGF0YS54QmVnaW4gfHwgaXNOYU4oZGF0YS54RW5kKSkgZGF0YS54RW5kID0gZGF0YS54QmVnaW4gKyAxMDA7XG5cdHZhciBtb3VzZURldGVjdGlvbjtcblx0aWYgKHR5cGVvZiBwYXJhbS5tb3VzZURldGVjdGlvbiAhPSBcInVuZGVmaW5lZFwiICl7XG5cdFx0bW91c2VEZXRlY3Rpb249cGFyYW0ubW91c2VEZXRlY3Rpb247XG5cdH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtLmFubm90YXRlRGlzcGxheSAhPSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0bW91c2VEZXRlY3Rpb249cGFyYW0uYW5ub3RhdGVEaXNwbGF5O1xuXHR9IGVsc2UgbW91c2VEZXRlY3Rpb249ZmFsc2U7XG5cdFxuXG5cblx0bmJfaGF0Y2hfbGluZXM9ICh0eXBlb2YgcGFyYW0ubmJfaGF0Y2hfbGluZXMgIT0gXCJ1bmRlZmluZWRcIiA/IHBhcmFtLm5iX2hhdGNoX2xpbmVzIDogMTAwKVxuXHRkYXRhLmRhdGFzZXRzWzJdID17XG4gICAgICBcdFx0XHRkYXRhIDogW10sXG4gICAgICBcdFx0XHR4UG9zIDogW10sXG5cdFx0XHRvcmlnaW4gOiBbXSxcbiAgICAgIFx0XHRcdGxpbmtUeXBlIDogMSxcbiAgICAgIFx0XHRcdG1vdXNlRGV0ZWN0aW9uIDogbW91c2VEZXRlY3Rpb24sXG4gICAgICBcdFx0XHRhbmltYXRpb24gOiAodHlwZW9mIHBhcmFtLmFuaW1hdGlvbiAhPSBcInVuZGVmaW5lZFwiID8gcGFyYW0uYW5pbWF0aW9uIDogdHJ1ZSksXG4gICAgICBcdFx0XHRpbkdyYXBoRGF0YVNob3c6ICh0eXBlb2YgcGFyYW0ucG9zaXRpdmVfaW5HcmFwaERhdGFTaG93ICE9IFwidW5kZWZpbmVkXCIgPyBwYXJhbS5wb3NpdGl2ZV9pbkdyYXBoRGF0YVNob3cgOiBmYWxzZSksXG4gICAgICBcdFx0XHRhbm5vdGF0ZURpc3BsYXkgOiAodHlwZW9mIHBhcmFtLnBvc2l0aXZlX2Fubm90YXRlRGlzcGxheSAhPSBcInVuZGVmaW5lZFwiID8gcGFyYW0ucG9zaXRpdmVfYW5ub3RhdGVEaXNwbGF5IDogZmFsc2UpLFxuICAgICAgXHRcdFx0dGl0bGUgOiAodHlwZW9mIHBhcmFtLnBvc2l0aXZlX3RpdGxlICE9IFwidW5kZWZpbmVkXCIgPyBwYXJhbS5wb3NpdGl2ZV90aXRsZSA6IFwiXCIpLFxuXHRcdFx0c3Ryb2tlQ29sb3IgOiAodHlwZW9mIHBhcmFtLnBvc2l0aXZlX3N0cm9rZUNvbG9yICE9IFwidW5kZWZpbmVkXCIgPyBwYXJhbS5wb3NpdGl2ZV9zdHJva2VDb2xvciA6IFwicmVkXCIpLFxuXHRcdFx0ZGF0YXNldFN0cm9rZVdpZHRoIDogKHR5cGVvZiBwYXJhbS5wb3NpdGl2ZV9kYXRhc2V0U3Ryb2tlV2lkdGggIT0gXCJ1bmRlZmluZWRcIiA/IHBhcmFtLnBvc2l0aXZlX2RhdGFzZXRTdHJva2VXaWR0aCA6IDIpLFxuXHRcdFx0ZGF0YXNldFN0cm9rZVN0eWxlIDogKHR5cGVvZiBwYXJhbS5wb3NpdGl2ZV9kYXRhc2V0U3Ryb2tlU3R5bGUgIT0gXCJ1bmRlZmluZWRcIiA/IHBhcmFtLnBvc2l0aXZlX2RhdGFzZXRTdHJva2VTdHlsZSA6IFwic29saWRcIiksXG5cdFx0XHRwb2ludENvbG9yIDogKHR5cGVvZiBwYXJhbS5wb3NpdGl2ZV9wb2ludENvbG9yICE9IFwidW5kZWZpbmVkXCIgPyBwYXJhbS5wb3NpdGl2ZV9wb2ludENvbG9yIDogXCJyZ2JhKDAsMCwwLDApXCIpLFxuICAgICAgICBcdFx0cG9pbnRTdHJva2VDb2xvciA6ICh0eXBlb2YgcGFyYW0ucG9zaXRpdmVfcG9pbnRTdHJva2VDb2xvciAhPSBcInVuZGVmaW5lZFwiID8gcGFyYW0ucG9zaXRpdmVfcG9pbnRTdHJva2VDb2xvciA6IFwicmdiYSgwLDAsMCwwKVwiKSAgICBcdFx0XHRcblx0fTtcblxuXHRkYXRhLmRhdGFzZXRzWzNdID17XG4gICAgICBcdFx0XHRkYXRhIDogW10sXG4gICAgICBcdFx0XHR4UG9zIDogW10sXG5cdFx0XHRvcmlnaW4gOiBbXSxcbiAgICAgIFx0XHRcdGxpbmtUeXBlIDogMSxcbiAgICAgIFx0XHRcdGhpZ2hMaWdodCA6IGZhbHNlLFxuICAgICAgXHRcdFx0bW91c2VEZXRlY3Rpb24gOiBtb3VzZURldGVjdGlvbixcbiAgICAgIFx0XHRcdGFuaW1hdGlvbiA6ICh0eXBlb2YgcGFyYW0uYW5pbWF0aW9uICE9IFwidW5kZWZpbmVkXCIgPyBwYXJhbS5hbmltYXRpb24gOiB0cnVlKSxcbiAgICAgIFx0XHRcdGluR3JhcGhEYXRhU2hvdzogKHR5cGVvZiBwYXJhbS5uZWdhdGl2ZV9pbkdyYXBoRGF0YVNob3cgIT0gXCJ1bmRlZmluZWRcIiA/IHBhcmFtLm5lZ2F0aXZlX2luR3JhcGhEYXRhU2hvdyA6IGZhbHNlKSxcbiAgICAgIFx0XHRcdGFubm90YXRlRGlzcGxheSA6ICh0eXBlb2YgcGFyYW0ubmVnYXRpdmVfYW5ub3RhdGVEaXNwbGF5ICE9IFwidW5kZWZpbmVkXCIgPyBwYXJhbS5uZWdhdGl2ZV9hbm5vdGF0ZURpc3BsYXkgOiBmYWxzZSksXG4gICAgICBcdFx0XHR0aXRsZSA6ICh0eXBlb2YgcGFyYW0ubmVnYXRpdmVfdGl0bGUgIT0gXCJ1bmRlZmluZWRcIiA/IHBhcmFtLm5lZ2F0aXZlX3RpdGxlIDogXCJcIiksXG5cdFx0XHRzdHJva2VDb2xvciA6ICh0eXBlb2YgcGFyYW0ubmVnYXRpdmVfc3Ryb2tlQ29sb3IgIT0gXCJ1bmRlZmluZWRcIiA/IHBhcmFtLm5lZ2F0aXZlX3N0cm9rZUNvbG9yIDogXCJibHVlXCIpLFxuXHRcdFx0ZGF0YXNldFN0cm9rZVdpZHRoIDogKHR5cGVvZiBwYXJhbS5uZWdhdGl2ZV9kYXRhc2V0U3Ryb2tlV2lkdGggIT0gXCJ1bmRlZmluZWRcIiA/IHBhcmFtLm5lZ2F0aXZlX2RhdGFzZXRTdHJva2VXaWR0aCA6IDIpLFxuXHRcdFx0ZGF0YXNldFN0cm9rZVN0eWxlIDogKHR5cGVvZiBwYXJhbS5uZWdhdGl2ZV9kYXRhc2V0U3Ryb2tlU3R5bGUgIT0gXCJ1bmRlZmluZWRcIiA/IHBhcmFtLm5lZ2F0aXZlX2RhdGFzZXRTdHJva2VTdHlsZSA6IFwic29saWRcIiksXG5cdFx0XHRwb2ludENvbG9yIDogKHR5cGVvZiBwYXJhbS5uZWdhdGl2ZV9wb2ludENvbG9yICE9IFwidW5kZWZpbmVkXCIgPyBwYXJhbS5uZWdhdGl2ZV9wb2ludENvbG9yIDogXCJyZ2JhKDAsMCwwLDApXCIpLFxuICAgICAgICBcdFx0cG9pbnRTdHJva2VDb2xvciA6ICh0eXBlb2YgcGFyYW0ubmVnYXRpdmVfcG9pbnRTdHJva2VDb2xvciAhPSBcInVuZGVmaW5lZFwiID8gcGFyYW0ubmVnYXRpdmVfcG9pbnRTdHJva2VDb2xvciA6IFwicmdiYSgwLDAsMCwwKVwiKSAgICBcdFx0XHRcblx0fTtcblx0XG5cdHZhciB2MSx2Mix2cG9zO1x0ICAgICAgICBcdFxuXHR2YXIgY250cD0wLGNudG49MDtcblx0Zm9yKHZhciBpPTA7aTxuYl9oYXRjaF9saW5lcztpKyspIHtcblx0XHR2cG9zPWRhdGEueEJlZ2luK2kqKGRhdGEueEVuZC1kYXRhLnhCZWdpbikvKG5iX2hhdGNoX2xpbmVzLTEpO1xuXHRcdHYxPXNldERhdGFWYWwodnBvcywwLGRhdGEpO1x0XHRcblx0XHR2Mj1zZXREYXRhVmFsKHZwb3MsMSxkYXRhKTtcdFx0XG5cdFx0XG5cdFx0aWYodjE+djIpIHtcblx0XHRcdGRhdGEuZGF0YXNldHNbMl0ueFBvc1tjbnRwXT12cG9zO1xuXHRcdFx0ZGF0YS5kYXRhc2V0c1syXS5vcmlnaW5bY250cF09djE7XHRcdFxuXHRcdFx0ZGF0YS5kYXRhc2V0c1syXS5kYXRhW2NudHBdPXYyO1xuXHRcdFx0Y250cCsrO1x0XHRcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YS5kYXRhc2V0c1szXS54UG9zW2NudG5dPXZwb3M7XG5cdFx0XHRkYXRhLmRhdGFzZXRzWzNdLm9yaWdpbltjbnRuXT12MTtcdFx0XG5cdFx0XHRkYXRhLmRhdGFzZXRzWzNdLmRhdGFbY250bl09djI7XHRcdFxuXHRcdFx0Y250bisrO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdHZhciB0bXBkYXRhPWRhdGEuZGF0YXNldHNbMF07XG5cdGRhdGEuZGF0YXNldHNbMF09ZGF0YS5kYXRhc2V0c1sxXTtcblx0ZGF0YS5kYXRhc2V0c1sxXT1kYXRhLmRhdGFzZXRzWzJdO1xuXHRkYXRhLmRhdGFzZXRzWzJdPWRhdGEuZGF0YXNldHNbM107XG5cdGRhdGEuZGF0YXNldHNbM109dG1wZGF0YTtcblx0dG1wZGF0YT1kYXRhLmRhdGFzZXRzWzBdO1xuXHRkYXRhLmRhdGFzZXRzWzBdPWRhdGEuZGF0YXNldHNbMV07XG5cdGRhdGEuZGF0YXNldHNbMV09ZGF0YS5kYXRhc2V0c1syXTtcblx0ZGF0YS5kYXRhc2V0c1syXT1kYXRhLmRhdGFzZXRzWzNdO1xuXHRkYXRhLmRhdGFzZXRzWzNdPXRtcGRhdGE7XG5cdFxuXHRpZihkYXRhLmRhdGFzZXRzWzFdLnhQb3MubGVuZ3RoPT0wKSB7XG5cdFx0ZGF0YS5kYXRhc2V0c1sxXT1kYXRhLmRhdGFzZXRzWzJdO1xuXHRcdGRhdGEuZGF0YXNldHNbMl09ZGF0YS5kYXRhc2V0c1szXTtcblx0XHRkYXRhLmRhdGFzZXRzLnBvcCgpO1xuXHR9XHRcblx0aWYoZGF0YS5kYXRhc2V0c1swXS54UG9zLmxlbmd0aD09MCkge1xuXHRcdGRhdGEuZGF0YXNldHNbMF09ZGF0YS5kYXRhc2V0c1sxXTtcblx0XHRkYXRhLmRhdGFzZXRzWzFdPWRhdGEuZGF0YXNldHNbMl07XG5cdFx0aWYoZGF0YS5kYXRhc2V0cy5sZW5ndGg9PTQpZGF0YS5kYXRhc2V0c1syXT1kYXRhLmRhdGFzZXRzWzNdO1xuXHRcdGRhdGEuZGF0YXNldHMucG9wKCk7XG5cdH1cdFxuXG5cblx0ZnVuY3Rpb24gc2V0RGF0YVZhbCh4cG9zLGksZGF0YSkge1xuXHRcdHZhciBwdDB4LCBwdDF4LCBwdDB5LCBwdDF5LHJ0dmFsO1xuXHRcdGlmKHhwb3M8ZGF0YS54QmVnaW4pIHJldHVybiBudWxsO1xuXHRcdGlmKHhwb3M+ZGF0YS54RW5kKSByZXR1cm4gbnVsbDtcblx0XHRpZihNYXRoLmFicyh4cG9zLWRhdGEueEJlZ2luKTwwLjAwMDEpcmV0dXJuIGRhdGEuZGF0YXNldHNbaV0uZGF0YVswXTtcblxuXHRcdGlmKHR5cGVvZiBkYXRhLmRhdGFzZXRzW2ldLnhQb3M9PVwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGlmKHhwb3M9PWRhdGEueEJlZ2luKXJldHVybiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbMF07XG5cdFx0XHR2YXIgY3VycG9zPSh4cG9zLWRhdGEueEJlZ2luKS8oKGRhdGEueEVuZC1kYXRhLnhCZWdpbikvKGRhdGEubGFiZWxzLmxlbmd0aC0xKSk7XG5cdFx0XHRpZihNYXRoLmFicyhjdXJwb3MtTWF0aC5yb3VuZChjdXJwb3MpKTwwLjAwMDEpIHJldHVybiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbTWF0aC5yb3VuZChjdXJwb3MpXTtcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRwdDB4PWRhdGEueEJlZ2luK01hdGguZmxvb3IoY3VycG9zKSooKGRhdGEueEVuZC1kYXRhLnhCZWdpbikvKGRhdGEubGFiZWxzLmxlbmd0aC0xKSk7XG5cdFx0XHRcdHB0MXg9ZGF0YS54QmVnaW4rTWF0aC5jZWlsKGN1cnBvcykqKChkYXRhLnhFbmQtZGF0YS54QmVnaW4pLyhkYXRhLmxhYmVscy5sZW5ndGgtMSkpO1xuXHRcdFx0XHRwdDB5PWRhdGEuZGF0YXNldHNbaV0uZGF0YVtNYXRoLmZsb29yKGN1cnBvcyldO1xuXHRcdFx0XHRwdDF5PWRhdGEuZGF0YXNldHNbaV0uZGF0YVtNYXRoLmNlaWwoY3VycG9zKV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHQgICAgICAgIHZhciBqPWRhdGEuZGF0YXNldHNbaV0ueFBvcy5sZW5ndGgtMTtcblx0XHRcdHdoaWxlKGo+PTAgJiYgdHlwZW9mIHB0MHg9PVwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0aWYodHlwZW9mICgxKmRhdGEuZGF0YXNldHNbaV0ueFBvc1tqXSk9PVwibnVtYmVyXCIgJiYgdHlwZW9mICgxKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSk9PVwibnVtYmVyXCIgJiYgdHlwZW9mIHB0MHggPT0gXCJ1bmRlZmluZWRcIikge1xuXG5cdFx0XHRcdFx0aWYoTWF0aC5hYnMoeHBvcy0xKmRhdGEuZGF0YXNldHNbaV0ueFBvc1tqXSk8MC4wMDAxKSByZXR1cm4gZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdO1xuXHRcdFx0XHRcdGlmKHhwb3M+PTEqZGF0YS5kYXRhc2V0c1tpXS54UG9zW2pdKSB7XG5cdFx0XHRcdFx0XHRwdDB4PTEqZGF0YS5kYXRhc2V0c1tpXS54UG9zW2pdO1xuXHRcdFx0XHRcdFx0cHQweT0xKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ai0tO1xuXHRcdFx0fVxuXHRcdFx0aWYodHlwZW9mIHB0MHggIT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRqKys7XG5cdFx0XHRcdHdoaWxlKGo8ZGF0YS5kYXRhc2V0c1tpXS54UG9zLmxlbmd0aCAmJiB0eXBlb2YgcHQxeD09XCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRcdGlmKHR5cGVvZiAoMSpkYXRhLmRhdGFzZXRzW2ldLnhQb3Nbal0pPT1cIm51bWJlclwiICYmIHR5cGVvZiAoMSpkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0pPT1cIm51bWJlclwiICYmIHR5cGVvZiBwdDF4ID09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0XHRcdGlmKHhwb3M8MSpkYXRhLmRhdGFzZXRzW2ldLnhQb3Nbal0pIHtcblx0XHRcdFx0XHRcdFx0cHQxeD0xKmRhdGEuZGF0YXNldHNbaV0ueFBvc1tqXTtcblx0XHRcdFx0XHRcdFx0cHQxeT0xKmRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aisrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XHRcdFx0XHRcdFx0XG5cdFx0fVxuXG5cdFx0aWYodHlwZW9mIHB0MHggIT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgcHQxeCAhPSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgYT0ocHQweS1wdDF5KS8ocHQweC1wdDF4KTtcblx0XHRcdHZhciBiPXB0MHktYSpwdDB4O1xuXHRcdFx0cnR2YWw9YSp4cG9zK2I7XG5cdFx0fVxuXHRcdHJldHVybiBydHZhbDtcblx0fVx0XG5cblx0XG5cblx0XG59O1xuIiwiLy8gSmF2YVNjcmlwdCBEb2N1bWVudFxuXG52YXIgZHJhd1NoYXBlX2RlZmF1bHQ9IHtcblx0cG9zaXRpb24gOiBcIklOQ0hBUlRcIixcblx0c2hhcGUgOiBcIkNJUkNMRVwiLFxuXHRyYWRpdXMgOiAxMCwgXG5cdGVsbGlwc2VIZWlnaHQgOiAyMCxcblx0ZWxsaXBzZVdpZHRoIDogNDAsXG5cdHNpZGVDb3VudCA6IDQsXG5cdGxpbmVDb3VudCA6IDMsXG5cdHgxOjAsXG5cdHgyOjAsXG5cdHgzOjAsXG5cdHg0OjAsXG5cdHg1OjAsXG5cdHg2OjAsXG5cdHg3OjAsXG5cdHg4OjAsXG5cdHg5OjAsXG5cdHgxMDowLFxuXHR5MTowLFxuXHR5MjowLFxuXHR5MzowLFxuXHR5NDowLFxuXHR5NTowLFxuXHR5NjowLFxuXHR5NzowLFxuXHR5ODowLFxuXHR5OTowLFxuXHR5MTA6MCxcblx0c3Ryb2tlU3R5bGU6IFwic29saWRcIixcblx0c3Ryb2tlU2l6ZToyLCBcblx0c3Ryb2tlQ29sb3IgOiBcImJsYWNrXCIsIFxuXHRmaWxsQ29sb3I6IFwiYmx1ZVwiLFxuXHRzdGFydEFuZ2xlIDogMCwgXG5cdGVuZEFuZ2xlIDogMzYwLCBcblx0bGltaXRUb0NoYXJ0IDogdHJ1ZSxcblx0cGFkZGluZ1gxOiAwLFxuXHRwYWRkaW5nWTE6IDAsXG5cdHBhZGRpbmdYMjogMCxcblx0cGFkZGluZ1kyOiAwLFxuXHRwYWRkaW5nWDM6IDAsXG5cdHBhZGRpbmdZMzogMCxcblx0cGFkZGluZ1g0OiAwLFxuXHRwYWRkaW5nWTQ6IDAsXG4gICAgICAgXHRwYWRkaW5nWDU6IDAsXG5cdHBhZGRpbmdZNTogMCxcblx0cGFkZGluZ1g2OiAwLFxuXHRwYWRkaW5nWTY6IDAsXG5cdHBhZGRpbmdYNzogMCxcblx0cGFkZGluZ1k3OiAwLFxuXHRwYWRkaW5nWDg6IDAsXG5cdHBhZGRpbmdZODogMCxcblx0cGFkZGluZ1g5OiAwLFxuXHRwYWRkaW5nWTk6IDAsXG5cdHBhZGRpbmdYMTA6IDAsXG5cdHBhZGRpbmdZMTA6IDAsXG5cblx0d2hlbiA6IFwiYWx3YXlzXCIsICAgIC8vIFwiaW5pdEZ1bmN0aW9uXCIsIFwiZW5kZGF0YWZ1bmN0aW9uXCIsIFwiZW5kc2NhbGVmdW5jdGlvblwiIG9yIFwiYWx3YXlzXCJcblx0aXRlciA6IFwiYWxsXCIsICAgICAgICAvLyBcImZpcnN0XCIsIFwibGFzdFwiLCBcImFsbFwiIG9yIGEgbnVtYmVyXG5cdGFuaW1hdGUgOiBmYWxzZSxcblx0YXJyb3dXaWR0aCA6IDE1LFxuXHRhcnJvd0hlaWdodCA6IDIwLFxuXHRhcnJvd1RvcCA6IHRydWUsXG5cdGFycm93Qm90dG9tIDogZmFsc2UsXG5cdHRleHQgOiBcIllvdXIgVGV4dFwiLFxuXHRyb3RhdGUgOiAwLFxuXHR0ZXh0QWxpZ24gOiBcImNlbnRlclwiLFxuXHR0ZXh0QmFzZWxpbmUgOiBcIm1pZGRsZVwiLFxuXHRpbWFnZXNyYyA6IFwiXCIsXG5cdGltYWdlQWxpZ24gOiBcImNlbnRlclwiLFxuXHRpbWFnZUJhc2VsaW5lIDogXCJtaWRkbGVcIixcblx0Zm9udENvbG9yIDogXCJyZ2JhKDIyMCwyMjAsMjIwLDEpXCIsIFxuXHRmb250U3R5bGUgOiBcIm5vcm1hbFwiLFxuXHRmb250U2l6ZSA6IDEyLFxuXHRmb250RmFtaWx5IDogXCInQXJpYWwnXCIsXG5cdHRleHRCb3JkZXJzIDogZmFsc2UsXG5cdHRleHRCb3JkZXJzQ29sb3IgOiBcImJsYWNrXCIsXG5cdHRleHRCb3JkZXJzV2lkdGggOiAxLFxuXHR0ZXh0Qm9yZGVyc1hTcGFjZSA6IDMsXG5cdHRleHRCb3JkZXJzWVNwYWNlIDogMyxcblx0dGV4dEJvcmRlcnNTdHlsZSA6IFwic29saWRcIixcblx0dGV4dEJhY2tncm91bmRDb2xvciA6IFwibm9uZVwiXG59O1xuXG5mdW5jdGlvbiBzaGFwZUxvYWRJbWFnZXMoZGF0YSkge1xuXHR2YXIgc2hhcGUsc2hhcGVzSW5DaGFydDtcblxuXG5cdGlmKHR5cGVvZiBkYXRhLnNoYXBlc0luQ2hhcnQgPT0gXCJvYmplY3RcIikgc2hhcGVzSW5DaGFydD1kYXRhLnNoYXBlc0luQ2hhcnQ7XG5cdGlmKHR5cGVvZiBkYXRhWzBdPT1cIm9iamVjdFwiKSBpZiAodHlwZW9mIGRhdGFbMF0uc2hhcGVzSW5DaGFydCA9PSBcIm9iamVjdFwiKSBzaGFwZXNJbkNoYXJ0PWRhdGFbMF0uc2hhcGVzSW5DaGFydDtcblx0XG5cdGlmKHR5cGVvZiBzaGFwZXNJbkNoYXJ0ID09IFwib2JqZWN0XCIpIHtcblx0XHQvLyAgICAgIHByZWxvYWQgYWxsIGltYWdlcyBmaXJzdDtcblx0XHRmb3IodmFyIGk9MDtpPHNoYXBlc0luQ2hhcnQubGVuZ3RoO2krKykge1xuXHRcdFx0aWYodHlwZW9mIHNoYXBlc0luQ2hhcnRbaV0uc2hhcGUgPT0gXCJzdHJpbmdcIilzaGFwZT1zaGFwZXNJbkNoYXJ0W2ldLnNoYXBlLnRvVXBwZXJDYXNlKClcblx0XHRcdGVsc2Ugc2hhcGU9IGRyYXdTaGFwZV9kZWZhdWx0LnNoYXBlLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRpZiAoc2hhcGU9PVwiSU1BR0VcIil7XG5cdFx0XHRcdGlmKHR5cGVvZiBzaGFwZXNJbkNoYXJ0W2ldLmxvYWRJbWFnZSA9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0c2hhcGVzSW5DaGFydFtpXS5sb2FkSW1hZ2U9bmV3IEltYWdlKCk7XG5cdFx0XHRcdFx0dmFyIGltYWdlc3JjID0gZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5pbWFnZXNyYyxkcmF3U2hhcGVfZGVmYXVsdC5pbWFnZXNyYyk7XG5cdFx0XHRcdFx0aWYgKGltYWdlc3JjPT1cIlwiKSBzaGFwZXNJbkNoYXJ0W2ldLmxvYWRJbWFnZS5zcmM9J2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEN3QUxBSUFBQUFBQTNwbi9aaUg1QkFFQUFBRUFMQUFBQUFBTEFBc0FBQUlVaEEraGtjdU80bG1OVmluZG83cXlySVhpR0JZQU93PT0nO1xuXHRcdFx0XHRcdGVsc2Ugc2hhcGVzSW5DaGFydFtpXS5sb2FkSW1hZ2Uuc3JjPWltYWdlc3JjO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XHRcblx0fVxuXHRmdW5jdGlvbiBkcmF3U2hhcGVTZXRWYWx1ZShkYXRhdmFsLGRlZnZhbCkge1xuXHRcdGlmKHR5cGVvZiBkYXRhdmFsICE9IFwidW5kZWZpbmVkXCIpIHJldHVybiBkYXRhdmFsO1xuXHRcdGVsc2UgcmV0dXJuIGRlZnZhbDtcblx0fTtcdFxuXG59XG5cblxuZnVuY3Rpb24gZHJhd1NoYXBlcyhhcmVhLCBjdHgsIGRhdGEsc3RhdERhdGEsIHBvc2kscG9zaixvdGhlcnZhcnMpe1xuXHR2YXIgc2hhcGUsd2hlbmRydyxpdGVyLHJlYWxBbmltYXRpb24sc2hhcGVzSW5DaGFydDtcblxuXHRpZih0eXBlb2YgZGF0YS5zaGFwZXNJbkNoYXJ0ID09IFwib2JqZWN0XCIpIHZhciBzaGFwZXNJbkNoYXJ0PWRhdGEuc2hhcGVzSW5DaGFydDtcblx0aWYodHlwZW9mIGRhdGFbMF09PVwib2JqZWN0XCIpIGlmICh0eXBlb2YgZGF0YVswXS5zaGFwZXNJbkNoYXJ0ID09IFwib2JqZWN0XCIpIHZhciBzaGFwZXNJbkNoYXJ0PWRhdGFbMF0uc2hhcGVzSW5DaGFydDtcblxuXHRcblx0aWYodHlwZW9mIHNoYXBlc0luQ2hhcnQgPT0gXCJvYmplY3RcIikge1xuXG5cdFx0Ly8gICAgICBwcmVsb2FkIGFsbCBpbWFnZXMgZmlyc3Q7XG5cdFx0c2hhcGVMb2FkSW1hZ2VzKGRhdGEpO1xuXHRcblx0XHRmb3IodmFyIGk9MDtpPHNoYXBlc0luQ2hhcnQubGVuZ3RoO2krKykge1xuXG5cdFx0XHRpZihhcmVhPT1cIkhJR0hMSUdIVFwiKSB7XG5cdFx0XHRcdGlmKHNoYXBlc0luQ2hhcnRbaV0uaGlnaHRMaWdodCAhPSB0cnVlKWNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIHtcdFx0XG5cdFx0XHRcdGlmKHR5cGVvZiBvdGhlcnZhcnMuY29uZmlnLmRpc3BTaGFwZXNJbkNoYXJ0ID09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRpZiAob3RoZXJ2YXJzLmNvbmZpZy5kaXNwU2hhcGVzSW5DaGFydC5pbmRleE9mKGkpPDApIGNvbnRpbnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvdGhlcnZhcnMuY29uZmlnLmRpc3BTaGFwZXNJbkNoYXJ0ICE9IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIG90aGVydmFycy5jb25maWcuZGlzcFNoYXBlc0luQ2hhcnQgPT0gZmFsc2UpY29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3aGVuZHJ3PWRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ud2hlbixkcmF3U2hhcGVfZGVmYXVsdC53aGVuKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHRpZiAod2hlbmRydyAhPSBcIkFMV0FZU1wiICYmIHdoZW5kcncgIT0gYXJlYSkgeyBjb250aW51ZTt9XG5cdFx0XHRcdGl0ZXI9ZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5pdGVyLGRyYXdTaGFwZV9kZWZhdWx0Lml0ZXIudG9VcHBlckNhc2UoKSk7XG5cdFx0XHRcdGlmICh0eXBlb2YgaXRlcj09XCJudW1iZXJcIiAmJiBpdGVyICE9IG90aGVydmFycy5jbnRpdGVyICYmIG90aGVydmFycy5jb25maWcuYW5pbWF0aW9uPT10cnVlKSB7Y29udGludWU7fVxuXHRcdFx0XHRpZiAoaXRlcj09PVwiZmlyc3RcIiAmJiBvdGhlcnZhcnMuY250aXRlciAhPSAxICYmIG90aGVydmFycy5jb25maWcuYW5pbWF0aW9uPT10cnVlKSB7Y29udGludWU7fVxuLy9cdFx0XHRcdGlmIChpdGVyPT09XCJsYXN0XCIgJiYgb3RoZXJ2YXJzLmNudGl0ZXIgIT0gb3RoZXJ2YXJzLmNvbmZpZy5hbmltYXRpb25TdGVwcyAmJiBvdGhlcnZhcnMuY29uZmlnLmFuaW1hdGlvbj09dHJ1ZSkge2NvbnRpbnVlO31cblx0XHRcdFx0aWYgKGl0ZXI9PT1cImxhc3RcIiAmJiBvdGhlcnZhcnMuYW5pbWF0aW9uVmFsdWUgPCAxICYmIG90aGVydmFycy5jb25maWcuYW5pbWF0aW9uPT10cnVlKSB7Y29udGludWU7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZih0eXBlb2Ygc2hhcGVzSW5DaGFydFtpXS5zaGFwZSA9PSBcImZ1bmN0aW9uXCIpc2hhcGU9IHNoYXBlc0luQ2hhcnRbaV0uc2hhcGU7XG5cdFx0XHRlbHNlIGlmKHR5cGVvZiBzaGFwZXNJbkNoYXJ0W2ldLnNoYXBlICE9IFwic3RyaW5nXCIpc2hhcGU9IGRyYXdTaGFwZV9kZWZhdWx0LnNoYXBlLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRlbHNlIHNoYXBlPXNoYXBlc0luQ2hhcnRbaV0uc2hhcGUudG9VcHBlckNhc2UoKTtcblxuXHRcdFx0aWYob3RoZXJ2YXJzLmNvbmZpZy5hbmltYXRpb24gJiYgZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5hbmltYXRlLGRyYXdTaGFwZV9kZWZhdWx0LmFuaW1hdGUpKSByZWFsQW5pbWF0aW9uPW90aGVydmFycy5hbmltYXRpb25WYWx1ZTtcblx0XHRcdGVsc2UgcmVhbEFuaW1hdGlvbj0xO1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdHN3aXRjaChzaGFwZSkge1xuXHRcdFx0XHRjYXNlIFwiTElORVwiIDpcblx0XHRcdFx0XHR2YXIgdnJpZ2h0LCB2bGVmdCwgdnRvcCwgdmJvdHRvbSwgdG1wO1xuXHRcdFx0XHRcdHZyaWdodD0gMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLngyLGRyYXdTaGFwZV9kZWZhdWx0LngyKTtcblx0XHRcdFx0XHR2bGVmdD0gMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLngxLGRyYXdTaGFwZV9kZWZhdWx0LngxKTtcblx0XHRcdFx0XHR2dG9wPSAxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueTIsZHJhd1NoYXBlX2RlZmF1bHQueTIpO1xuXHRcdFx0XHRcdHZib3R0b209IDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS55MSxkcmF3U2hhcGVfZGVmYXVsdC55MSk7XG5cdFx0XHRcdFx0aWYgKHZyaWdodDx2bGVmdCl7XG5cdFx0XHRcdFx0XHR0bXA9dnJpZ2h0O3ZyaWdodD12bGVmdDt2bGVmdD10bXA7XG5cdFx0XHRcdFx0XHR0bXA9dnRvcDt2dG9wPXZib3R0b207dmJvdHRvbT10bXA7XG5cdFx0XHRcdFx0fVxuICBcblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0dmFyIHh5cG9zMT1zZXRYWXBvcyhzaGFwZSxzaGFwZXNJbkNoYXJ0W2ldLFwiXCIsXCJcIixcIlwiLGN0eCxkYXRhLHN0YXREYXRhLG90aGVydmFycyx2cmlnaHQsdnRvcCwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1gxLGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdYMSksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdZMSxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWTEpLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ubGltaXRUb0NoYXJ0LGRyYXdTaGFwZV9kZWZhdWx0LmxpbWl0VG9DaGFydCkpO1xuXHRcdFx0XHRcdHZhciB4eXBvczI9c2V0WFlwb3Moc2hhcGUsc2hhcGVzSW5DaGFydFtpXSxcIlwiLFwiXCIsXCJcIixjdHgsZGF0YSxzdGF0RGF0YSxvdGhlcnZhcnMsdmxlZnQsdmJvdHRvbSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1gyLGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdYMiksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdZMixkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWTIpLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ubGltaXRUb0NoYXJ0LGRyYXdTaGFwZV9kZWZhdWx0LmxpbWl0VG9DaGFydCkpO1xuXHRcdFx0XHRcdGlmKE1hdGguYWJzKHh5cG9zMS54cG9zLXh5cG9zMi54cG9zKSA8IG90aGVydmFycy5jb25maWcuemVyb1ZhbHVlKSB7IC8vIHZlcnRpY2FsIGxpbmU7XG5cdFx0XHRcdFx0XHR2cmlnaHQ9eHlwb3MxLnhwb3M7XG5cdFx0XHRcdFx0XHR2bGVmdD14eXBvczIueHBvcztcblx0XHRcdFx0XHRcdHZib3R0b209eHlwb3MxLnlwb3MgKyAoMS1yZWFsQW5pbWF0aW9uKSooeHlwb3MyLnlwb3MteHlwb3MxLnlwb3MpLzI7XG5cdFx0XHRcdFx0XHR2dG9wPXh5cG9zMi55cG9zIC0gKDEtcmVhbEFuaW1hdGlvbikqKHh5cG9zMi55cG9zLXh5cG9zMS55cG9zKS8yIDtcblx0XHRcdFx0XHR9IGVsc2UgeyAvLyBub24gdmVydGljYWwgbGluZTtcblx0XHRcdFx0XHRcdC8vIGNvbXB1dGUgbGluZSBmdW5jdGlvbjtcblx0XHRcdFx0XHRcdHZhciBhPSh4eXBvczEueXBvcy14eXBvczIueXBvcykvKHh5cG9zMS54cG9zLXh5cG9zMi54cG9zKTtcblx0XHRcdFx0XHRcdHZhciBiPXh5cG9zMS55cG9zLWEqeHlwb3MxLnhwb3M7XG5cdFx0XHRcdFx0XHR2cmlnaHQ9eHlwb3MyLnhwb3MgLSAoMS1yZWFsQW5pbWF0aW9uKSooeHlwb3MyLnhwb3MteHlwb3MxLnhwb3MpLzI7XG5cdFx0XHRcdFx0XHR2bGVmdCA9eHlwb3MxLnhwb3MgKyAoMS1yZWFsQW5pbWF0aW9uKSooeHlwb3MyLnhwb3MteHlwb3MxLnhwb3MpLzI7XG5cdFx0XHRcdFx0XHR2dG9wPWEqdnJpZ2h0K2I7XG5cdFx0XHRcdFx0XHR2Ym90dG9tPWEqdmxlZnQrYjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh2cmlnaHQsIHZ0b3ApO1xuXHRcdFx0XHRcdGN0eC5saW5lVG8odmxlZnQsIHZib3R0b20pO1xuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc3Ryb2tlU2l6ZSxkcmF3U2hhcGVfZGVmYXVsdC5zdHJva2VTaXplKSk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zdHJva2VDb2xvcixkcmF3U2hhcGVfZGVmYXVsdC5zdHJva2VDb2xvcik7XG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc3Ryb2tlU3R5bGUsZHJhd1NoYXBlX2RlZmF1bHQuc3Ryb2tlU3R5bGUpKSk7XHRcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcIkFSUk9XXCIgOlxuXHRcdFx0XHRcdHZhciB2cmlnaHQsIHZsZWZ0LCB2dG9wLCB2Ym90dG9tLCB0bXA7XG5cdFx0XHRcdFx0dmFyIGFycm93dHgxLGFycm93dHgyLGFycm93dHkxLGFycm93dHkyO1xuXHRcdFx0XHRcdHZhciBhcnJvd2J4MSxhcnJvd2J4MixhcnJvd2J5MSxhcnJvd2J5Mjtcblx0XHRcdFx0XHR2cmlnaHQ9IDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS54MSxkcmF3U2hhcGVfZGVmYXVsdC54MSk7XG5cdFx0XHRcdFx0dmxlZnQ9IDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS54MixkcmF3U2hhcGVfZGVmYXVsdC54Mik7XG5cdFx0XHRcdFx0dnRvcD0gMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnkxLGRyYXdTaGFwZV9kZWZhdWx0LnkxKTtcblx0XHRcdFx0XHR2Ym90dG9tPSAxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueTIsZHJhd1NoYXBlX2RlZmF1bHQueTIpO1xuXG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdHZhciB4eXBvczE9c2V0WFlwb3Moc2hhcGUsc2hhcGVzSW5DaGFydFtpXSxcIlwiLFwiXCIsXCJcIixjdHgsZGF0YSxzdGF0RGF0YSxvdGhlcnZhcnMsdnJpZ2h0LHZ0b3AsMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdYMSxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWDEpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWTEsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1kxKSxkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmxpbWl0VG9DaGFydCxkcmF3U2hhcGVfZGVmYXVsdC5saW1pdFRvQ2hhcnQpKTtcblx0XHRcdFx0XHR2YXIgeHlwb3MyPXNldFhZcG9zKHNoYXBlLHNoYXBlc0luQ2hhcnRbaV0sXCJcIixcIlwiLFwiXCIsY3R4LGRhdGEsc3RhdERhdGEsb3RoZXJ2YXJzLHZsZWZ0LHZib3R0b20sMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdYMixkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWDIpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWTIsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1kyKSxkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmxpbWl0VG9DaGFydCxkcmF3U2hhcGVfZGVmYXVsdC5saW1pdFRvQ2hhcnQpKTtcblx0XHRcdFx0XHR2YXIgYXJyb3dXaWR0aD1yZWFsQW5pbWF0aW9uKjEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5hcnJvd1dpZHRoLGRyYXdTaGFwZV9kZWZhdWx0LmFycm93V2lkdGgpIDtcblx0XHRcdFx0XHR2YXIgYXJyb3dIZWlnaHQ9cmVhbEFuaW1hdGlvbioxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uYXJyb3dIZWlnaHQsZHJhd1NoYXBlX2RlZmF1bHQuYXJyb3dIZWlnaHQpO1xuXG5cdFx0XHRcdFx0aWYoTWF0aC5hYnMoeHlwb3MxLnhwb3MteHlwb3MyLnhwb3MpIDwgb3RoZXJ2YXJzLmNvbmZpZy56ZXJvVmFsdWUpIHsgLy8gdmVydGljYWwgbGluZTtcblx0XHRcdFx0XHRcdHZyaWdodD14eXBvczEueHBvcztcblx0XHRcdFx0XHRcdHZsZWZ0PXh5cG9zMi54cG9zO1xuXHRcdFx0XHRcdFx0dmJvdHRvbT14eXBvczEueXBvcyA7XG5cdFx0XHRcdFx0XHR2dG9wPXh5cG9zMi55cG9zIC0gKDEtcmVhbEFuaW1hdGlvbikqKHh5cG9zMi55cG9zLXh5cG9zMS55cG9zKTtcblx0XHRcdFx0XHRcdGlmKHZib3R0b20+dnRvcClmYWN0PTE7ZWxzZSBmYWN0PS0xO1xuXHRcdFx0XHRcdFx0YXJyb3dieTE9dmJvdHRvbS1mYWN0KmFycm93SGVpZ2h0O1xuXHRcdFx0XHRcdFx0YXJyb3dieTI9YXJyb3dieTE7XG5cdFx0XHRcdFx0XHRhcnJvd3R5MT12dG9wK2ZhY3QqYXJyb3dIZWlnaHQ7XG5cdFx0XHRcdFx0XHRhcnJvd3R5Mj1hcnJvd3R5MTtcblx0XHRcdFx0XHRcdGFycm93YngxPXZyaWdodC1hcnJvd1dpZHRoLzI7XG5cdFx0XHRcdFx0XHRhcnJvd2J4Mj12cmlnaHQrYXJyb3dXaWR0aC8yO1xuXHRcdFx0XHRcdFx0YXJyb3d0eDE9YXJyb3dieDE7XG5cdFx0XHRcdFx0XHRhcnJvd3R4Mj1hcnJvd2J4Mjtcblx0XHRcdFx0XHR9IGVsc2UgeyAvLyBub24gdmVydGljYWwgbGluZTtcblx0XHRcdFx0XHRcdC8vIGNvbXB1dGUgbGluZSBmdW5jdGlvbjtcblx0XHRcdFx0XHRcdHZhciBhPSh4eXBvczEueXBvcy14eXBvczIueXBvcykvKHh5cG9zMS54cG9zLXh5cG9zMi54cG9zKTtcblx0XHRcdFx0XHRcdHZhciBiPXh5cG9zMS55cG9zLWEqeHlwb3MxLnhwb3M7XG5cdFx0XHRcdFx0XHR2cmlnaHQ9eHlwb3MyLnhwb3MgLSAoMS1yZWFsQW5pbWF0aW9uKSooeHlwb3MyLnhwb3MteHlwb3MxLnhwb3MpO1xuXHRcdFx0XHRcdFx0dmxlZnQgPXh5cG9zMS54cG9zIDtcblx0XHRcdFx0XHRcdHZ0b3A9YSp2cmlnaHQrYjtcblx0XHRcdFx0XHRcdHZib3R0b209YSp2bGVmdCtiO1xuXHRcdFx0XHRcdFx0aWYoTWF0aC5hYnModnRvcC12Ym90dG9tKSA8IG90aGVydmFycy5jb25maWcuemVyb1ZhbHVlKSB7IC8vIEhvcml6b250YWwgQXJyb3c7XG5cdFx0XHRcdFx0XHRcdHZhciBmYWN0O1xuXHRcdFx0XHRcdFx0XHRpZih2bGVmdDx2cmlnaHQpZmFjdD0xO2Vsc2UgZmFjdD0tMTtcblx0XHRcdFx0XHRcdFx0YXJyb3dieTE9dmJvdHRvbS1hcnJvd1dpZHRoLzI7XG5cdFx0XHRcdFx0XHRcdGFycm93YnkyPXZib3R0b20rYXJyb3dXaWR0aC8yO1xuXHRcdFx0XHRcdFx0XHRhcnJvd2J4MT12bGVmdCtmYWN0KmFycm93SGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHRhcnJvd2J4Mj1hcnJvd2J4MTtcblx0XHRcdFx0XHRcdFx0YXJyb3d0eTE9YXJyb3dieTE7XG5cdFx0XHRcdFx0XHRcdGFycm93dHkyPWFycm93YnkyO1xuXHRcdFx0XHRcdFx0XHRhcnJvd3R4MT12cmlnaHQtZmFjdCphcnJvd0hlaWdodDtcblx0XHRcdFx0XHRcdFx0YXJyb3d0eDI9YXJyb3d0eDE7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBmYWN0O1xuXHRcdFx0XHRcdFx0XHRpZih2bGVmdDx2cmlnaHQpZmFjdD0xO2Vsc2UgZmFjdD0tMTtcblx0XHRcdFx0XHRcdFx0dmFyIGNyb3NzcHR4PXZsZWZ0K2ZhY3QqYXJyb3dIZWlnaHQqTWF0aC5jb3MoTWF0aC5hdGFuKGEpKTtcblx0XHRcdFx0XHRcdFx0dmFyIGNyb3NzcHR5PWEqY3Jvc3NwdHgrYjtcblx0XHRcdFx0XHRcdFx0dmFyIGJwcmltPWNyb3NzcHR5KygxL2EpKmNyb3NzcHR4O1xuXHRcdFx0XHRcdFx0XHRhcnJvd2J4MT1jcm9zc3B0eC0oYXJyb3dXaWR0aC8yKSooTWF0aC5jb3MoTWF0aC5hdGFuKC0xL2EpKSk7XG5cdFx0XHRcdFx0XHRcdGFycm93YngyPWNyb3NzcHR4KyhhcnJvd1dpZHRoLzIpKihNYXRoLmNvcyhNYXRoLmF0YW4oLTEvYSkpKTtcblx0XHRcdFx0XHRcdFx0YXJyb3dieTE9KC0xL2EpKmFycm93YngxK2JwcmltO1xuXHRcdFx0XHRcdFx0XHRhcnJvd2J5Mj0oLTEvYSkqYXJyb3dieDIrYnByaW07XG5cdFx0XHRcdFx0XHRcdGNyb3NzcHR4PXZyaWdodC1mYWN0KmFycm93SGVpZ2h0Kk1hdGguY29zKE1hdGguYXRhbihhKSk7XG5cdFx0XHRcdFx0XHRcdGNyb3NzcHR5PWEqY3Jvc3NwdHgrYjtcblx0XHRcdFx0XHRcdFx0YnByaW09Y3Jvc3NwdHkrKDEvYSkqY3Jvc3NwdHg7XG5cdFx0XHRcdFx0XHRcdGFycm93dHgxPWNyb3NzcHR4LShhcnJvd1dpZHRoLzIpKihNYXRoLmNvcyhNYXRoLmF0YW4oLTEvYSkpKTtcblx0XHRcdFx0XHRcdFx0YXJyb3d0eDI9Y3Jvc3NwdHgrKGFycm93V2lkdGgvMikqKE1hdGguY29zKE1hdGguYXRhbigtMS9hKSkpO1xuXHRcdFx0XHRcdFx0XHRhcnJvd3R5MT0oLTEvYSkqYXJyb3d0eDErYnByaW07XG5cdFx0XHRcdFx0XHRcdGFycm93dHkyPSgtMS9hKSphcnJvd3R4MiticHJpbTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgY3Jvc3NwdHg9dmxlZnQrYXJyb3dIZWlnaHQqTWF0aC5jb3MoTWF0aC5hdGFuKGEpKTtcblx0XHRcdFx0XHRcdHZhciBjcm9zc3B0eT1hKmNyb3NzcHR4K2I7XG5cdFx0XHRcdFx0XHR2YXIgYnByaW09Y3Jvc3NwdHkrKDEvYSlcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHgubW92ZVRvKHZyaWdodCwgdnRvcCk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh2bGVmdCwgdmJvdHRvbSk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zdHJva2VTaXplLGRyYXdTaGFwZV9kZWZhdWx0LnN0cm9rZVNpemUpKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnN0cm9rZUNvbG9yLGRyYXdTaGFwZV9kZWZhdWx0LnN0cm9rZUNvbG9yKTtcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zdHJva2VTdHlsZSxkcmF3U2hhcGVfZGVmYXVsdC5zdHJva2VTdHlsZSkpKTtcdFxuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc3Ryb2tlQ29sb3IsZHJhd1NoYXBlX2RlZmF1bHQuc3Ryb2tlQ29sb3IpO1xuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnN0cm9rZVN0eWxlLGRyYXdTaGFwZV9kZWZhdWx0LnN0cm9rZVN0eWxlKSkpO1x0XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zdHJva2VTaXplLGRyYXdTaGFwZV9kZWZhdWx0LnN0cm9rZVNpemUpKTtcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXG5cdFx0XHRcdFx0aWYoZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5hcnJvd1RvcCxkcmF3U2hhcGVfZGVmYXVsdC5hcnJvd1RvcCkpIHtcblx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8odnJpZ2h0LCB2dG9wKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oYXJyb3d0eDEsIGFycm93dHkxKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oYXJyb3d0eDIsIGFycm93dHkyKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8odnJpZ2h0LHZ0b3ApO1xuXHRcdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1kcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnN0cm9rZUNvbG9yLGRyYXdTaGFwZV9kZWZhdWx0LnN0cm9rZUNvbG9yKTtcblx0XHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uYXJyb3dCb3R0b20sZHJhd1NoYXBlX2RlZmF1bHQuYXJyb3dCb3R0b20pKSB7XG5cdFx0XHRcdFx0XHRjdHgubW92ZVRvKHZsZWZ0LCB2Ym90dG9tKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oYXJyb3dieDEsIGFycm93YnkxKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oYXJyb3dieDIsIGFycm93YnkyKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8odmxlZnQsdmJvdHRvbSk7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPWRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc3Ryb2tlQ29sb3IsZHJhd1NoYXBlX2RlZmF1bHQuc3Ryb2tlQ29sb3IpO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcIlRFWFRcIiA6XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdHZhciB2eCwgdnksIHRleHQ7XG5cdFx0XHRcdFx0dng9IDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS54MSxkcmF3U2hhcGVfZGVmYXVsdC54MSk7XG5cdFx0XHRcdFx0dnk9IDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS55MSxkcmF3U2hhcGVfZGVmYXVsdC55MSk7XG5cdFx0XHRcdFx0dGV4dD0gZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS50ZXh0LGRyYXdTaGFwZV9kZWZhdWx0LnRleHQpO1xuXHRcdFx0XHRcdGlmKHR5cGVvZiB0ZXh0PT1cImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdHRleHQ9dGV4dChpLCBudWxsLCBjdHgsIG90aGVydmFycy5jb25maWcsIHZ4LCB2eSwgb3RoZXJ2YXJzLmJvcmRlclgsIG90aGVydmFycy5ib3JkZXJZLCB0cnVlLCBkYXRhLCBvdGhlcnZhcnMuYW5pbWF0aW9uVmFsdWUsb3RoZXJ2YXJzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHh5cG9zMT1zZXRYWXBvcyhzaGFwZSxzaGFwZXNJbkNoYXJ0W2ldLFwiXCIsXCJcIixcIlwiLGN0eCxkYXRhLHN0YXREYXRhLG90aGVydmFycyx2eCx2eSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1gxLGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdYMSksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdZMSxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWTEpLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ubGltaXRUb0NoYXJ0LGRyYXdTaGFwZV9kZWZhdWx0LmxpbWl0VG9DaGFydCkpO1xuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoeHlwb3MxLnhwb3MsIHh5cG9zMS55cG9zKTtcblx0XHRcdFx0XHR2YXIgZm9udFNpemU9cmVhbEFuaW1hdGlvbipkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmZvbnRTaXplLGRyYXdTaGFwZV9kZWZhdWx0LmZvbnRTaXplKTtcblx0XHRcdFx0XHRjdHguZm9udCA9IGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uZm9udFN0eWxlLGRyYXdTaGFwZV9kZWZhdWx0LmZvbnRTdHlsZSkgKyBcIiBcIiArIChNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmZvbnRTaXplKSkudG9TdHJpbmcoKSArIFwicHggXCIgKyBkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmZvbnRGYW1pbHksZHJhd1NoYXBlX2RlZmF1bHQuZm9udEZhbWlseSk7XG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uZm9udENvbG9yLGRyYXdTaGFwZV9kZWZhdWx0LmZvbnRDb2xvcik7XG5cdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0udGV4dEFsaWduLGRyYXdTaGFwZV9kZWZhdWx0LnRleHRBbGlnbik7XG5cdFx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0udGV4dEJhc2VsaW5lLGRyYXdTaGFwZV9kZWZhdWx0LnRleHRCYXNlbGluZSk7XG5cdFx0XHRcdFx0dmFyIHJvdGF0ZVZhbD1NYXRoLlBJICogMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnJvdGF0ZSxkcmF3U2hhcGVfZGVmYXVsdC5yb3RhdGUpIC8gMTgwO1xuXHRcdFx0XHRcdGN0eC5yb3RhdGUocm90YXRlVmFsKTtcblx0XHRcdFx0XHRzZXRUZXh0Qm9yZGVyc0FuZEJhY2tncm91bmQoY3R4LHRleHQsTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpmb250U2l6ZSksMCwwLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0udGV4dEJvcmRlcnMsZHJhd1NoYXBlX2RlZmF1bHQudGV4dEJvcmRlcnMpLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0udGV4dEJvcmRlcnNDb2xvcixkcmF3U2hhcGVfZGVmYXVsdC50ZXh0Qm9yZGVyc0NvbG9yKSxNYXRoLmNlaWwoKHJlYWxBbmltYXRpb24pKmN0eC5jaGFydExpbmVTY2FsZSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnRleHRCb3JkZXJzV2lkdGgsZHJhd1NoYXBlX2RlZmF1bHQudGV4dEJvcmRlcnNXaWR0aCkpLE1hdGguY2VpbChjdHguY2hhcnRTcGFjZVNjYWxlKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0udGV4dEJvcmRlcnNYU3BhY2UsZHJhd1NoYXBlX2RlZmF1bHQudGV4dEJvcmRlcnNYU3BhY2UpKSxNYXRoLmNlaWwoY3R4LmNoYXJ0U3BhY2VTY2FsZSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnRleHRCb3JkZXJzWVNwYWNlLGRyYXdTaGFwZV9kZWZhdWx0LnRleHRCb3JkZXJzWVNwYWNlKSksZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS50ZXh0Qm9yZGVyc1N0eWxlLGRyYXdTaGFwZV9kZWZhdWx0LnRleHRCb3JkZXJzU3R5bGUpLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0udGV4dEJhY2tncm91bmRDb2xvcixkcmF3U2hhcGVfZGVmYXVsdC50ZXh0QmFja2dyb3VuZENvbG9yKSxcIlRFWFRJTlNIQVBFXCIpO1xuXHRcdFx0XHRcdGlmIChpdGVyICE9PVwiYWxsXCIgfHwgKGl0ZXIgPT09IFwiYWxsXCIgJiYgb3RoZXJ2YXJzLmNudGl0ZXIgIT0gb3RoZXJ2YXJzLmNvbmZpZy5hbmltYXRpb25TdGVwcykgfHwgb3RoZXJ2YXJzLmNvbmZpZy5hbmltYXRpb249PWZhbHNlKSB7XG5cdFx0XHRcdFx0ICAgICAgIGN0eC5maWxsVGV4dE11bHRpTGluZSh0ZXh0LCAwLCAwLCBjdHgudGV4dEJhc2VsaW5lLCBNYXRoLmNlaWwoY3R4LmNoYXJ0VGV4dFNjYWxlKmZvbnRTaXplKSx0cnVlLG90aGVydmFycy5jb25maWcuZGV0ZWN0TW91c2VPblRleHQsY3R4LFwiU0hBUEVTSU5DSEFSVF9URVhUTU9VU0VcIixyb3RhdGVWYWwseHlwb3MxLnhwb3MsIHh5cG9zMS55cG9zLC0xLC0xKTtcblx0XHRcdFx0XHR9IGVsc2UgY3R4LmZpbGxUZXh0TXVsdGlMaW5lKHRleHQsIDAsIDAsIGN0eC50ZXh0QmFzZWxpbmUsIE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqZm9udFNpemUpLHRydWUsZmFsc2UsY3R4LFwiU0hBUEVTSU5DSEFSVF9URVhUTU9VU0VcIixyb3RhdGVWYWwseHlwb3MxLnhwb3MsIHh5cG9zMS55cG9zLC0xLC0xKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcIklNQUdFXCIgOlxuXHRcdFx0XHRcdHZhciBpbWFnZUFsaWduID0gZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5pbWFnZUFsaWduLGRyYXdTaGFwZV9kZWZhdWx0LmltYWdlQWxpZ24pO1xuXHRcdFx0XHRcdHZhciBpbWFnZUJhc2VsaW5lID0gZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5pbWFnZUJhc2VsaW5lLGRyYXdTaGFwZV9kZWZhdWx0LmltYWdlQmFzZWxpbmUpO1xuXHRcdFx0XHRcdHZhciB2eCwgdnksIHRleHQ7XG5cdFx0XHRcdFx0dng9IDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS54MSxkcmF3U2hhcGVfZGVmYXVsdC54MSk7XG5cdFx0XHRcdFx0dnk9IDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS55MSxkcmF3U2hhcGVfZGVmYXVsdC55MSk7XG5cdFx0XHRcdFx0dmFyIHh5cG9zMT1zZXRYWXBvcyhzaGFwZSxzaGFwZXNJbkNoYXJ0W2ldLGltYWdlQWxpZ24saW1hZ2VCYXNlbGluZSxzaGFwZXNJbkNoYXJ0W2ldLmxvYWRJbWFnZSxjdHgsZGF0YSxzdGF0RGF0YSxvdGhlcnZhcnMsdngsdnksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdYMSxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWDEpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWTEsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1kxKSxkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmxpbWl0VG9DaGFydCxkcmF3U2hhcGVfZGVmYXVsdC5saW1pdFRvQ2hhcnQpKTtcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHh5cG9zMS54cG9zLCB4eXBvczEueXBvcyk7XG5cdFx0XHRcdFx0dmFyIHJvdGF0ZVZhbD1NYXRoLlBJICogMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnJvdGF0ZSxkcmF3U2hhcGVfZGVmYXVsdC5yb3RhdGUpIC8gMTgwO1xuXHRcdFx0XHRcdGN0eC5yb3RhdGUocm90YXRlVmFsKTtcblx0XHRcdFx0XHR2YXIgaW1hZ2VXaWR0aD1kcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmltYWdlV2lkdGgsc2hhcGVzSW5DaGFydFtpXS5sb2FkSW1hZ2Uud2lkdGgpO1xuXHRcdFx0XHRcdHZhciBpbWFnZUhlaWdodD1kcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmltYWdlSGVpZ2h0LHNoYXBlc0luQ2hhcnRbaV0ubG9hZEltYWdlLmhlaWdodCk7XG5cdFx0XHRcdFx0Y3R4LmRyYXdJbWFnZShzaGFwZXNJbkNoYXJ0W2ldLmxvYWRJbWFnZSwgMCwgMCxzaGFwZXNJbkNoYXJ0W2ldLmxvYWRJbWFnZS53aWR0aCxzaGFwZXNJbkNoYXJ0W2ldLmxvYWRJbWFnZS5oZWlnaHQsMCwgMCxpbWFnZVdpZHRoLGltYWdlSGVpZ2h0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcIlNUQVJcIiA6XG5cdFx0XHRcdGNhc2UgXCJQTFVTXCIgOlxuXHRcdFx0XHRjYXNlIFwiQ1JPU1NcIiA6XG5cdFx0XHRcdFx0dmFyIHZ4czEsdnlzMSx2eHMyLHZ5czIsbGluZUNvdW50LGFuZ2xlLHZ4LHZ5LHZ4Mix2eTI7XG5cdFx0XHRcdFx0dmFyIGFuZ2xlICAgICA9IChNYXRoLlBJKigxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucm90YXRlLGRyYXdTaGFwZV9kZWZhdWx0LnJvdGF0ZSktOTApLzE4MCk7XG5cdFx0XHRcdFx0c3dpdGNoKHNoYXBlKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFwiUExVU1wiIDpcblx0XHRcdFx0XHRcdFx0bGluZUNvdW50PTI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIkNST1NTXCIgOlxuXHRcdFx0XHRcdFx0XHRsaW5lQ291bnQ9Mjtcblx0XHRcdFx0XHRcdFx0YW5nbGUrPU1hdGguUEkvNDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OiBcblx0XHRcdFx0XHRcdFx0bGluZUNvdW50ID0gMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmxpbmVDb3VudCxkcmF3U2hhcGVfZGVmYXVsdC5saW5lQ291bnQpO1xuXHRcdFx0XHRcdFx0XHRpZiAobGluZUNvdW50PDIpbGluZUNvdW50PTI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgYW5nbGVwbHVzID0gTWF0aC5QSS9saW5lQ291bnQ7XG5cdFx0XHRcdFx0dng9IDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS54MSxkcmF3U2hhcGVfZGVmYXVsdC54MSk7XG5cdFx0XHRcdFx0dnk9IDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS55MSxkcmF3U2hhcGVfZGVmYXVsdC55MSk7XG5cdFx0XHRcdFx0dmFyIHJhZGl1cyAgICA9IHJlYWxBbmltYXRpb24qMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnJhZGl1cyxkcmF3U2hhcGVfZGVmYXVsdC5yYWRpdXMpO1xuXHRcdFx0XHRcdGlmIChyYWRpdXMgPCAwKSB7XG5cdFx0XHRcdFx0XHR2YXIgeHlwb3MyPXNldFhZcG9zKHNoYXBlLHNoYXBlc0luQ2hhcnRbaV0sXCJcIixcIlwiLFwiXCIsY3R4LGRhdGEsc3RhdERhdGEsb3RoZXJ2YXJzLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS54MixkcmF3U2hhcGVfZGVmYXVsdC54MiksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnkyLGRyYXdTaGFwZV9kZWZhdWx0LnkyKSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1gyLGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdYMiksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdZMixkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWTIpLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ubGltaXRUb0NoYXJ0LGRyYXdTaGFwZV9kZWZhdWx0LmxpbWl0VG9DaGFydCkpO1xuXHRcdFx0XHRcdFx0cmFkaXVzPU1hdGguc3FydCgoKHh5cG9zLnhwb3MteHlwb3MyLnhwb3MpKih4eXBvcy54cG9zLXh5cG9zMi54cG9zKSkrKCh4eXBvcy55cG9zLXh5cG9zMi55cG9zKSooeHlwb3MueXBvcy14eXBvczIueXBvcykpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHh5cG9zMT1zZXRYWXBvcyhzaGFwZSxzaGFwZXNJbkNoYXJ0W2ldLFwiXCIsXCJcIixcIlwiLGN0eCxkYXRhLHN0YXREYXRhLG90aGVydmFycyx2eCx2eSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1gxLGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdYMSksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdZMSxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWTEpLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ubGltaXRUb0NoYXJ0LGRyYXdTaGFwZV9kZWZhdWx0LmxpbWl0VG9DaGFydCkpO1xuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc3Ryb2tlU2l6ZSxkcmF3U2hhcGVfZGVmYXVsdC5zdHJva2VTaXplKSk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zdHJva2VDb2xvcixkcmF3U2hhcGVfZGVmYXVsdC5zdHJva2VDb2xvcik7XG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc3Ryb2tlU3R5bGUsZHJhd1NoYXBlX2RlZmF1bHQuc3Ryb2tlU3R5bGUpKSk7XHRcblx0XHRcdFx0XHRmb3IodmFyIGo9MDtqPGxpbmVDb3VudDtqKyspIHtcblx0XHRcdFx0XHRcdHZ4czE9eHlwb3MxLnhwb3MrcmFkaXVzKk1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRcdHZ5czE9eHlwb3MxLnlwb3MrcmFkaXVzKk1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHRcdHZ4czI9eHlwb3MxLnhwb3MtcmFkaXVzKk1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRcdHZ5czI9eHlwb3MxLnlwb3MtcmFkaXVzKk1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHRcdGFuZ2xlKz1hbmdsZXBsdXM7XG5cdFx0XHRcdFx0XHRjdHgubW92ZVRvKHZ4czEsdnlzMSk7XG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKHZ4czIsdnlzMik7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0fVx0XHRcdFx0XHRcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiUkVHVUxBUlNIQVBFXCIgOlxuXHRcdFx0XHRjYXNlIFwiVFJJQU5HTEVcIiA6XG5cdFx0XHRcdGNhc2UgXCJTUVVBUkVcIiA6XG5cdFx0XHRcdGNhc2UgXCJESUFNT05EXCIgOlxuXHRcdFx0XHRcdHZhciB2eHMsdnlzLHNpZGVDb3VudCxhbmdsZTtcblx0XHRcdFx0XHR2YXIgYW5nbGUgICAgID0gKE1hdGguUEkqKDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5yb3RhdGUsZHJhd1NoYXBlX2RlZmF1bHQucm90YXRlKS05MCkvMTgwKTtcblx0XHRcdFx0XHRzd2l0Y2goc2hhcGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgXCJUUklBTkdMRVwiIDpcblx0XHRcdFx0XHRcdFx0c2lkZUNvdW50PTM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIlNRVUFSRVwiIDpcblx0XHRcdFx0XHRcdFx0c2lkZUNvdW50PTQ7XG5cdFx0XHRcdFx0XHRcdGFuZ2xlKz1NYXRoLlBJLzQ7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIkRJQU1PTkRcIiA6XG5cdFx0XHRcdFx0XHRcdHNpZGVDb3VudD00O1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6IFxuXHRcdFx0XHRcdFx0XHRzaWRlQ291bnQgPSAxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc2lkZUNvdW50LGRyYXdTaGFwZV9kZWZhdWx0LnNpZGVDb3VudCk7XG5cdFx0XHRcdFx0XHRcdGlmIChzaWRlQ291bnQ8MylzaWRlQ291bnQ9Mztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBhbmdsZXBsdXMgPSAyKk1hdGguUEkvc2lkZUNvdW50O1xuXHRcdFx0XHRcdHZ4PSAxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueDEsZHJhd1NoYXBlX2RlZmF1bHQueDEpO1xuXHRcdFx0XHRcdHZ5PSAxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueTEsZHJhd1NoYXBlX2RlZmF1bHQueTEpO1xuXHRcdFx0XHRcdHZhciB4eXBvczE9c2V0WFlwb3Moc2hhcGUsc2hhcGVzSW5DaGFydFtpXSxcIlwiLFwiXCIsXCJcIixjdHgsZGF0YSxzdGF0RGF0YSxvdGhlcnZhcnMsdngsdnksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdYMSxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWDEpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWTEsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1kxKSxkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmxpbWl0VG9DaGFydCxkcmF3U2hhcGVfZGVmYXVsdC5saW1pdFRvQ2hhcnQpKTtcblx0XHRcdFx0XHR2YXIgcmFkaXVzICAgID0gcmVhbEFuaW1hdGlvbioxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucmFkaXVzLGRyYXdTaGFwZV9kZWZhdWx0LnJhZGl1cyk7XG5cdFx0XHRcdFx0aWYgKHJhZGl1cyA8IDApIHtcblx0XHRcdFx0XHRcdHZhciB4eXBvczI9c2V0WFlwb3Moc2hhcGUsc2hhcGVzSW5DaGFydFtpXSxcIlwiLFwiXCIsXCJcIixjdHgsZGF0YSxzdGF0RGF0YSxvdGhlcnZhcnMsMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLngyLGRyYXdTaGFwZV9kZWZhdWx0LngyKSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueTIsZHJhd1NoYXBlX2RlZmF1bHQueTIpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWDIsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1gyKSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1kyLGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdZMiksZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5saW1pdFRvQ2hhcnQsZHJhd1NoYXBlX2RlZmF1bHQubGltaXRUb0NoYXJ0KSk7XG5cdFx0XHRcdFx0XHRyYWRpdXM9TWF0aC5zcXJ0KCgoeHlwb3MueHBvcy14eXBvczIueHBvcykqKHh5cG9zLnhwb3MteHlwb3MyLnhwb3MpKSsoKHh5cG9zLnlwb3MteHlwb3MyLnlwb3MpKih4eXBvcy55cG9zLXh5cG9zMi55cG9zKSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IE1hdGguY2VpbChjdHguY2hhcnRMaW5lU2NhbGUqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zdHJva2VTaXplLGRyYXdTaGFwZV9kZWZhdWx0LnN0cm9rZVNpemUpKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnN0cm9rZUNvbG9yLGRyYXdTaGFwZV9kZWZhdWx0LnN0cm9rZUNvbG9yKTtcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2gobGluZVN0eWxlRm4oZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zdHJva2VTdHlsZSxkcmF3U2hhcGVfZGVmYXVsdC5zdHJva2VTdHlsZSkpKTtcdFxuXHRcdFx0XHRcdGZvcih2YXIgaj0wO2o8c2lkZUNvdW50O2orKykge1xuXHRcdFx0XHRcdFx0dnhzPXh5cG9zMS54cG9zK3JhZGl1cypNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0XHR2eXM9eHlwb3MxLnlwb3MrcmFkaXVzKk1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHRcdGFuZ2xlKz1hbmdsZXBsdXM7XG5cdFx0XHRcdFx0XHRpZihqPT0wKSBjdHgubW92ZVRvKHZ4cyx2eXMpO1xuXHRcdFx0XHRcdFx0ZWxzZSAgICAgY3R4LmxpbmVUbyh2eHMsdnlzKTtcblx0XHRcdFx0XHR9XHRcdFx0XHRcdFxuXHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPXNldE9wdGlvblZhbHVlKHRydWUsMSxcIlNIQVBFU0lOQ0hBUlRfUkVHVUxBUlNIQVBFXCIsY3R4LGRhdGEsc3RhdERhdGEsc2hhcGVzSW5DaGFydFtpXS5maWxsQ29sb3IsZHJhd1NoYXBlX2RlZmF1bHQuZmlsbENvbG9yLFwiZmlsbENvbG9yXCIsLTEsLTEse2dyYWRpZW50Q29sb3JzOiBzaGFwZXNJbkNoYXJ0W2ldLmdyYWRpZW50Q29sb3JzLGFuaW1hdGlvblZhbHVlIDogcmVhbEFuaW1hdGlvbiwgbWlkUG9zWCA6IHh5cG9zMS54cG9zLCBtaWRQb3NZIDogeHlwb3MxLnlwb3MsIHJhZGl1cyA6IHJhZGl1cyB9KTtcblx0XHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goW10pO1xuXHRcdFx0XHRcdGJyZWFrO1x0XHRcdFx0XHRcblx0XHRcdFx0Y2FzZSBcIkVMTElQU0VcIiA6XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdHZhciB4eXBvcz1zZXRYWXBvcyhzaGFwZSxzaGFwZXNJbkNoYXJ0W2ldLFwiXCIsXCJcIixcIlwiLGN0eCxkYXRhLHN0YXREYXRhLG90aGVydmFycywxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueDEsZHJhd1NoYXBlX2RlZmF1bHQueDEpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS55MSxkcmF3U2hhcGVfZGVmYXVsdC55MSksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdYMSxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWDEpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWTEsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1kxKSxkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmxpbWl0VG9DaGFydCxkcmF3U2hhcGVfZGVmYXVsdC5saW1pdFRvQ2hhcnQpKTtcblx0XHRcdFx0XHR2YXIgaGVpZ2h0PXJlYWxBbmltYXRpb24qMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmVsbGlwc2VIZWlnaHQsZHJhd1NoYXBlX2RlZmF1bHQuZWxsaXBzZUhlaWdodCk7XG5cdFx0XHRcdFx0dmFyIHdpZHRoPSByZWFsQW5pbWF0aW9uKjEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5lbGxpcHNlV2lkdGgsZHJhd1NoYXBlX2RlZmF1bHQuZWxsaXBzZVdpZHRoKTtcblx0XHRcdFx0XHRjdHgubW92ZVRvKHh5cG9zLnhwb3MsIHh5cG9zLnlwb3MgLSBoZWlnaHQvMik7IC8vIEExXG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oXG4gICAgXHRcdFx0XHRcdFx0eHlwb3MueHBvcyArIHdpZHRoLzIsIHh5cG9zLnlwb3MgLSBoZWlnaHQvMiwgLy8gQzFcbiAgICBcdFx0XHRcdFx0XHR4eXBvcy54cG9zICsgd2lkdGgvMiwgeHlwb3MueXBvcyArIGhlaWdodC8yLCAvLyBDMlxuICAgIFx0XHRcdFx0XHRcdHh5cG9zLnhwb3MsIHh5cG9zLnlwb3MgKyBoZWlnaHQvMik7IC8vIEEyXG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oXG5cdFx0XHRcdFx0XHR4eXBvcy54cG9zIC0gd2lkdGgvMiwgeHlwb3MueXBvcyArIGhlaWdodC8yLCAvLyBDM1xuXHRcdFx0XHRcdFx0eHlwb3MueHBvcyAtIHdpZHRoLzIsIHh5cG9zLnlwb3MgLSBoZWlnaHQvMiwgLy8gQzRcblx0XHRcdFx0XHRcdHh5cG9zLnhwb3MsIHh5cG9zLnlwb3MgLSBoZWlnaHQvMik7IC8vIEExXG5cdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGU9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0hBUEVTSU5DSEFSVF9FTExJUFNFXCIsY3R4LGRhdGEsc3RhdERhdGEsc2hhcGVzSW5DaGFydFtpXS5maWxsQ29sb3IsZHJhd1NoYXBlX2RlZmF1bHQuZmlsbENvbG9yLFwiZmlsbENvbG9yXCIsLTEsLTEse2dyYWRpZW50Q29sb3JzOiBzaGFwZXNJbkNoYXJ0W2ldLmdyYWRpZW50Q29sb3JzLGFuaW1hdGlvblZhbHVlIDogcmVhbEFuaW1hdGlvbiwgbWlkUG9zWCA6IHh5cG9zLnhwb3MsIG1pZFBvc1kgOiB4eXBvcy55cG9zLCByYWRpdXMgOiBNYXRoLm1heCh3aWR0aC8yLGhlaWdodC8yKSB9KTtcblx0XHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc3Ryb2tlU2l6ZSxkcmF3U2hhcGVfZGVmYXVsdC5zdHJva2VTaXplKSk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zdHJva2VDb2xvcixkcmF3U2hhcGVfZGVmYXVsdC5zdHJva2VDb2xvcik7XG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc3Ryb2tlU3R5bGUsZHJhd1NoYXBlX2RlZmF1bHQuc3Ryb2tlU3R5bGUpKSk7XHRcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcIlJFQ1RBTkdMRVwiIDpcblx0XG5cdFx0XHRcdFx0dmFyIHZyaWdodCwgdmxlZnQsIHZ0b3AsIHZib3R0b20sIHRtcDtcblx0XHRcdFx0XHR2cmlnaHQ9IDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS54MSxkcmF3U2hhcGVfZGVmYXVsdC54MSk7XG5cdFx0XHRcdFx0dmxlZnQ9IDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS54MixkcmF3U2hhcGVfZGVmYXVsdC54Mik7XG5cdFx0XHRcdFx0dnRvcD0gMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnkyLGRyYXdTaGFwZV9kZWZhdWx0LnkyKTtcblx0XHRcdFx0XHR2Ym90dG9tPSAxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueTEsZHJhd1NoYXBlX2RlZmF1bHQueTEpO1xuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdFx0XHRcdHZhciB4eXBvczE9c2V0WFlwb3Moc2hhcGUsc2hhcGVzSW5DaGFydFtpXSxcIlwiLFwiXCIsXCJcIixjdHgsZGF0YSxzdGF0RGF0YSxvdGhlcnZhcnMsdmxlZnQsdnRvcCwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1gxLGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdYMSksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdZMSxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWTEpLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ubGltaXRUb0NoYXJ0LGRyYXdTaGFwZV9kZWZhdWx0LmxpbWl0VG9DaGFydCkpO1xuXHRcdFx0XHRcdHZhciB4eXBvczI9c2V0WFlwb3Moc2hhcGUsc2hhcGVzSW5DaGFydFtpXSxcIlwiLFwiXCIsXCJcIixjdHgsZGF0YSxzdGF0RGF0YSxvdGhlcnZhcnMsdnJpZ2h0LHZib3R0b20sMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdYMixkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWDIpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWTIsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1kyKSxkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmxpbWl0VG9DaGFydCxkcmF3U2hhcGVfZGVmYXVsdC5saW1pdFRvQ2hhcnQpKTtcblxuXHRcdFx0XHRcdGlmICh4eXBvczIueHBvczx4eXBvczEueHBvcyl7dG1wPXh5cG9zMi54cG9zO3h5cG9zMi54cG9zPXh5cG9zMS54cG9zO3h5cG9zMS54cG9zPXRtcDt9XG5cdFx0XHRcdFx0aWYgKHh5cG9zMi55cG9zPHh5cG9zMS55cG9zKXt0bXA9eHlwb3MyLnlwb3M7eHlwb3MyLnlwb3M9eHlwb3MxLnlwb3M7eHlwb3MxLnlwb3M9dG1wO31cblxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oeHlwb3MxLnhwb3MrKDEtcmVhbEFuaW1hdGlvbikqKCh4eXBvczIueHBvcy14eXBvczEueHBvcykvMiksIHh5cG9zMS55cG9zKygxLXJlYWxBbmltYXRpb24pKigoeHlwb3MyLnlwb3MteHlwb3MxLnlwb3MpLzIpKTtcblx0XHRcdFx0XHRjdHgubGluZVRvKHh5cG9zMS54cG9zKygxLXJlYWxBbmltYXRpb24pKigoeHlwb3MyLnhwb3MteHlwb3MxLnhwb3MpLzIpLCB4eXBvczIueXBvcy0oMS1yZWFsQW5pbWF0aW9uKSooKHh5cG9zMi55cG9zLXh5cG9zMS55cG9zKS8yKSk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh4eXBvczIueHBvcy0oMS1yZWFsQW5pbWF0aW9uKSooKHh5cG9zMi54cG9zLXh5cG9zMS54cG9zKS8yKSwgeHlwb3MyLnlwb3MtKDEtcmVhbEFuaW1hdGlvbikqKCh4eXBvczIueXBvcy14eXBvczEueXBvcykvMikpO1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeHlwb3MyLnhwb3MtKDEtcmVhbEFuaW1hdGlvbikqKCh4eXBvczIueHBvcy14eXBvczEueHBvcykvMiksIHh5cG9zMS55cG9zKygxLXJlYWxBbmltYXRpb24pKigoeHlwb3MyLnlwb3MteHlwb3MxLnlwb3MpLzIpKTtcblx0XG5cdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGU9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0hBUEVTSU5DSEFSVF9SRUNUXCIsY3R4LGRhdGEsc3RhdERhdGEsc2hhcGVzSW5DaGFydFtpXS5maWxsQ29sb3IsZHJhd1NoYXBlX2RlZmF1bHQuZmlsbENvbG9yLFwiZmlsbENvbG9yXCIsLTEsLTEse2dyYWRpZW50Q29sb3JzOiBzaGFwZXNJbkNoYXJ0W2ldLmdyYWRpZW50Q29sb3JzLGFuaW1hdGlvblZhbHVlIDogcmVhbEFuaW1hdGlvbiwgeFBvc0xlZnQgOiB4eXBvczEueHBvcysoMS1yZWFsQW5pbWF0aW9uKSooKHh5cG9zMi54cG9zLXh5cG9zMS54cG9zKS8yKSwgeVBvc0JvdHRvbSA6IHh5cG9zMS55cG9zKygxLXJlYWxBbmltYXRpb24pKigoeHlwb3MyLnlwb3MteHlwb3MxLnlwb3MpLzIpLCB5UG9zVG9wIDp4eXBvczIueXBvcy0oMS1yZWFsQW5pbWF0aW9uKSooKHh5cG9zMi55cG9zLXh5cG9zMS55cG9zKS8yKSB9KTtcblx0XHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSBNYXRoLmNlaWwoY3R4LmNoYXJ0TGluZVNjYWxlKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc3Ryb2tlU2l6ZSxkcmF3U2hhcGVfZGVmYXVsdC5zdHJva2VTaXplKSk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zdHJva2VDb2xvcixkcmF3U2hhcGVfZGVmYXVsdC5zdHJva2VDb2xvcik7XG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxpbmVTdHlsZUZuKGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc3Ryb2tlU3R5bGUsZHJhd1NoYXBlX2RlZmF1bHQuc3Ryb2tlU3R5bGUpKSk7XHRcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcIk1ZU0hBUEVcIiA6XG5cdFx0XHRcdFx0dmFyIHhwb3MseXBvcyx4eXBvczEscGFkZGluZ1gscGFkZGluZ1k7XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0XHRcdFx0aWYodHlwZW9mIHNoYXBlc0luQ2hhcnRbaV0uc2hhcGVQb2ludHMgIT09IFwib2JqZWN0XCIpIGJyZWFrO1xuXHRcdFx0XHRcdGlmKHNoYXBlc0luQ2hhcnRbaV0uc2hhcGVQb2ludHMubGVuZ3RoIDwzKSBicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IodmFyIGo9MDtqPHNoYXBlc0luQ2hhcnRbaV0uc2hhcGVQb2ludHMubGVuZ3RoO2orKykge1xuXHRcdFx0XHRcdFx0eHBvcz1kcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnNoYXBlUG9pbnRzW2pdWzBdLGRyYXdTaGFwZV9kZWZhdWx0LngxKTtcblx0XHRcdFx0XHRcdHlwb3M9ZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zaGFwZVBvaW50c1tqXVsxXSxkcmF3U2hhcGVfZGVmYXVsdC55MSk7XG5cdFx0XHRcdFx0XHRwYWRkaW5nWD1kcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnNoYXBlUGFkZGluZ1tqXVswXSxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWDEpO1xuXHRcdFx0XHRcdFx0cGFkZGluZ1k9ZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zaGFwZVBhZGRpbmdbal1bMV0sZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1kxKTtcblx0XHRcdFx0XHRcdHh5cG9zMT1zZXRYWXBvcyhzaGFwZSxzaGFwZXNJbkNoYXJ0W2ldLFwiXCIsXCJcIixcIlwiLGN0eCxkYXRhLHN0YXREYXRhLG90aGVydmFycyx4cG9zLHlwb3MsMSpwYWRkaW5nWCwxKnBhZGRpbmdZLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ubGltaXRUb0NoYXJ0LGRyYXdTaGFwZV9kZWZhdWx0LmxpbWl0VG9DaGFydCkpO1xuXHRcdFx0XHRcdFx0aWYoaj09MCkgY3R4Lm1vdmVUbyh4eXBvczEueHBvcyx4eXBvczEueXBvcyk7XG5cdFx0XHRcdFx0XHRlbHNlIGN0eC5saW5lVG8oeHlwb3MxLnhwb3MseHlwb3MxLnlwb3MpO1xuXHRcdFx0XHRcdH0gXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPWRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uZmlsbENvbG9yLGRyYXdTaGFwZV9kZWZhdWx0LmZpbGxDb2xvcik7XG5cdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnN0cm9rZVNpemUsZHJhd1NoYXBlX2RlZmF1bHQuc3Ryb2tlU2l6ZSkpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc3Ryb2tlQ29sb3IsZHJhd1NoYXBlX2RlZmF1bHQuc3Ryb2tlQ29sb3IpO1xuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnN0cm9rZVN0eWxlLGRyYXdTaGFwZV9kZWZhdWx0LnN0cm9rZVN0eWxlKSkpO1x0XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJDSVJDTEVcIiA6XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdHZhciB4eXBvcz1zZXRYWXBvcyhzaGFwZSxzaGFwZXNJbkNoYXJ0W2ldLFwiXCIsXCJcIixcIlwiLGN0eCxkYXRhLHN0YXREYXRhLG90aGVydmFycywxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueDEsZHJhd1NoYXBlX2RlZmF1bHQueDEpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS55MSxkcmF3U2hhcGVfZGVmYXVsdC55MSksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdYMSxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWDEpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWTEsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1kxKSxkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmxpbWl0VG9DaGFydCxkcmF3U2hhcGVfZGVmYXVsdC5saW1pdFRvQ2hhcnQpKTtcblx0XHRcdFx0XHR2YXIgcmFkaXVzICAgID0gcmVhbEFuaW1hdGlvbioxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucmFkaXVzLGRyYXdTaGFwZV9kZWZhdWx0LnJhZGl1cyk7XG5cdFx0XHRcdFx0aWYgKHJhZGl1cyA8IDApIHtcblx0XHRcdFx0XHRcdHZhciB4eXBvczI9c2V0WFlwb3Moc2hhcGUsc2hhcGVzSW5DaGFydFtpXSxcIlwiLFwiXCIsXCJcIixjdHgsZGF0YSxzdGF0RGF0YSxvdGhlcnZhcnMsMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLngyLGRyYXdTaGFwZV9kZWZhdWx0LngyKSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueTIsZHJhd1NoYXBlX2RlZmF1bHQueTIpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWDIsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1gyKSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1kyLGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdZMiksZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5saW1pdFRvQ2hhcnQsZHJhd1NoYXBlX2RlZmF1bHQubGltaXRUb0NoYXJ0KSk7XG5cdFx0XHRcdFx0XHRyYWRpdXM9TWF0aC5zcXJ0KCgoeHlwb3MueHBvcy14eXBvczIueHBvcykqKHh5cG9zLnhwb3MteHlwb3MyLnhwb3MpKSsoKHh5cG9zLnlwb3MteHlwb3MyLnlwb3MpKih4eXBvcy55cG9zLXh5cG9zMi55cG9zKSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgeHlwb3M9c2V0WFlwb3Moc2hhcGUsc2hhcGVzSW5DaGFydFtpXSxcIlwiLFwiXCIsXCJcIixjdHgsZGF0YSxzdGF0RGF0YSxvdGhlcnZhcnMsMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLngxLGRyYXdTaGFwZV9kZWZhdWx0LngxKSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueTEsZHJhd1NoYXBlX2RlZmF1bHQueTEpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWDEsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1gxKSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1kxLGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdZMSksZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5saW1pdFRvQ2hhcnQsZHJhd1NoYXBlX2RlZmF1bHQubGltaXRUb0NoYXJ0KSk7XG5cdFx0XHRcdFx0aWYgKDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5lbmRBbmdsZSxkcmF3U2hhcGVfZGVmYXVsdC5lbmRBbmdsZSktMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnN0YXJ0QW5nbGUsZHJhd1NoYXBlX2RlZmF1bHQuc3RhcnRBbmdsZSkgIT0gIDM2MClcblx0XHRcdFx0XHRcdGN0eC5hcmMoeHlwb3MueHBvcyx4eXBvcy55cG9zLCAwLCAoTWF0aC5QSS8xODApKjEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zdGFydEFuZ2xlLGRyYXdTaGFwZV9kZWZhdWx0LnN0YXJ0QW5nbGUpLCAoTWF0aC5QSS8xODApKjEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5lbmRBbmdsZSxkcmF3U2hhcGVfZGVmYXVsdC5lbmRBbmdsZSksZmFsc2UpO1xuXHRcdFx0XHRcdGN0eC5hcmMoeHlwb3MueHBvcyx4eXBvcy55cG9zLCByZWFsQW5pbWF0aW9uKjEqcmFkaXVzLCAoTWF0aC5QSS8xODApKjEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5zdGFydEFuZ2xlLGRyYXdTaGFwZV9kZWZhdWx0LnN0YXJ0QW5nbGUpLCAoTWF0aC5QSS8xODApKjEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5lbmRBbmdsZSxkcmF3U2hhcGVfZGVmYXVsdC5lbmRBbmdsZSksdHJ1ZSk7XG5cdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGU9c2V0T3B0aW9uVmFsdWUodHJ1ZSwxLFwiU0hBUEVTSU5DSEFSVF9DSVJDTEVcIixjdHgsZGF0YSxzdGF0RGF0YSxzaGFwZXNJbkNoYXJ0W2ldLmZpbGxDb2xvcixkcmF3U2hhcGVfZGVmYXVsdC5maWxsQ29sb3IsXCJmaWxsQ29sb3JcIiwtMSwtMSx7Z3JhZGllbnRDb2xvcnM6IHNoYXBlc0luQ2hhcnRbaV0uZ3JhZGllbnRDb2xvcnMsYW5pbWF0aW9uVmFsdWUgOiByZWFsQW5pbWF0aW9uLCBtaWRQb3NYIDogeHlwb3MueHBvcywgbWlkUG9zWSA6IHh5cG9zLnlwb3MsIHJhZGl1cyA6IHJhZGl1cyAgfSk7XG4vL1x0XHRcdFx0XHRjdHguZmlsbFN0eWxlPWRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uZmlsbENvbG9yLGRyYXdTaGFwZV9kZWZhdWx0LmZpbGxDb2xvcik7XG5cdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gTWF0aC5jZWlsKGN0eC5jaGFydExpbmVTY2FsZSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnN0cm9rZVNpemUsZHJhd1NoYXBlX2RlZmF1bHQuc3Ryb2tlU2l6ZSkpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0uc3Ryb2tlQ29sb3IsZHJhd1NoYXBlX2RlZmF1bHQuc3Ryb2tlQ29sb3IpO1xuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnN0cm9rZVN0eWxlLGRyYXdTaGFwZV9kZWZhdWx0LnN0cm9rZVN0eWxlKSkpO1x0XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChbXSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQgOiBcblx0XHRcdFx0XHRpZih0eXBlb2Ygc2hhcGVzSW5DaGFydFtpXS5zaGFwZSA9PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0XHRcdFx0b3RoZXJ2YXJzLmN1cnJlbnRTaGFwZT1pO1xuXHRcdFx0XHRcdFx0b3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQ9c2hhcGVzSW5DaGFydFtpXTtcblx0XHRcdFx0XHRcdG90aGVydmFycy54eXBvczE9c2V0WFlwb3Moc2hhcGUsc2hhcGVzSW5DaGFydFtpXSxcIlwiLFwiXCIsXCJcIixjdHgsZGF0YSxzdGF0RGF0YSxvdGhlcnZhcnMsMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLngxLGRyYXdTaGFwZV9kZWZhdWx0LngxKSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueTEsZHJhd1NoYXBlX2RlZmF1bHQueTEpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWDEsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1gxKSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1kxLGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdZMSksZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5saW1pdFRvQ2hhcnQsZHJhd1NoYXBlX2RlZmF1bHQubGltaXRUb0NoYXJ0KSk7XG5cdFx0XHRcdFx0XHRvdGhlcnZhcnMueHlwb3MyPXNldFhZcG9zKHNoYXBlLHNoYXBlc0luQ2hhcnRbaV0sXCJcIixcIlwiLFwiXCIsY3R4LGRhdGEsc3RhdERhdGEsb3RoZXJ2YXJzLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS54MixkcmF3U2hhcGVfZGVmYXVsdC54MiksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnkyLGRyYXdTaGFwZV9kZWZhdWx0LnkyKSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1gyLGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdYMiksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdZMixkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWTIpLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ubGltaXRUb0NoYXJ0LGRyYXdTaGFwZV9kZWZhdWx0LmxpbWl0VG9DaGFydCkpO1xuXHRcdFx0XHRcdFx0b3RoZXJ2YXJzLnh5cG9zMz1zZXRYWXBvcyhzaGFwZSxzaGFwZXNJbkNoYXJ0W2ldLFwiXCIsXCJcIixcIlwiLGN0eCxkYXRhLHN0YXREYXRhLG90aGVydmFycywxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueDMsZHJhd1NoYXBlX2RlZmF1bHQueDMpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS55MyxkcmF3U2hhcGVfZGVmYXVsdC55MyksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdYMyxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWDMpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWTMsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1kzKSxkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmxpbWl0VG9DaGFydCxkcmF3U2hhcGVfZGVmYXVsdC5saW1pdFRvQ2hhcnQpKTtcblx0XHRcdFx0XHRcdG90aGVydmFycy54eXBvczQ9c2V0WFlwb3Moc2hhcGUsc2hhcGVzSW5DaGFydFtpXSxcIlwiLFwiXCIsXCJcIixjdHgsZGF0YSxzdGF0RGF0YSxvdGhlcnZhcnMsMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLng0LGRyYXdTaGFwZV9kZWZhdWx0Lng0KSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueTQsZHJhd1NoYXBlX2RlZmF1bHQueTQpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWDQsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1g0KSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1k0LGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdZNCksZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5saW1pdFRvQ2hhcnQsZHJhd1NoYXBlX2RlZmF1bHQubGltaXRUb0NoYXJ0KSk7XG5cdFx0XHRcdFx0XHRvdGhlcnZhcnMueHlwb3M1PXNldFhZcG9zKHNoYXBlLHNoYXBlc0luQ2hhcnRbaV0sXCJcIixcIlwiLFwiXCIsY3R4LGRhdGEsc3RhdERhdGEsb3RoZXJ2YXJzLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS54NSxkcmF3U2hhcGVfZGVmYXVsdC54NSksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnk1LGRyYXdTaGFwZV9kZWZhdWx0Lnk1KSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1g1LGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdYNSksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdZNSxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWTUpLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ubGltaXRUb0NoYXJ0LGRyYXdTaGFwZV9kZWZhdWx0LmxpbWl0VG9DaGFydCkpO1xuXHRcdFx0XHRcdFx0b3RoZXJ2YXJzLnh5cG9zNj1zZXRYWXBvcyhzaGFwZSxzaGFwZXNJbkNoYXJ0W2ldLFwiXCIsXCJcIixcIlwiLGN0eCxkYXRhLHN0YXREYXRhLG90aGVydmFycywxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueDYsZHJhd1NoYXBlX2RlZmF1bHQueDYpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS55NixkcmF3U2hhcGVfZGVmYXVsdC55NiksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdYNixkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWDYpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWTYsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1k2KSxkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmxpbWl0VG9DaGFydCxkcmF3U2hhcGVfZGVmYXVsdC5saW1pdFRvQ2hhcnQpKTtcblx0XHRcdFx0XHRcdG90aGVydmFycy54eXBvczc9c2V0WFlwb3Moc2hhcGUsc2hhcGVzSW5DaGFydFtpXSxcIlwiLFwiXCIsXCJcIixjdHgsZGF0YSxzdGF0RGF0YSxvdGhlcnZhcnMsMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLng3LGRyYXdTaGFwZV9kZWZhdWx0Lng3KSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueTcsZHJhd1NoYXBlX2RlZmF1bHQueTcpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWDcsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1g3KSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1k3LGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdZNyksZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5saW1pdFRvQ2hhcnQsZHJhd1NoYXBlX2RlZmF1bHQubGltaXRUb0NoYXJ0KSk7XG5cdFx0XHRcdFx0XHRvdGhlcnZhcnMueHlwb3M4PXNldFhZcG9zKHNoYXBlLHNoYXBlc0luQ2hhcnRbaV0sXCJcIixcIlwiLFwiXCIsY3R4LGRhdGEsc3RhdERhdGEsb3RoZXJ2YXJzLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS54OCxkcmF3U2hhcGVfZGVmYXVsdC54OCksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnk4LGRyYXdTaGFwZV9kZWZhdWx0Lnk4KSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ucGFkZGluZ1g4LGRyYXdTaGFwZV9kZWZhdWx0LnBhZGRpbmdYOCksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdZOCxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWTgpLGRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ubGltaXRUb0NoYXJ0LGRyYXdTaGFwZV9kZWZhdWx0LmxpbWl0VG9DaGFydCkpO1xuXHRcdFx0XHRcdFx0b3RoZXJ2YXJzLnh5cG9zOT1zZXRYWXBvcyhzaGFwZSxzaGFwZXNJbkNoYXJ0W2ldLFwiXCIsXCJcIixcIlwiLGN0eCxkYXRhLHN0YXREYXRhLG90aGVydmFycywxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueDksZHJhd1NoYXBlX2RlZmF1bHQueDkpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS55OSxkcmF3U2hhcGVfZGVmYXVsdC55OSksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdYOSxkcmF3U2hhcGVfZGVmYXVsdC5wYWRkaW5nWDkpLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5wYWRkaW5nWTksZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1k5KSxkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLmxpbWl0VG9DaGFydCxkcmF3U2hhcGVfZGVmYXVsdC5saW1pdFRvQ2hhcnQpKTtcblx0XHRcdFx0XHRcdG90aGVydmFycy54eXBvczEwPXNldFhZcG9zKHNoYXBlLHNoYXBlc0luQ2hhcnRbaV0sXCJcIixcIlwiLFwiXCIsY3R4LGRhdGEsc3RhdERhdGEsb3RoZXJ2YXJzLDEqZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS54MTAsZHJhd1NoYXBlX2RlZmF1bHQueDEwKSwxKmRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnRbaV0ueTEwLGRyYXdTaGFwZV9kZWZhdWx0LnkxMCksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdYMTAsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1gxMCksMSpkcmF3U2hhcGVTZXRWYWx1ZShzaGFwZXNJbkNoYXJ0W2ldLnBhZGRpbmdZMTAsZHJhd1NoYXBlX2RlZmF1bHQucGFkZGluZ1kxMCksZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydFtpXS5saW1pdFRvQ2hhcnQsZHJhd1NoYXBlX2RlZmF1bHQubGltaXRUb0NoYXJ0KSk7XG5cdFx0XHRcdFx0XHRzaGFwZXNJbkNoYXJ0W2ldLnNoYXBlKGFyZWEsIGN0eCwgZGF0YSxzdGF0RGF0YSwgcG9zaSxwb3NqLG90aGVydmFycyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHNldFhZcG9zKHNoYXBlLHNoYXBlc0luQ2hhcnQsaW1hZ2VBbGlnbixpbWFnZUJhc2VsaW5lLGltYWdlLGN0eCxkYXRhLHN0YXREYXRhLG90aGVydmFycyx4cG9zdmFsLHlwb3N2YWwscGFkZGluZ1gxLHBhZGRpbmdZMSxsaW1pdFRvQ2hhcnQpIHtcblx0XHR2YXIgeHBvcywgeXBvcywgcG9zaXRpb247XG5cdFx0aWYodHlwZW9mIHNoYXBlc0luQ2hhcnQucG9zaXRpb24gIT0gXCJzdHJpbmdcIilwb3NpdGlvbj0gZHJhd1NoYXBlX2RlZmF1bHQucG9zaXRpb24udG9VcHBlckNhc2UoKTtcblx0XHRlbHNlIHBvc2l0aW9uPXNoYXBlc0luQ2hhcnQucG9zaXRpb24udG9VcHBlckNhc2UoKTtcblx0XHRzd2l0Y2gocG9zaXRpb24pIHtcblx0XHRcdGNhc2UgXCJSRUxBVElWRVwiIDpcblx0XHRcdFx0eHBvcyA9IHBhZGRpbmdYMTtcblx0XHRcdFx0eXBvcyA9IHBhZGRpbmdZMTtcblx0XHRcdFx0c3dpdGNoICh4cG9zdmFsKSB7XG5cdFx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0eHBvcyArPSBvdGhlcnZhcnMuYm9yZGVyWDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdHhwb3MgKz0gb3RoZXJ2YXJzLm1pZFBvc1g7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIC0yOlxuXHRcdFx0XHRcdFx0aWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB4cG9zICs9IChjdHguY2FudmFzLndpZHRoLzIpL3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuXHRcdFx0XHRcdFx0ZWxzZSB4cG9zICs9IGN0eC5jYW52YXMud2lkdGggLyAyO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRcdFx0eHBvcyArPSB4cG9zICsgMiAqIG90aGVydmFycy5taWRQb3NYIC0gb3RoZXJ2YXJzLmJvcmRlclg7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHRpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8pIHhwb3MgKz0gY3R4LmNhbnZhcy53aWR0aC93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblx0XHRcdFx0XHRcdGVsc2UgeHBvcyArPSBjdHguY2FudmFzLndpZHRoO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHhwb3MgKz0gb3RoZXJ2YXJzLm1pZFBvc1g7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKHlwb3N2YWwpIHtcblx0XHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHR5cG9zICs9IG90aGVydmFycy5ib3JkZXJZO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0eXBvcyArPSBvdGhlcnZhcnMubWlkUG9zWTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgLTI6XG5cdFx0XHRcdFx0XHRpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8pIHlwb3MgKz0gKGN0eC5jYW52YXMuaGVpZ2h0LzIpL3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuXHRcdFx0XHRcdFx0ZWxzZSB5cG9zICs9IGN0eC5jYW52YXMuaGVpZ2h0IC8gMjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdHlwb3MgKz0geXBvcyArIDIgKiBvdGhlcnZhcnMubWlkUG9zWSAtIG90aGVydmFycy5ib3JkZXJZO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdFx0aWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB5cG9zICs9IGN0eC5jYW52YXMuaGVpZ2h0L3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuXHRcdFx0XHRcdFx0ZWxzZSB5cG9zICs9IGN0eC5jYW52YXMuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHlwb3MgKz0gb3RoZXJ2YXJzLm1pZFBvc1k7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJJTkNIQVJUXCIgOlxuXHRcdFx0XHRzd2l0Y2goY3R4LnRwZGF0YSkge1xuXHRcdFx0XHRcdGNhc2UgMCA6XG5cdFx0XHRcdFx0XHRzd2l0Y2godHBkcmF3KGN0eCxkYXRhLmRhdGFzZXRzWzBdKSkge1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwiUmFkYXJcIiA6XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGFuZ2xlPSgoMipNYXRoLlBJKS8oZGF0YS5sYWJlbHMubGVuZ3RoKSkqeHBvc3ZhbDtcblx0XHRcdFx0XHRcdFx0XHR5cG9zPWNhbGN1bGF0ZU9mZnNldChvdGhlcnZhcnMuY29uZmlnLmxvZ2FyaXRobWljLCB5cG9zdmFsLCBzdGF0RGF0YVswXVswXS5jYWxjdWxhdGVkU2NhbGUsIHN0YXREYXRhWzBdWzBdLnNjYWxlSG9wLGxpbWl0VG9DaGFydCk7XG5cdFx0XHRcdFx0XHRcdFx0eHBvcz1NYXRoLmNvcyhvdGhlcnZhcnMuY29uZmlnLnN0YXJ0QW5nbGUgKiBNYXRoLlBJIC8gMTgwIC0gYW5nbGUpICogeXBvcztcblx0XHRcdFx0XHRcdFx0XHR5cG9zPU1hdGguc2luKG90aGVydmFycy5jb25maWcuc3RhcnRBbmdsZSAqIE1hdGguUEkgLyAxODAgLSBhbmdsZSkgKiB5cG9zO1xuXHRcdFx0XHRcdFx0XHRcdHhwb3M9c3RhdERhdGFbMF1bMF0ubWlkUG9zWCArIHhwb3MrcGFkZGluZ1gxO1xuXHRcdFx0XHRcdFx0XHRcdHlwb3M9c3RhdERhdGFbMF1bMF0ubWlkUG9zWSAtIHlwb3MrcGFkZGluZ1kxO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwiTGluZVwiIDpcblx0XHRcdFx0XHRcdFx0XHR5cG9zPSBjYWxjdWxhdGVPZmZzZXQoc3RhdERhdGFbMF1bMF0ubG9nYXJpdGhtaWMsIHlwb3N2YWwsIHN0YXREYXRhWzBdWzBdLmNhbGN1bGF0ZWRTY2FsZSwgc3RhdERhdGFbMF1bMF0uc2NhbGVIb3AsbGltaXRUb0NoYXJ0KSAtIHN0YXREYXRhWzBdWzBdLnplcm9ZO1xuXHRcdFx0XHRcdFx0XHRcdHlwb3M9c3RhdERhdGFbMF1bMF0ueUF4aXNQb3MgLSB5cG9zK3BhZGRpbmdZMTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgeHBvc3ZhbF93az14cG9zdmFsO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGxpbWl0VG9DaGFydCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoeHBvc3ZhbF93azwwKXhwb3N2YWxfd2s9MDtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh4cG9zdmFsX3drPnN0YXREYXRhWzBdWzBdLm5iVmFsdWVIb3ApeHBvc3ZhbF93az1zdGF0RGF0YVswXVswXS5uYlZhbHVlSG9wO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR4cG9zPXN0YXREYXRhWzBdWzBdLnlBeGlzUG9zWCArIChzdGF0RGF0YVswXVswXS52YWx1ZUhvcCAqIHhwb3N2YWxfd2spK3BhZGRpbmdYMTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBcIkJhclwiIDpcblx0XHRcdFx0XHRcdFx0Y2FzZSBcIlN0YWNrZWRCYXJcIiA6XG5cdFx0XHRcdFx0XHRcdFx0eXBvcyA9IHN0YXREYXRhWzBdWzBdLnhBeGlzUG9zWSAtIGNhbGN1bGF0ZU9mZnNldChvdGhlcnZhcnMuY29uZmlnLmxvZ2FyaXRobWljLCB5cG9zdmFsICwgc3RhdERhdGFbMF1bMF0uY2FsY3VsYXRlZFNjYWxlLCBzdGF0RGF0YVswXVswXS5zY2FsZUhvcCxsaW1pdFRvQ2hhcnQpK3BhZGRpbmdZMTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgeHBvc3ZhbF93az14cG9zdmFsO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGxpbWl0VG9DaGFydCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoeHBvc3ZhbF93azwtMC41KXhwb3N2YWxfd2s9LTAuNTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh4cG9zdmFsX3drPmRhdGEubGFiZWxzLmxlbmd0aC0wLjUpeHBvc3ZhbF93az1kYXRhLmxhYmVscy5sZW5ndGgtMC41O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR4cG9zID0gc3RhdERhdGFbMF1bMF0ueUF4aXNQb3NYICsgc3RhdERhdGFbMF1bMF0udmFsdWVIb3AgKiAoeHBvc3ZhbF93ayswLjUpK3BhZGRpbmdYMTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBcIkhvcml6b250YWxTdGFja2VkQmFyXCIgOlxuXHRcdFx0XHRcdFx0XHRjYXNlIFwiSG9yaXpvbnRhbEJhclwiIDpcblx0XHRcdFx0XHRcdFx0XHR4cG9zID0gc3RhdERhdGFbMF1bMF0ueUF4aXNQb3NYICsgY2FsY3VsYXRlT2Zmc2V0KG90aGVydmFycy5jb25maWcubG9nYXJpdGhtaWMsIHhwb3N2YWwgLCBzdGF0RGF0YVswXVswXS5jYWxjdWxhdGVkU2NhbGUsIHN0YXREYXRhWzBdWzBdLnZhbHVlSG9wLGxpbWl0VG9DaGFydCkrcGFkZGluZ1gxO1xuXHRcdFx0XHRcdFx0XHRcdHZhciB4cG9zdmFsX3drPXlwb3N2YWw7XG5cdFx0XHRcdFx0XHRcdFx0aWYobGltaXRUb0NoYXJ0KXtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh4cG9zdmFsX3drPC0wLjUpeHBvc3ZhbF93az0tMC41O1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHhwb3N2YWxfd2s+ZGF0YS5sYWJlbHMubGVuZ3RoLTAuNSl4cG9zdmFsX3drPWRhdGEubGFiZWxzLmxlbmd0aC0wLjU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHlwb3MgPSBzdGF0RGF0YVswXVswXS54QXhpc1Bvc1kgLSBzdGF0RGF0YVswXVswXS5zY2FsZUhvcCAqICh4cG9zdmFsX3drKzAuNSkrcGFkZGluZ1kxO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdCAgICAgICAgXHRcdFx0XHRkZWZhdWx0IDpcblx0XHRcdFx0XHRcdFx0XHR4cG9zPXhwb3N2YWwrcGFkZGluZ1gxO1xuXHRcdFx0XHRcdFx0XHRcdHlwb3M9eXBvc3ZhbCtwYWRkaW5nWTE7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDE6IFxuXHRcdFx0XHRcdFx0c3dpdGNoKGN0eC50cGNoYXJ0KSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJQaWVcIiA6XG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJEb3VnaG51dFwiIDpcblx0XHRcdFx0XHRcdFx0Y2FzZSBcIlBvbGFyQXJlYVwiIDpcblx0XHRcdFx0XHRcdFx0XHRpZih4cG9zdmFsIDwgLTAuNDk5KXhwb3M9LTAuNDk5O1xuXHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYoeHBvc3ZhbCA+IGRhdGEubGVuZ3RoLTAuNTAxKSB4cG9zPWRhdGEubGVuZ3RoLTAuNTAxO1xuXHRcdFx0XHRcdFx0XHRcdGVsc2UgeHBvcz14cG9zdmFsO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBjdXJkYXRhPU1hdGgucm91bmQoeHBvcyk7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHN0YXJ0QW5nbGU9c3RhdERhdGFbY3VyZGF0YV0uc3RhcnRBbmdsZTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgc2VnbWVudEFuZ2xlPXN0YXREYXRhW2N1cmRhdGFdLnNlZ21lbnRBbmdsZTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZmlyc3RBbmdsZT1zdGF0RGF0YVtjdXJkYXRhXS5maXJzdEFuZ2xlO1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZWFsU3RhcnRBbmdsZT1zdGF0RGF0YVtjdXJkYXRhXS5yZWFsU3RhcnRBbmdsZTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZW5kQW5nbGU9c3RhdERhdGFbY3VyZGF0YV0uZW5kQW5nbGU7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGFuZ2xlPTIqTWF0aC5QSS0oc3RhcnRBbmdsZSsoeHBvcy1jdXJkYXRhKzAuNSkqc2VnbWVudEFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0XHRpZihjdHgudHBjaGFydD09XCJQb2xhckFyZWFcIilcblx0XHRcdFx0XHRcdFx0XHRcdHlwb3M9IGNhbGN1bGF0ZU9mZnNldChvdGhlcnZhcnMuY29uZmlnLmxvZ2FyaXRobWljLCB5cG9zdmFsLCBzdGF0RGF0YVswXS5jYWxjdWxhdGVkU2NhbGUsIHN0YXREYXRhWzBdLnNjYWxlSG9wKTtcblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHlwb3M9c3RhdERhdGFbMF0uaW50X3JhZGl1cyt5cG9zdmFsKihzdGF0RGF0YVswXS5leHRfcmFkaXVzLXN0YXREYXRhWzBdLmludF9yYWRpdXMpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZihsaW1pdFRvQ2hhcnQpe1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHlwb3M8LXN0YXREYXRhWzBdLmV4dF9yYWRpdXMpeXBvcz0tc3RhdERhdGFbMF0uZXh0X3JhZGl1cztcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh5cG9zPnN0YXREYXRhWzBdLmV4dF9yYWRpdXMpeXBvcz1zdGF0RGF0YVswXS5leHRfcmFkaXVzO1xuXHRcdFx0XHRcdFx0XHRcdH0gXG5cdFx0XHRcdFx0XHRcdFx0eHBvcz1NYXRoLmNvcyhhbmdsZSkgKiB5cG9zO1xuXHRcdFx0XHRcdFx0XHRcdHlwb3M9TWF0aC5zaW4oYW5nbGUpICogeXBvcztcblx0XHRcdFx0XHRcdFx0XHR4cG9zPXN0YXREYXRhWzBdLm1pZFBvc1ggKyB4cG9zK3BhZGRpbmdYMTtcblx0XHRcdFx0XHRcdFx0XHR5cG9zPXN0YXREYXRhWzBdLm1pZFBvc1kgLSB5cG9zK3BhZGRpbmdZMTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHQgICAgICAgIFx0XHRcdFx0ZGVmYXVsdCA6XG5cdFx0XHRcdFx0XHRcdFx0eHBvcz14cG9zdmFsK3BhZGRpbmdYMTtcblx0XHRcdFx0XHRcdFx0XHR5cG9zPXlwb3N2YWwrcGFkZGluZ1kxO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgICAgIFx0XHRcdFx0ZGVmYXVsdCA6XG5cdFx0XHRcdFx0XHR4cG9zPXhwb3N2YWwrcGFkZGluZ1gxO1xuXHRcdFx0XHRcdFx0eXBvcz15cG9zdmFsK3BhZGRpbmdZMTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJBQlNPTFVURVwiIDpcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHhwb3M9eHBvc3ZhbCtwYWRkaW5nWDE7XG5cdFx0XHRcdHlwb3M9eXBvc3ZhbCtwYWRkaW5nWTE7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXHRcdGlmKHNoYXBlPT1cIklNQUdFXCIpIHtcblx0XHRcdHZhciBpbWFnZVdpZHRoPWRyYXdTaGFwZVNldFZhbHVlKHNoYXBlc0luQ2hhcnQuaW1hZ2VXaWR0aCxpbWFnZS53aWR0aCk7XG5cdFx0XHR2YXIgaW1hZ2VIZWlnaHQ9ZHJhd1NoYXBlU2V0VmFsdWUoc2hhcGVzSW5DaGFydC5pbWFnZUhlaWdodCxpbWFnZS5oZWlnaHQpO1xuXHRcdFx0c3dpdGNoIChpbWFnZUFsaWduKSB7XG5cdFx0XHRcdGNhc2UgXCJsZWZ0XCI6XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJyaWdodFwiOlxuXHRcdFx0XHRcdHhwb3MgLT0gaW1hZ2VXaWR0aDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImNlbnRlclwiOlxuXHRcdFx0XHRcdHhwb3MgLT0gKGltYWdlV2lkdGggLyAyKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAoaW1hZ2VCYXNlbGluZSkge1xuXHRcdFx0XHRjYXNlIFwidG9wXCI6XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJib3R0b21cIjpcblx0XHRcdFx0XHR5cG9zIC09IGltYWdlSGVpZ2h0O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwibWlkZGxlXCI6XG5cdFx0XHRcdFx0eXBvcyAtPSAoaW1hZ2VIZWlnaHQgLyAyKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRcblx0XHRyZXR1cm4ge3hwb3M6eHBvcyx5cG9zOnlwb3N9O1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KGxvZ2FyaXRobWljLCB2YWwsIGNhbGN1bGF0ZWRTY2FsZSwgc2NhbGVIb3AsbGltaXRUb0NoYXJ0KSB7XG5cdFx0aWYgKCFsb2dhcml0aG1pYykgeyAvLyBubyBsb2dhcml0aG1pYyBzY2FsZVxuXHRcdFx0dmFyIG91dGVyVmFsdWUgPSBjYWxjdWxhdGVkU2NhbGUuc3RlcHMgKiBjYWxjdWxhdGVkU2NhbGUuc3RlcFZhbHVlO1xuXHRcdFx0dmFyIGFkanVzdGVkVmFsdWUgPSB2YWwgLSBjYWxjdWxhdGVkU2NhbGUuZ3JhcGhNaW47XG5cdFx0XHRpZihsaW1pdFRvQ2hhcnQpIHtcblx0XHRcdFx0dmFyIHNjYWxpbmdGYWN0b3IgPSBDYXBWYWx1ZShhZGp1c3RlZFZhbHVlIC8gb3V0ZXJWYWx1ZSwgMSwgMCk7XG5cdFx0XHRcdHJldHVybiAoc2NhbGVIb3AgKiBjYWxjdWxhdGVkU2NhbGUuc3RlcHMpICogc2NhbGluZ0ZhY3Rvcjtcblx0XHRcdH0gZWxzZSBcdHJldHVybiAoc2NhbGVIb3AgKiBjYWxjdWxhdGVkU2NhbGUuc3RlcHMpICogKGFkanVzdGVkVmFsdWUvb3V0ZXJWYWx1ZSk7XG5cdFx0fSBlbHNlIHsgLy8gbG9nYXJpdGhtaWMgc2NhbGVcblx0XHRcdHJldHVybiBDYXBWYWx1ZShsb2cxMCh2YWwpICogc2NhbGVIb3AgLSBsb2cxMChjYWxjdWxhdGVkU2NhbGUuZ3JhcGhNaW4pICogc2NhbGVIb3AsIHVuZGVmaW5lZCwgMCk7XG5cdFx0fVxuXHR9O1xuXHRmdW5jdGlvbiBDYXBWYWx1ZSh2YWx1ZVRvQ2FwLCBtYXhWYWx1ZSwgbWluVmFsdWUpIHtcblx0XHRpZiAoaXNOdW1iZXIobWF4VmFsdWUpKSB7XG5cdFx0XHRpZiAodmFsdWVUb0NhcCA+IG1heFZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiBtYXhWYWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGlzTnVtYmVyKG1pblZhbHVlKSkge1xuXHRcdFx0aWYgKHZhbHVlVG9DYXAgPCBtaW5WYWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gbWluVmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZVRvQ2FwO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGRyYXdTaGFwZVNldFZhbHVlKGRhdGF2YWwsZGVmdmFsKSB7XG5cdFx0aWYodHlwZW9mIGRhdGF2YWwgIT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGRhdGF2YWw7XG5cdFx0ZWxzZSByZXR1cm4gZGVmdmFsO1xuXHR9O1x0XG5cdFxuXHRmdW5jdGlvbiB4UG9zKGl0ZXJhdGlvbiwgZGF0YSx5QXhpc1Bvc1gsdmFsdWVIb3AsbmJWYWx1ZUhvcCkge1xuXHRcdHJldHVybiB5QXhpc1Bvc1ggKyAodmFsdWVIb3AgKiBpdGVyYXRpb24pO1xuXHR9O1xuXG59O1xuXG5mdW5jdGlvbiBhZGRJbnNfaGlnaExpZ2h0KGN0eCwgY29uZmlnLCBkYXRhLCBtb3ZlbWVudCwgYW5pbWF0aW9uQ291bnQsc3RhdERhdGEpe1xuXHR2YXIgc3BlY2lhbDtcblx0dmFyIHNoYXBlc1ZhcixzaGFwZUFkZGlucztcblx0dmFyIGksZGVjYWxSYWRpdXMscHJvcGVydHk7XG5cdHZhciBhZGRIaWdoTGlnaHQ9ZmFsc2UsdG90cmVhdDtcblx0dmFyIHJlY3RIZWlnaHQsIHJlY3RXaWR0aCwgcmF0aW87XG5cdGlmIChjdHgudHBkYXRhPT0wKXtcblx0XHRpZih0eXBlb2YgZGF0YS5zcGVjaWFsPT1cIm9iamVjdFwiKXNwZWNpYWw9ZGF0YS5zcGVjaWFsO1xuXHRcdGlmKHR5cGVvZiBkYXRhLnNoYXBlc0luQ2hhcnQgPT0gXCJvYmplY3RcIikgc2hhcGVzVmFyPWRhdGEuc2hhcGVzSW5DaGFydDtcblx0XHRlbHNlIHtcblx0XHRcdGRhdGEuc2hhcGVzSW5DaGFydD1bXTtcblx0XHRcdHNoYXBlc1Zhcj1kYXRhLnNoYXBlc0luQ2hhcnQ7XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdGlmKHR5cGVvZiBkYXRhWzBdLnNwZWNpYWw9PVwib2JqZWN0XCIpc3BlY2lhbD1kYXRhWzBdLnNwZWNpYWw7XG5cdFx0aWYodHlwZW9mIGRhdGFbMF0uc2hhcGVzSW5DaGFydCA9PSBcIm9iamVjdFwiKSBzaGFwZXNWYXI9ZGF0YVswXS5zaGFwZXNJbkNoYXJ0O1xuXHRcdGVsc2Uge1xuXHRcdFx0ZGF0YVswXS5zaGFwZXNJbkNoYXJ0PVtdO1xuXHRcdFx0c2hhcGVzVmFyPWRhdGFbMF0uc2hhcGVzSW5DaGFydDtcblx0XHR9XG5cdH1cblx0YWRkSGlnaExpZ2h0PWZhbHNlO1x0XG5cdGlmKHR5cGVvZiBzcGVjaWFsPT1cIm9iamVjdFwiKSB7XG5cdFx0Zm9yKGk9MDtpPHNwZWNpYWwubGVuZ3RoO2krKykge1xuXHRcdFx0dG90cmVhdD1mYWxzZTtcblx0XHRcdGlmKHR5cGVvZiBzcGVjaWFsW2ldLmFkZEluc19zaGFwZT09IFwidW5kZWZpbmVkXCIpc2hhcGVBZGRpbnM9XCJBUlJPV1wiIDtcblx0XHRcdGVsc2Ugc2hhcGVBZGRpbnM9c3BlY2lhbFtpXS5hZGRJbnNfc2hhcGUudG9VcHBlckNhc2UoKTtcblx0XHRcdHN3aXRjaChzaGFwZUFkZGlucykge1xuXHRcdFx0XHRjYXNlIFwiRUxMSVBTRVwiIDpcblx0XHRcdFx0XHRzd2l0Y2godHBkcmF3KGN0eCwodHlwZW9mIGRhdGEuZGF0YXNldHMgPT0gXCJvYmplY3RcIikgPyBkYXRhLmRhdGFzZXRzW3NwZWNpYWxbaV0ucG9zaV0gOiB1bmRlZmluZWQpKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFwiTGluZVwiIDpcblx0XHRcdFx0XHRcdGNhc2UgXCJSYWRhclwiIDpcblx0XHRcdFx0XHRcdFx0dG90cmVhdD10cnVlO1xuXHRcdFx0XHRcdFx0XHRhZGRIaWdoTGlnaHQ9dHJ1ZTtcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGhdPXtoaWdodExpZ2h0IDogdHJ1ZSB9O1xuXHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS5zaGFwZT0gc3BlY2lhbFtpXS5hZGRJbnNfc2hhcGU7XG5cdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLnBvc2l0aW9uPSBcImluY2hhcnRcIjtcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueDE9IHNwZWNpYWxbaV0ucG9zajtcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueTE9IGRhdGEuZGF0YXNldHNbc3BlY2lhbFtpXS5wb3NpXS5kYXRhW3NwZWNpYWxbaV0ucG9zal07XG5cdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLmVsbGlwc2VIZWlnaHQ9MzA7XG5cdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLmVsbGlwc2VXaWR0aD00MDtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJCYXJcIiA6XG5cdFx0XHRcdFx0XHRjYXNlIFwiU3RhY2tlZEJhclwiIDpcblx0XHRcdFx0XHRcdGNhc2UgXCJIb3Jpem9udGFsQmFyXCIgOlxuXHRcdFx0XHRcdFx0Y2FzZSBcIkhvcml6b250YWxTdGFja2VkQmFyXCIgOlxuXHRcdFx0XHRcdFx0XHR0b3RyZWF0PXRydWU7XG5cdFx0XHRcdFx0XHRcdGFkZEhpZ2hMaWdodD10cnVlO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aF09e2hpZ2h0TGlnaHQgOiB0cnVlIH07XG5cdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLnNoYXBlPSBzcGVjaWFsW2ldLmFkZEluc19zaGFwZTtcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ucG9zaXRpb249IFwiYWJzb2x1dGVcIjtcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueDE9IChzdGF0RGF0YVtzcGVjaWFsW2ldLnBvc2ldW3NwZWNpYWxbaV0ucG9zal0ueFBvc1JpZ2h0K3N0YXREYXRhW3NwZWNpYWxbaV0ucG9zaV1bc3BlY2lhbFtpXS5wb3NqXS54UG9zTGVmdCkvMjtcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueTE9IChzdGF0RGF0YVtzcGVjaWFsW2ldLnBvc2ldW3NwZWNpYWxbaV0ucG9zal0ueVBvc1RvcCtzdGF0RGF0YVtzcGVjaWFsW2ldLnBvc2ldW3NwZWNpYWxbaV0ucG9zal0ueVBvc0JvdHRvbSkvMjtcblx0XHRcdFx0XHRcdFx0cmVjdEhlaWdodD0xLjI1Kk1hdGguYWJzKHN0YXREYXRhW3NwZWNpYWxbaV0ucG9zaV1bc3BlY2lhbFtpXS5wb3NqXS55UG9zVG9wLXN0YXREYXRhW3NwZWNpYWxbaV0ucG9zaV1bc3BlY2lhbFtpXS5wb3NqXS55UG9zQm90dG9tKTtcblx0XHRcdFx0XHRcdFx0cmVjdFdpZHRoPTEuMjUqTWF0aC5hYnMoc3RhdERhdGFbc3BlY2lhbFtpXS5wb3NpXVtzcGVjaWFsW2ldLnBvc2pdLnhQb3NSaWdodC1zdGF0RGF0YVtzcGVjaWFsW2ldLnBvc2ldW3NwZWNpYWxbaV0ucG9zal0ueFBvc0xlZnQpO1xuXHRcdFx0XHRcdFx0XHRyYXRpbz1yZWN0V2lkdGgvcmVjdEhlaWdodDtcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0uZWxsaXBzZVdpZHRoPU1hdGguc3FydCgocmVjdFdpZHRoKnJlY3RXaWR0aCkgKyAocmF0aW8qcmF0aW8pICogKHJlY3RIZWlnaHQqcmVjdEhlaWdodCkpO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS5lbGxpcHNlSGVpZ2h0PXNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLmVsbGlwc2VXaWR0aC9yYXRpbztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiUGllXCIgOlxuXHRcdFx0XHRcdFx0Y2FzZSBcIkRvdWdobnV0XCIgOlxuXHRcdFx0XHRcdFx0Y2FzZSBcIlBvbGFyQXJlYVwiIDpcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cdFx0XHRcdFxuXHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLnN0cm9rZUNvbG9yPSBcImJsYWNrXCI7XG5cdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0uZmlsbENvbG9yPSBcImJsYWNrXCI7ICAgIFxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiQVJST1dcIiA6XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dG90cmVhdD10cnVlO1xuXHRcdFx0XHRcdGFkZEhpZ2hMaWdodD10cnVlO1xuXHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoXT17aGlnaHRMaWdodCA6IHRydWUgfTtcblx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS5zaGFwZT0gXCJhcnJvd1wiO1xuXHRcdFx0XHRcdHN3aXRjaCh0cGRyYXcoY3R4LCh0eXBlb2YgZGF0YS5kYXRhc2V0cyA9PSBcIm9iamVjdFwiKSA/IGRhdGEuZGF0YXNldHNbc3BlY2lhbFtpXS5wb3NpXSA6IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0XHRcdGNhc2UgXCJMaW5lXCIgOlxuXHRcdFx0XHRcdFx0Y2FzZSBcIlJhZGFyXCIgOlxuXHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS5wb3NpdGlvbj0gXCJpbmNoYXJ0XCI7XG5cdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLngxPSBzcGVjaWFsW2ldLnBvc2o7XG5cdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLnkxPSBkYXRhLmRhdGFzZXRzW3NwZWNpYWxbaV0ucG9zaV0uZGF0YVtzcGVjaWFsW2ldLnBvc2pdO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS5wYWRkaW5nWDE9IDMwO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS5wYWRkaW5nWTE9IC0zMDtcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueDI9IHNwZWNpYWxbaV0ucG9zajtcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueTI9IGRhdGEuZGF0YXNldHNbc3BlY2lhbFtpXS5wb3NpXS5kYXRhW3NwZWNpYWxbaV0ucG9zal07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIkJhclwiIDpcblx0XHRcdFx0XHRcdGNhc2UgXCJTdGFja2VkQmFyXCIgOlxuXHRcdFx0XHRcdFx0Y2FzZSBcIkhvcml6b250YWxCYXJcIiA6XG5cdFx0XHRcdFx0XHRjYXNlIFwiSG9yaXpvbnRhbFN0YWNrZWRCYXJcIiA6XG5cdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLnBvc2l0aW9uPSBcImFic29sdXRlXCI7XG5cdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLngyPSBzdGF0RGF0YVtzcGVjaWFsW2ldLnBvc2ldW3NwZWNpYWxbaV0ucG9zal0ueFBvc1JpZ2h0O1xuXHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS55Mj0gc3RhdERhdGFbc3BlY2lhbFtpXS5wb3NpXVtzcGVjaWFsW2ldLnBvc2pdLnlQb3NUb3A7XG5cdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLngxPSBzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS54Mjtcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueTE9IHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLnkyO1xuXHRcdFx0XHRcdFx0XHRpZihjdHgudHBjaGFydD09XCJCYXJcIiB8fCBjdHgudHBjaGFydD09XCJTdGFja2VkQmFyXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS54MT1zaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS54MSszMDtcblx0XHRcdFx0XHRcdFx0XHRpZihkYXRhLmRhdGFzZXRzW3NwZWNpYWxbaV0ucG9zaV0uZGF0YVtzcGVjaWFsW2ldLnBvc2pdPj0wKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS55MT0gc2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueTEtMzA7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLnkxPSBzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS55MSszMDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueTE9c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueTEtMzA7XG5cdFx0XHRcdFx0XHRcdFx0aWYoZGF0YS5kYXRhc2V0c1tzcGVjaWFsW2ldLnBvc2ldLmRhdGFbc3BlY2lhbFtpXS5wb3NqXT49MCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueDE9IHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLngxKzMwO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS54MT0gc2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueDEtMzA7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIlBpZVwiIDpcblx0XHRcdFx0XHRcdGNhc2UgXCJEb3VnaG51dFwiIDpcblx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIGNvbmZpZy5oaWdoTGlnaHRTZXQuZXhwYW5kT3V0UmFkaXVzPT1cIm51bWJlclwiKWRlY2FsUmFkaXVzPWNvbmZpZy5oaWdoTGlnaHRTZXQuZXhwYW5kT3V0UmFkaXVzO1xuXHRcdFx0XHRcdFx0XHRlbHNlIGRlY2FsUmFkaXVzPTA7XHRcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ucG9zaXRpb249IFwiaW5jaGFydFwiO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS5saW1pdFRvQ2hhcnQ9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS54MT0gc3BlY2lhbFtpXS5wb3NpO1xuXHRcdFx0XHRcdFx0XHRpZihjdHgudHBjaGFydD09XCJQaWVcIilcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLnkxPSAxLjMrZGVjYWxSYWRpdXM7XG5cdFx0XHRcdFx0XHRcdGVsc2Ugc2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueTE9IDErKDEwMCowLjMpLygxMDAtY29uZmlnLnBlcmNlbnRhZ2VJbm5lckN1dG91dCk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS54Mj0gc3BlY2lhbFtpXS5wb3NpO1xuXHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS55Mj0gMStkZWNhbFJhZGl1cztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiUG9sYXJBcmVhXCIgOlxuXHRcdFx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS5wb3NpdGlvbj0gXCJpbmNoYXJ0XCI7XG5cdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLmxpbWl0VG9DaGFydD0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLngxPSBzcGVjaWFsW2ldLnBvc2k7XG5cdFx0XHRcdFx0XHRcdHNoYXBlc1ZhcltzaGFwZXNWYXIubGVuZ3RoLTFdLnkxPSBkYXRhW3NwZWNpYWxbaV0ucG9zaV0udmFsdWUrMC4zKihzdGF0RGF0YVswXS5vdXRlclZhbC1zdGF0RGF0YVswXS5jYWxjdWxhdGVkU2NhbGUuZ3JhcGhNaW4pOztcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueDI9IHNwZWNpYWxbaV0ucG9zaTtcblx0XHRcdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0ueTI9IGRhdGFbc3BlY2lhbFtpXS5wb3NpXS52YWx1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVx0XHRcdFx0XG5cdFx0XHRcdFx0c2hhcGVzVmFyW3NoYXBlc1Zhci5sZW5ndGgtMV0uc3Ryb2tlQ29sb3I9IFwiYmxhY2tcIjtcblx0XHRcdFx0XHRzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS5maWxsQ29sb3I9IFwiYmxhY2tcIjsgICAgXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gb3ZlcndyaXRlIG9wdGlvbnM7XG5cdFx0XHRpZih0b3RyZWF0KSB7XG5cdFx0XHRcdGZvciAocHJvcGVydHkgaW4gY29uZmlnLmhpZ2hMaWdodFNldCkge1xuXHRcdFx0XHRcdGlmKHByb3BlcnR5LnN1YnN0cmluZygwLDcpPT1cImFkZEluc19cIikge1x0XHRcdCBcblx0XHRcdFx0XHRcdGV2YWwoXCJzaGFwZXNWYXJbc2hhcGVzVmFyLmxlbmd0aC0xXS5cIitwcm9wZXJ0eS5zdWJzdHJpbmcoNyw1MCkrXCI9Y29uZmlnLmhpZ2hMaWdodFNldFtwcm9wZXJ0eV07XCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdFxuXHRcdGlmKGFkZEhpZ2hMaWdodCkge1xuXHRcdFx0Ly8gZHJhdyBzaGFwZXM7XG5cdFx0XHRkcmF3U2hhcGVzKFwiSElHSExJR0hUXCIsIGN0eCwgZGF0YSxzdGF0RGF0YSwgMCwgMCAseyBjb25maWc6IGNvbmZpZ30pO1xuXHRcdFx0Ly8gcmVtb3ZlIHNoYXBlcztcblx0XHRcdGZvcihpPXNoYXBlc1Zhci5sZW5ndGgtMTtpPj0wO2ktLSkgc2hhcGVzVmFyLnNwbGljZShpLDEpO1xuXHRcdH1cblx0fVxuXG59O1xuIiwidmFyIG1vcmVJbkNoYXJ0RGF0YV9kZWZhdWx0PSB7XG5cdHBvc2l0aW9uIDogXCJJTkNIQVJUXCIsXG5cdGl0ZXIgOiBcImxhc3RcIixcblxuXHRsaW5rIDogXCJMaW5lXCIsXG5cdFxuXHQvLyBkZWZhdWx0IHZhbHVlcyBmb3IgTGluZTtcblx0bGlua1N0cm9rZUNvbG9yTGluZTogXCJibGFja1wiLFxuXHRsaW5rU3Ryb2tlU3R5bGVMaW5lIDogXCJzb2xpZFwiLCBcblx0bGlua1N0cm9rZVNpemVMaW5lOiAyLFxuXHRwYWRkaW5nVmFsWExpbmUgOiA0LFxuXHRwYWRkaW5nVmFsWUxpbmUgOiAwLFxuXHRwaWVQYWRkaW5nWSA6IDAuMSxcblx0cGFkZGluZ1ggOiAwLFxuXHRwYWRkaW5nWSA6IDAsXG5cblxuXHQvLyBkZWZhdWx0IHZhbHVlcyBmb3IgVHJpYW5nbGU7XG5cdGFycm93V2lkdGggOiAyLFxuXHRhcnJvd0hlaWdodCA6IDAuMSxcbi8vICAgICBcdGxpbmtGaWxsQ29sb3JUcmlhbmdsZSA6IG51bGwsXG5cdGxpbmtTdHJva2VDb2xvclRyaWFuZ2xlOiBcInJnYmEoMCwwLDAsMClcIixcblx0bGlua1N0cm9rZVN0eWxlVHJpYW5nbGUgOiBcInNvbGlkXCIsIFxuXHRsaW5rU3Ryb2tlU2l6ZVRyaWFuZ2xlOiAwLFxuXHRwYWRkaW5nVmFsWFRyaWFuZ2xlIDogNCxcblx0cGFkZGluZ1ZhbFlUcmlhbmdsZSA6IC0xNixcblx0XG5cdC8vIGRlZmF1bHQgZm9yIHRleHQ7XG5cdHRleHQgOiBcIjxWYWx1ZT5cIixcblx0Zm9udENvbG9yIDogXCJibGFja1wiLCBcblx0Zm9udFN0eWxlIDogXCJub3JtYWxcIixcblx0Zm9udFNpemUgOiAyNSxcblx0Zm9udEZhbWlseSA6IFwiJ0FyaWFsJ1wiLFxuXG5cdC8vIGRlZmF1bHQgZm9yIEltYWdlO1xuXHRpbWFnZUxvYWQgOiBudWxsLFxuXHRpbWFnZVBvcyA6IDEsICAgICAvLyAwIGJlZm9yZSB0ZXh0LCAxIGFmdGVyIHRleHQ7XG5cdGltYWdlV2lkdGggOiAyMCwgICBcblx0aW1hZ2VIZWlnaHQ6IDIwLCAgIFxuXG5cdHNwYWNlQmV0d2VlblRleHRBbmRJbWFnZSA6IDUsXG4vL1x0cmVsYXRpdmVJbWFnZVBvc2l0aW9uIDogXCJzbWFydFwiLFxuLy9cdHJvdGF0ZSA6IDAsXG5cblx0Ly8gUG9pbnQgcG9zaXRpb247XG5cblx0bGltaXRUb0NoYXJ0IDogZmFsc2UsXG5cdHgxIDogbnVsbCxcblx0eTEgOiBudWxsLFxuXHR4MiA6IG51bGwsXG5cdHkyIDogbnVsbCxcblx0eDMgOiBudWxsLFxuXHR5MyA6IG51bGwsXG5cdHg0IDogbnVsbCxcblx0eTQgOiBudWxsLFxuXHR4NSA6IG51bGwsXG5cdHk1IDogbnVsbCxcblx0eDYgOiBudWxsLFxuXHR5NiA6IG51bGwsXG5cdHg3IDogbnVsbCxcblx0eTcgOiBudWxsLFxuXHR4OCA6IG51bGwsXG5cdHk4IDogbnVsbCxcblx0eDkgOiBudWxsLFxuXHR5OSA6IG51bGwsXG5cdHgxMCA6IG51bGwsXG5cdHkxMCA6IG51bGwsXG5cdHBhZGRpbmdYMSA6IG51bGwsXG5cdHBhZGRpbmdZMSA6IG51bGwsXG5cdHBhZGRpbmdYMiA6IG51bGwsXG5cdHBhZGRpbmdZMiA6IG51bGwsXG5cdHBhZGRpbmdYMyA6IG51bGwsXG5cdHBhZGRpbmdZMyA6IG51bGwsXG5cdHBhZGRpbmdYNCA6IG51bGwsXG5cdHBhZGRpbmdZNCA6IG51bGwsXG5cdHBhZGRpbmdYNSA6IG51bGwsXG5cdHBhZGRpbmdZNSA6IG51bGwsXG5cdHBhZGRpbmdYNiA6IG51bGwsXG5cdHBhZGRpbmdZNiA6IG51bGwsXG5cdHBhZGRpbmdYNyA6IG51bGwsXG5cdHBhZGRpbmdZNyA6IG51bGwsXG5cdHBhZGRpbmdYOCA6IG51bGwsXG5cdHBhZGRpbmdZOCA6IG51bGwsXG5cdHBhZGRpbmdYOSA6IG51bGwsXG5cdHBhZGRpbmdZOSA6IG51bGwsXG5cdHBhZGRpbmdYMTAgOiBudWxsLFxuXHRwYWRkaW5nWTEwIDogbnVsbCxcblx0XG5cdC8vIFNwZWNpYWwgdmFsdWVzO1xuXHRhdm9pZE92ZXJ3cml0ZSA6IHRydWVcdFxuXHRcblx0XG59O1xuXG5mdW5jdGlvbiBwdXNoSW5HcmFwaERhdGEodHlwZV9jaGFydCxkYXRhLGNvbmZpZyxwdXNoSW5mb0RlZmF1bHQpIHtcblxuXHR2YXIgcHVzaGNvbmZpZyA9IChwdXNoSW5mb0RlZmF1bHQpID8gbWVyZ2VDaGFydENvbmZpZyhtb3JlSW5DaGFydERhdGFfZGVmYXVsdCwgcHVzaEluZm9EZWZhdWx0KSA6IG1vcmVJbkNoYXJ0RGF0YV9kZWZhdWx0O1xuXHR2YXIgcmVzY29uZmlnO1xuXG5cdHZhciBwdXNoSW5mbyxzaGFwZXNJbkNoYXJ0O1xuXHRpZih0eXBlb2YgZGF0YS5kYXRhc2V0cyA9PSBcIm9iamVjdFwiKSB7XG5cdFx0cHVzaEluZm89ZGF0YS5kYXRhc2V0cztcblx0XHRpZih0eXBlb2YgZGF0YS5zaGFwZXNJbkNoYXJ0ID09IFwidW5kZWZpbmVkXCIpIGRhdGEuc2hhcGVzSW5DaGFydD1bXTtcblx0XHRzaGFwZXNJbkNoYXJ0PWRhdGEuc2hhcGVzSW5DaGFydDtcblx0XHRmb3IgKHZhciBpPTA7aTxkYXRhLmRhdGFzZXRzLmxlbmd0aDtpKyspe1xuXHRcdFx0Zm9yKHZhciBqPTA7ajxkYXRhLmRhdGFzZXRzW2ldLmRhdGEubGVuZ3RoO2orKykge1xuXHRcdFx0XHRpZih0eXBlb2YgZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdIT1cInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0cmVzY29uZmlnID0gbWVyZ2VDaGFydENvbmZpZyhkYXRhLmRhdGFzZXRzW2ldLCBwdXNoY29uZmlnKTtcblx0XHRcdFx0XHRwdXNoSW5HcmFwaERhdGFTdWIodHlwZV9jaGFydC51cGNhc2UoKSxkYXRhLmRhdGFzZXRzW2ldLGksaixzaGFwZXNJbkNoYXJ0LGRhdGEsY29uZmlnLHJlc2NvbmZpZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0cHVzaEluZm89ZGF0YTtcblx0XHRpZih0eXBlb2YgZGF0YVswXS5zaGFwZXNJbkNoYXJ0ID09IFwidW5kZWZpbmVkXCIpIGRhdGFbMF0uc2hhcGVzSW5DaGFydD1bXTtcblx0XHRzaGFwZXNJbkNoYXJ0PWRhdGFbMF0uc2hhcGVzSW5DaGFydDtcblx0XHRmb3IgKHZhciBpPTA7aTxkYXRhLmxlbmd0aDtpKyspe1xuXHRcdFx0aWYodHlwZW9mIGRhdGFbaV0udmFsdWUgIT1cInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdHJlc2NvbmZpZyA9IG1lcmdlQ2hhcnRDb25maWcoZGF0YVtpXSwgcHVzaGNvbmZpZyk7XG5cdFx0XHRcdHB1c2hJbkdyYXBoRGF0YVN1Yih0eXBlX2NoYXJ0LnRvVXBwZXJDYXNlKCksZGF0YVtpXSxpLC0xLHNoYXBlc0luQ2hhcnQsZGF0YSxjb25maWcscmVzY29uZmlnKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZGF0YVswXS5zaGFwZXNJbkNoYXJ0WzBdLmF2b2lkT3ZlcndyaXRlPXB1c2hjb25maWcuYXZvaWRPdmVyd3JpdGU7XG5cdH1cblx0XG5cblx0ZnVuY3Rpb24gbWVyZ2VPcHRpb25Db25maWcoZGVmYXVsdHMsIHVzZXJEZWZpbmVkKSB7XG5cdFx0dmFyIHJldHVybk9iaiA9IHt9O1xuXHRcdGZvciAodmFyIGF0dHJuYW1lIGluIGRlZmF1bHRzKSB7XG5cdFx0XHRyZXR1cm5PYmpbYXR0cm5hbWVdID0gZGVmYXVsdHNbYXR0cm5hbWVdO1xuXHRcdH1cblx0XHRmb3IgKHZhciBhdHRybmFtZUJpcyBpbiB1c2VyRGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuT2JqW2F0dHJuYW1lQmlzXSA9IHVzZXJEZWZpbmVkW2F0dHJuYW1lQmlzXTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldHVybk9iajtcblx0fTtcblxuXG5cdGZ1bmN0aW9uIHB1c2hJbkdyYXBoRGF0YVN1Yih0eXBlX2NoYXJ0LHB1c2hJbmZvSSxpLGosc2hhcGVzSW5DaGFydCxkYXRhLGNvbmZpZyxyZXNjb25maWcpIHtcblxuICAgICAgICBcdHZhciBhZGRSYWRpdXM7XG5cdFx0c2hhcGVzSW5DaGFydFtzaGFwZXNJbkNoYXJ0Lmxlbmd0aF09bWVyZ2VPcHRpb25Db25maWcocmVzY29uZmlnLHB1c2hJbmZvSSk7XG5cdFxuXHRcdC8vIHB1c2ggc2hhcGVzSW5DaGFydCBpbmZvIGZvciB0aGUgcG9pbnRlcjtcblxuXHRcdHZhciBuZXdTaGFwZXM9c2hhcGVzSW5DaGFydFtzaGFwZXNJbkNoYXJ0Lmxlbmd0aC0xXTtcblxuXHRcdGlmIChuZXdTaGFwZXMudGV4dC5pbmRleE9mKFwiPFRpdGxlPlwiKSA+PSAwKSBuZXdTaGFwZXMudGV4dD1uZXdTaGFwZXMudGV4dC5yZXBsYWNlKFwiPFRpdGxlPlwiLHB1c2hJbmZvSS50aXRsZSk7XG5cdFx0aWYgKG5ld1NoYXBlcy50ZXh0LmluZGV4T2YoXCI8VmFsdWU+XCIpID49IDApe1xuXHRcdFx0aWYoaj09LTEpbmV3U2hhcGVzLnRleHQ9bmV3U2hhcGVzLnRleHQucmVwbGFjZShcIjxWYWx1ZT5cIixcIlwiK3B1c2hJbmZvSS52YWx1ZSk7XG5cdFx0XHRlbHNlIG5ld1NoYXBlcy50ZXh0PW5ld1NoYXBlcy50ZXh0LnJlcGxhY2UoXCI8VmFsdWU+XCIsXCJcIitwdXNoSW5mb0kuZGF0YVtqXSk7XG5cdFx0fVxuXHRcdHN3aXRjaChuZXdTaGFwZXMubGluay50b1VwcGVyQ2FzZSgpKSB7XG5cdFx0XHRjYXNlICBcIlRSSUFOR0xFXCIgOlxuXHRcdFx0XHR2YXIgY3VtdmFsPTA7XG5cdFx0XHRcdGZvcih2YXIgdmk9MDt2aTxkYXRhLmxlbmd0aDt2aSsrKWN1bXZhbD1jdW12YWwrMSpkYXRhW3ZpXS52YWx1ZTtcblx0XHRcdFx0dmFyIGFycm93V2lkdGg9KGN1bXZhbC8zNjApKm5ld1NoYXBlcy5hcnJvd1dpZHRoO1xuXHRcblx0XHRcdFx0bmV3U2hhcGVzLnNoYXBlID0gYW5ub3RhdGVUcmlhbmdsZUZ1bmN0aW9uO1xuXHRcdFx0XHRuZXdTaGFwZXMuc3Ryb2tlQ29sb3I9bmV3U2hhcGVzLmxpbmtTdHJva2VDb2xvckxpbmU7XG5cdFx0XHRcdG5ld1NoYXBlcy5zdHJva2VTdHlsZT1uZXdTaGFwZXMubGlua1N0cm9rZVN0eWxlTGluZTsgXG5cdFx0XHRcdG5ld1NoYXBlcy5zdHJva2VTaXplPW5ld1NoYXBlcy5saW5rU3Ryb2tlU2l6ZUxpbmU7XG5cdFx0XHRcdHN3aXRjaCh0eXBlX2NoYXJ0KSB7XG5cdFx0XHRcdFx0Y2FzZSBcIlBJRVwiIDpcblx0XHRcdFx0XHRjYXNlIFwiRE9VR0hOVVRcIiA6XG5cdFx0XHRcdFx0XHR2YXIgbXVsdFJhZGl1cztcblx0XHRcdFx0XHRcdHZhciBwZXJjZW50YWdlSW5uZXJDdXRvdXQ9NTA7XG5cdFx0XHRcdFx0XHRpZih0eXBlb2YgY29uZmlnLnBlcmNlbnRhZ2VJbm5lckN1dG91dCAhPSBcInVuZGVmaW5lZFwiKXBlcmNlbnRhZ2VJbm5lckN1dG91dD1jb25maWcucGVyY2VudGFnZUlubmVyQ3V0b3V0O1xuXHRcdFx0XHRcdFx0aWYodHlwZV9jaGFydC50b1VwcGVyQ2FzZSgpPT1cIkRPVUdITlVUXCIpbXVsdFJhZGl1cz0xMDAvKDEwMC1wZXJjZW50YWdlSW5uZXJDdXRvdXQpO1xuXHRcdFx0XHRcdFx0ZWxzZSBtdWx0UmFkaXVzPTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSYWRpdXM9MDtcblx0XHRcdFx0XHRcdGlmKHR5cGVvZiBwdXNoSW5mb0kuZXhwYW5kT3V0UmFkaXVzIT1cInVuZGVmaW5lZFwiKWFkZFJhZGl1cz0xKnB1c2hJbmZvSS5leHBhbmRPdXRSYWRpdXM7XG5cblx0XHRcdFx0XHRcdGlmKG5ld1NoYXBlcy54MT09bnVsbCluZXdTaGFwZXMueDE9ICAocHVzaEluZm9JLnZhbHVlPT0wID8gaSA6IE1hdGgubWF4KGktMC41LGktKGFycm93V2lkdGgvcHVzaEluZm9JLnZhbHVlKSkpO1xuXHRcdFx0XHRcdFx0aWYobmV3U2hhcGVzLnkxPT1udWxsKW5ld1NoYXBlcy55MT0gMC45OSthZGRSYWRpdXM7XG5cdFx0XHRcdFx0XHRpZihuZXdTaGFwZXMueDI9PW51bGwpbmV3U2hhcGVzLngyPSBpO1xuXHRcdFx0XHRcdFx0aWYobmV3U2hhcGVzLnkyPT1udWxsKW5ld1NoYXBlcy55MiA9MStuZXdTaGFwZXMuYXJyb3dIZWlnaHQrYWRkUmFkaXVzO1xuXHRcdFx0XHRcdFx0aWYobmV3U2hhcGVzLngzPT1udWxsKW5ld1NoYXBlcy54Mz0gKHB1c2hJbmZvSS52YWx1ZT09MCA/IGkgOiBNYXRoLm1pbihpKzAuNSxpKyhhcnJvd1dpZHRoL3B1c2hJbmZvSS52YWx1ZSkpKTtcblx0XHRcdFx0XHRcdGlmKG5ld1NoYXBlcy55Mz09bnVsbCluZXdTaGFwZXMueTMgPSAwLjk5K2FkZFJhZGl1cztcblx0XHRcdFx0XHRcdGlmKG5ld1NoYXBlcy54ND09bnVsbCluZXdTaGFwZXMueDQgPSBpO1xuXHRcdFx0XHRcdFx0aWYobmV3U2hhcGVzLnk0PT1udWxsKW5ld1NoYXBlcy55NCA9IDEuMithZGRSYWRpdXM7XG5cdFx0XHRcdFx0XHRpZihuZXdTaGFwZXMuZmlsbENvbG9yPT1udWxsKW5ld1NoYXBlcy5maWxsQ29sb3IgPXB1c2hJbmZvSS5jb2xvcjtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIlBPTEFSQVJFQVwiIDpcblx0XHRcdFx0XHRjYXNlIFwiTElORVwiIDpcblx0XHRcdFx0XHRjYXNlIFwiUkFEQVJcIiA6XG5cdFx0XHRcdFx0Y2FzZSBcIkJBUlwiIDpcblx0XHRcdFx0XHRjYXNlIFwiSE9SSVpPTlRBTEJBUlwiIDogXG5cdFx0XHRcdFx0Y2FzZSBcIlNUQUNLRURCQVJcIiA6XG5cdFx0XHRcdFx0Y2FzZSBcIkhPUklaT05UQUxTVEFDS0VEQkFSXCIgOiBcblx0XHRcdFx0XHRcdC8vIG5vdCBpbXBsZW1lbnRlZDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgIFwiTElORVwiIDpcdFxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0bmV3U2hhcGVzLnNoYXBlID0gYW5ub3RhdGVMaW5lRnVuY3Rpb247XG5cdFx0XHRcdG5ld1NoYXBlcy5zdHJva2VDb2xvcj1uZXdTaGFwZXMubGlua1N0cm9rZUNvbG9yTGluZTtcblx0XHRcdFx0bmV3U2hhcGVzLnN0cm9rZVN0eWxlPW5ld1NoYXBlcy5saW5rU3Ryb2tlU3R5bGVMaW5lOyBcblx0XHRcdFx0bmV3U2hhcGVzLnN0cm9rZVNpemU9bmV3U2hhcGVzLmxpbmtTdHJva2VTaXplTGluZTtcblx0XHRcdFx0c3dpdGNoKHR5cGVfY2hhcnQpIHtcblx0XHRcdFx0XHRjYXNlIFwiUElFXCIgOlxuXHRcdFx0XHRcdGNhc2UgXCJET1VHSE5VVFwiIDpcblx0XHRcdFx0XHRcdHZhciBtdWx0UmFkaXVzO1xuXHRcdFx0XHRcdFx0dmFyIHBlcmNlbnRhZ2VJbm5lckN1dG91dD01MDtcblx0XHRcdFx0XHRcdGlmKHR5cGVvZiBjb25maWcucGVyY2VudGFnZUlubmVyQ3V0b3V0ICE9IFwidW5kZWZpbmVkXCIpcGVyY2VudGFnZUlubmVyQ3V0b3V0PWNvbmZpZy5wZXJjZW50YWdlSW5uZXJDdXRvdXQ7XG5cdFx0XHRcdFx0XHRpZih0eXBlX2NoYXJ0LnRvVXBwZXJDYXNlKCk9PVwiRE9VR0hOVVRcIiltdWx0UmFkaXVzPTEwMC8oMTAwLXBlcmNlbnRhZ2VJbm5lckN1dG91dCk7XG5cdFx0XHRcdFx0XHRlbHNlIG11bHRSYWRpdXM9MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJhZGl1cz0wO1xuXHRcdFx0XHRcdFx0aWYodHlwZW9mIHB1c2hJbmZvSS5leHBhbmRPdXRSYWRpdXMhPVwidW5kZWZpbmVkXCIpYWRkUmFkaXVzPTEqcHVzaEluZm9JLmV4cGFuZE91dFJhZGl1cztcblx0XHRcdFx0XHRcdGlmKG5ld1NoYXBlcy54MT09bnVsbCluZXdTaGFwZXMueDE9aTtcblx0XHRcdFx0XHRcdGlmKG5ld1NoYXBlcy55MT09bnVsbCluZXdTaGFwZXMueTE9MSthZGRSYWRpdXM7XG5cdFx0XHRcdFx0XHRpZihuZXdTaGFwZXMueDI9PW51bGwpbmV3U2hhcGVzLngyPWk7XG5cdFx0XHRcdFx0XHRpZihuZXdTaGFwZXMueTI9PW51bGwpbmV3U2hhcGVzLnkyPTErbmV3U2hhcGVzLnBpZVBhZGRpbmdZKm11bHRSYWRpdXM7XG5cdFx0XHRcdFx0XHRpZihuZXdTaGFwZXMueDEwPT1udWxsKW5ld1NoYXBlcy54MTA9aTtcblx0XHRcdFx0XHRcdGlmKG5ld1NoYXBlcy55MTA9PW51bGwpbmV3U2hhcGVzLnkxMD0xLW11bHRSYWRpdXM7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiUE9MQVJBUkVBXCIgOlxuXHRcdFx0XHRcdGNhc2UgXCJMSU5FXCIgOlxuXHRcdFx0XHRcdGNhc2UgXCJSQURBUlwiIDpcblx0XHRcdFx0XHRjYXNlIFwiQkFSXCIgOlxuXHRcdFx0XHRcdGNhc2UgXCJIT1JJWk9OVEFMQkFSXCIgOiBcblx0XHRcdFx0XHRjYXNlIFwiU1RBQ0tFREJBUlwiIDpcblx0XHRcdFx0XHRjYXNlIFwiSE9SSVpPTlRBTFNUQUNLRURCQVJcIiA6IFxuXHRcdFx0XHRcdFx0Ly8gbm90IGltcGxlbWVudGVkO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0fVxuXHRcblx0XHQvLyBwdXNoIHNoYXBlc0luQ2hhcnQgaW5mbyBmb3IgdGhlIHRleHQgYW5kIEltYWdlO1xuXHRcblx0fSA7XG59O1xuXG5cbmZ1bmN0aW9uIGFubm90YXRlTGluZUZ1bmN0aW9uKGFyZWEsIGN0eCwgZGF0YSwgc3RhdERhdGEsIHBvc2kscG9zaixvdGhlcnZhcnMpe1xuXG5cdGlmICh0eXBlb2YgY3R4LnNwZWNpYWxJbkNoYXJ0RGF0YT09XCJ1bmRlZmluZWRcIiljdHguc3BlY2lhbEluQ2hhcnREYXRhPVtdO1xuXHQvKiBjb21wdXRlIHJhZGl1cyAqL1xuXHR2YXIgcmFkaXVzPSAoTWF0aC5zcXJ0KE1hdGgucG93KG90aGVydmFycy54eXBvczIueHBvcy1vdGhlcnZhcnMueHlwb3MxMC54cG9zLDIpKyBNYXRoLnBvdyhvdGhlcnZhcnMueHlwb3MyLnlwb3Mtb3RoZXJ2YXJzLnh5cG9zMTAueXBvcywyKSkpO1xuXG5cdHZhciB4bG4sIHlsbjtcblx0dmFyIHhpcCwgeWlwO1xuXHR2YXIgcGFkZGluZ1gsIHBhZGRpbmdZO1xuXHR2YXIgcGFkZGluZ1ZhbFg9b3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQucGFkZGluZ1ZhbFhMaW5lO1xuXHR2YXIgcGFkZGluZ1ZhbFk9b3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQucGFkZGluZ1ZhbFlMaW5lO1xuXG4vLyBsaW5lIHRvIGxhYmVsO1xuXHRcblx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdHhpcD1vdGhlcnZhcnMueHlwb3MyLnhwb3M7XG5cdHlpcD1vdGhlcnZhcnMueHlwb3MyLnlwb3M7XG5cblx0XHRcblx0aWYob3RoZXJ2YXJzLnh5cG9zMTAueHBvcz5vdGhlcnZhcnMueHlwb3MyLnhwb3MpIHtcblx0XHRjdHgudGV4dEFsaWduPVwicmlnaHRcIjtcblx0XHRwYWRkaW5nWD0tcGFkZGluZ1ZhbFg7XG5cdFx0eGxuPW90aGVydmFycy54eXBvczEwLnhwb3MtcmFkaXVzK290aGVydmFycy5zaGFwZXNJbkNoYXJ0LnBhZGRpbmdYO1xuXHRcdHlsbj1vdGhlcnZhcnMueHlwb3MyLnlwb3Mrb3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQucGFkZGluZ1k7XG5cdH0gZWxzZSB7XG5cdFx0Y3R4LnRleHRBbGlnbj1cImxlZnRcIjtcblx0XHRwYWRkaW5nWD1wYWRkaW5nVmFsWDtcblx0XHR4bG49cmFkaXVzICsgb3RoZXJ2YXJzLnh5cG9zMTAueHBvcytvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5wYWRkaW5nWDtcblx0XHR5bG49b3RoZXJ2YXJzLnh5cG9zMi55cG9zK290aGVydmFycy5zaGFwZXNJbkNoYXJ0LnBhZGRpbmdZO1xuXHR9XG5cblx0aWYoZGF0YVswXS5zaGFwZXNJbkNoYXJ0WzBdLmF2b2lkT3ZlcndyaXRlKSB7XG5cdFxuXHRcdGlmICh0eXBlb2YgY3R4LnNwZWNpYWxJbkNoYXJ0RGF0YS5wcmV2WWxuIT1cInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRpZihNYXRoLmFicyhjdHguc3BlY2lhbEluQ2hhcnREYXRhLnByZXZYbG4teGxuKTwwLjAwMSkge1xuXHRcdFx0XHRpZihvdGhlcnZhcnMueHlwb3MxMC54cG9zPG90aGVydmFycy54eXBvczIueHBvcykgeWxuPU1hdGgubWF4KHlsbixjdHguc3BlY2lhbEluQ2hhcnREYXRhLnByZXZZbG4rMS41Km90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmZvbnRTaXplKTtcblx0XHRcdFx0ZWxzZSB5bG49TWF0aC5taW4oeWxuLGN0eC5zcGVjaWFsSW5DaGFydERhdGEucHJldllsbi0xLjUqb3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuZm9udFNpemUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y3R4LnNwZWNpYWxJbkNoYXJ0RGF0YS5wcmV2WGxuPXhsbjtcblx0XHRjdHguc3BlY2lhbEluQ2hhcnREYXRhLnByZXZZbG49eWxuO1xuXHR9O1xuXG5cdGN0eC5iZWdpblBhdGgoKTtcblxuXHRjdHgubW92ZVRvKG90aGVydmFycy54eXBvczEueHBvcywgb3RoZXJ2YXJzLnh5cG9zMS55cG9zKTtcblx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeGlwLCB5aXAseGxuLCB5bG4pO1xuXHRjdHgubGluZVdpZHRoID0gb3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuc3Ryb2tlU2l6ZTtcblx0Y3R4LnN0cm9rZVN0eWxlID0gb3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuc3Ryb2tlQ29sb3I7XG5cdGN0eC5zZXRMaW5lRGFzaChsaW5lU3R5bGVGbihvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5zdHJva2VTdHlsZSkpO1x0XG5cdGN0eC5zdHJva2UoKTtcblxuLy8gc2V0IHRleHQvc2hhcGUgcG9zaXRpb247XG5cdGN0eC5iZWdpblBhdGgoKTtcblx0Y3R4LnRleHRCYXNlbGluZT1cIm1pZGRsZVwiO1xuXHRpZihvdGhlcnZhcnMueHlwb3MyLnlwb3M8b3RoZXJ2YXJzLnh5cG9zMS55cG9zKSB7XG5cdFx0cGFkZGluZ1k9LXBhZGRpbmdWYWxZO1xuXHR9IGVsc2Uge1xuXHRcdHBhZGRpbmdZPTEqcGFkZGluZ1ZhbFk7XG5cdH1cblxuLy8gZHJhdyBsYWJlbHMvaW1hZ2VzO1xuXHRkcmF3VGV4dEFuZEltYWdlKGFyZWEsIGN0eCwgZGF0YSxzdGF0RGF0YSwgcG9zaSxwb3NqLG90aGVydmFycyx4bG4rcGFkZGluZ1gsIHlsbitwYWRkaW5nWSk7XG5cbn07XG5cblxuZnVuY3Rpb24gYW5ub3RhdGVUcmlhbmdsZUZ1bmN0aW9uKGFyZWEsIGN0eCwgZGF0YSxzdGF0RGF0YSwgcG9zaSxwb3NqLG90aGVydmFycyl7XG5cblx0aWYgKHR5cGVvZiBjdHguc3BlY2lhbEluQ2hhcnREYXRhPT1cInVuZGVmaW5lZFwiKWN0eC5zcGVjaWFsSW5DaGFydERhdGE9W107XG5cbi8vIHRyaWFuZ2xlIHRvIGxhYmVsO1xuXHRjdHguYmVnaW5QYXRoKCk7XG5cdGlmKG90aGVydmFycy54eXBvczEueHBvcz09b3RoZXJ2YXJzLnh5cG9zMy54cG9zICYmIG90aGVydmFycy54eXBvczEueXBvcz09b3RoZXJ2YXJzLnh5cG9zMy55cG9zKSB7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuZmlsbENvbG9yO1xuXHRcdGN0eC5saW5lV2lkdGggPSAyO1xuXHRcdGN0eC5tb3ZlVG8ob3RoZXJ2YXJzLnh5cG9zMS54cG9zLCBvdGhlcnZhcnMueHlwb3MxLnlwb3MpO1xuXHRcdGN0eC5saW5lVG8ob3RoZXJ2YXJzLnh5cG9zMi54cG9zLCBvdGhlcnZhcnMueHlwb3MyLnlwb3MpO1xuXHR9IGVsc2Uge1x0XG5cdFx0Y3R4Lm1vdmVUbyhvdGhlcnZhcnMueHlwb3MxLnhwb3MsIG90aGVydmFycy54eXBvczEueXBvcyk7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IDA7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsMCwwLDApXCI7XG5cdFx0Y3R4LmxpbmVUbyhvdGhlcnZhcnMueHlwb3MyLnhwb3MsIG90aGVydmFycy54eXBvczIueXBvcyk7XG5cdFx0Y3R4LmxpbmVUbyhvdGhlcnZhcnMueHlwb3MzLnhwb3MsIG90aGVydmFycy54eXBvczMueXBvcyk7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdGN0eC5maWxsU3R5bGU9b3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuZmlsbENvbG9yO1xuXHRcdGN0eC5maWxsKCk7XG5cdH1cblx0Y3R4LnN0cm9rZSgpO1xuXG5cblxuLy8gc2V0IExhYmVsL2ltYWdlIHBvc2l0aW9uO1xuXHR2YXIgcGFkZGluZ1g9MDtcblx0dmFyIHBhZGRpbmdZPTA7XG5cdHZhciBwYWRkaW5nVmFsWD1vdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5wYWRkaW5nVmFsWFRyaWFuZ2xlO1xuXHR2YXIgcGFkZGluZ1ZhbFk9b3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQucGFkZGluZ1ZhbFlUcmlhbmdsZTtcblx0dmFyIHhsbj1vdGhlcnZhcnMueHlwb3M0Lnhwb3M7XG5cdHZhciB5bG49b3RoZXJ2YXJzLnh5cG9zNC55cG9zO1xuXG5cdGN0eC5iZWdpblBhdGgoKTtcblx0aWYob3RoZXJ2YXJzLnh5cG9zNC54cG9zPj1vdGhlcnZhcnMueHlwb3MyLnhwb3MpIHtcblx0XHRwYWRkaW5nWD1wYWRkaW5nVmFsWDtcblx0XHRjdHgudGV4dEFsaWduPVwibGVmdFwiO1xuXHR9IGVsc2Uge1xuXHRcdHBhZGRpbmdYPS1wYWRkaW5nVmFsWDtcblx0XHRjdHgudGV4dEFsaWduPVwicmlnaHRcIjtcblx0fVxuXHRcblx0Y3R4LnRleHRCYXNlbGluZT1cIm1pZGRsZVwiO1xuXG5cdGlmKGRhdGFbMF0uc2hhcGVzSW5DaGFydFswXS5hdm9pZE92ZXJ3cml0ZSkge1xuXHRcblx0XHRpZiAodHlwZW9mIGN0eC5zcGVjaWFsSW5DaGFydERhdGEucHJldllsbiE9XCJ1bmRlZmluZWRcIiAmJiBjdHgudGV4dEFsaWduPT1jdHguc3BlY2lhbEluQ2hhcnREYXRhLnRleHRBbGlnbikge1xuXHRcdFx0XHRpZihvdGhlcnZhcnMueHlwb3M0Lnhwb3M+PW90aGVydmFycy54eXBvczIueHBvcykgeyBcblx0XHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdFx0eWxuPU1hdGgubWF4KHlsbixjdHguc3BlY2lhbEluQ2hhcnREYXRhLnByZXZZbG4rMS41Km90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmZvbnRTaXplKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5bG49TWF0aC5taW4oeWxuLGN0eC5zcGVjaWFsSW5DaGFydERhdGEucHJldllsbi0xLjUqb3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuZm9udFNpemUpO1xuXHRcdFx0XHR9XG5cdFx0fVxuXHRcdGN0eC5zcGVjaWFsSW5DaGFydERhdGEucHJldlhsbj14bG47XG5cdFx0Y3R4LnNwZWNpYWxJbkNoYXJ0RGF0YS5wcmV2WWxuPXlsbjtcblx0fTtcblxuLy8gZHJhdyBsYWJlbHMvaW1hZ2VzO1xuXHRjdHguc3BlY2lhbEluQ2hhcnREYXRhLnByZXZNc3I9ZHJhd1RleHRBbmRJbWFnZShhcmVhLCBjdHgsIGRhdGEsc3RhdERhdGEsIHBvc2kscG9zaixvdGhlcnZhcnMseGxuK3BhZGRpbmdYLCB5bG4rcGFkZGluZ1kpO1xuICAgICAgICBjdHguc3BlY2lhbEluQ2hhcnREYXRhLnRleHRBbGlnbj1jdHgudGV4dEFsaWduO1xuICAgICAgICBjdHguc3BlY2lhbEluQ2hhcnREYXRhLnRleHRCYXNlbGluZT1jdHgudGV4dEJhc2VsaW5lO1xuICAgICAgICBcbn07XG5cbmZ1bmN0aW9uIGRyYXdUZXh0QW5kSW1hZ2UoYXJlYSwgY3R4LCBkYXRhLHN0YXREYXRhLCBwb3NpLHBvc2osb3RoZXJ2YXJzLHhwb3MseXBvcykge1xuXG5cdHZhciBwYWRkaW5nVGV4dFg9MDtcblx0dmFyIHBhZGRpbmdUZXh0WT0wO1xuXHR2YXIgcGFkZGluZ0ltYWdlWD0wO1xuXHR2YXIgcGFkZGluZ0ltYWdlWT0wO1xuXHR2YXIgbGd0PTA7XG5cdHZhciBoZ3Q9MDtcblx0dmFyIHR4dFNpemU9MDtcblx0XG5cdC8vIGNvbXB1dGUgcGFkZGluZyB2YWx1ZXM7XG5cdGlmKG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmltYWdlTG9hZCAhPSBudWxsICYmIG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LnRleHQgIT0gXCJcIikge1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dmFyIGZvbnRTaXplPW90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmZvbnRTaXplO1xuXHRcdGN0eC5mb250ID0gb3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuZm9udFN0eWxlICsgXCIgXCIgKyBvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5mb250U2l6ZS50b1N0cmluZygpICsgXCJweCBcIiArIG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmZvbnRGYW1pbHk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmZvbnRDb2xvcjtcblx0XHR0eHRTaXplPWN0eC5tZWFzdXJlVGV4dE11bHRpTGluZShvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC50ZXh0LG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmZvbnRTaXplKTtcblxuXHRcdGlmKG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmltYWdlUG9zPT0xICYmIGN0eC50ZXh0QWxpZ249PVwicmlnaHRcIikge1xuXHRcdFx0cGFkZGluZ1RleHRYPS0ob3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuaW1hZ2VXaWR0aCtvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5zcGFjZUJldHdlZW5UZXh0QW5kSW1hZ2UpO1xuXHRcdFx0cGFkZGluZ0ltYWdlWD0tKG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmltYWdlV2lkdGgpO1xuXHRcdH0gZWxzZSBpZihvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5pbWFnZVBvcz09MCAmJiBjdHgudGV4dEFsaWduPT1cImxlZnRcIikge1xuXHRcdFx0cGFkZGluZ1RleHRYPW90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmltYWdlV2lkdGgrb3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuc3BhY2VCZXR3ZWVuVGV4dEFuZEltYWdlO1xuXHRcdH0gZWxzZSBpZihvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5pbWFnZVBvcz09MCAmJiBjdHgudGV4dEFsaWduPT1cInJpZ2h0XCIpIHtcblx0XHRcdHBhZGRpbmdJbWFnZVg9LSh0eHRTaXplLnRleHRXaWR0aCtvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5zcGFjZUJldHdlZW5UZXh0QW5kSW1hZ2Urb3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuaW1hZ2VXaWR0aCk7XG5cdFx0fSBlbHNlIGlmKG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmltYWdlUG9zPT0xICYmIGN0eC50ZXh0QWxpZ249PVwibGVmdFwiKSB7XG5cdFx0XHRwYWRkaW5nSW1hZ2VYPXR4dFNpemUudGV4dFdpZHRoK290aGVydmFycy5zaGFwZXNJbkNoYXJ0LnNwYWNlQmV0d2VlblRleHRBbmRJbWFnZTtcblx0XHR9XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRsZ3Q9b3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuc3BhY2VCZXR3ZWVuVGV4dEFuZEltYWdlO1xuXHR9O1xuXG5cdC8vIGRyYXcgdGV4dDtcblx0aWYob3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQudGV4dCE9XCJcIikge1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LnRyYW5zbGF0ZSh4cG9zK3BhZGRpbmdUZXh0WCx5cG9zK3BhZGRpbmdUZXh0WSk7XG5cdFx0dmFyIGZvbnRTaXplPW90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmZvbnRTaXplO1xuXHRcdGN0eC5mb250ID0gb3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuZm9udFN0eWxlICsgXCIgXCIgKyBvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5mb250U2l6ZS50b1N0cmluZygpICsgXCJweCBcIiArIG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmZvbnRGYW1pbHk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmZvbnRDb2xvcjtcblx0XHRpZiAob3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuaXRlciAhPT1cImFsbFwiIHx8IChvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5pdGVyID09PSBcImFsbFwiICYmIG90aGVydmFycy5jbnRpdGVyICE9IG90aGVydmFycy5jb25maWcuYW5pbWF0aW9uU3RlcHMpIHx8IG90aGVydmFycy5jb25maWcuYW5pbWF0aW9uPT1mYWxzZSkge1xuXHRcdFx0Y3R4LmZpbGxUZXh0TXVsdGlMaW5lKG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LnRleHQsIDAsIDAsIGN0eC50ZXh0QmFzZWxpbmUsIE1hdGguY2VpbChjdHguY2hhcnRUZXh0U2NhbGUqZm9udFNpemUpLHRydWUsb3RoZXJ2YXJzLmNvbmZpZy5kZXRlY3RNb3VzZU9uVGV4dCxjdHgsXCJTSEFQRVNJTkNIQVJUX1RFWFRNT1VTRVwiLDAseHBvcytwYWRkaW5nVGV4dFgseXBvcytwYWRkaW5nVGV4dFksLTEsLTEpO1xuXHRcdH0gZWxzZSBjdHguZmlsbFRleHRNdWx0aUxpbmUob3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQudGV4dCwgMCwgMCwgY3R4LnRleHRCYXNlbGluZSwgTWF0aC5jZWlsKGN0eC5jaGFydFRleHRTY2FsZSpmb250U2l6ZSksdHJ1ZSxmYWxzZSxjdHgsXCJTSEFQRVNJTkNIQVJUX1RFWFRNT1VTRVwiLDAseHBvcytwYWRkaW5nVGV4dFgseXBvcytwYWRkaW5nVGV4dFksLTEsLTEpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0bGd0Kz10eHRTaXplO1xuXHRcdGhndD1NYXRoLm1heChoZ3QsMS41KiBvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5mb250U2l6ZSk7XG5cdH1cblx0Ly8gZHJhdyBpbWFnZTtcblx0aWYob3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuaW1hZ2VMb2FkICE9IG51bGwpIHtcblx0XHRwYWRkaW5nSW1hZ2VZPS0ob3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuaW1hZ2VIZWlnaHQtKCgyLzMpKnR4dFNpemUudGV4dEhlaWdodC8yKSk7XG5cblx0XHRjdHguc2F2ZSgpO1xuLy9cdFx0Y3R4LnRyYW5zbGF0ZSh4cG9zK3BhZGRpbmdJbWFnZVgsIHlwb3MrcGFkZGluZ0ltYWdlWSAtKG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmZvbnRTaXplLzIpK2ltYWdlQWZ0ZXJQYWRkaW5nWS0ob3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuaW1hZ2VBZnRlckhlaWdodC8yKSk7XG5cdFx0Y3R4LnRyYW5zbGF0ZSh4cG9zK3BhZGRpbmdJbWFnZVgsIHlwb3MrcGFkZGluZ0ltYWdlWSk7XG5cdFx0Y3R4LmRyYXdJbWFnZShvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5pbWFnZUxvYWQsIDAsIDAsb3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuaW1hZ2VMb2FkLndpZHRoLG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmltYWdlTG9hZC5oZWlnaHQsMCwgMCxvdGhlcnZhcnMuc2hhcGVzSW5DaGFydC5pbWFnZVdpZHRoLG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmltYWdlSGVpZ2h0KTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdGxndCs9b3RoZXJ2YXJzLnNoYXBlc0luQ2hhcnQuaW1hZ2VXaWR0aDtcblx0XHRoZ3Q9TWF0aC5tYXgoaGd0LG90aGVydmFycy5zaGFwZXNJbkNoYXJ0LmltYWdlV2lkdGguaW1hZ2VIZWlnaHQpO1xuXHR9XG5cdFxuXHRyZXR1cm4ge2hlaWdodCA6IGhndCx3aWR0aCA6IGxndH07XG5cblxuXG59O1xuXG5cblxuIiwiXG5mdW5jdGlvbiBzdGF0cyhkYXRhLCBjb25maWcpIHtcblx0ZGF0YS5zdGF0cyA9IHt9O1xuXHRpZiAodHlwZW9mIGRhdGEuZGF0YXNldHMgPT0gJ3VuZGVmaW5lZCcpIHsgLy8gUGllIHN0cnVjdHVyZTtcblx0XHRQU2Jhc2ljKGRhdGEpO1xuXHR9IGVsc2UgeyAvLyBsaW5lIHN0cnVjdHVyZTtcblx0XHRMU2Jhc2ljKGRhdGEpO1xuXHRcdExpbmVhcl9SZWdyZXNzaW9uKGRhdGEpO1xuXHR9XG5cdHJlcGxhY2Vfc3RhdHMoZGF0YSwgY29uZmlnKTtcblx0cmV0dXJuO1xufTtcblxuZnVuY3Rpb24gaXNTdGF0KHZhbCkge1xuXHRpZiAodHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiKSB7XG5cdFx0aWYgKHZhbC5pbmRleE9mKFwiI1wiKSA+PSAwKSByZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBMaW5lYXJfUmVncmVzc2lvbihkYXRhKSB7XG5cdC8vIGNvbXB1dGUgTWVhbnMgLSBzb3VyY2Ugb2YgYWxnb3JpdGhtIDogaHR0cDovL2ZyLndpa2lwZWRpYS5vcmcvd2lraS9SJUMzJUE5Z3Jlc3Npb25fbGluJUMzJUE5YWlyZVxuXHRkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2NvdW50X3hQb3MgPSAwO1xuXHRkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX3N1bV94UG9zID0gMDtcblx0ZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9zdW1fZGF0YSA9IDA7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICghKHR5cGVvZiBkYXRhLmRhdGFzZXRzW2ldLnhQb3MgPT0gXCJ1bmRlZmluZWRcIikpIHtcblx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fc3VtX3hQb3MgPSAwO1xuXHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9zdW1fZGF0YSA9IDA7XG5cdFx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2NvdW50X3hQb3MgPSAwO1xuXHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9kYXRhID0gMDtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmICghKHR5cGVvZiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gPT0gXCJ1bmRlZmluZWRcIikgJiYgISh0eXBlb2YgZGF0YS5kYXRhc2V0c1tpXS54UG9zW2pdID09IFwidW5kZWZpbmVkXCIpKSB7XG5cdFx0XHRcdFx0ZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9jb3VudF94UG9zKys7XG5cdFx0XHRcdFx0ZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9zdW1feFBvcyArPSBkYXRhLmRhdGFzZXRzW2ldLnhQb3Nbal07XG5cdFx0XHRcdFx0ZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9zdW1fZGF0YSArPSBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal07XG5cdFx0XHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9jb3VudF94UG9zKys7XG5cdFx0XHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9zdW1feFBvcyArPSBkYXRhLmRhdGFzZXRzW2ldLnhQb3Nbal07XG5cdFx0XHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9zdW1fZGF0YSArPSBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2NvdW50X3hQb3MgPiAwKSB7XG5cdFx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fbWVhbl94UG9zID0gZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9zdW1feFBvcyAvIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fY291bnRfeFBvcztcblx0XHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9tZWFuX2RhdGEgPSBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX3N1bV9kYXRhIC8gZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9jb3VudF94UG9zO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyBtZWFuO1xuXHRpZiAoZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9jb3VudF94UG9zID4gMCkge1xuXHRcdGRhdGEuc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fbWVhbl94UG9zID0gZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9zdW1feFBvcyAvIGRhdGEuc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fY291bnRfeFBvcztcblx0XHRkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX21lYW5fZGF0YSA9IGRhdGEuc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fc3VtX2RhdGEgLyBkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2NvdW50X3hQb3M7XG5cdH1cblx0Ly8gQ292YXJpYW5jZSAtIHZhcmlhbmNlO1xuXHRkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2NvdmFyaWFuY2UgPSAwO1xuXHRkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX3ZhcmlhbmNlID0gMDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKCEodHlwZW9mIGRhdGEuZGF0YXNldHNbaV0ueFBvcyA9PSBcInVuZGVmaW5lZFwiKSkge1xuXHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9jb3ZhcmlhbmNlID0gMDtcblx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fdmFyaWFuY2UgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhLmRhdGFzZXRzW2ldLmRhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKCEodHlwZW9mIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA9PSBcInVuZGVmaW5lZFwiKSAmJiAhKHR5cGVvZiBkYXRhLmRhdGFzZXRzW2ldLnhQb3Nbal0gPT0gXCJ1bmRlZmluZWRcIikpIHtcblx0XHRcdFx0XHRkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2NvdmFyaWFuY2UgKz0gKGRhdGEuZGF0YXNldHNbaV0ueFBvc1tqXSAtIGRhdGEuc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fbWVhbl94UG9zKSAqIChkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gLSBkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX21lYW5fZGF0YSk7XG5cdFx0XHRcdFx0ZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl92YXJpYW5jZSArPSAoZGF0YS5kYXRhc2V0c1tpXS54UG9zW2pdIC0gZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9tZWFuX3hQb3MpICogKGRhdGEuZGF0YXNldHNbaV0ueFBvc1tqXSAtIGRhdGEuc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fbWVhbl94UG9zKTtcblx0XHRcdFx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2NvdmFyaWFuY2UgKz0gKGRhdGEuZGF0YXNldHNbaV0ueFBvc1tqXSAtIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fbWVhbl94UG9zKSAqIChkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gLSBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX21lYW5fZGF0YSk7XG5cdFx0XHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl92YXJpYW5jZSArPSAoZGF0YS5kYXRhc2V0c1tpXS54UG9zW2pdIC0gZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9tZWFuX3hQb3MpICogKGRhdGEuZGF0YXNldHNbaV0ueFBvc1tqXSAtIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fbWVhbl94UG9zKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fY291bnRfeFBvcyA+IDApIHtcblx0XHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9jb3ZhcmlhbmNlIC89IGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fY291bnRfeFBvcztcblx0XHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl92YXJpYW5jZSAvPSBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2NvdW50X3hQb3M7XG5cdFx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fYjEgPSBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2NvdmFyaWFuY2UgLyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX3ZhcmlhbmNlO1xuXHRcdFx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2IwID0gZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9tZWFuX2RhdGEgLSBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2IxICogZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9tZWFuX3hQb3M7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIGIxIC0gYjA7XG5cdGlmIChkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2NvdW50X3hQb3MgPiAwKSB7XG5cdFx0ZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9jb3ZhcmlhbmNlIC89IGRhdGEuc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fY291bnRfeFBvcztcblx0XHRkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX3ZhcmlhbmNlIC89IGRhdGEuc3RhdHMubGluZWFyX3JlZ3Jlc3Npb25fY291bnRfeFBvcztcblx0XHRkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2IxID0gZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9jb3ZhcmlhbmNlIC8gZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl92YXJpYW5jZTtcblx0XHRkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2IwID0gZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9tZWFuX2RhdGEgLSBkYXRhLnN0YXRzLmxpbmVhcl9yZWdyZXNzaW9uX2IxICogZGF0YS5zdGF0cy5saW5lYXJfcmVncmVzc2lvbl9tZWFuX3hQb3M7XG5cdH1cbn1cblxuZnVuY3Rpb24gUFNiYXNpYyhkYXRhKSB7XG5cdGRhdGEuc3RhdHMuc3VtID0gMDtcblx0ZGF0YS5zdGF0cy5jb3VudF9hbGwgPSAwO1xuXHRkYXRhLnN0YXRzLmNvdW50X21pc3NpbmcgPSAwO1xuXHRkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nID0gMDtcblx0ZGF0YS5zdGF0cy5tZWFuID0gdW5kZWZpbmVkO1xuXHRkYXRhLnN0YXRzLnN1bV9zcXVhcmVfZGlmZl9tZWFuID0gMDtcblx0ZGF0YS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb24gPSB1bmRlZmluZWQ7XG5cdGRhdGEuc3RhdHMuc3RhbmRhcmRfZGV2aWF0aW9uX2VzdGltYXRpb24gPSB1bmRlZmluZWQ7XG5cdGRhdGEuc3RhdHMuc3R1ZGVudF90X3Rlc3QgPSB1bmRlZmluZWQ7XG5cdGRhdGEuc3RhdHMuY29lZmZpY2llbnRfdmFyaWF0aW9uID0gdW5kZWZpbmVkO1xuXHRkYXRhLnN0YXRzLmRhdGFfd2l0aF9zdGF0cyA9IGZhbHNlO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFbXCJsZW5ndGhcIl07IGkrKykge1xuXHRcdGlmICghaXNTdGF0KGRhdGFbaV0udmFsdWUpKSB7XG5cdFx0XHQoZGF0YS5zdGF0cy5jb3VudF9hbGwpICsrO1xuXHRcdH0gZWxzZSBkYXRhLnN0YXRzLmRhdGFfd2l0aF9zdGF0cyA9IHRydWU7XG5cdFx0aWYgKHR5cGVvZiBkYXRhW2ldLnZhbHVlID09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdChkYXRhLnN0YXRzLmNvdW50X21pc3NpbmcpICsrO1xuXHRcdH0gZWxzZSBpZiAoaXNTdGF0KGRhdGFbaV0udmFsdWUpKSB7fSBlbHNlIHtcblx0XHRcdChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nKSArKztcblx0XHRcdChkYXRhLnN0YXRzLnN1bSkgKz0gMSAqIGRhdGFbaV0udmFsdWU7XG5cdFx0fVxuXHR9XG5cdGlmIChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nID4gMCkge1xuXHRcdGRhdGEuc3RhdHMubWVhbiA9IGRhdGEuc3RhdHMuc3VtIC8gZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZztcblx0fVxuXHQvLyBzdW0gb2YgKHZhbC1tZWFuKTI7XG5cdC8vIHN1bSBvZiAodmFsLW1lYW4pMztcblx0ZGF0YS5zdGF0cy5zdW1fc3F1YXJlX2RpZmZfbWVhbiA9IDA7XG5cdGRhdGEuc3RhdHMuc3VtX3BvdzNfZGlmZl9tZWFuID0gMDtcblx0ZGF0YS5zdGF0cy5zdW1fcG93NF9kaWZmX21lYW4gPSAwO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFbXCJsZW5ndGhcIl07IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZGF0YVtpXS52YWx1ZSAhPSBcInVuZGVmaW5lZFwiICYmICFpc1N0YXQoZGF0YVtpXS52YWx1ZSkpIHtcblx0XHRcdGRhdGEuc3RhdHMuc3VtX3NxdWFyZV9kaWZmX21lYW4gKz0gTWF0aC5wb3coZGF0YVtpXS52YWx1ZSAtIGRhdGEuc3RhdHMubWVhbiwgMik7XG5cdFx0XHRkYXRhLnN0YXRzLnN1bV9wb3czX2RpZmZfbWVhbiArPSBNYXRoLnBvdyhkYXRhW2ldLnZhbHVlIC0gZGF0YS5zdGF0cy5tZWFuLCAzKTtcblx0XHRcdGRhdGEuc3RhdHMuc3VtX3BvdzRfZGlmZl9tZWFuICs9IE1hdGgucG93KGRhdGFbaV0udmFsdWUgLSBkYXRhLnN0YXRzLm1lYW4sIDQpO1xuXHRcdH1cblx0fVxuXHQvLyBzdGFuZGFyZCBkZXZpYXRpb247XG5cdGlmIChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nID4gMCkge1xuXHRcdGRhdGEuc3RhdHMudmFyaWFuY2UgPSBkYXRhLnN0YXRzLnN1bV9zcXVhcmVfZGlmZl9tZWFuIC8gZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZztcblx0XHRkYXRhLnN0YXRzLnN0YW5kYXJkX2RldmlhdGlvbiA9IE1hdGguc3FydChkYXRhLnN0YXRzLnN1bV9zcXVhcmVfZGlmZl9tZWFuIC8gZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyk7XG5cdFx0ZGF0YS5zdGF0cy5zdGFuZGFyZF9lcnJvcl9tZWFuID0gTWF0aC5zcXJ0KGRhdGEuc3RhdHMuc3VtX3NxdWFyZV9kaWZmX21lYW4pIC8gZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZztcblx0fVxuXHQvLyBzdGFuZGFyZCBkZXZpYXRpb24gZXN0aW1hdGlvbjtcblx0aWYgKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgPiAxKSB7XG5cdFx0ZGF0YS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbiA9IE1hdGguc3FydChkYXRhLnN0YXRzLnN1bV9zcXVhcmVfZGlmZl9tZWFuIC8gKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgLSAxKSk7XG5cdFx0aWYgKGRhdGEuc3RhdHMubWVhbiA+IDApIGRhdGEuc3RhdHMuY29lZmZpY2llbnRfdmFyaWF0aW9uID0gMTAwICogZGF0YS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbiAvIGRhdGEuc3RhdHMubWVhbjtcblx0XHRpZiAoZGF0YS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbiA+IDApIGRhdGEuc3RhdHMuc3R1ZGVudF90X3Rlc3QgPSBkYXRhLnN0YXRzLm1lYW4gLyAoZGF0YS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbiAvIE1hdGguc3FydChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nKSk7XG4vL1x0XHRjb25zb2xlLmxvZyhkYXRhLnN0YXRzLm1lYW4pO1xuLy9cdFx0Y29uc29sZS5sb2coZGF0YS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbik7XG4vL1x0XHRjb25zb2xlLmxvZyhkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nKTtcblx0fVxuXHQvLyBza2V3bmVzcztcblx0aWYgKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgPiAyKSB7XG5cdFx0ZGF0YS5zdGF0cy5za2V3bmVzcyA9IChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nICogZGF0YS5zdGF0cy5zdW1fcG93M19kaWZmX21lYW4pIC8gKE1hdGgucG93KGRhdGEuc3RhdHMuc3RhbmRhcmRfZGV2aWF0aW9uX2VzdGltYXRpb24sIDMpICogKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgLSAxKSAqIChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nIC0gMikpO1xuXHR9IGVsc2Uge1xuXHRcdGRhdGEuc3RhdHMuc2tld25lc3MgPSB1bmRlZmluZWQ7XG5cdH1cblx0Ly8ga3V0b3Npcztcblx0aWYgKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgPiAzKSB7XG5cdFx0ZGF0YS5zdGF0cy5rdXJ0b3NpcyA9IChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nICogKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgKyAxKSAqIGRhdGEuc3RhdHMuc3VtX3BvdzRfZGlmZl9tZWFuKSAvIChNYXRoLnBvdyhkYXRhLnN0YXRzLnN0YW5kYXJkX2RldmlhdGlvbl9lc3RpbWF0aW9uLCA0KSAqIChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nIC0gMSkgKiAoZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAtIDIpICogKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgLSAzKSkgLSAzICogKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgLSAxKSAqIChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nIC0gMSkgLyAoKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgLSAyKSAqIChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nIC0gMykpO1xuXHR9IGVsc2Uge1xuXHRcdGRhdGEuc3RhdHMua3VydG9zaXMgPSB1bmRlZmluZWQ7XG5cdH1cblx0Ly8gb3JkZXJpbmcgc3RhdHM7XG5cdHZhciBvcmRlclN0YXQgPSBuZXcgQXJyYXkoKTtcblx0Y250ID0gMDtcblx0Zm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodHlwZW9mIGRhdGFbaV0udmFsdWUgIT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNTdGF0KGRhdGFbaV0udmFsdWUpKSB7XG5cdFx0XHRvcmRlclN0YXRbY250XSA9IHtcblx0XHRcdFx0dmFsOiAxICogZGF0YVtpXS52YWx1ZSxcblx0XHRcdFx0b25lOiAxXG5cdFx0XHR9O1xuXHRcdFx0Y250Kys7XG5cdFx0fVxuXHR9XG5cdHZhciBzZXRTdGF0ID0gbmV3IEFycmF5KCk7XG5cdHNldFN0YXQgPSBQc3RhdHMob3JkZXJTdGF0LCBcIm9uZVwiKTtcblx0Zm9yIChpID0gMDsgaSA8IHNldFN0YXQubGVuZ3RoOyBpKyspIHtcblx0XHRkYXRhLnN0YXRzLm1pbmltdW0gPSBzZXRTdGF0W2ldLnJlcy5taW5pbXVtO1xuXHRcdGRhdGEuc3RhdHMubWluaW11bXBpID0gc2V0U3RhdFtpXS5yZXMubWluaW11bXBpO1xuXHRcdGRhdGEuc3RhdHMubWluaW11bXBqID0gc2V0U3RhdFtpXS5yZXMubWluaW11bXBqO1xuXHRcdGRhdGEuc3RhdHMubWF4aW11bSA9IHNldFN0YXRbaV0ucmVzLm1heGltdW07XG5cdFx0ZGF0YS5zdGF0cy5tYXhpbXVtcGkgPSBzZXRTdGF0W2ldLnJlcy5tYXhpbXVtcGk7XG5cdFx0ZGF0YS5zdGF0cy5tYXhpbXVtcGogPSBzZXRTdGF0W2ldLnJlcy5tYXhpbXVtcGo7XG5cdFx0ZGF0YS5zdGF0cy5RMCA9IHNldFN0YXRbaV0ucmVzLlEwO1xuXHRcdGRhdGEuc3RhdHMuUTEgPSBzZXRTdGF0W2ldLnJlcy5RMTtcblx0XHRkYXRhLnN0YXRzLlE1ID0gc2V0U3RhdFtpXS5yZXMuUTU7XG5cdFx0ZGF0YS5zdGF0cy5RMTAgPSBzZXRTdGF0W2ldLnJlcy5RMTA7XG5cdFx0ZGF0YS5zdGF0cy5RMjUgPSBzZXRTdGF0W2ldLnJlcy5RMjU7XG5cdFx0ZGF0YS5zdGF0cy5RNTAgPSBzZXRTdGF0W2ldLnJlcy5RNTA7XG5cdFx0ZGF0YS5zdGF0cy5RNzUgPSBzZXRTdGF0W2ldLnJlcy5RNzU7XG5cdFx0ZGF0YS5zdGF0cy5ROTAgPSBzZXRTdGF0W2ldLnJlcy5ROTA7XG5cdFx0ZGF0YS5zdGF0cy5ROTUgPSBzZXRTdGF0W2ldLnJlcy5ROTU7XG5cdFx0ZGF0YS5zdGF0cy5ROTkgPSBzZXRTdGF0W2ldLnJlcy5ROTk7XG5cdFx0ZGF0YS5zdGF0cy5RMTAwID0gc2V0U3RhdFtpXS5yZXMuUTEwMDtcblx0XHRkYXRhLnN0YXRzLm1lZGlhbiA9IHNldFN0YXRbaV0ucmVzLm1lZGlhbjtcblx0XHRkYXRhLnN0YXRzLmludGVycXVhcnRpbGVfcmFuZ2UgPSBkYXRhLnN0YXRzLlE3NSAtIGRhdGEuc3RhdHMuUTI1O1xuXHR9XG59O1xuXG5mdW5jdGlvbiBMU2Jhc2ljKGRhdGEpIHtcblx0ZGF0YS5zdGF0cy5zdW0gPSAwO1xuXHRkYXRhLnN0YXRzLmNvdW50X2FsbCA9IDA7XG5cdGRhdGEuc3RhdHMuY291bnRfbWlzc2luZyA9IDA7XG5cdGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgPSAwO1xuXHRkYXRhLnN0YXRzLm1lYW4gPSB1bmRlZmluZWQ7XG5cdGRhdGEuc3RhdHMuc3VtX3NxdWFyZV9kaWZmX21lYW4gPSAwO1xuXHRkYXRhLnN0YXRzLnN1bV9wb3czX2RpZmZfbWVhbiA9IDA7XG5cdGRhdGEuc3RhdHMuc3VtX3BvdzRfZGlmZl9tZWFuID0gMDtcblx0ZGF0YS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb24gPSB1bmRlZmluZWQ7XG5cdGRhdGEuc3RhdHMuc3RhbmRhcmRfZGV2aWF0aW9uX2VzdGltYXRpb24gPSB1bmRlZmluZWQ7XG5cdGRhdGEuc3RhdHMuc3R1ZGVudF90X3Rlc3QgPSB1bmRlZmluZWQ7XG5cdGRhdGEuc3RhdHMuY29lZmZpY2llbnRfdmFyaWF0aW9uID0gdW5kZWZpbmVkO1xuXHRkYXRhLnN0YXRzLmRhdGFfd2l0aF9zdGF0cyA9IGZhbHNlO1xuXHRkYXRhLnN0YXRzLmRhdGFfbWluaW11bSA9IHt9O1xuXHRkYXRhLnN0YXRzLmRhdGFfbWF4aW11bSA9IHt9O1xuXHRkYXRhLnN0YXRzLmRhdGFfbWluaW11bXBpID0ge307XG5cdGRhdGEuc3RhdHMuZGF0YV9tYXhpbXVtcGkgPSB7fTtcblx0ZGF0YS5zdGF0cy5kYXRhX21pbmltdW1waiA9IHt9O1xuXHRkYXRhLnN0YXRzLmRhdGFfbWF4aW11bXBqID0ge307XG5cdGRhdGEuc3RhdHMuZGF0YV9RMCA9IHt9O1xuXHRkYXRhLnN0YXRzLmRhdGFfUTEgPSB7fTtcblx0ZGF0YS5zdGF0cy5kYXRhX1E1ID0ge307XG5cdGRhdGEuc3RhdHMuZGF0YV9RMTAgPSB7fTtcblx0ZGF0YS5zdGF0cy5kYXRhX1EyNSA9IHt9O1xuXHRkYXRhLnN0YXRzLmRhdGFfUTUwID0ge307XG5cdGRhdGEuc3RhdHMuZGF0YV9RNzUgPSB7fTtcblx0ZGF0YS5zdGF0cy5kYXRhX1E5MCA9IHt9O1xuXHRkYXRhLnN0YXRzLmRhdGFfUTk1ID0ge307XG5cdGRhdGEuc3RhdHMuZGF0YV9ROTkgPSB7fTtcblx0ZGF0YS5zdGF0cy5kYXRhX1ExMDAgPSB7fTtcblx0ZGF0YS5zdGF0cy5kYXRhX21lZGlhbiA9IHt9O1xuXHRkYXRhLnN0YXRzLmRhdGFfc3VtID0ge307XG5cdGRhdGEuc3RhdHMuZGF0YV9jb3VudF9hbGwgPSB7fTtcblx0ZGF0YS5zdGF0cy5kYXRhX2NvdW50X21pc3NpbmcgPSB7fTtcblx0ZGF0YS5zdGF0cy5kYXRhX2NvdW50X25vdF9taXNzaW5nID0ge307XG5cdGRhdGEuc3RhdHMuZGF0YV9tZWFuID0ge307XG5cdGRhdGEuc3RhdHMuZGF0YV9zdW1fc3F1YXJlX2RpZmZfbWVhbiA9IHt9O1xuXHRkYXRhLnN0YXRzLmRhdGFfc3VtX3BvdzNfZGlmZl9tZWFuID0ge307XG5cdGRhdGEuc3RhdHMuZGF0YV9zdW1fcG93NF9kaWZmX21lYW4gPSB7fTtcblx0ZGF0YS5zdGF0cy5kYXRhX3ZhcmlhbmNlID0ge307XG5cdGRhdGEuc3RhdHMuZGF0YV9zdGFuZGFyZF9kZXZpYXRpb24gPSB7fTtcblx0ZGF0YS5zdGF0cy5kYXRhX3N0YW5kYXJkX2Vycm9yX21lYW4gPSB7fTtcblx0ZGF0YS5zdGF0cy5kYXRhX3N0YW5kYXJkX2RldmlhdGlvbl9lc3RpbWF0aW9uID0ge307XG5cdGRhdGEuc3RhdHMuZGF0YV9zdHVkZW50X3RfdGVzdCA9IHt9O1xuXHRkYXRhLnN0YXRzLmRhdGFfY29lZmZpY2llbnRfdmFyaWF0aW9uID0ge307XG5cdGRhdGEuc3RhdHMuZGF0YV9za2V3bmVzcyA9IHt9O1xuXHRkYXRhLnN0YXRzLmRhdGFfa3VydG9zaXMgPSB7fTtcblx0ZGF0YS5zdGF0cy5kYXRhX2ludGVycXVhcnRpbGVfcmFuZ2UgPSB7fTtcblx0ZGF0YS5zdGF0cy5tYXhfbnVtYmVyX2RhdGEgPSAwO1xuXHRkYXRhLnN0YXRzLm1pbl9udW1iZXJfZGF0YSA9IE51bWJlci5NQVhfVkFMVUU7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0c1tcImxlbmd0aFwiXTsgaSsrKSB7XG5cdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cyA9IHt9O1xuXHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3VtID0gMDtcblx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X2FsbCA9IDA7XG5cdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9taXNzaW5nID0gMDtcblx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X25vdF9taXNzaW5nID0gMDtcblx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLm1lYW4gPSB1bmRlZmluZWQ7XG5cdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5zdW1fc3F1YXJlX2RpZmZfbWVhbiA9IDA7XG5cdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5zdW1fcG93M19kaWZmX21lYW4gPSAwO1xuXHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3VtX3BvdzRfZGlmZl9tZWFuID0gMDtcblx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnN0YW5kYXJkX2RldmlhdGlvbiA9IHVuZGVmaW5lZDtcblx0XHRpZiAoZGF0YS5kYXRhc2V0c1tpXS5kYXRhW1wibGVuZ3RoXCJdID4gZGF0YS5zdGF0cy5tYXhfbnVtYmVyX2RhdGEpIHtcblx0XHRcdGZvciAodmFyIGsgPSBkYXRhLnN0YXRzLm1heF9udW1iZXJfZGF0YTsgayA8IGRhdGEuZGF0YXNldHNbaV0uZGF0YVtcImxlbmd0aFwiXTsgaysrKSB7XG5cdFx0XHRcdGRhdGEuc3RhdHMuZGF0YV9zdW1ba10gPSAwO1xuXHRcdFx0XHRkYXRhLnN0YXRzLmRhdGFfY291bnRfYWxsW2tdID0gMDtcblx0XHRcdFx0ZGF0YS5zdGF0cy5kYXRhX2NvdW50X21pc3Npbmdba10gPSAwO1xuXHRcdFx0XHRkYXRhLnN0YXRzLmRhdGFfY291bnRfbm90X21pc3Npbmdba10gPSAwO1xuXHRcdFx0XHRkYXRhLnN0YXRzLmRhdGFfbWVhbltrXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0ZGF0YS5zdGF0cy5kYXRhX3N1bV9zcXVhcmVfZGlmZl9tZWFuW2tdID0gMDtcblx0XHRcdFx0ZGF0YS5zdGF0cy5kYXRhX3N1bV9wb3czX2RpZmZfbWVhbltrXSA9IDA7XG5cdFx0XHRcdGRhdGEuc3RhdHMuZGF0YV9zdW1fcG93NF9kaWZmX21lYW5ba10gPSAwO1xuXHRcdFx0XHRkYXRhLnN0YXRzLmRhdGFfc3RhbmRhcmRfZGV2aWF0aW9uW2tdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRkYXRhLnN0YXRzLmRhdGFfc3RhbmRhcmRfZGV2aWF0aW9uX2VzdGltYXRpb25ba10gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGRhdGEuc3RhdHMuZGF0YV9zdHVkZW50X3RfdGVzdFtrXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0ZGF0YS5zdGF0cy5kYXRhX2NvZWZmaWNpZW50X3ZhcmlhdGlvbltrXSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGRhdGEuc3RhdHMubWF4X251bWJlcl9kYXRhID0gZGF0YS5kYXRhc2V0c1tpXS5kYXRhW1wibGVuZ3RoXCJdO1xuXHRcdFx0ZGF0YS5zdGF0cy5taW5fbnVtYmVyX2RhdGEgPSBNYXRoLm1pbihkYXRhLnN0YXRzLm1pbl9udW1iZXJfZGF0YSwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhW1wibGVuZ3RoXCJdKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbXCJsZW5ndGhcIl07IGorKykge1xuXHRcdFx0aWYgKCFpc1N0YXQoZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdKSkge1xuXHRcdFx0XHQoZGF0YS5zdGF0cy5jb3VudF9hbGwpICsrO1xuXHRcdFx0XHQoZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9hbGwpICsrO1xuXHRcdFx0XHQoZGF0YS5zdGF0cy5kYXRhX2NvdW50X2FsbFtqXSkgKys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhLnN0YXRzLmRhdGFfd2l0aF9zdGF0cyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdChkYXRhLnN0YXRzLmNvdW50X21pc3NpbmcpICsrO1xuXHRcdFx0XHQoZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9taXNzaW5nKSArKztcblx0XHRcdFx0KGRhdGEuc3RhdHMuZGF0YV9jb3VudF9taXNzaW5nW2pdKSArKztcblx0XHRcdH0gZWxzZSBpZiAoaXNTdGF0KGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSkpIHt9IGVsc2Uge1xuXHRcdFx0XHQoZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZykgKys7XG5cdFx0XHRcdChkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X25vdF9taXNzaW5nKSArKztcblx0XHRcdFx0KGRhdGEuc3RhdHMuZGF0YV9jb3VudF9ub3RfbWlzc2luZ1tqXSkgKys7XG5cdFx0XHRcdChkYXRhLnN0YXRzLnN1bSkgKz0gMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXTtcblx0XHRcdFx0KGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3VtKSArPSAxICogZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdO1xuXHRcdFx0XHQoZGF0YS5zdGF0cy5kYXRhX3N1bVtqXSkgKz0gMSAqIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuY291bnRfbm90X21pc3NpbmcgPT0gMCkge1xuXHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5taW5pbXVtID0gdW5kZWZpbmVkO1xuXHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5taW5pbXVtcGkgPSB1bmRlZmluZWQ7XG5cdFx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLm1pbmltdW1waiA9IHVuZGVmaW5lZDtcblx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubWF4aW11bSA9IHVuZGVmaW5lZDtcblx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubWF4aW11bXBpID0gdW5kZWZpbmVkO1xuXHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5tYXhpbXVtcGogPSB1bmRlZmluZWQ7XG5cdFx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnN1bSA9IHVuZGVmaW5lZDtcblx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubWVhbiA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5tZWFuID0gZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5zdW0gLyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X25vdF9taXNzaW5nO1xuXHRcdH1cblx0fVxuXHRpZiAoZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyA+IDApIHtcblx0XHRkYXRhLnN0YXRzLm1lYW4gPSBkYXRhLnN0YXRzLnN1bSAvIGRhdGEuc3RhdHMuY291bnRfbm90X21pc3Npbmc7XG5cdH1cblx0Zm9yIChpID0gMDsgaSA8IGRhdGEuc3RhdHMubWF4X251bWJlcl9kYXRhOyBpKyspIHtcblx0XHRpZiAoZGF0YS5zdGF0cy5kYXRhX2NvdW50X25vdF9taXNzaW5nW2ldID4gMCkge1xuXHRcdFx0ZGF0YS5zdGF0cy5kYXRhX21lYW5baV0gPSBkYXRhLnN0YXRzLmRhdGFfc3VtW2ldIC8gZGF0YS5zdGF0cy5kYXRhX2NvdW50X25vdF9taXNzaW5nW2ldO1xuXHRcdH1cblx0fVxuXHQvLyBzdW0gb2YgKHZhbC1tZWFuKTI7XG5cdGRhdGEuc3RhdHMuc3VtX3NxdWFyZV9kaWZmX21lYW4gPSAwO1xuXHRkYXRhLnN0YXRzLnN1bV9wb3czX2RpZmZfbWVhbiA9IDA7XG5cdGRhdGEuc3RhdHMuc3VtX3BvdzRfZGlmZl9tZWFuID0gMDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmRhdGFzZXRzW1wibGVuZ3RoXCJdOyBpKyspIHtcblx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnN1bV9zcXVhcmVfZGlmZl9tZWFuID0gMDtcblx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnN1bV9wb3czX2RpZmZfbWVhbiA9IDA7XG5cdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5zdW1fcG93NF9kaWZmX21lYW4gPSAwO1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhW1wibGVuZ3RoXCJdOyBqKyspIHtcblx0XHRcdGlmICh0eXBlb2YgZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdICE9IFwidW5kZWZpbmVkXCIgJiYgIWlzU3RhdChkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0udmFsdWUpKSB7XG5cdFx0XHRcdGRhdGEuc3RhdHMuc3VtX3NxdWFyZV9kaWZmX21lYW4gKz0gTWF0aC5wb3coZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdIC0gZGF0YS5zdGF0cy5tZWFuLCAyKTtcblx0XHRcdFx0ZGF0YS5zdGF0cy5zdW1fcG93M19kaWZmX21lYW4gKz0gTWF0aC5wb3coZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdIC0gZGF0YS5zdGF0cy5tZWFuLCAzKTtcblx0XHRcdFx0ZGF0YS5zdGF0cy5zdW1fcG93NF9kaWZmX21lYW4gKz0gTWF0aC5wb3coZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdIC0gZGF0YS5zdGF0cy5tZWFuLCA0KTtcblx0XHRcdFx0ZGF0YS5zdGF0cy5kYXRhX3N1bV9zcXVhcmVfZGlmZl9tZWFuW2pdICs9IE1hdGgucG93KGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSAtIGRhdGEuc3RhdHMuZGF0YV9tZWFuW2pdLCAyKTtcblx0XHRcdFx0ZGF0YS5zdGF0cy5kYXRhX3N1bV9wb3czX2RpZmZfbWVhbltqXSArPSBNYXRoLnBvdyhkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gLSBkYXRhLnN0YXRzLmRhdGFfbWVhbltqXSwgMyk7XG5cdFx0XHRcdGRhdGEuc3RhdHMuZGF0YV9zdW1fcG93NF9kaWZmX21lYW5bal0gKz0gTWF0aC5wb3coZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdIC0gZGF0YS5zdGF0cy5kYXRhX21lYW5bal0sIDQpO1xuXHRcdFx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnN1bV9zcXVhcmVfZGlmZl9tZWFuICs9IE1hdGgucG93KGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSAtIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubWVhbiwgMik7XG5cdFx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3VtX3BvdzNfZGlmZl9tZWFuICs9IE1hdGgucG93KGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSAtIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubWVhbiwgMyk7XG5cdFx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3VtX3BvdzRfZGlmZl9tZWFuICs9IE1hdGgucG93KGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSAtIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubWVhbiwgNCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIHN0YW5kYXJkIGRldmlhdGlvbjtcblx0aWYgKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgPiAwKSB7XG5cdFx0ZGF0YS5zdGF0cy52YXJpYW5jZSA9IGRhdGEuc3RhdHMuc3VtX3NxdWFyZV9kaWZmX21lYW4gLyBkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nO1xuXHRcdGRhdGEuc3RhdHMuc3RhbmRhcmRfZGV2aWF0aW9uID0gTWF0aC5zcXJ0KGRhdGEuc3RhdHMuc3VtX3NxdWFyZV9kaWZmX21lYW4gLyBkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nKTtcblx0XHRkYXRhLnN0YXRzLnN0YW5kYXJkX2Vycm9yX21lYW4gPSBNYXRoLnNxcnQoZGF0YS5zdGF0cy5zdW1fc3F1YXJlX2RpZmZfbWVhbikgLyBkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nO1xuXHR9XG5cdGZvciAoaSA9IDA7IGkgPCBkYXRhLmRhdGFzZXRzW1wibGVuZ3RoXCJdOyBpKyspIHtcblx0XHRpZiAoZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyA+IDApIHtcblx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMudmFyaWFuY2UgPSBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnN1bV9zcXVhcmVfZGlmZl9tZWFuIC8gZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZztcblx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3RhbmRhcmRfZGV2aWF0aW9uID0gTWF0aC5zcXJ0KGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3VtX3NxdWFyZV9kaWZmX21lYW4gLyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X25vdF9taXNzaW5nKTtcblx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3RhbmRhcmRfZXJyb3JfbWVhbiA9IE1hdGguc3FydChkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnN1bV9zcXVhcmVfZGlmZl9tZWFuKSAvIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuY291bnRfbm90X21pc3Npbmc7XG5cdFx0fVxuXHR9XG5cdGZvciAoaiA9IDA7IGogPCBkYXRhLnN0YXRzLm1heF9udW1iZXJfZGF0YTsgaisrKSB7XG5cdFx0aWYgKGRhdGEuc3RhdHMuZGF0YV9jb3VudF9ub3RfbWlzc2luZ1tqXSA+IDApIHtcblx0XHRcdGRhdGEuc3RhdHMuZGF0YV92YXJpYW5jZVtqXSA9IGRhdGEuc3RhdHMuZGF0YV9zdW1fc3F1YXJlX2RpZmZfbWVhbltqXSAvIGRhdGEuc3RhdHMuZGF0YV9jb3VudF9ub3RfbWlzc2luZ1tqXTtcblx0XHRcdGRhdGEuc3RhdHMuZGF0YV9zdGFuZGFyZF9kZXZpYXRpb25bal0gPSBNYXRoLnNxcnQoZGF0YS5zdGF0cy5kYXRhX3N1bV9zcXVhcmVfZGlmZl9tZWFuW2pdIC8gZGF0YS5zdGF0cy5kYXRhX2NvdW50X25vdF9taXNzaW5nW2pdKTtcblx0XHRcdGRhdGEuc3RhdHMuZGF0YV9zdGFuZGFyZF9lcnJvcl9tZWFuW2pdID0gTWF0aC5zcXJ0KGRhdGEuc3RhdHMuZGF0YV9zdW1fc3F1YXJlX2RpZmZfbWVhbltqXSkgLyBkYXRhLnN0YXRzLmRhdGFfY291bnRfbm90X21pc3Npbmdbal07XG5cdFx0fVxuXHR9XG5cdC8vIHN0YW5kYXJkIGRldmlhdGlvbiBlc3RpbWF0aW9uO1xuXHRpZiAoZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyA+IDEpIHtcblx0XHRkYXRhLnN0YXRzLnN0YW5kYXJkX2RldmlhdGlvbl9lc3RpbWF0aW9uID0gTWF0aC5zcXJ0KGRhdGEuc3RhdHMuc3VtX3NxdWFyZV9kaWZmX21lYW4gLyAoZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAtIDEpKTtcblx0XHRpZiAoZGF0YS5zdGF0cy5tZWFuID4gMCkgZGF0YS5zdGF0cy5jb2VmZmljaWVudF92YXJpYXRpb24gPSAxMDAgKiBkYXRhLnN0YXRzLnN0YW5kYXJkX2RldmlhdGlvbl9lc3RpbWF0aW9uIC8gZGF0YS5zdGF0cy5tZWFuO1xuXHRcdGlmIChkYXRhLnN0YXRzLnN0YW5kYXJkX2RldmlhdGlvbl9lc3RpbWF0aW9uID4gMCkgZGF0YS5zdGF0cy5zdHVkZW50X3RfdGVzdCA9IGRhdGEuc3RhdHMubWVhbiAvIChkYXRhLnN0YXRzLnN0YW5kYXJkX2RldmlhdGlvbl9lc3RpbWF0aW9uIC8gTWF0aC5zcXJ0KGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcpKTtcblx0fVxuXHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0c1tcImxlbmd0aFwiXTsgaSsrKSB7XG5cdFx0aWYgKGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuY291bnRfbm90X21pc3NpbmcgPiAxKSB7XG5cdFx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnN0YW5kYXJkX2RldmlhdGlvbl9lc3RpbWF0aW9uID0gTWF0aC5zcXJ0KGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3VtX3NxdWFyZV9kaWZmX21lYW4gLyAoZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAtIDEpKTtcblx0XHRcdGlmIChkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLm1lYW4gPiAwKSBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvZWZmaWNpZW50X3ZhcmlhdGlvbiA9IDEwMCAqIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3RhbmRhcmRfZGV2aWF0aW9uX2VzdGltYXRpb24gLyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLm1lYW47XG5cdFx0XHRpZiAoZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbiA+IDApIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3R1ZGVudF90X3Rlc3QgPSBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLm1lYW4gLyAoZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbiAvIE1hdGguc3FydChkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X25vdF9taXNzaW5nKSk7XG5cdFx0fVxuXHR9XG5cdGZvciAoaiA9IDA7IGogPCBkYXRhLnN0YXRzLm1heF9udW1iZXJfZGF0YTsgaisrKSB7XG5cdFx0aWYgKGRhdGEuc3RhdHMuZGF0YV9jb3VudF9ub3RfbWlzc2luZ1tqXSA+IDEpIHtcblx0XHRcdGRhdGEuc3RhdHMuZGF0YV9zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbltqXSA9IE1hdGguc3FydChkYXRhLnN0YXRzLmRhdGFfc3VtX3NxdWFyZV9kaWZmX21lYW5bal0gLyAoZGF0YS5zdGF0cy5kYXRhX2NvdW50X25vdF9taXNzaW5nW2pdIC0gMSkpO1xuXHRcdFx0aWYgKGRhdGEuc3RhdHMuZGF0YV9tZWFuW2pdID4gMCkgZGF0YS5zdGF0cy5kYXRhX2NvZWZmaWNpZW50X3ZhcmlhdGlvbltqXSA9IDEwMCAqIGRhdGEuc3RhdHMuZGF0YV9zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbltqXSAvIGRhdGEuc3RhdHMuZGF0YV9tZWFuW2pdO1xuXHRcdFx0aWYgKGRhdGEuc3RhdHMuZGF0YV9zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbltqXSA+IDApIGRhdGEuc3RhdHMuZGF0YV9zdHVkZW50X3RfdGVzdFtqXSA9IGRhdGEuc3RhdHMuZGF0YV9tZWFuW2pdIC8gKGRhdGEuc3RhdHMuZGF0YV9zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbltqXSAvIE1hdGguc3FydChkYXRhLnN0YXRzLmRhdGFfY291bnRfbm90X21pc3Npbmdbal0pKTtcblx0XHR9XG5cdH1cblx0Ly8gc2tld25lc3M7XG5cdGlmIChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nID49IDIpIHtcblx0XHRkYXRhLnN0YXRzLnNrZXduZXNzID0gKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgKiBkYXRhLnN0YXRzLnN1bV9wb3czX2RpZmZfbWVhbikgLyAoTWF0aC5wb3coZGF0YS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbiwgMykgKiAoZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAtIDEpICogKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgLSAyKSk7XG5cdH0gZWxzZSB7XG5cdFx0ZGF0YS5zdGF0cy5za2V3bmVzcyA9IHVuZGVmaW5lZDtcblx0fVxuXHQvLyBrdXJ0b3Npcztcblx0aWYgKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgPj0gMykge1xuXHRcdGRhdGEuc3RhdHMua3VydG9zaXMgPSAoZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAqIChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nICsgMSkgKiBkYXRhLnN0YXRzLnN1bV9wb3c0X2RpZmZfbWVhbikgLyAoTWF0aC5wb3coZGF0YS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbiwgNCkgKiAoZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAtIDEpICogKGRhdGEuc3RhdHMuY291bnRfbm90X21pc3NpbmcgLSAyKSAqIChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nIC0gMykpIC0gMyAqIChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nIC0gMSkgKiAoZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAtIDEpIC8gKChkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nIC0gMikgKiAoZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAtIDMpKTtcblx0fSBlbHNlIHtcblx0XHRkYXRhLnN0YXRzLmt1cnRvc2lzID0gdW5kZWZpbmVkO1xuXHR9XG5cdGZvciAoaSA9IDA7IGkgPCBkYXRhLmRhdGFzZXRzW1wibGVuZ3RoXCJdOyBpKyspIHtcblx0XHRpZiAoZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyA+PSAyKSB7XG5cdFx0XHRkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnNrZXduZXNzID0gKGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuY291bnRfbm90X21pc3NpbmcgKiBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnN1bV9wb3czX2RpZmZfbWVhbikgLyAoTWF0aC5wb3coZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbiwgMykgKiAoZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAtIDEpICogKGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuY291bnRfbm90X21pc3NpbmcgLSAyKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc2tld25lc3MgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X25vdF9taXNzaW5nID49IDMpIHtcblx0XHRcdGRhdGEuZGF0YXNldHNbaV0uc3RhdHMua3VydG9zaXMgPSAoZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAqIChkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X25vdF9taXNzaW5nICsgMSkgKiBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnN1bV9wb3c0X2RpZmZfbWVhbikgLyAoTWF0aC5wb3coZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb25fZXN0aW1hdGlvbiwgNCkgKiAoZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAtIDEpICogKGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuY291bnRfbm90X21pc3NpbmcgLSAyKSAqIChkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X25vdF9taXNzaW5nIC0gMykpIC0gMyAqIChkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X25vdF9taXNzaW5nIC0gMSkgKiAoZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAtIDEpIC8gKChkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X25vdF9taXNzaW5nIC0gMikgKiAoZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyAtIDMpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5rdXJ0b3NpcyA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0Zm9yIChqID0gMDsgaiA8IGRhdGEuc3RhdHMubWF4X251bWJlcl9kYXRhOyBqKyspIHtcblx0XHRpZiAoZGF0YS5zdGF0cy5kYXRhX2NvdW50X25vdF9taXNzaW5nW2pdID49IDIpIHtcblx0XHRcdGRhdGEuc3RhdHMuZGF0YV9za2V3bmVzc1tqXSA9IChkYXRhLnN0YXRzLmRhdGFfY291bnRfbm90X21pc3Npbmdbal0gKiBkYXRhLnN0YXRzLmRhdGFfc3VtX3BvdzNfZGlmZl9tZWFuW2pdKSAvIChNYXRoLnBvdyhkYXRhLnN0YXRzLmRhdGFfc3RhbmRhcmRfZGV2aWF0aW9uX2VzdGltYXRpb25bal0sIDMpICogKGRhdGEuc3RhdHMuZGF0YV9jb3VudF9ub3RfbWlzc2luZ1tqXSAtIDEpICogKGRhdGEuc3RhdHMuZGF0YV9jb3VudF9ub3RfbWlzc2luZ1tqXSAtIDIpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YS5zdGF0cy5kYXRhX3NrZXduZXNzW2pdID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5zdGF0cy5kYXRhX2NvdW50X25vdF9taXNzaW5nW2pdID49IDMpIHtcblx0XHRcdGRhdGEuc3RhdHMuZGF0YV9rdXJ0b3Npc1tqXSA9IChkYXRhLnN0YXRzLmRhdGFfY291bnRfbm90X21pc3Npbmdbal0gKiAoZGF0YS5zdGF0cy5kYXRhX2NvdW50X25vdF9taXNzaW5nW2pdICsgMSkgKiBkYXRhLnN0YXRzLmRhdGFfc3VtX3BvdzRfZGlmZl9tZWFuW2pdKSAvIChNYXRoLnBvdyhkYXRhLnN0YXRzLmRhdGFfc3RhbmRhcmRfZGV2aWF0aW9uX2VzdGltYXRpb25bal0sIDQpICogKGRhdGEuc3RhdHMuZGF0YV9jb3VudF9ub3RfbWlzc2luZ1tqXSAtIDEpICogKGRhdGEuc3RhdHMuZGF0YV9jb3VudF9ub3RfbWlzc2luZ1tqXSAtIDIpICogKGRhdGEuc3RhdHMuZGF0YV9jb3VudF9ub3RfbWlzc2luZ1tqXSAtIDMpKSAtIDMgKiAoZGF0YS5zdGF0cy5kYXRhX2NvdW50X25vdF9taXNzaW5nW2pdIC0gMSkgKiAoZGF0YS5zdGF0cy5kYXRhX2NvdW50X25vdF9taXNzaW5nW2pdIC0gMSkgLyAoKGRhdGEuc3RhdHMuZGF0YV9jb3VudF9ub3RfbWlzc2luZ1tqXSAtIDIpICogKGRhdGEuc3RhdHMuZGF0YV9jb3VudF9ub3RfbWlzc2luZ1tqXSAtIDMpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YS5zdGF0cy5kYXRhX2t1cnRvc2lzW2pdID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHQvLyBvcmRlcmluZyBzdGF0cztcblx0dmFyIG9yZGVyU3RhdCA9IG5ldyBBcnJheSgpO1xuXHRjbnQgPSAwO1xuXHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0c1tcImxlbmd0aFwiXTsgaSsrKSB7XG5cdFx0Zm9yIChqID0gMDsgaiA8IGRhdGEuZGF0YXNldHNbaV0uZGF0YVtcImxlbmd0aFwiXTsgaisrKSB7XG5cdFx0XHRpZiAodHlwZW9mIGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSAhPSBcInVuZGVmaW5lZFwiICYmICFpc1N0YXQoZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdLnZhbHVlKSkge1xuXHRcdFx0XHRvcmRlclN0YXRbY250XSA9IHtcblx0XHRcdFx0XHR2YWw6IDEgKiBkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0sXG5cdFx0XHRcdFx0ZGF0YXNldDogaSxcblx0XHRcdFx0XHRjb2w6IGosXG5cdFx0XHRcdFx0b25lOiAxXG5cdFx0XHRcdH07XG5cdFx0XHRcdGNudCsrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHR2YXIgc2V0U3RhdCA9IG5ldyBBcnJheSgpO1xuXHRzZXRTdGF0ID0gUHN0YXRzKG9yZGVyU3RhdCwgXCJvbmVcIik7XG5cdGZvciAoaSA9IDA7IGkgPCBzZXRTdGF0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0ZGF0YS5zdGF0cy5taW5pbXVtID0gc2V0U3RhdFtpXS5yZXMubWluaW11bTtcblx0XHRkYXRhLnN0YXRzLm1pbmltdW1waSA9IHNldFN0YXRbaV0ucmVzLm1pbmltdW1waTtcblx0XHRkYXRhLnN0YXRzLm1pbmltdW1waiA9IHNldFN0YXRbaV0ucmVzLm1pbmltdW1wajtcblx0XHRkYXRhLnN0YXRzLm1heGltdW0gPSBzZXRTdGF0W2ldLnJlcy5tYXhpbXVtO1xuXHRcdGRhdGEuc3RhdHMubWF4aW11bXBpID0gc2V0U3RhdFtpXS5yZXMubWF4aW11bXBpO1xuXHRcdGRhdGEuc3RhdHMubWF4aW11bXBqID0gc2V0U3RhdFtpXS5yZXMubWF4aW11bXBqO1xuXHRcdGRhdGEuc3RhdHMuUTAgPSBzZXRTdGF0W2ldLnJlcy5RMDtcblx0XHRkYXRhLnN0YXRzLlExID0gc2V0U3RhdFtpXS5yZXMuUTE7XG5cdFx0ZGF0YS5zdGF0cy5RNSA9IHNldFN0YXRbaV0ucmVzLlE1O1xuXHRcdGRhdGEuc3RhdHMuUTEwID0gc2V0U3RhdFtpXS5yZXMuUTEwO1xuXHRcdGRhdGEuc3RhdHMuUTI1ID0gc2V0U3RhdFtpXS5yZXMuUTI1O1xuXHRcdGRhdGEuc3RhdHMuUTUwID0gc2V0U3RhdFtpXS5yZXMuUTUwO1xuXHRcdGRhdGEuc3RhdHMuUTc1ID0gc2V0U3RhdFtpXS5yZXMuUTc1O1xuXHRcdGRhdGEuc3RhdHMuUTkwID0gc2V0U3RhdFtpXS5yZXMuUTkwO1xuXHRcdGRhdGEuc3RhdHMuUTk1ID0gc2V0U3RhdFtpXS5yZXMuUTk1O1xuXHRcdGRhdGEuc3RhdHMuUTk5ID0gc2V0U3RhdFtpXS5yZXMuUTk5O1xuXHRcdGRhdGEuc3RhdHMuUTEwMCA9IHNldFN0YXRbaV0ucmVzLlExMDA7XG5cdFx0ZGF0YS5zdGF0cy5tZWRpYW4gPSBzZXRTdGF0W2ldLnJlcy5tZWRpYW47XG5cdFx0ZGF0YS5zdGF0cy5pbnRlcnF1YXJ0aWxlX3JhbmdlID0gZGF0YS5zdGF0cy5RNzUgLSBkYXRhLnN0YXRzLlEyNTtcblx0fVxuXHRzZXRTdGF0ID0gUHN0YXRzKG9yZGVyU3RhdCwgXCJkYXRhc2V0XCIpO1xuXHRmb3IgKGkgPSAwOyBpIDwgc2V0U3RhdC5sZW5ndGg7IGkrKykge1xuXHRcdGRhdGEuZGF0YXNldHNbc2V0U3RhdFtpXS5zZWN2YWx1ZV0uc3RhdHMubWluaW11bSA9IHNldFN0YXRbaV0ucmVzLm1pbmltdW07XG5cdFx0ZGF0YS5kYXRhc2V0c1tzZXRTdGF0W2ldLnNlY3ZhbHVlXS5zdGF0cy5taW5pbXVtcGkgPSBzZXRTdGF0W2ldLnJlcy5taW5pbXVtcGk7XG5cdFx0ZGF0YS5kYXRhc2V0c1tzZXRTdGF0W2ldLnNlY3ZhbHVlXS5zdGF0cy5taW5pbXVtcGogPSBzZXRTdGF0W2ldLnJlcy5taW5pbXVtcGo7XG5cdFx0ZGF0YS5kYXRhc2V0c1tzZXRTdGF0W2ldLnNlY3ZhbHVlXS5zdGF0cy5tYXhpbXVtID0gc2V0U3RhdFtpXS5yZXMubWF4aW11bTtcblx0XHRkYXRhLmRhdGFzZXRzW3NldFN0YXRbaV0uc2VjdmFsdWVdLnN0YXRzLm1heGltdW1waSA9IHNldFN0YXRbaV0ucmVzLm1heGltdW1waTtcblx0XHRkYXRhLmRhdGFzZXRzW3NldFN0YXRbaV0uc2VjdmFsdWVdLnN0YXRzLm1heGltdW1waiA9IHNldFN0YXRbaV0ucmVzLm1heGltdW1wajtcblx0XHRkYXRhLmRhdGFzZXRzW3NldFN0YXRbaV0uc2VjdmFsdWVdLnN0YXRzLlEwID0gc2V0U3RhdFtpXS5yZXMuUTA7XG5cdFx0ZGF0YS5kYXRhc2V0c1tzZXRTdGF0W2ldLnNlY3ZhbHVlXS5zdGF0cy5RMSA9IHNldFN0YXRbaV0ucmVzLlExO1xuXHRcdGRhdGEuZGF0YXNldHNbc2V0U3RhdFtpXS5zZWN2YWx1ZV0uc3RhdHMuUTUgPSBzZXRTdGF0W2ldLnJlcy5RNTtcblx0XHRkYXRhLmRhdGFzZXRzW3NldFN0YXRbaV0uc2VjdmFsdWVdLnN0YXRzLlExMCA9IHNldFN0YXRbaV0ucmVzLlExMDtcblx0XHRkYXRhLmRhdGFzZXRzW3NldFN0YXRbaV0uc2VjdmFsdWVdLnN0YXRzLlEyNSA9IHNldFN0YXRbaV0ucmVzLlEyNTtcblx0XHRkYXRhLmRhdGFzZXRzW3NldFN0YXRbaV0uc2VjdmFsdWVdLnN0YXRzLlE1MCA9IHNldFN0YXRbaV0ucmVzLlE1MDtcblx0XHRkYXRhLmRhdGFzZXRzW3NldFN0YXRbaV0uc2VjdmFsdWVdLnN0YXRzLlE3NSA9IHNldFN0YXRbaV0ucmVzLlE3NTtcblx0XHRkYXRhLmRhdGFzZXRzW3NldFN0YXRbaV0uc2VjdmFsdWVdLnN0YXRzLlE5MCA9IHNldFN0YXRbaV0ucmVzLlE5MDtcblx0XHRkYXRhLmRhdGFzZXRzW3NldFN0YXRbaV0uc2VjdmFsdWVdLnN0YXRzLlE5NSA9IHNldFN0YXRbaV0ucmVzLlE5NTtcblx0XHRkYXRhLmRhdGFzZXRzW3NldFN0YXRbaV0uc2VjdmFsdWVdLnN0YXRzLlE5OSA9IHNldFN0YXRbaV0ucmVzLlE5OTtcblx0XHRkYXRhLmRhdGFzZXRzW3NldFN0YXRbaV0uc2VjdmFsdWVdLnN0YXRzLlExMDAgPSBzZXRTdGF0W2ldLnJlcy5RMTAwO1xuXHRcdGRhdGEuZGF0YXNldHNbc2V0U3RhdFtpXS5zZWN2YWx1ZV0uc3RhdHMubWVkaWFuID0gc2V0U3RhdFtpXS5yZXMubWVkaWFuO1xuXHRcdGRhdGEuZGF0YXNldHNbc2V0U3RhdFtpXS5zZWN2YWx1ZV0uc3RhdHMuaW50ZXJxdWFydGlsZV9yYW5nZSA9IGRhdGEuZGF0YXNldHNbc2V0U3RhdFtpXS5zZWN2YWx1ZV0uc3RhdHMuUTc1IC0gZGF0YS5kYXRhc2V0c1tzZXRTdGF0W2ldLnNlY3ZhbHVlXS5zdGF0cy5RMjU7XG5cdH1cblx0c2V0U3RhdCA9IFBzdGF0cyhvcmRlclN0YXQsIFwiY29sXCIpO1xuXHRmb3IgKGkgPSAwOyBpIDwgc2V0U3RhdC5sZW5ndGg7IGkrKykge1xuXHRcdGRhdGEuc3RhdHMuZGF0YV9taW5pbXVtW3NldFN0YXRbaV0uc2VjdmFsdWVdID0gc2V0U3RhdFtpXS5yZXMubWluaW11bTtcblx0XHRkYXRhLnN0YXRzLmRhdGFfbWluaW11bXBpW3NldFN0YXRbaV0uc2VjdmFsdWVdID0gc2V0U3RhdFtpXS5yZXMubWluaW11bXBpO1xuXHRcdGRhdGEuc3RhdHMuZGF0YV9taW5pbXVtcGpbc2V0U3RhdFtpXS5zZWN2YWx1ZV0gPSBzZXRTdGF0W2ldLnJlcy5taW5pbXVtcGo7XG5cdFx0ZGF0YS5zdGF0cy5kYXRhX21heGltdW1bc2V0U3RhdFtpXS5zZWN2YWx1ZV0gPSBzZXRTdGF0W2ldLnJlcy5tYXhpbXVtO1xuXHRcdGRhdGEuc3RhdHMuZGF0YV9tYXhpbXVtcGlbc2V0U3RhdFtpXS5zZWN2YWx1ZV0gPSBzZXRTdGF0W2ldLnJlcy5tYXhpbXVtcGk7XG5cdFx0ZGF0YS5zdGF0cy5kYXRhX21heGltdW1waltzZXRTdGF0W2ldLnNlY3ZhbHVlXSA9IHNldFN0YXRbaV0ucmVzLm1heGltdW1wajtcblx0XHRkYXRhLnN0YXRzLmRhdGFfUTBbc2V0U3RhdFtpXS5zZWN2YWx1ZV0gPSBzZXRTdGF0W2ldLnJlcy5RMDtcblx0XHRkYXRhLnN0YXRzLmRhdGFfUTFbc2V0U3RhdFtpXS5zZWN2YWx1ZV0gPSBzZXRTdGF0W2ldLnJlcy5RMTtcblx0XHRkYXRhLnN0YXRzLmRhdGFfUTVbc2V0U3RhdFtpXS5zZWN2YWx1ZV0gPSBzZXRTdGF0W2ldLnJlcy5RNTtcblx0XHRkYXRhLnN0YXRzLmRhdGFfUTEwW3NldFN0YXRbaV0uc2VjdmFsdWVdID0gc2V0U3RhdFtpXS5yZXMuUTEwO1xuXHRcdGRhdGEuc3RhdHMuZGF0YV9RMjVbc2V0U3RhdFtpXS5zZWN2YWx1ZV0gPSBzZXRTdGF0W2ldLnJlcy5RMjU7XG5cdFx0ZGF0YS5zdGF0cy5kYXRhX1E1MFtzZXRTdGF0W2ldLnNlY3ZhbHVlXSA9IHNldFN0YXRbaV0ucmVzLlE1MDtcblx0XHRkYXRhLnN0YXRzLmRhdGFfUTc1W3NldFN0YXRbaV0uc2VjdmFsdWVdID0gc2V0U3RhdFtpXS5yZXMuUTc1O1xuXHRcdGRhdGEuc3RhdHMuZGF0YV9ROTBbc2V0U3RhdFtpXS5zZWN2YWx1ZV0gPSBzZXRTdGF0W2ldLnJlcy5ROTA7XG5cdFx0ZGF0YS5zdGF0cy5kYXRhX1E5NVtzZXRTdGF0W2ldLnNlY3ZhbHVlXSA9IHNldFN0YXRbaV0ucmVzLlE5NTtcblx0XHRkYXRhLnN0YXRzLmRhdGFfUTk5W3NldFN0YXRbaV0uc2VjdmFsdWVdID0gc2V0U3RhdFtpXS5yZXMuUTk5O1xuXHRcdGRhdGEuc3RhdHMuZGF0YV9RMTAwW3NldFN0YXRbaV0uc2VjdmFsdWVdID0gc2V0U3RhdFtpXS5yZXMuUTEwMDtcblx0XHRkYXRhLnN0YXRzLmRhdGFfbWVkaWFuW3NldFN0YXRbaV0uc2VjdmFsdWVdID0gc2V0U3RhdFtpXS5yZXMubWVkaWFuO1xuXHRcdGRhdGEuc3RhdHMuZGF0YV9pbnRlcnF1YXJ0aWxlX3JhbmdlW3NldFN0YXRbaV0uc2VjdmFsdWVdID0gZGF0YS5zdGF0cy5kYXRhX1E3NVtzZXRTdGF0W2ldLnNlY3ZhbHVlXSAtIGRhdGEuc3RhdHMuZGF0YV9RMjVbc2V0U3RhdFtpXS5zZWN2YWx1ZV07XG5cdH1cbn07XG5cbmZ1bmN0aW9uIFBzdGF0cyhvcmRlclN0YXQsIHNlY1Zhcikge1xuXHR2YXIgcmVzdWx0ID0gbmV3IEFycmF5KCk7XG5cdG9yZGVyU3RhdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRpZiAoYVtzZWNWYXJdIDwgYltzZWNWYXJdKSByZXR1cm4gLTFcblx0XHRlbHNlIGlmIChhW3NlY1Zhcl0gPiBiW3NlY1Zhcl0pIHJldHVybiAxXG5cdFx0aWYgKGEudmFsIDwgYi52YWwpIHJldHVybiAtMVxuXHRcdGVsc2UgaWYgKGEudmFsID4gYi52YWwpIHJldHVybiAxXG5cdFx0ZWxzZSByZXR1cm4gMFxuXHR9KTtcblx0dmFyIGRlYiA9IDAsXG5cdFx0ZmluID0gMDtcblx0Zm9yIChpID0gMTsgaSA8IG9yZGVyU3RhdC5sZW5ndGg7IGkrKykge1xuXHRcdGlmIChvcmRlclN0YXRbaV1bc2VjVmFyXSA9PSBvcmRlclN0YXRbZGViXVtzZWNWYXJdKSBmaW4rKztcblx0XHRlbHNlIHtcblx0XHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHtcblx0XHRcdFx0c2VjdmFsdWU6IG9yZGVyU3RhdFtkZWJdW3NlY1Zhcl0sXG5cdFx0XHRcdHJlczogUDJzdGF0cyhkZWIsIGZpbiwgb3JkZXJTdGF0KVxuXHRcdFx0fTtcblx0XHRcdGZpbisrO1xuXHRcdFx0ZGViID0gZmluO1xuXHRcdH1cblx0fVxuXHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB7XG5cdFx0c2VjdmFsdWU6IG9yZGVyU3RhdFtkZWJdW3NlY1Zhcl0sXG5cdFx0cmVzOiBQMnN0YXRzKGRlYiwgZmluLCBvcmRlclN0YXQpXG5cdH07XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBQMnN0YXRzKGRlYiwgZmluLCBvcmRlclN0YXQpIHtcblx0cmV0dXJuIHtcblx0XHRtaW5pbXVtOiBvcmRlclN0YXRbZGViXS52YWwsXG5cdFx0bWluaW11bXBpIDogb3JkZXJTdGF0W2RlYl0uZGF0YXNldCxcblx0XHRtaW5pbXVtcGogOiBvcmRlclN0YXRbZGViXS5jb2wsXG5cdFx0bWF4aW11bTogb3JkZXJTdGF0W2Zpbl0udmFsLFxuXHRcdG1heGltdW1waSA6IG9yZGVyU3RhdFtmaW5dLmRhdGFzZXQsXG5cdFx0bWF4aW11bXBqIDogb3JkZXJTdGF0W2Zpbl0uY29sLFxuXHRcdFEwOiBvcmRlclN0YXRbZGViXS52YWwsXG5cdFx0UTE6IFF1YW50aWxlKDEsIGRlYiwgZmluLCBvcmRlclN0YXQpLFxuXHRcdFE1OiBRdWFudGlsZSg1LCBkZWIsIGZpbiwgb3JkZXJTdGF0KSxcblx0XHRRMTA6IFF1YW50aWxlKDEwLCBkZWIsIGZpbiwgb3JkZXJTdGF0KSxcblx0XHRRMjU6IFF1YW50aWxlKDI1LCBkZWIsIGZpbiwgb3JkZXJTdGF0KSxcblx0XHRRNTA6IFF1YW50aWxlKDUwLCBkZWIsIGZpbiwgb3JkZXJTdGF0KSxcblx0XHRRNzU6IFF1YW50aWxlKDc1LCBkZWIsIGZpbiwgb3JkZXJTdGF0KSxcblx0XHRROTA6IFF1YW50aWxlKDkwLCBkZWIsIGZpbiwgb3JkZXJTdGF0KSxcblx0XHRROTU6IFF1YW50aWxlKDk1LCBkZWIsIGZpbiwgb3JkZXJTdGF0KSxcblx0XHRROTk6IFF1YW50aWxlKDk5LCBkZWIsIGZpbiwgb3JkZXJTdGF0KSxcblx0XHRRMTAwOiBvcmRlclN0YXRbZmluXS52YWwsXG5cdFx0bWVkaWFuOiBRdWFudGlsZSg1MCwgZGViLCBmaW4sIG9yZGVyU3RhdClcblx0fVxufTtcblxuZnVuY3Rpb24gUXVhbnRpbGUocXVhbnQsIGRlYiwgZmluLCBvcmRlclN0YXQpIHtcblx0dmFyIG5ib2JzID0gZmluIC0gZGViICsgMTtcblx0aWYgKHF1YW50IDw9IDUwLjAxKSB7XG5cdFx0dmFyIHYxID0gTWF0aC5jZWlsKChuYm9icyAqIHF1YW50IC8gMTAwKSAtIDAuMDAwMDAxKSAtIDE7XG5cdFx0dmFyIHYyID0gTWF0aC5jZWlsKCgobmJvYnMgKyAxKSAqIHF1YW50IC8gMTAwKSAtIDAuMDAwMDAxKSAtIDE7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHYxID0gTWF0aC5jZWlsKChuYm9icyAqICgxMDAgLSBxdWFudCkgLyAxMDApIC0gMC4wMDAwMDEpIC0gMTtcblx0XHR2MSA9IG5ib2JzIC0gdjEgLSAxO1xuXHRcdHZhciB2MiA9IE1hdGguY2VpbCgoKG5ib2JzICsgMSkgKiAoMTAwIC0gcXVhbnQpIC8gMTAwKSAtIDAuMDAwMDAxKSAtIDE7XG5cdFx0djIgPSBuYm9icyAtIHYyIC0gMTtcblx0fVxuXHQvLyAgaWYoZGViK3YyPmZpbil2Mj1maW4tZGViLTE7XG5cdHJldHVybiAoKG9yZGVyU3RhdFtkZWIgKyB2MV0udmFsICsgb3JkZXJTdGF0W2RlYiArIHYyXS52YWwpIC8gMik7XG59O1xuXG5mdW5jdGlvbiBkaXNwX3N0YXRzKGRhdGEpIHtcblx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLmNvdW50X2FsbD1cIiArIGRhdGEuc3RhdHMuY291bnRfYWxsICsgXCI8QlI+XCIpO1xuXHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuY291bnRfbWlzc2luZz1cIiArIGRhdGEuc3RhdHMuY291bnRfbWlzc2luZyArIFwiPEJSPlwiKTtcblx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLmNvdW50X25vdF9taXNzaW5nPVwiICsgZGF0YS5zdGF0cy5jb3VudF9ub3RfbWlzc2luZyArIFwiPEJSPlwiKTtcblx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLm1pbmltdW09XCIgKyBkYXRhLnN0YXRzLm1pbmltdW0gKyBcIjxCUj5cIik7XG5cdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5taW5pbXVtcGk9XCIgKyBkYXRhLnN0YXRzLm1pbmltdW1waSArIFwiPEJSPlwiKTtcblx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLm1pbmltdW1waj1cIiArIGRhdGEuc3RhdHMubWluaW11bXBqICsgXCI8QlI+XCIpO1xuXHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMubWF4aW11bT1cIiArIGRhdGEuc3RhdHMubWF4aW11bSArIFwiPEJSPlwiKTtcblx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLm1heGltdW1waT1cIiArIGRhdGEuc3RhdHMubWF4aW11bXBpICsgXCI8QlI+XCIpO1xuXHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMubWF4aW11bXBqPVwiICsgZGF0YS5zdGF0cy5tYXhpbXVtcGogKyBcIjxCUj5cIik7XG5cdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5zdW09XCIgKyBkYXRhLnN0YXRzLnN1bSArIFwiPEJSPlwiKTtcblx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLm1lYW49XCIgKyBkYXRhLnN0YXRzLm1lYW4gKyBcIjxCUj5cIik7XG5cdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5zdW1fc3F1YXJlX2RpZmZfbWVhbj1cIiArIGRhdGEuc3RhdHMuc3VtX3NxdWFyZV9kaWZmX21lYW4gKyBcIjxCUj5cIik7XG5cdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy52YXJpYW5jZT1cIiArIGRhdGEuc3RhdHMudmFyaWFuY2UgKyBcIjxCUj5cIik7XG5cdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5zdGFuZGFyZCBfZGV2aWF0aW9uPVwiICsgZGF0YS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb24gKyBcIjxCUj5cIik7XG5cdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5zdGFuZGFyZF9lcnJvcl9tZWFuPVwiICsgZGF0YS5zdGF0cy5zdGFuZGFyZF9lcnJvcl9tZWFuICsgXCI8QlI+XCIpO1xuXHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuc3RhbmRhcmRfZGV2aWF0aW9uX2VzdGltYXRpb249XCIgKyBkYXRhLnN0YXRzLnN0YW5kYXJkX2RldmlhdGlvbl9lc3RpbWF0aW9uICsgXCI8QlI+XCIpO1xuXHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuY29lZmZpY2llbnRfdmFyaWF0aW9uPVwiICsgZGF0YS5zdGF0cy5jb2VmZmljaWVudF92YXJpYXRpb24gKyBcIjxCUj5cIik7XG5cdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5za2V3bmVzcz1cIiArIGRhdGEuc3RhdHMuc2tld25lc3MgKyBcIjxCUj5cIik7XG5cdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5rdXJ0b3Npcz1cIiArIGRhdGEuc3RhdHMua3VydG9zaXMgKyBcIjxCUj5cIik7XG5cdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5zdHVkZW50X3RfdGVzdD1cIiArIGRhdGEuc3RhdHMuc3R1ZGVudF90X3Rlc3QgKyBcIjxCUj5cIik7XG5cdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5RMFwiICsgZGF0YS5zdGF0cy5RMCArIFwiPEJSPlwiKTtcblx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLlExPVwiICsgZGF0YS5zdGF0cy5RMSArIFwiPEJSPlwiKTtcblx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLlE1PVwiICsgZGF0YS5zdGF0cy5RNSArIFwiPEJSPlwiKTtcblx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLlExMD1cIiArIGRhdGEuc3RhdHMuUTEwICsgXCI8QlI+XCIpO1xuXHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuUTI1PVwiICsgZGF0YS5zdGF0cy5RMjUgKyBcIjxCUj5cIik7XG5cdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5RNTA9XCIgKyBkYXRhLnN0YXRzLlE1MCArIFwiPEJSPlwiKTtcblx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLlE3NT1cIiArIGRhdGEuc3RhdHMuUTc1ICsgXCI8QlI+XCIpO1xuXHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuUTkwPVwiICsgZGF0YS5zdGF0cy5ROTAgKyBcIjxCUj5cIik7XG5cdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5ROTU9XCIgKyBkYXRhLnN0YXRzLlE5NSArIFwiPEJSPlwiKTtcblx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLlE5OT1cIiArIGRhdGEuc3RhdHMuUTk5ICsgXCI8QlI+XCIpO1xuXHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuUTEwMD1cIiArIGRhdGEuc3RhdHMuUTEwMCArIFwiPEJSPlwiKTtcblx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLm1lZGlhbj1cIiArIGRhdGEuc3RhdHMubWVkaWFuICsgXCI8QlI+XCIpO1xuXHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuaW50ZXJxdWFydGlsZV9yYW5nZT1cIiArIGRhdGEuc3RhdHMuaW50ZXJxdWFydGlsZV9yYW5nZSArIFwiPEJSPlwiKTtcblx0ZG9jdW1lbnQud3JpdGUoXCI8aHI+XCIpXG5cdGlmICh0eXBlb2YgZGF0YS5kYXRhc2V0cyAhPSAndW5kZWZpbmVkJykge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcIjxocj5cIilcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiREFUQVNFVDogXCIgKyBpICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLmRhdGFzZXRzW1wiICsgaSArIFwiXS5zdGF0cy5jb3VudF9hbGw9XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X2FsbCArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5kYXRhc2V0c1tcIiArIGkgKyBcIl0uc3RhdHMuY291bnRfbWlzc2luZz1cIiArIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuY291bnRfbWlzc2luZyArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5kYXRhc2V0c1tcIiArIGkgKyBcIl0uc3RhdHMuY291bnRfbm90X21pc3Npbmc9XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLmNvdW50X25vdF9taXNzaW5nICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLmRhdGFzZXRzW1wiICsgaSArIFwiXS5zdGF0cy5taW5pbXVtPVwiICsgZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5taW5pbXVtICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLmRhdGFzZXRzW1wiICsgaSArIFwiXS5zdGF0cy5taW5pbXVtcGk9XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLm1pbmltdW1waSArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5kYXRhc2V0c1tcIiArIGkgKyBcIl0uc3RhdHMubWluaW11bXBqPVwiICsgZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5taW5pbXVtcGogKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuZGF0YXNldHNbXCIgKyBpICsgXCJdLnN0YXRzLm1heGltdW09XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLm1heGltdW0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuZGF0YXNldHNbXCIgKyBpICsgXCJdLnN0YXRzLm1heGltdW1waT1cIiArIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMubWF4aW11bXBpICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLmRhdGFzZXRzW1wiICsgaSArIFwiXS5zdGF0cy5tYXhpbXVtcGo9XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLm1heGltdW1waiArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5kYXRhc2V0c1tcIiArIGkgKyBcIl0uc3RhdHMuc3VtPVwiICsgZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5zdW0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuZGF0YXNldHNbXCIgKyBpICsgXCJdLnN0YXRzLm1lYW49XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLm1lYW4gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuZGF0YXNldHNbXCIgKyBpICsgXCJdLnN0YXRzLnN1bV9zcXVhcmVfZGlmZl9tZWFuPVwiICsgZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5zdW1fc3F1YXJlX2RpZmZfbWVhbiArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5kYXRhc2V0c1tcIiArIGkgKyBcIl0uc3RhdHMudmFyaWFuY2U9XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnZhcmlhbmNlICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLmRhdGFzZXRzW1wiICsgaSArIFwiXS5zdGF0cy5zdGFuZGFyZF9kZXZpYXRpb249XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnN0YW5kYXJkX2RldmlhdGlvbiArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5kYXRhc2V0c1tcIiArIGkgKyBcIl0uc3RhdHMuc3RhbmRhcmRfZXJyb3JfbWVhbj1cIiArIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3RhbmRhcmRfZXJyb3JfbWVhbiArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5kYXRhc2V0c1tcIiArIGkgKyBcIl0uc3RhdHMuc3RhbmRhcmRfZGV2aWF0aW9uX2VzdGltYXRpb249XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLnN0YW5kYXJkX2RldmlhdGlvbl9lc3RpbWF0aW9uICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLmRhdGFzZXRzW1wiICsgaSArIFwiXS5zdGF0cy5zdHVkZW50X3RfdGVzdD1cIiArIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuc3R1ZGVudF90X3Rlc3QgKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuZGF0YXNldHNbXCIgKyBpICsgXCJdLnN0YXRzLmNvZWZmaWNpZW50X3ZhcmlhdGlvbj1cIiArIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuY29lZmZpY2llbnRfdmFyaWF0aW9uICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLmRhdGFzZXRzW1wiICsgaSArIFwiXXN0YXRzLnNrZXduZXNzPVwiICsgZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5za2V3bmVzcyArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5kYXRhc2V0c1tcIiArIGkgKyBcIl1zdGF0cy5rdXJ0b3Npcz1cIiArIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMua3VydG9zaXMgKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuZGF0YXNldHNbXCIgKyBpICsgXCJdLnN0YXRzLlEwPVwiICsgZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5RMCArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5kYXRhc2V0c1tcIiArIGkgKyBcIl0uc3RhdHMuUTE9XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLlExICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLmRhdGFzZXRzW1wiICsgaSArIFwiXS5zdGF0cy5RNT1cIiArIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuUTUgKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuZGF0YXNldHNbXCIgKyBpICsgXCJdLnN0YXRzLlExMD1cIiArIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuUTEwICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLmRhdGFzZXRzW1wiICsgaSArIFwiXS5zdGF0cy5RMjU9XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLlEyNSArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5kYXRhc2V0c1tcIiArIGkgKyBcIl0uc3RhdHMuUTUwPVwiICsgZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5RNTAgKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuZGF0YXNldHNbXCIgKyBpICsgXCJdLnN0YXRzLlE3NT1cIiArIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuUTc1ICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLmRhdGFzZXRzW1wiICsgaSArIFwiXS5zdGF0cy5ROTA9XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLlE5MCArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5kYXRhc2V0c1tcIiArIGkgKyBcIl0uc3RhdHMuUTk1PVwiICsgZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5ROTUgKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuZGF0YXNldHNbXCIgKyBpICsgXCJdLnN0YXRzLlE5OT1cIiArIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuUTk5ICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLmRhdGFzZXRzW1wiICsgaSArIFwiXS5zdGF0cy5RMTAwPVwiICsgZGF0YS5kYXRhc2V0c1tpXS5zdGF0cy5RMTAwICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLmRhdGFzZXRzW1wiICsgaSArIFwiXS5zdGF0cy5tZWRpYW49XCIgKyBkYXRhLmRhdGFzZXRzW2ldLnN0YXRzLm1lZGlhbiArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5kYXRhc2V0c1tcIiArIGkgKyBcIl0uc3RhdHMuaW50ZXJxdWFydGlsZV9yYW5nZT1cIiArIGRhdGEuZGF0YXNldHNbaV0uc3RhdHMuaW50ZXJxdWFydGlsZV9yYW5nZSArIFwiPEJSPlwiKTtcblx0XHR9XG5cdFx0ZG9jdW1lbnQud3JpdGUoXCI8aHI+XCIpXG5cdFx0Zm9yIChpID0gMDsgaSA8IGRhdGEuc3RhdHMubWF4X251bWJlcl9kYXRhOyBpKyspIHtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiPGhyPlwiKVxuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJEYXRhOiBcIiArIGkgKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9jb3VudF9hbGxbXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX2NvdW50X2FsbFtpXSArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5kYXRhX2NvdW50X21pc3NpbmdbXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX2NvdW50X21pc3NpbmdbaV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9jb3VudF9ub3RfbWlzc2luZ1tcIiArIGkgKyBcIl09XCIgKyBkYXRhLnN0YXRzLmRhdGFfY291bnRfbm90X21pc3NpbmdbaV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9taW5pbXVtW1wiICsgaSArIFwiXT1cIiArIGRhdGEuc3RhdHMuZGF0YV9taW5pbXVtW2ldICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLmRhdGFfbWluaW11bXBpW1wiICsgaSArIFwiXT1cIiArIGRhdGEuc3RhdHMuZGF0YV9taW5pbXVtcGlbaV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9taW5pbXVtcGpbXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX21pbmltdW1waltpXSArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5kYXRhX21heGltdW1bXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX21heGltdW1baV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9tYXhpbXVtcGlbXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX21heGltdW1waVtpXSArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5kYXRhX21heGltdW1waltcIiArIGkgKyBcIl09XCIgKyBkYXRhLnN0YXRzLmRhdGFfbWF4aW11bXBqW2ldICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLmRhdGFfc3VtW1wiICsgaSArIFwiXT1cIiArIGRhdGEuc3RhdHMuZGF0YV9zdW1baV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9tZWFuW1wiICsgaSArIFwiXT1cIiArIGRhdGEuc3RhdHMuZGF0YV9tZWFuW2ldICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLmRhdGFfc3VtX3NxdWFyZV9kaWZmX21lYW5bXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX3N1bV9zcXVhcmVfZGlmZl9tZWFuW2ldICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLmRhdGFfdmFyaWFuY2VbXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX3ZhcmlhbmNlW2ldICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLmRhdGFfc3RhbmRhcmRfZGV2aWF0aW9uW1wiICsgaSArIFwiXT1cIiArIGRhdGEuc3RhdHMuZGF0YV9zdGFuZGFyZF9kZXZpYXRpb25baV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9zdGFuZGFyZF9lcnJvcl9tZWFuW1wiICsgaSArIFwiXT1cIiArIGRhdGEuc3RhdHMuZGF0YV9zdGFuZGFyZF9lcnJvcl9tZWFuW2ldICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLmRhdGFfc3RhbmRhcmRfZGV2aWF0aW9uX2VzdGltYXRpb25bXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX3N0YW5kYXJkX2RldmlhdGlvbl9lc3RpbWF0aW9uW2ldICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLmRhdGFfc3R1ZGVudF90X3Rlc3RbXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX3N0dWRlbnRfdF90ZXN0W2ldICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLmRhdGFfY29lZmZpY2llbnRfdmFyaWF0aW9uW1wiICsgaSArIFwiXT1cIiArIGRhdGEuc3RhdHMuZGF0YV9jb2VmZmljaWVudF92YXJpYXRpb25baV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9za2V3bmVzc1tcIiArIGkgKyBcIl09XCIgKyBkYXRhLnN0YXRzLmRhdGFfc2tld25lc3NbaV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9rdXJ0b3Npc1tcIiArIGkgKyBcIl09XCIgKyBkYXRhLnN0YXRzLmRhdGFfa3VydG9zaXNbaV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9RMFtcIiArIGkgKyBcIl09XCIgKyBkYXRhLnN0YXRzLmRhdGFfUTBbaV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9RMVtcIiArIGkgKyBcIl09XCIgKyBkYXRhLnN0YXRzLmRhdGFfUTFbaV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9RNVtcIiArIGkgKyBcIl09XCIgKyBkYXRhLnN0YXRzLmRhdGFfUTVbaV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9RMTBbXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX1ExMFtpXSArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5kYXRhX1EyNVtcIiArIGkgKyBcIl09XCIgKyBkYXRhLnN0YXRzLmRhdGFfUTI1W2ldICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLmRhdGFfUTUwW1wiICsgaSArIFwiXT1cIiArIGRhdGEuc3RhdHMuZGF0YV9RNTBbaV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9RNzVbXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX1E3NVtpXSArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5kYXRhX1E5MFtcIiArIGkgKyBcIl09XCIgKyBkYXRhLnN0YXRzLmRhdGFfUTkwW2ldICsgXCI8QlI+XCIpO1xuXHRcdFx0ZG9jdW1lbnQud3JpdGUoXCJkYXRhLnN0YXRzLmRhdGFfUTk1W1wiICsgaSArIFwiXT1cIiArIGRhdGEuc3RhdHMuZGF0YV9ROTVbaV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9ROTlbXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX1E5OVtpXSArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5kYXRhX1ExMDBbXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX1ExMDBbaV0gKyBcIjxCUj5cIik7XG5cdFx0XHRkb2N1bWVudC53cml0ZShcImRhdGEuc3RhdHMuZGF0YV9tZWRpYW5bXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX21lZGlhbltpXSArIFwiPEJSPlwiKTtcblx0XHRcdGRvY3VtZW50LndyaXRlKFwiZGF0YS5zdGF0cy5kYXRhX2ludGVycXVhcnRpbGVfcmFuZ2VbXCIgKyBpICsgXCJdPVwiICsgZGF0YS5zdGF0cy5kYXRhX2ludGVycXVhcnRpbGVfcmFuZ2VbaV0gKyBcIjxCUj5cIik7XG5cdFx0fVxuXHR9XG59O1xuXG5mdW5jdGlvbiByZXBsYWNlX3N0YXRzKGRhdGEsIGNvbmZpZykge1xuXHQvLyByZXBsYWNlIGluIHRoZSBkYXRhXG5cdHZhciBpLGo7XG5cdGlmIChkYXRhLnN0YXRzLmRhdGFfd2l0aF9zdGF0cykge1xuXHRcdGlmICh0eXBlb2YgZGF0YS5kYXRhc2V0cyA9PSAndW5kZWZpbmVkJykgeyAvLyBQaWUgc3RydWN0dXJlO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGlzU3RhdChkYXRhW2ldLnZhbHVlKSkgZGF0YVtpXS52YWx1ZSA9IHJlcGxhY2VfU3RhdHNfSW4oZGF0YVtpXS52YWx1ZSwgZGF0YSwgLTEsIC0xKTtcblx0XHRcdFx0Ly8gdGVtcGxhdGVzID9cblx0XHRcdFx0aWYgKGlzVGVtcGxhdGUoZGF0YVtpXS52YWx1ZSkpIHtcblx0XHRcdFx0XHRkYXRhW2ldLnZhbHVlID0gdG1wbFN0YXQoZGF0YVtpXS52YWx1ZSwge1xuXHRcdFx0XHRcdFx0VjE6IDFcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7IC8vIGxpbmUgc3RydWN0dXJlO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGEuZGF0YXNldHNbXCJsZW5ndGhcIl07IGkrKykge1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZGF0YS5kYXRhc2V0c1tpXS5kYXRhW1wibGVuZ3RoXCJdOyBqKyspIHtcblx0XHRcdFx0XHRpZiAoaXNTdGF0KGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSkpIHtcblx0XHRcdFx0XHRcdGRhdGEuZGF0YXNldHNbaV0uZGF0YVtqXSA9IHJlcGxhY2VfU3RhdHNfSW4oZGF0YS5kYXRhc2V0c1tpXS5kYXRhW2pdLCBkYXRhLCBpLCBqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gdGVtcGxhdGVzID9cblx0XHRcdFx0XHRpZiAoaXNUZW1wbGF0ZShkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0pKSB7XG5cdFx0XHRcdFx0XHRkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0gPSB0bXBsU3RhdChkYXRhLmRhdGFzZXRzW2ldLmRhdGFbal0sIHtcblx0XHRcdFx0XHRcdFx0VjE6IDFcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyByZXBsYWNlIGluIG90aGVyIHBhcnQgb2YgdGhlIGRhdGEgKHRpdGxlcylcblx0aWYgKHR5cGVvZiBkYXRhLmRhdGFzZXRzID09ICd1bmRlZmluZWQnKSB7IC8vIFBpZSBzdHJ1Y3R1cmU7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChpc1N0YXQoZGF0YVtpXS50aXRsZSkpIGRhdGFbaV0udGl0bGUgPSByZXBsYWNlX1N0YXRzX0luKGRhdGFbaV0udGl0bGUsIGRhdGEsIC0xLCAtMSk7XG5cdFx0XHQvLyB0ZW1wbGF0ZXMgP1xuXHRcdFx0aWYgKGlzVGVtcGxhdGUoZGF0YVtpXS50aXRsZSkpIHtcblx0XHRcdFx0ZGF0YVtpXS50aXRsZSA9IHRtcGxTdGF0KGRhdGFbaV0udGl0bGUsIHtcblx0XHRcdFx0XHRWMTogMVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGxpbmUgc3RydWN0dXJlO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5kYXRhc2V0c1tcImxlbmd0aFwiXTsgaSsrKSB7XG5cdFx0XHRpZiAoaXNTdGF0KGRhdGEuZGF0YXNldHNbaV0udGl0bGUpKSB7XG5cdFx0XHRcdGRhdGEuZGF0YXNldHNbaV0udGl0bGUgPSByZXBsYWNlX1N0YXRzX0luKGRhdGEuZGF0YXNldHNbaV0udGl0bGUsIGRhdGEsIGksIC0xKTtcblx0XHRcdH1cblx0XHRcdC8vIHRlbXBsYXRlcyA/XG5cdFx0XHRpZiAoaXNUZW1wbGF0ZShkYXRhLmRhdGFzZXRzW2ldLnRpdGxlKSkge1xuXHRcdFx0XHRkYXRhLmRhdGFzZXRzW2ldLnRpdGxlID0gdG1wbFN0YXQoZGF0YS5kYXRhc2V0c1tpXS50aXRsZSwge1xuXHRcdFx0XHRcdFYxOiAxXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyByZXBsYWNlIGluIHNoYXBlc0luQ2hhcnQ7XG5cdGlmICh0eXBlb2YgZGF0YS5kYXRhc2V0cyA9PSAndW5kZWZpbmVkJykgeyAvLyBQaWUgc3RydWN0dXJlO1xuXHRcdGlmICh0eXBlb2YgZGF0YVswXS5zaGFwZXNJbkNoYXJ0ID09IFwib2JqZWN0XCIpIHtcblx0XHRcdGZvcihpPTA7aTxkYXRhWzBdLnNoYXBlc0luQ2hhcnQubGVuZ3RoO2krKykge1xuXHRcdFx0XHRyZXBsYWNlX2luX29iamVjdChkYXRhWzBdLnNoYXBlc0luQ2hhcnRbaV0sIGRhdGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gTGluZSBzdHJ1Y3R1cmU7XG5cdFx0aWYodHlwZW9mIGRhdGEuc2hhcGVzSW5DaGFydCA9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRmb3IoaT0wO2k8ZGF0YS5zaGFwZXNJbkNoYXJ0Lmxlbmd0aDtpKyspIHtcblx0XHRcdFx0cmVwbGFjZV9pbl9vYmplY3QoZGF0YS5zaGFwZXNJbkNoYXJ0W2ldLCBkYXRhKTtcblx0XHRcdH1cblx0XHR9IFxuXG5cdH1cdFxuXHQvLyByZXBsYWNlIGluIG9wdGlvbnM7XG5cdHJlcGxhY2VfaW5fb2JqZWN0KGNvbmZpZywgZGF0YSk7XG59O1xuXG5mdW5jdGlvbiByZXBsYWNlX2luX29iamVjdChvYmosIGRhdGEpIHtcblx0Zm9yICh2YXIgYXR0cm5hbWUgaW4gb2JqKSB7XG5cdFx0aWYgKHR5cGVvZiBvYmpbYXR0cm5hbWVdID09IFwib2JqZWN0XCIpIHtcblx0XHRcdHJlcGxhY2VfaW5fb2JqZWN0KG9ialthdHRybmFtZV0sIGRhdGEpO1xuXHRcdH0gZWxzZSBpZiAoaXNTdGF0KG9ialthdHRybmFtZV0pKSB7XG5cdFx0XHRvYmpbYXR0cm5hbWVdID0gcmVwbGFjZV9TdGF0c19JbihvYmpbYXR0cm5hbWVdLCBkYXRhLCAtMSwgLTEpO1xuXHRcdFx0Ly8gdGVtcGxhdGVzIGlmIG5vdCBhIHRlbXBsYXRlIG9wdGlvbi4uLi5cblx0XHRcdGlmICghKGF0dHJuYW1lID09IFwiYW5ub3RhdGVMYWJlbFwiIHx8IGF0dHJuYW1lID09IFwiaW5HcmFwaERhdGFUbXBsXCIgfHwgYXR0cm5hbWUgPT0gXCJzY2FsZUxhYmVsXCIpKSB7XG5cdFx0XHRcdGlmIChpc1RlbXBsYXRlKG9ialthdHRybmFtZV0pKSB7XG5cdFx0XHRcdFx0b2JqW2F0dHJuYW1lXSA9IHRtcGxTdGF0KG9ialthdHRybmFtZV0sIHtcblx0XHRcdFx0XHRcdFYxOiAxXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIHRtcGxTdGF0KHN0ciwgZGF0YSkge1xuXHQvLyBGaWd1cmUgb3V0IGlmIHdlJ3JlIGdldHRpbmcgYSB0ZW1wbGF0ZSwgb3IgaWYgd2UgbmVlZCB0b1xuXHQvLyBsb2FkIHRoZSB0ZW1wbGF0ZSAtIGFuZCBiZSBzdXJlIHRvIGNhY2hlIHRoZSByZXN1bHQuXG5cdHZhciBmbiA9ICEvXFxXLy50ZXN0KHN0cikgP1xuXHRcdGNhY2hlYmlzW3N0cl0gPSBjYWNoZWJpc1tzdHJdIHx8XG5cdFx0dG1wbGJpcyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHIpLmlubmVySFRNTCkgOlxuXHRcdC8vIEdlbmVyYXRlIGEgcmV1c2FibGUgZnVuY3Rpb24gdGhhdCB3aWxsIHNlcnZlIGFzIGEgdGVtcGxhdGVcblx0XHQvLyBnZW5lcmF0b3IgKGFuZCB3aGljaCB3aWxsIGJlIGNhY2hlZCkuXG5cdFx0bmV3IEZ1bmN0aW9uKFwib2JqXCIsXG5cdFx0XHRcInZhciBwPVtdLHByaW50PWZ1bmN0aW9uKCl7cC5wdXNoLmFwcGx5KHAsYXJndW1lbnRzKTt9O1wiICtcblx0XHRcdC8vIEludHJvZHVjZSB0aGUgZGF0YSBhcyBsb2NhbCB2YXJpYWJsZXMgdXNpbmcgd2l0aCgpe31cblx0XHRcdFwid2l0aChvYmope3AucHVzaCgnXCIgK1xuXHRcdFx0Ly8gQ29udmVydCB0aGUgdGVtcGxhdGUgaW50byBwdXJlIEphdmFTY3JpcHRcblx0XHRcdHN0clxuXHRcdFx0LnJlcGxhY2UoL1tcXHJcXHRcXG5dL2csIFwiIFwiKVxuXHRcdFx0LnNwbGl0KFwiPCVcIikuam9pbihcIlxcdFwiKVxuXHRcdFx0LnJlcGxhY2UoLygoXnwlPilbXlxcdF0qKScvZywgXCIkMVxcclwiKVxuXHRcdFx0LnJlcGxhY2UoL1xcdD0oLio/KSU+L2csIFwiJywkMSwnXCIpXG5cdFx0XHQuc3BsaXQoXCJcXHRcIikuam9pbihcIicpO1wiKVxuXHRcdFx0LnNwbGl0KFwiJT5cIikuam9pbihcInAucHVzaCgnXCIpXG5cdFx0XHQuc3BsaXQoXCJcXHJcIikuam9pbihcIlxcXFwnXCIpICsgXCInKTt9cmV0dXJuIHAuam9pbignJyk7XCIpO1xuXHQvLyBQcm92aWRlIHNvbWUgYmFzaWMgY3VycnlpbmcgdG8gdGhlIHVzZXJcblx0cmV0dXJuIGRhdGEgPyBmbihkYXRhKSA6IGZuO1xufTtcblxuZnVuY3Rpb24gaXNUZW1wbGF0ZShzdHJ2YXIpIHtcblx0aWYgKHR5cGVvZiBzdHJ2YXIgPT0gXCJzdHJpbmdcIikge1xuXHRcdGlmIChzdHJ2YXIuaW5kZXhPZihcIjwlXCIpID49IDApIHtcblx0XHRcdGlmIChzdHJ2YXIuaW5kZXhPZihcIj5cIiwgc3RydmFyLmluZGV4T2YoXCIlPlwiKSkgPiAwKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZXBsYWNlX1N0YXRzX0luKHN0cnZhbCwgZGF0YSwgZGF0YXNldCwgY29sZGF0YSkge1xuXHR2YXIgcmVzdmFsID0gXCJcIjtcblx0dmFyIHN0YXJ0ID0gMDtcblx0dmFyIHByZXZzdGF0ID0gdHJ1ZTtcblx0d2hpbGUgKHN0cnZhbC5pbmRleE9mKFwiI1wiLCBzdGFydCkgPj0gMCkge1xuXHRcdC8vIHN0cnZhbC5zdWJzdHJpbmcoc3RhcnQsKSAgICAgICAgICAgO1xuXHRcdGlmICghcHJldnN0YXQpIHtcblx0XHRcdHZhciBzdGF0T2YgPSBjb252ZXJ0U3RhdChzdHJ2YWwuc3Vic3RyaW5nKHN0YXJ0LCBzdHJ2YWwuaW5kZXhPZihcIiNcIiwgc3RhcnQpKSwgZGF0YSwgZGF0YXNldCwgY29sZGF0YSk7XG5cdFx0XHRpZiAoc3RhdE9mLmZvdW5kKSB7XG5cdFx0XHRcdHJlc3ZhbCA9IHJlc3ZhbCArIHN0YXRPZi5yZXN2YWw7XG5cdFx0XHRcdHN0YXJ0ID0gc3RydmFsLmluZGV4T2YoXCIjXCIsIHN0YXJ0KSArIDE7XG5cdFx0XHRcdHByZXZzdGF0ID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3ZhbCA9IHJlc3ZhbCArIFwiI1wiICsgc3RhdE9mLnJlc3ZhbDtcblx0XHRcdFx0c3RhcnQgPSBzdHJ2YWwuaW5kZXhPZihcIiNcIiwgc3RhcnQpICsgMTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHN0YXJ0ID4gMCkgcmVzdmFsID0gcmVzdmFsO1xuXHRcdFx0cmVzdmFsID0gcmVzdmFsICsgc3RydmFsLnN1YnN0cmluZyhzdGFydCwgc3RydmFsLmluZGV4T2YoXCIjXCIsIHN0YXJ0KSk7XG5cdFx0XHRzdGFydCA9IHN0cnZhbC5pbmRleE9mKFwiI1wiLCBzdGFydCkgKyAxO1xuXHRcdFx0cHJldnN0YXQgPSBmYWxzZTtcblx0XHR9XG5cdH1cblx0aWYgKCFwcmV2c3RhdCkgcmVzdmFsID0gcmVzdmFsICsgXCIjXCI7XG5cdHJlc3ZhbCA9IHJlc3ZhbCArIHN0cnZhbC5zdWJzdHJpbmcoc3RhcnQsIHN0cnZhbC5sZW5ndGgpO1xuXHRyZXR1cm4gcmVzdmFsO1xufTtcblxuZnVuY3Rpb24gY29udmVydFN0YXQoc3RhdHZhbCwgZGF0YSwgZGF0YXNldCwgY29sZGF0YSkge1xuXHR2YXIgcmVzdmFsID0gc3RhdHZhbDtcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdGlmICh0eXBlb2YgZGF0YS5zdGF0c1tzdGF0dmFsLnRvTG93ZXJDYXNlKCldICE9IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGRhdGEuc3RhdHNbc3RhdHZhbC50b0xvd2VyQ2FzZSgpXSAhPSBcIm9iamVjdFwiKSB7XG5cdFx0cmVzdmFsID0gZGF0YS5zdGF0c1tzdGF0dmFsLnRvTG93ZXJDYXNlKCldO1xuXHRcdGZvdW5kID0gdHJ1ZTtcblx0fSBlbHNlIGlmIChzdGF0dmFsLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsIDMpID09IFwiZHNfXCIpIHtcblx0XHRzdGF0ID0gc3RhdHZhbC50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygzKTtcblx0XHRpZiAoc3RhdC5pbmRleE9mKFwiKFwiKSA+IDApIHtcblx0XHRcdHZhciB2ZGF0YXNldCA9IHN0YXQuc3Vic3RyaW5nKHN0YXQuaW5kZXhPZihcIihcIikgKyAxKTtcblx0XHRcdHZkYXRhc2V0ID0gMSAqIHZkYXRhc2V0LnN1YnN0cmluZygwLCB2ZGF0YXNldC5pbmRleE9mKFwiKVwiKSk7XG5cdFx0XHR2YXIgc3RhdCA9IHN0YXQuc3Vic3RyaW5nKDAsIHN0YXQuaW5kZXhPZihcIihcIikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2ZGF0YXNldCA9IE1hdGgubWF4KDEgKiBkYXRhc2V0LCAwKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBkYXRhLmRhdGFzZXRzID09IFwib2JqZWN0XCIpIHtcblx0XHRcdGlmICh0eXBlb2YgZGF0YS5kYXRhc2V0c1t2ZGF0YXNldF0gPT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHRpZiAodHlwZW9mIGRhdGEuZGF0YXNldHNbdmRhdGFzZXRdLnN0YXRzID09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIGRhdGEuZGF0YXNldHNbdmRhdGFzZXRdLnN0YXRzW3N0YXRdID09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRcdHJlc3ZhbCA9IGRhdGEuZGF0YXNldHNbdmRhdGFzZXRdLnN0YXRzW3N0YXRdO1xuXHRcdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmIChzdGF0dmFsLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsIDUpID09IFwiZGF0YV9cIikge1xuXHRcdHN0YXQgPSBzdGF0dmFsLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDUpO1xuXHRcdGlmIChzdGF0LmluZGV4T2YoXCIoXCIpID4gMCkge1xuXHRcdFx0dmRhdGFzZXQgPSBzdGF0LnN1YnN0cmluZyhzdGF0LmluZGV4T2YoXCIoXCIpICsgMSk7XG5cdFx0XHR2ZGF0YXNldCA9IDEgKiB2ZGF0YXNldC5zdWJzdHJpbmcoMCwgdmRhdGFzZXQuaW5kZXhPZihcIilcIikpO1xuXHRcdFx0c3RhdCA9IHN0YXQuc3Vic3RyaW5nKDAsIHN0YXQuaW5kZXhPZihcIihcIikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2ZGF0YXNldCA9IE1hdGgubWF4KDEgKiBjb2xkYXRhLCAwKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBkYXRhLmRhdGFzZXRzID09IFwib2JqZWN0XCIpIHtcblx0XHRcdGlmICh0eXBlb2YgZGF0YS5zdGF0c1tcImRhdGFfXCIgKyBzdGF0XSA9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZGF0YS5zdGF0c1tcImRhdGFfXCIgKyBzdGF0XVt2ZGF0YXNldF0gPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdHJlc3ZhbCA9IGRhdGEuc3RhdHNbXCJkYXRhX1wiICsgc3RhdF1bdmRhdGFzZXRdO1xuXHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmIChzdGF0dmFsLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsIDkpID09IFwidmFyaWFibGVfXCIpIHtcblx0XHRyZXN2YWwgPSBldmFsKHN0YXR2YWwudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoOSkpO1xuXHRcdGZvdW5kPXRydWU7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRmb3VuZDogZm91bmQsXG5cdFx0cmVzdmFsOiByZXN2YWxcblx0fTtcbn07XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
